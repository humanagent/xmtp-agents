# XMTP Browser SDK Implementation Notes

## Overview
This document captures the working implementation of XMTP Browser SDK v0.0.6 with WebAssembly (WASM) support in a Next.js 16 application.

## Package Versions
```json
{
  "@xmtp/browser-sdk": "^0.0.6",
  "ethers": "^6.13.4",
  "next": "16.0.10"
}
```

## Key Challenges & Solutions

### 1. Client Creation with WASM

**Challenge**: The XMTP Browser SDK uses WebAssembly under the hood, which requires special handling in Next.js.

**Solution**: Simple client creation without complex options:

```typescript
import { Client } from "@xmtp/browser-sdk";
import { getBytes } from "ethers";
import type { Wallet, HDNodeWallet } from "ethers";

function createXMTPSigner(wallet: Wallet | HDNodeWallet) {
  return {
    getAddress: async () => wallet.address,
    signMessage: async (message: string) => {
      const signature = await wallet.signMessage(message);
      return getBytes(signature);
    },
  };
}

export async function createXMTPClient(
  wallet: Wallet | HDNodeWallet
): Promise<Client> {
  const signer = createXMTPSigner(wallet);
  const encryptionKey = new Uint8Array(32); // 32 bytes for encryption
  
  // Simple signature: (signer, encryptionKey)
  const client = await Client.create(signer, encryptionKey);
  
  return client;
}
```

**What Worked**:
- ✅ Using `getBytes()` from ethers to convert signature string to Uint8Array
- ✅ Simple two-parameter call: `Client.create(signer, encryptionKey)`
- ✅ 32-byte encryption key (new Uint8Array(32))
- ✅ Async signer methods returning Promises

**What Didn't Work**:
- ❌ Trying to pass options object as third parameter (not supported in v0.0.6)
- ❌ Using environment configuration in Client.create() options
- ❌ Trying to use `hexToBytes()` (doesn't exist in ethers v6)

### 2. Type Exports

**Challenge**: The SDK doesn't export TypeScript types like `Dm`, `Conversation`, etc.

**Solution**: Use `any` type with comments:

```typescript
// Use any for now since the SDK types are not fully exposed
type Dm = any;
```

**What Worked**:
- ✅ Using `any` type for conversation objects
- ✅ Importing only `Client` and `DecodedMessage` types
- ✅ Creating our own XMTPMessage type wrapper

**What Didn't Work**:
- ❌ `import type { Dm } from "@xmtp/browser-sdk"` - type not exported
- ❌ `import type { Conversation } from "@xmtp/browser-sdk"` - type not exported

### 3. Conversation Creation

**Challenge**: API methods for conversation creation differ from documentation.

**Solution**: Direct method call with type casting:

```typescript
export async function startConversation(
  client: Client,
  agentAddress: string
): Promise<Dm> {
  // Create or get DM with the agent address
  const dm = await (client.conversations as any).newDm(agentAddress.toLowerCase());
  return dm;
}
```

**What Worked**:
- ✅ Using `(client.conversations as any).newDm()`
- ✅ Lowercasing Ethereum addresses
- ✅ Direct address parameter (not identifier object)

**What Didn't Work**:
- ❌ `client.findInboxIdByIdentifier()` - method doesn't exist
- ❌ `client.conversations.getDmByInboxId()` - method doesn't exist
- ❌ `client.conversations.newDmWithIdentifier()` - method doesn't exist
- ❌ Using identifier objects with `identifierKind: "Ethereum"`

### 4. Message Operations

**Challenge**: Timestamp conversion and message structure.

**Solution**: Convert nanoseconds to milliseconds:

```typescript
export async function getMessages(conversation: Dm): Promise<XMTPMessage[]> {
  await conversation.sync();
  const messages = await conversation.messages();
  
  return messages.map((msg: DecodedMessage) => ({
    id: msg.id,
    content: msg.content as string,
    senderAddress: msg.senderInboxId, // Note: inboxId, not Ethereum address
    sentAt: new Date(Number(msg.sentAtNs) / 1_000_000), // ns -> ms
  }));
}
```

**What Worked**:
- ✅ `await conversation.sync()` before getting messages
- ✅ `conversation.messages()` returns array
- ✅ Converting `sentAtNs` (nanoseconds) to Date: `new Date(Number(sentAtNs) / 1_000_000)`
- ✅ `msg.senderInboxId` contains sender identifier

**What Didn't Work**:
- ❌ Using `sentAt` directly - doesn't exist, use `sentAtNs`
- ❌ Expecting Ethereum address in sender field - it's inbox ID

### 5. Message Streaming

**Challenge**: Setting up real-time message streaming with cleanup.

**Solution**: Async cleanup function:

```typescript
export async function streamMessages(
  conversation: Dm,
  onMessage: (message: XMTPMessage) => void
): Promise<() => Promise<void>> {
  const stream = await conversation.stream({
    onValue: (message: DecodedMessage) => {
      onMessage({
        id: message.id,
        content: message.content as string,
        senderAddress: message.senderInboxId,
        sentAt: new Date(Number(message.sentAtNs) / 1_000_000),
      });
    },
  });
  
  return async () => {
    await stream.end();
  };
}
```

**What Worked**:
- ✅ `conversation.stream({ onValue: callback })`
- ✅ Returning async cleanup function
- ✅ `await stream.end()` for cleanup
- ✅ Callback fires for each new message

**What Didn't Work**:
- ❌ Trying to use `for await...of` loop
- ❌ Synchronous cleanup functions

### 6. Next.js Configuration

**Challenge**: WASM files need proper handling in Next.js.

**Solution**: Minimal Next.js config with Turbopack:

```typescript
// next.config.ts
import type { NextConfig } from "next";

const nextConfig: NextConfig = {
  cacheComponents: true,
  turbopack: {}, // Enable Turbopack
};

export default nextConfig;
```

**What Worked**:
- ✅ Using Turbopack (enabled by default in Next.js 16)
- ✅ Minimal configuration
- ✅ No special webpack config needed for WASM

**What Didn't Work**:
- ❌ Custom webpack configurations for WASM
- ❌ Polyfills for crypto (not needed with browser-sdk)

### 7. React Component Integration

**Challenge**: Managing XMTP client lifecycle in React.

**Solution**: useEffect with proper cleanup:

```typescript
useEffect(() => {
  let cleanup: (() => Promise<void>) | null = null;

  const initConversation = async () => {
    try {
      const conversation = await startConversation(client, agent.address);
      conversationRef.current = conversation;

      const existingMessages = await getMessages(conversation);
      setMessages(existingMessages);

      cleanup = await streamMessages(conversation, (message) => {
        setMessages((prev) => [...prev, message]);
      });
    } catch (error) {
      console.error("Failed to initialize conversation:", error);
      toast({ type: "error", description: "Failed to connect to agent" });
    }
  };

  initConversation();

  return () => {
    if (cleanup) {
      cleanup();
    }
  };
}, [client, agent]);
```

**What Worked**:
- ✅ Storing cleanup function in variable
- ✅ Calling async cleanup in useEffect return
- ✅ Using refs for conversation object
- ✅ Dependencies: `[client, agent]`

**What Didn't Work**:
- ❌ Trying to await cleanup in useEffect return (must be sync)
- ❌ Not storing cleanup reference properly

## Debugging Tips

### Add Extensive Logging

```typescript
export async function createXMTPClient(
  wallet: Wallet | HDNodeWallet
): Promise<Client> {
  console.log("[XMTP] Starting client creation...");
  console.log("[XMTP] Wallet address:", wallet.address);
  
  const signer = createXMTPSigner(wallet);
  console.log("[XMTP] Signer created");
  
  const encryptionKey = new Uint8Array(32);
  console.log("[XMTP] Encryption key generated");
  
  console.log("[XMTP] Calling Client.create...");
  try {
    const client = await Client.create(signer, encryptionKey);
    console.log("[XMTP] Client created successfully!");
    console.log("[XMTP] Inbox ID:", client.inboxId);
    return client;
  } catch (error) {
    console.error("[XMTP] Client creation failed:", error);
    console.error("[XMTP] Error details:", {
      message: error instanceof Error ? error.message : String(error),
      stack: error instanceof Error ? error.stack : undefined,
    });
    throw error;
  }
}
```

### Check WASM Loading

Open browser DevTools and check:
- Network tab for `.wasm` file loads
- Console for any WASM-related errors
- Check that WASM is supported: `typeof WebAssembly !== 'undefined'`

### Common Errors

1. **"Client.create requires 2-3 arguments"**
   - Solution: Use exactly 2 args: `Client.create(signer, encryptionKey)`

2. **"Property X does not exist on type Client"**
   - Solution: Use type casting `(client.conversations as any).method()`

3. **"Module 'Dm' not found"**
   - Solution: Use `type Dm = any;` instead of importing

## Production Considerations

### Environment Variables

```env
# .env.local
NEXT_PUBLIC_XMTP_ENV=production
```

### Agent Addresses

Update [`lib/xmtp/agents.ts`](lib/xmtp/agents.ts) with real XMTP-enabled agent addresses:

```typescript
export const AI_AGENTS: AIAgent[] = [
  {
    id: "agent-1",
    name: "Real Agent",
    description: "Production AI agent",
    address: "0xREAL_ETHEREUM_ADDRESS_HERE", // Must be XMTP-enabled
  },
];
```

### Database Path

For persistent storage (optional):
```typescript
// Client.create can accept dbPath in options (if supported)
// For v0.0.6, encryption key handles local encryption
```

## Testing

### Prerequisites
1. Real XMTP-enabled agent Ethereum addresses
2. Agents must be running and listening for messages
3. Both dev and production XMTP networks available

### Test Flow
1. Open app → Ephemeral wallet created and stored in localStorage
2. Select agent → DM conversation initiated
3. Send message → Should appear in messages list
4. Agent responds → Message received via stream

## Resources

- [XMTP Browser SDK](https://github.com/xmtp/xmtp-js/tree/main/sdks/browser-sdk)
- [XMTP Documentation](https://docs.xmtp.org)
- [WebAssembly in Next.js](https://nextjs.org/docs/app/building-your-application/optimizing/webassembly)

## Summary

The key to making XMTP Browser SDK v0.0.6 work:
1. **Simple client creation**: Just signer + encryption key
2. **Type flexibility**: Use `any` where types aren't exported
3. **Direct API calls**: Use runtime methods with type casting
4. **Proper cleanup**: Async cleanup functions with React hooks
5. **Extensive logging**: Debug WASM loading and client creation
6. **Minimal config**: Let Next.js/Turbopack handle WASM automatically

