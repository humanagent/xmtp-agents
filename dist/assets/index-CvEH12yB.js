function _mergeNamespaces(a, e) {
  for (var f = 0; f < e.length; f++) {
    const _ = e[f];
    if (typeof _ != "string" && !Array.isArray(_)) {
      for (const w in _)
        if (w !== "default" && !(w in a)) {
          const v = Object.getOwnPropertyDescriptor(_, w);
          v &&
            Object.defineProperty(
              a,
              w,
              v.get ? v : { enumerable: !0, get: () => _[w] },
            );
        }
    }
  }
  return Object.freeze(
    Object.defineProperty(a, Symbol.toStringTag, { value: "Module" }),
  );
}
(function () {
  const e = document.createElement("link").relList;
  if (e && e.supports && e.supports("modulepreload")) return;
  for (const w of document.querySelectorAll('link[rel="modulepreload"]')) _(w);
  new MutationObserver((w) => {
    for (const v of w)
      if (v.type === "childList")
        for (const S of v.addedNodes)
          S.tagName === "LINK" && S.rel === "modulepreload" && _(S);
  }).observe(document, { childList: !0, subtree: !0 });
  function f(w) {
    const v = {};
    return (
      w.integrity && (v.integrity = w.integrity),
      w.referrerPolicy && (v.referrerPolicy = w.referrerPolicy),
      w.crossOrigin === "use-credentials"
        ? (v.credentials = "include")
        : w.crossOrigin === "anonymous"
          ? (v.credentials = "omit")
          : (v.credentials = "same-origin"),
      v
    );
  }
  function _(w) {
    if (w.ep) return;
    w.ep = !0;
    const v = f(w);
    fetch(w.href, v);
  }
})();
var commonjsGlobal =
  typeof globalThis < "u"
    ? globalThis
    : typeof window < "u"
      ? window
      : typeof global < "u"
        ? global
        : typeof self < "u"
          ? self
          : {};
function getDefaultExportFromCjs(a) {
  return a && a.__esModule && Object.prototype.hasOwnProperty.call(a, "default")
    ? a.default
    : a;
}
var jsxRuntime = { exports: {} },
  reactJsxRuntime_production = {};
/**
 * @license React
 * react-jsx-runtime.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var hasRequiredReactJsxRuntime_production;
function requireReactJsxRuntime_production() {
  if (hasRequiredReactJsxRuntime_production) return reactJsxRuntime_production;
  hasRequiredReactJsxRuntime_production = 1;
  var a = Symbol.for("react.transitional.element"),
    e = Symbol.for("react.fragment");
  function f(_, w, v) {
    var S = null;
    if (
      (v !== void 0 && (S = "" + v),
      w.key !== void 0 && (S = "" + w.key),
      "key" in w)
    ) {
      v = {};
      for (var R in w) R !== "key" && (v[R] = w[R]);
    } else v = w;
    return (
      (w = v.ref),
      { $$typeof: a, type: _, key: S, ref: w !== void 0 ? w : null, props: v }
    );
  }
  return (
    (reactJsxRuntime_production.Fragment = e),
    (reactJsxRuntime_production.jsx = f),
    (reactJsxRuntime_production.jsxs = f),
    reactJsxRuntime_production
  );
}
var hasRequiredJsxRuntime;
function requireJsxRuntime() {
  return (
    hasRequiredJsxRuntime ||
      ((hasRequiredJsxRuntime = 1),
      (jsxRuntime.exports = requireReactJsxRuntime_production())),
    jsxRuntime.exports
  );
}
var jsxRuntimeExports = requireJsxRuntime(),
  react = { exports: {} },
  react_production = {};
/**
 * @license React
 * react.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var hasRequiredReact_production;
function requireReact_production() {
  if (hasRequiredReact_production) return react_production;
  hasRequiredReact_production = 1;
  var a = Symbol.for("react.transitional.element"),
    e = Symbol.for("react.portal"),
    f = Symbol.for("react.fragment"),
    _ = Symbol.for("react.strict_mode"),
    w = Symbol.for("react.profiler"),
    v = Symbol.for("react.consumer"),
    S = Symbol.for("react.context"),
    R = Symbol.for("react.forward_ref"),
    O = Symbol.for("react.suspense"),
    j = Symbol.for("react.memo"),
    F = Symbol.for("react.lazy"),
    q = Symbol.for("react.activity"),
    Q = Symbol.iterator;
  function te(Fe) {
    return Fe === null || typeof Fe != "object"
      ? null
      : ((Fe = (Q && Fe[Q]) || Fe["@@iterator"]),
        typeof Fe == "function" ? Fe : null);
  }
  var se = {
      isMounted: function () {
        return !1;
      },
      enqueueForceUpdate: function () {},
      enqueueReplaceState: function () {},
      enqueueSetState: function () {},
    },
    re = Object.assign,
    Oe = {};
  function Le(Fe, Ue, ot) {
    ((this.props = Fe),
      (this.context = Ue),
      (this.refs = Oe),
      (this.updater = ot || se));
  }
  ((Le.prototype.isReactComponent = {}),
    (Le.prototype.setState = function (Fe, Ue) {
      if (typeof Fe != "object" && typeof Fe != "function" && Fe != null)
        throw Error(
          "takes an object of state variables to update or a function which returns an object of state variables.",
        );
      this.updater.enqueueSetState(this, Fe, Ue, "setState");
    }),
    (Le.prototype.forceUpdate = function (Fe) {
      this.updater.enqueueForceUpdate(this, Fe, "forceUpdate");
    }));
  function Be() {}
  Be.prototype = Le.prototype;
  function Ve(Fe, Ue, ot) {
    ((this.props = Fe),
      (this.context = Ue),
      (this.refs = Oe),
      (this.updater = ot || se));
  }
  var ze = (Ve.prototype = new Be());
  ((ze.constructor = Ve), re(ze, Le.prototype), (ze.isPureReactComponent = !0));
  var Ge = Array.isArray;
  function Ke() {}
  var qe = { H: null, A: null, T: null, S: null },
    nt = Object.prototype.hasOwnProperty;
  function pt(Fe, Ue, ot) {
    var lt = ot.ref;
    return {
      $$typeof: a,
      type: Fe,
      key: Ue,
      ref: lt !== void 0 ? lt : null,
      props: ot,
    };
  }
  function gt(Fe, Ue) {
    return pt(Fe.type, Ue, Fe.props);
  }
  function mt(Fe) {
    return typeof Fe == "object" && Fe !== null && Fe.$$typeof === a;
  }
  function dt(Fe) {
    var Ue = { "=": "=0", ":": "=2" };
    return (
      "$" +
      Fe.replace(/[=:]/g, function (ot) {
        return Ue[ot];
      })
    );
  }
  var _t = /\/+/g;
  function bt(Fe, Ue) {
    return typeof Fe == "object" && Fe !== null && Fe.key != null
      ? dt("" + Fe.key)
      : Ue.toString(36);
  }
  function at(Fe) {
    switch (Fe.status) {
      case "fulfilled":
        return Fe.value;
      case "rejected":
        throw Fe.reason;
      default:
        switch (
          (typeof Fe.status == "string"
            ? Fe.then(Ke, Ke)
            : ((Fe.status = "pending"),
              Fe.then(
                function (Ue) {
                  Fe.status === "pending" &&
                    ((Fe.status = "fulfilled"), (Fe.value = Ue));
                },
                function (Ue) {
                  Fe.status === "pending" &&
                    ((Fe.status = "rejected"), (Fe.reason = Ue));
                },
              )),
          Fe.status)
        ) {
          case "fulfilled":
            return Fe.value;
          case "rejected":
            throw Fe.reason;
        }
    }
    throw Fe;
  }
  function $e(Fe, Ue, ot, lt, ut) {
    var yt = typeof Fe;
    (yt === "undefined" || yt === "boolean") && (Fe = null);
    var it = !1;
    if (Fe === null) it = !0;
    else
      switch (yt) {
        case "bigint":
        case "string":
        case "number":
          it = !0;
          break;
        case "object":
          switch (Fe.$$typeof) {
            case a:
            case e:
              it = !0;
              break;
            case F:
              return ((it = Fe._init), $e(it(Fe._payload), Ue, ot, lt, ut));
          }
      }
    if (it)
      return (
        (ut = ut(Fe)),
        (it = lt === "" ? "." + bt(Fe, 0) : lt),
        Ge(ut)
          ? ((ot = ""),
            it != null && (ot = it.replace(_t, "$&/") + "/"),
            $e(ut, Ue, ot, "", function (At) {
              return At;
            }))
          : ut != null &&
            (mt(ut) &&
              (ut = gt(
                ut,
                ot +
                  (ut.key == null || (Fe && Fe.key === ut.key)
                    ? ""
                    : ("" + ut.key).replace(_t, "$&/") + "/") +
                  it,
              )),
            Ue.push(ut)),
        1
      );
    it = 0;
    var Et = lt === "" ? "." : lt + ":";
    if (Ge(Fe))
      for (var xt = 0; xt < Fe.length; xt++)
        ((lt = Fe[xt]), (yt = Et + bt(lt, xt)), (it += $e(lt, Ue, ot, yt, ut)));
    else if (((xt = te(Fe)), typeof xt == "function"))
      for (Fe = xt.call(Fe), xt = 0; !(lt = Fe.next()).done; )
        ((lt = lt.value),
          (yt = Et + bt(lt, xt++)),
          (it += $e(lt, Ue, ot, yt, ut)));
    else if (yt === "object") {
      if (typeof Fe.then == "function") return $e(at(Fe), Ue, ot, lt, ut);
      throw (
        (Ue = String(Fe)),
        Error(
          "Objects are not valid as a React child (found: " +
            (Ue === "[object Object]"
              ? "object with keys {" + Object.keys(Fe).join(", ") + "}"
              : Ue) +
            "). If you meant to render a collection of children, use an array instead.",
        )
      );
    }
    return it;
  }
  function Ye(Fe, Ue, ot) {
    if (Fe == null) return Fe;
    var lt = [],
      ut = 0;
    return (
      $e(Fe, lt, "", "", function (yt) {
        return Ue.call(ot, yt, ut++);
      }),
      lt
    );
  }
  function Qe(Fe) {
    if (Fe._status === -1) {
      var Ue = Fe._result;
      ((Ue = Ue()),
        Ue.then(
          function (ot) {
            (Fe._status === 0 || Fe._status === -1) &&
              ((Fe._status = 1), (Fe._result = ot));
          },
          function (ot) {
            (Fe._status === 0 || Fe._status === -1) &&
              ((Fe._status = 2), (Fe._result = ot));
          },
        ),
        Fe._status === -1 && ((Fe._status = 0), (Fe._result = Ue)));
    }
    if (Fe._status === 1) return Fe._result.default;
    throw Fe._result;
  }
  var tt =
      typeof reportError == "function"
        ? reportError
        : function (Fe) {
            if (
              typeof window == "object" &&
              typeof window.ErrorEvent == "function"
            ) {
              var Ue = new window.ErrorEvent("error", {
                bubbles: !0,
                cancelable: !0,
                message:
                  typeof Fe == "object" &&
                  Fe !== null &&
                  typeof Fe.message == "string"
                    ? String(Fe.message)
                    : String(Fe),
                error: Fe,
              });
              if (!window.dispatchEvent(Ue)) return;
            } else if (
              typeof process == "object" &&
              typeof process.emit == "function"
            ) {
              process.emit("uncaughtException", Fe);
              return;
            }
            console.error(Fe);
          },
    ht = {
      map: Ye,
      forEach: function (Fe, Ue, ot) {
        Ye(
          Fe,
          function () {
            Ue.apply(this, arguments);
          },
          ot,
        );
      },
      count: function (Fe) {
        var Ue = 0;
        return (
          Ye(Fe, function () {
            Ue++;
          }),
          Ue
        );
      },
      toArray: function (Fe) {
        return (
          Ye(Fe, function (Ue) {
            return Ue;
          }) || []
        );
      },
      only: function (Fe) {
        if (!mt(Fe))
          throw Error(
            "React.Children.only expected to receive a single React element child.",
          );
        return Fe;
      },
    };
  return (
    (react_production.Activity = q),
    (react_production.Children = ht),
    (react_production.Component = Le),
    (react_production.Fragment = f),
    (react_production.Profiler = w),
    (react_production.PureComponent = Ve),
    (react_production.StrictMode = _),
    (react_production.Suspense = O),
    (react_production.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE =
      qe),
    (react_production.__COMPILER_RUNTIME = {
      __proto__: null,
      c: function (Fe) {
        return qe.H.useMemoCache(Fe);
      },
    }),
    (react_production.cache = function (Fe) {
      return function () {
        return Fe.apply(null, arguments);
      };
    }),
    (react_production.cacheSignal = function () {
      return null;
    }),
    (react_production.cloneElement = function (Fe, Ue, ot) {
      if (Fe == null)
        throw Error(
          "The argument must be a React element, but you passed " + Fe + ".",
        );
      var lt = re({}, Fe.props),
        ut = Fe.key;
      if (Ue != null)
        for (yt in (Ue.key !== void 0 && (ut = "" + Ue.key), Ue))
          !nt.call(Ue, yt) ||
            yt === "key" ||
            yt === "__self" ||
            yt === "__source" ||
            (yt === "ref" && Ue.ref === void 0) ||
            (lt[yt] = Ue[yt]);
      var yt = arguments.length - 2;
      if (yt === 1) lt.children = ot;
      else if (1 < yt) {
        for (var it = Array(yt), Et = 0; Et < yt; Et++)
          it[Et] = arguments[Et + 2];
        lt.children = it;
      }
      return pt(Fe.type, ut, lt);
    }),
    (react_production.createContext = function (Fe) {
      return (
        (Fe = {
          $$typeof: S,
          _currentValue: Fe,
          _currentValue2: Fe,
          _threadCount: 0,
          Provider: null,
          Consumer: null,
        }),
        (Fe.Provider = Fe),
        (Fe.Consumer = { $$typeof: v, _context: Fe }),
        Fe
      );
    }),
    (react_production.createElement = function (Fe, Ue, ot) {
      var lt,
        ut = {},
        yt = null;
      if (Ue != null)
        for (lt in (Ue.key !== void 0 && (yt = "" + Ue.key), Ue))
          nt.call(Ue, lt) &&
            lt !== "key" &&
            lt !== "__self" &&
            lt !== "__source" &&
            (ut[lt] = Ue[lt]);
      var it = arguments.length - 2;
      if (it === 1) ut.children = ot;
      else if (1 < it) {
        for (var Et = Array(it), xt = 0; xt < it; xt++)
          Et[xt] = arguments[xt + 2];
        ut.children = Et;
      }
      if (Fe && Fe.defaultProps)
        for (lt in ((it = Fe.defaultProps), it))
          ut[lt] === void 0 && (ut[lt] = it[lt]);
      return pt(Fe, yt, ut);
    }),
    (react_production.createRef = function () {
      return { current: null };
    }),
    (react_production.forwardRef = function (Fe) {
      return { $$typeof: R, render: Fe };
    }),
    (react_production.isValidElement = mt),
    (react_production.lazy = function (Fe) {
      return { $$typeof: F, _payload: { _status: -1, _result: Fe }, _init: Qe };
    }),
    (react_production.memo = function (Fe, Ue) {
      return { $$typeof: j, type: Fe, compare: Ue === void 0 ? null : Ue };
    }),
    (react_production.startTransition = function (Fe) {
      var Ue = qe.T,
        ot = {};
      qe.T = ot;
      try {
        var lt = Fe(),
          ut = qe.S;
        (ut !== null && ut(ot, lt),
          typeof lt == "object" &&
            lt !== null &&
            typeof lt.then == "function" &&
            lt.then(Ke, tt));
      } catch (yt) {
        tt(yt);
      } finally {
        (Ue !== null && ot.types !== null && (Ue.types = ot.types),
          (qe.T = Ue));
      }
    }),
    (react_production.unstable_useCacheRefresh = function () {
      return qe.H.useCacheRefresh();
    }),
    (react_production.use = function (Fe) {
      return qe.H.use(Fe);
    }),
    (react_production.useActionState = function (Fe, Ue, ot) {
      return qe.H.useActionState(Fe, Ue, ot);
    }),
    (react_production.useCallback = function (Fe, Ue) {
      return qe.H.useCallback(Fe, Ue);
    }),
    (react_production.useContext = function (Fe) {
      return qe.H.useContext(Fe);
    }),
    (react_production.useDebugValue = function () {}),
    (react_production.useDeferredValue = function (Fe, Ue) {
      return qe.H.useDeferredValue(Fe, Ue);
    }),
    (react_production.useEffect = function (Fe, Ue) {
      return qe.H.useEffect(Fe, Ue);
    }),
    (react_production.useEffectEvent = function (Fe) {
      return qe.H.useEffectEvent(Fe);
    }),
    (react_production.useId = function () {
      return qe.H.useId();
    }),
    (react_production.useImperativeHandle = function (Fe, Ue, ot) {
      return qe.H.useImperativeHandle(Fe, Ue, ot);
    }),
    (react_production.useInsertionEffect = function (Fe, Ue) {
      return qe.H.useInsertionEffect(Fe, Ue);
    }),
    (react_production.useLayoutEffect = function (Fe, Ue) {
      return qe.H.useLayoutEffect(Fe, Ue);
    }),
    (react_production.useMemo = function (Fe, Ue) {
      return qe.H.useMemo(Fe, Ue);
    }),
    (react_production.useOptimistic = function (Fe, Ue) {
      return qe.H.useOptimistic(Fe, Ue);
    }),
    (react_production.useReducer = function (Fe, Ue, ot) {
      return qe.H.useReducer(Fe, Ue, ot);
    }),
    (react_production.useRef = function (Fe) {
      return qe.H.useRef(Fe);
    }),
    (react_production.useState = function (Fe) {
      return qe.H.useState(Fe);
    }),
    (react_production.useSyncExternalStore = function (Fe, Ue, ot) {
      return qe.H.useSyncExternalStore(Fe, Ue, ot);
    }),
    (react_production.useTransition = function () {
      return qe.H.useTransition();
    }),
    (react_production.version = "19.2.3"),
    react_production
  );
}
var hasRequiredReact;
function requireReact() {
  return (
    hasRequiredReact ||
      ((hasRequiredReact = 1), (react.exports = requireReact_production())),
    react.exports
  );
}
var reactExports = requireReact();
const React2 = getDefaultExportFromCjs(reactExports),
  React = _mergeNamespaces({ __proto__: null, default: React2 }, [
    reactExports,
  ]);
var client = { exports: {} },
  reactDomClient_production = {},
  scheduler = { exports: {} },
  scheduler_production = {};
/**
 * @license React
 * scheduler.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var hasRequiredScheduler_production;
function requireScheduler_production() {
  return (
    hasRequiredScheduler_production ||
      ((hasRequiredScheduler_production = 1),
      (function (a) {
        function e($e, Ye) {
          var Qe = $e.length;
          $e.push(Ye);
          e: for (; 0 < Qe; ) {
            var tt = (Qe - 1) >>> 1,
              ht = $e[tt];
            if (0 < w(ht, Ye)) (($e[tt] = Ye), ($e[Qe] = ht), (Qe = tt));
            else break e;
          }
        }
        function f($e) {
          return $e.length === 0 ? null : $e[0];
        }
        function _($e) {
          if ($e.length === 0) return null;
          var Ye = $e[0],
            Qe = $e.pop();
          if (Qe !== Ye) {
            $e[0] = Qe;
            e: for (var tt = 0, ht = $e.length, Fe = ht >>> 1; tt < Fe; ) {
              var Ue = 2 * (tt + 1) - 1,
                ot = $e[Ue],
                lt = Ue + 1,
                ut = $e[lt];
              if (0 > w(ot, Qe))
                lt < ht && 0 > w(ut, ot)
                  ? (($e[tt] = ut), ($e[lt] = Qe), (tt = lt))
                  : (($e[tt] = ot), ($e[Ue] = Qe), (tt = Ue));
              else if (lt < ht && 0 > w(ut, Qe))
                (($e[tt] = ut), ($e[lt] = Qe), (tt = lt));
              else break e;
            }
          }
          return Ye;
        }
        function w($e, Ye) {
          var Qe = $e.sortIndex - Ye.sortIndex;
          return Qe !== 0 ? Qe : $e.id - Ye.id;
        }
        if (
          ((a.unstable_now = void 0),
          typeof performance == "object" &&
            typeof performance.now == "function")
        ) {
          var v = performance;
          a.unstable_now = function () {
            return v.now();
          };
        } else {
          var S = Date,
            R = S.now();
          a.unstable_now = function () {
            return S.now() - R;
          };
        }
        var O = [],
          j = [],
          F = 1,
          q = null,
          Q = 3,
          te = !1,
          se = !1,
          re = !1,
          Oe = !1,
          Le = typeof setTimeout == "function" ? setTimeout : null,
          Be = typeof clearTimeout == "function" ? clearTimeout : null,
          Ve = typeof setImmediate < "u" ? setImmediate : null;
        function ze($e) {
          for (var Ye = f(j); Ye !== null; ) {
            if (Ye.callback === null) _(j);
            else if (Ye.startTime <= $e)
              (_(j), (Ye.sortIndex = Ye.expirationTime), e(O, Ye));
            else break;
            Ye = f(j);
          }
        }
        function Ge($e) {
          if (((re = !1), ze($e), !se))
            if (f(O) !== null) ((se = !0), Ke || ((Ke = !0), dt()));
            else {
              var Ye = f(j);
              Ye !== null && at(Ge, Ye.startTime - $e);
            }
        }
        var Ke = !1,
          qe = -1,
          nt = 5,
          pt = -1;
        function gt() {
          return Oe ? !0 : !(a.unstable_now() - pt < nt);
        }
        function mt() {
          if (((Oe = !1), Ke)) {
            var $e = a.unstable_now();
            pt = $e;
            var Ye = !0;
            try {
              e: {
                ((se = !1), re && ((re = !1), Be(qe), (qe = -1)), (te = !0));
                var Qe = Q;
                try {
                  t: {
                    for (
                      ze($e), q = f(O);
                      q !== null && !(q.expirationTime > $e && gt());

                    ) {
                      var tt = q.callback;
                      if (typeof tt == "function") {
                        ((q.callback = null), (Q = q.priorityLevel));
                        var ht = tt(q.expirationTime <= $e);
                        if (
                          (($e = a.unstable_now()), typeof ht == "function")
                        ) {
                          ((q.callback = ht), ze($e), (Ye = !0));
                          break t;
                        }
                        (q === f(O) && _(O), ze($e));
                      } else _(O);
                      q = f(O);
                    }
                    if (q !== null) Ye = !0;
                    else {
                      var Fe = f(j);
                      (Fe !== null && at(Ge, Fe.startTime - $e), (Ye = !1));
                    }
                  }
                  break e;
                } finally {
                  ((q = null), (Q = Qe), (te = !1));
                }
                Ye = void 0;
              }
            } finally {
              Ye ? dt() : (Ke = !1);
            }
          }
        }
        var dt;
        if (typeof Ve == "function")
          dt = function () {
            Ve(mt);
          };
        else if (typeof MessageChannel < "u") {
          var _t = new MessageChannel(),
            bt = _t.port2;
          ((_t.port1.onmessage = mt),
            (dt = function () {
              bt.postMessage(null);
            }));
        } else
          dt = function () {
            Le(mt, 0);
          };
        function at($e, Ye) {
          qe = Le(function () {
            $e(a.unstable_now());
          }, Ye);
        }
        ((a.unstable_IdlePriority = 5),
          (a.unstable_ImmediatePriority = 1),
          (a.unstable_LowPriority = 4),
          (a.unstable_NormalPriority = 3),
          (a.unstable_Profiling = null),
          (a.unstable_UserBlockingPriority = 2),
          (a.unstable_cancelCallback = function ($e) {
            $e.callback = null;
          }),
          (a.unstable_forceFrameRate = function ($e) {
            0 > $e || 125 < $e
              ? console.error(
                  "forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported",
                )
              : (nt = 0 < $e ? Math.floor(1e3 / $e) : 5);
          }),
          (a.unstable_getCurrentPriorityLevel = function () {
            return Q;
          }),
          (a.unstable_next = function ($e) {
            switch (Q) {
              case 1:
              case 2:
              case 3:
                var Ye = 3;
                break;
              default:
                Ye = Q;
            }
            var Qe = Q;
            Q = Ye;
            try {
              return $e();
            } finally {
              Q = Qe;
            }
          }),
          (a.unstable_requestPaint = function () {
            Oe = !0;
          }),
          (a.unstable_runWithPriority = function ($e, Ye) {
            switch ($e) {
              case 1:
              case 2:
              case 3:
              case 4:
              case 5:
                break;
              default:
                $e = 3;
            }
            var Qe = Q;
            Q = $e;
            try {
              return Ye();
            } finally {
              Q = Qe;
            }
          }),
          (a.unstable_scheduleCallback = function ($e, Ye, Qe) {
            var tt = a.unstable_now();
            switch (
              (typeof Qe == "object" && Qe !== null
                ? ((Qe = Qe.delay),
                  (Qe = typeof Qe == "number" && 0 < Qe ? tt + Qe : tt))
                : (Qe = tt),
              $e)
            ) {
              case 1:
                var ht = -1;
                break;
              case 2:
                ht = 250;
                break;
              case 5:
                ht = 1073741823;
                break;
              case 4:
                ht = 1e4;
                break;
              default:
                ht = 5e3;
            }
            return (
              (ht = Qe + ht),
              ($e = {
                id: F++,
                callback: Ye,
                priorityLevel: $e,
                startTime: Qe,
                expirationTime: ht,
                sortIndex: -1,
              }),
              Qe > tt
                ? (($e.sortIndex = Qe),
                  e(j, $e),
                  f(O) === null &&
                    $e === f(j) &&
                    (re ? (Be(qe), (qe = -1)) : (re = !0), at(Ge, Qe - tt)))
                : (($e.sortIndex = ht),
                  e(O, $e),
                  se || te || ((se = !0), Ke || ((Ke = !0), dt()))),
              $e
            );
          }),
          (a.unstable_shouldYield = gt),
          (a.unstable_wrapCallback = function ($e) {
            var Ye = Q;
            return function () {
              var Qe = Q;
              Q = Ye;
              try {
                return $e.apply(this, arguments);
              } finally {
                Q = Qe;
              }
            };
          }));
      })(scheduler_production)),
    scheduler_production
  );
}
var hasRequiredScheduler;
function requireScheduler() {
  return (
    hasRequiredScheduler ||
      ((hasRequiredScheduler = 1),
      (scheduler.exports = requireScheduler_production())),
    scheduler.exports
  );
}
var reactDom = { exports: {} },
  reactDom_production = {};
/**
 * @license React
 * react-dom.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var hasRequiredReactDom_production;
function requireReactDom_production() {
  if (hasRequiredReactDom_production) return reactDom_production;
  hasRequiredReactDom_production = 1;
  var a = requireReact();
  function e(O) {
    var j = "https://react.dev/errors/" + O;
    if (1 < arguments.length) {
      j += "?args[]=" + encodeURIComponent(arguments[1]);
      for (var F = 2; F < arguments.length; F++)
        j += "&args[]=" + encodeURIComponent(arguments[F]);
    }
    return (
      "Minified React error #" +
      O +
      "; visit " +
      j +
      " for the full message or use the non-minified dev environment for full errors and additional helpful warnings."
    );
  }
  function f() {}
  var _ = {
      d: {
        f,
        r: function () {
          throw Error(e(522));
        },
        D: f,
        C: f,
        L: f,
        m: f,
        X: f,
        S: f,
        M: f,
      },
      p: 0,
      findDOMNode: null,
    },
    w = Symbol.for("react.portal");
  function v(O, j, F) {
    var q =
      3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
    return {
      $$typeof: w,
      key: q == null ? null : "" + q,
      children: O,
      containerInfo: j,
      implementation: F,
    };
  }
  var S = a.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;
  function R(O, j) {
    if (O === "font") return "";
    if (typeof j == "string") return j === "use-credentials" ? j : "";
  }
  return (
    (reactDom_production.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE =
      _),
    (reactDom_production.createPortal = function (O, j) {
      var F =
        2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null;
      if (!j || (j.nodeType !== 1 && j.nodeType !== 9 && j.nodeType !== 11))
        throw Error(e(299));
      return v(O, j, null, F);
    }),
    (reactDom_production.flushSync = function (O) {
      var j = S.T,
        F = _.p;
      try {
        if (((S.T = null), (_.p = 2), O)) return O();
      } finally {
        ((S.T = j), (_.p = F), _.d.f());
      }
    }),
    (reactDom_production.preconnect = function (O, j) {
      typeof O == "string" &&
        (j
          ? ((j = j.crossOrigin),
            (j =
              typeof j == "string"
                ? j === "use-credentials"
                  ? j
                  : ""
                : void 0))
          : (j = null),
        _.d.C(O, j));
    }),
    (reactDom_production.prefetchDNS = function (O) {
      typeof O == "string" && _.d.D(O);
    }),
    (reactDom_production.preinit = function (O, j) {
      if (typeof O == "string" && j && typeof j.as == "string") {
        var F = j.as,
          q = R(F, j.crossOrigin),
          Q = typeof j.integrity == "string" ? j.integrity : void 0,
          te = typeof j.fetchPriority == "string" ? j.fetchPriority : void 0;
        F === "style"
          ? _.d.S(O, typeof j.precedence == "string" ? j.precedence : void 0, {
              crossOrigin: q,
              integrity: Q,
              fetchPriority: te,
            })
          : F === "script" &&
            _.d.X(O, {
              crossOrigin: q,
              integrity: Q,
              fetchPriority: te,
              nonce: typeof j.nonce == "string" ? j.nonce : void 0,
            });
      }
    }),
    (reactDom_production.preinitModule = function (O, j) {
      if (typeof O == "string")
        if (typeof j == "object" && j !== null) {
          if (j.as == null || j.as === "script") {
            var F = R(j.as, j.crossOrigin);
            _.d.M(O, {
              crossOrigin: F,
              integrity: typeof j.integrity == "string" ? j.integrity : void 0,
              nonce: typeof j.nonce == "string" ? j.nonce : void 0,
            });
          }
        } else j == null && _.d.M(O);
    }),
    (reactDom_production.preload = function (O, j) {
      if (
        typeof O == "string" &&
        typeof j == "object" &&
        j !== null &&
        typeof j.as == "string"
      ) {
        var F = j.as,
          q = R(F, j.crossOrigin);
        _.d.L(O, F, {
          crossOrigin: q,
          integrity: typeof j.integrity == "string" ? j.integrity : void 0,
          nonce: typeof j.nonce == "string" ? j.nonce : void 0,
          type: typeof j.type == "string" ? j.type : void 0,
          fetchPriority:
            typeof j.fetchPriority == "string" ? j.fetchPriority : void 0,
          referrerPolicy:
            typeof j.referrerPolicy == "string" ? j.referrerPolicy : void 0,
          imageSrcSet:
            typeof j.imageSrcSet == "string" ? j.imageSrcSet : void 0,
          imageSizes: typeof j.imageSizes == "string" ? j.imageSizes : void 0,
          media: typeof j.media == "string" ? j.media : void 0,
        });
      }
    }),
    (reactDom_production.preloadModule = function (O, j) {
      if (typeof O == "string")
        if (j) {
          var F = R(j.as, j.crossOrigin);
          _.d.m(O, {
            as: typeof j.as == "string" && j.as !== "script" ? j.as : void 0,
            crossOrigin: F,
            integrity: typeof j.integrity == "string" ? j.integrity : void 0,
          });
        } else _.d.m(O);
    }),
    (reactDom_production.requestFormReset = function (O) {
      _.d.r(O);
    }),
    (reactDom_production.unstable_batchedUpdates = function (O, j) {
      return O(j);
    }),
    (reactDom_production.useFormState = function (O, j, F) {
      return S.H.useFormState(O, j, F);
    }),
    (reactDom_production.useFormStatus = function () {
      return S.H.useHostTransitionStatus();
    }),
    (reactDom_production.version = "19.2.3"),
    reactDom_production
  );
}
var hasRequiredReactDom;
function requireReactDom() {
  if (hasRequiredReactDom) return reactDom.exports;
  hasRequiredReactDom = 1;
  function a() {
    if (
      !(
        typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" ||
        typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function"
      )
    )
      try {
        __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(a);
      } catch (e) {
        console.error(e);
      }
  }
  return (
    a(),
    (reactDom.exports = requireReactDom_production()),
    reactDom.exports
  );
}
/**
 * @license React
 * react-dom-client.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var hasRequiredReactDomClient_production;
function requireReactDomClient_production() {
  if (hasRequiredReactDomClient_production) return reactDomClient_production;
  hasRequiredReactDomClient_production = 1;
  var a = requireScheduler(),
    e = requireReact(),
    f = requireReactDom();
  function _(g) {
    var y = "https://react.dev/errors/" + g;
    if (1 < arguments.length) {
      y += "?args[]=" + encodeURIComponent(arguments[1]);
      for (var x = 2; x < arguments.length; x++)
        y += "&args[]=" + encodeURIComponent(arguments[x]);
    }
    return (
      "Minified React error #" +
      g +
      "; visit " +
      y +
      " for the full message or use the non-minified dev environment for full errors and additional helpful warnings."
    );
  }
  function w(g) {
    return !(!g || (g.nodeType !== 1 && g.nodeType !== 9 && g.nodeType !== 11));
  }
  function v(g) {
    var y = g,
      x = g;
    if (g.alternate) for (; y.return; ) y = y.return;
    else {
      g = y;
      do ((y = g), (y.flags & 4098) !== 0 && (x = y.return), (g = y.return));
      while (g);
    }
    return y.tag === 3 ? x : null;
  }
  function S(g) {
    if (g.tag === 13) {
      var y = g.memoizedState;
      if (
        (y === null && ((g = g.alternate), g !== null && (y = g.memoizedState)),
        y !== null)
      )
        return y.dehydrated;
    }
    return null;
  }
  function R(g) {
    if (g.tag === 31) {
      var y = g.memoizedState;
      if (
        (y === null && ((g = g.alternate), g !== null && (y = g.memoizedState)),
        y !== null)
      )
        return y.dehydrated;
    }
    return null;
  }
  function O(g) {
    if (v(g) !== g) throw Error(_(188));
  }
  function j(g) {
    var y = g.alternate;
    if (!y) {
      if (((y = v(g)), y === null)) throw Error(_(188));
      return y !== g ? null : g;
    }
    for (var x = g, E = y; ; ) {
      var V = x.return;
      if (V === null) break;
      var z = V.alternate;
      if (z === null) {
        if (((E = V.return), E !== null)) {
          x = E;
          continue;
        }
        break;
      }
      if (V.child === z.child) {
        for (z = V.child; z; ) {
          if (z === x) return (O(V), g);
          if (z === E) return (O(V), y);
          z = z.sibling;
        }
        throw Error(_(188));
      }
      if (x.return !== E.return) ((x = V), (E = z));
      else {
        for (var ne = !1, je = V.child; je; ) {
          if (je === x) {
            ((ne = !0), (x = V), (E = z));
            break;
          }
          if (je === E) {
            ((ne = !0), (E = V), (x = z));
            break;
          }
          je = je.sibling;
        }
        if (!ne) {
          for (je = z.child; je; ) {
            if (je === x) {
              ((ne = !0), (x = z), (E = V));
              break;
            }
            if (je === E) {
              ((ne = !0), (E = z), (x = V));
              break;
            }
            je = je.sibling;
          }
          if (!ne) throw Error(_(189));
        }
      }
      if (x.alternate !== E) throw Error(_(190));
    }
    if (x.tag !== 3) throw Error(_(188));
    return x.stateNode.current === x ? g : y;
  }
  function F(g) {
    var y = g.tag;
    if (y === 5 || y === 26 || y === 27 || y === 6) return g;
    for (g = g.child; g !== null; ) {
      if (((y = F(g)), y !== null)) return y;
      g = g.sibling;
    }
    return null;
  }
  var q = Object.assign,
    Q = Symbol.for("react.element"),
    te = Symbol.for("react.transitional.element"),
    se = Symbol.for("react.portal"),
    re = Symbol.for("react.fragment"),
    Oe = Symbol.for("react.strict_mode"),
    Le = Symbol.for("react.profiler"),
    Be = Symbol.for("react.consumer"),
    Ve = Symbol.for("react.context"),
    ze = Symbol.for("react.forward_ref"),
    Ge = Symbol.for("react.suspense"),
    Ke = Symbol.for("react.suspense_list"),
    qe = Symbol.for("react.memo"),
    nt = Symbol.for("react.lazy"),
    pt = Symbol.for("react.activity"),
    gt = Symbol.for("react.memo_cache_sentinel"),
    mt = Symbol.iterator;
  function dt(g) {
    return g === null || typeof g != "object"
      ? null
      : ((g = (mt && g[mt]) || g["@@iterator"]),
        typeof g == "function" ? g : null);
  }
  var _t = Symbol.for("react.client.reference");
  function bt(g) {
    if (g == null) return null;
    if (typeof g == "function")
      return g.$$typeof === _t ? null : g.displayName || g.name || null;
    if (typeof g == "string") return g;
    switch (g) {
      case re:
        return "Fragment";
      case Le:
        return "Profiler";
      case Oe:
        return "StrictMode";
      case Ge:
        return "Suspense";
      case Ke:
        return "SuspenseList";
      case pt:
        return "Activity";
    }
    if (typeof g == "object")
      switch (g.$$typeof) {
        case se:
          return "Portal";
        case Ve:
          return g.displayName || "Context";
        case Be:
          return (g._context.displayName || "Context") + ".Consumer";
        case ze:
          var y = g.render;
          return (
            (g = g.displayName),
            g ||
              ((g = y.displayName || y.name || ""),
              (g = g !== "" ? "ForwardRef(" + g + ")" : "ForwardRef")),
            g
          );
        case qe:
          return (
            (y = g.displayName || null),
            y !== null ? y : bt(g.type) || "Memo"
          );
        case nt:
          ((y = g._payload), (g = g._init));
          try {
            return bt(g(y));
          } catch {}
      }
    return null;
  }
  var at = Array.isArray,
    $e = e.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,
    Ye = f.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,
    Qe = { pending: !1, data: null, method: null, action: null },
    tt = [],
    ht = -1;
  function Fe(g) {
    return { current: g };
  }
  function Ue(g) {
    0 > ht || ((g.current = tt[ht]), (tt[ht] = null), ht--);
  }
  function ot(g, y) {
    (ht++, (tt[ht] = g.current), (g.current = y));
  }
  var lt = Fe(null),
    ut = Fe(null),
    yt = Fe(null),
    it = Fe(null);
  function Et(g, y) {
    switch ((ot(yt, y), ot(ut, g), ot(lt, null), y.nodeType)) {
      case 9:
      case 11:
        g = (g = y.documentElement) && (g = g.namespaceURI) ? Ff(g) : 0;
        break;
      default:
        if (((g = y.tagName), (y = y.namespaceURI)))
          ((y = Ff(y)), (g = $f(y, g)));
        else
          switch (g) {
            case "svg":
              g = 1;
              break;
            case "math":
              g = 2;
              break;
            default:
              g = 0;
          }
    }
    (Ue(lt), ot(lt, g));
  }
  function xt() {
    (Ue(lt), Ue(ut), Ue(yt));
  }
  function At(g) {
    g.memoizedState !== null && ot(it, g);
    var y = lt.current,
      x = $f(y, g.type);
    y !== x && (ot(ut, g), ot(lt, x));
  }
  function Lt(g) {
    (ut.current === g && (Ue(lt), Ue(ut)),
      it.current === g && (Ue(it), (Ds._currentValue = Qe)));
  }
  var Vt, Yt;
  function Zt(g) {
    if (Vt === void 0)
      try {
        throw Error();
      } catch (x) {
        var y = x.stack.trim().match(/\n( *(at )?)/);
        ((Vt = (y && y[1]) || ""),
          (Yt =
            -1 <
            x.stack.indexOf(`
    at`)
              ? " (<anonymous>)"
              : -1 < x.stack.indexOf("@")
                ? "@unknown:0:0"
                : ""));
      }
    return (
      `
` +
      Vt +
      g +
      Yt
    );
  }
  var gn = !1;
  function Wn(g, y) {
    if (!g || gn) return "";
    gn = !0;
    var x = Error.prepareStackTrace;
    Error.prepareStackTrace = void 0;
    try {
      var E = {
        DetermineComponentFrameRoot: function () {
          try {
            if (y) {
              var ft = function () {
                throw Error();
              };
              if (
                (Object.defineProperty(ft.prototype, "props", {
                  set: function () {
                    throw Error();
                  },
                }),
                typeof Reflect == "object" && Reflect.construct)
              ) {
                try {
                  Reflect.construct(ft, []);
                } catch (rt) {
                  var et = rt;
                }
                Reflect.construct(g, [], ft);
              } else {
                try {
                  ft.call();
                } catch (rt) {
                  et = rt;
                }
                g.call(ft.prototype);
              }
            } else {
              try {
                throw Error();
              } catch (rt) {
                et = rt;
              }
              (ft = g()) &&
                typeof ft.catch == "function" &&
                ft.catch(function () {});
            }
          } catch (rt) {
            if (rt && et && typeof rt.stack == "string")
              return [rt.stack, et.stack];
          }
          return [null, null];
        },
      };
      E.DetermineComponentFrameRoot.displayName = "DetermineComponentFrameRoot";
      var V = Object.getOwnPropertyDescriptor(
        E.DetermineComponentFrameRoot,
        "name",
      );
      V &&
        V.configurable &&
        Object.defineProperty(E.DetermineComponentFrameRoot, "name", {
          value: "DetermineComponentFrameRoot",
        });
      var z = E.DetermineComponentFrameRoot(),
        ne = z[0],
        je = z[1];
      if (ne && je) {
        var He = ne.split(`
`),
          Je = je.split(`
`);
        for (
          V = E = 0;
          E < He.length && !He[E].includes("DetermineComponentFrameRoot");

        )
          E++;
        for (
          ;
          V < Je.length && !Je[V].includes("DetermineComponentFrameRoot");

        )
          V++;
        if (E === He.length || V === Je.length)
          for (
            E = He.length - 1, V = Je.length - 1;
            1 <= E && 0 <= V && He[E] !== Je[V];

          )
            V--;
        for (; 1 <= E && 0 <= V; E--, V--)
          if (He[E] !== Je[V]) {
            if (E !== 1 || V !== 1)
              do
                if ((E--, V--, 0 > V || He[E] !== Je[V])) {
                  var st =
                    `
` + He[E].replace(" at new ", " at ");
                  return (
                    g.displayName &&
                      st.includes("<anonymous>") &&
                      (st = st.replace("<anonymous>", g.displayName)),
                    st
                  );
                }
              while (1 <= E && 0 <= V);
            break;
          }
      }
    } finally {
      ((gn = !1), (Error.prepareStackTrace = x));
    }
    return (x = g ? g.displayName || g.name : "") ? Zt(x) : "";
  }
  function Ho(g, y) {
    switch (g.tag) {
      case 26:
      case 27:
      case 5:
        return Zt(g.type);
      case 16:
        return Zt("Lazy");
      case 13:
        return g.child !== y && y !== null
          ? Zt("Suspense Fallback")
          : Zt("Suspense");
      case 19:
        return Zt("SuspenseList");
      case 0:
      case 15:
        return Wn(g.type, !1);
      case 11:
        return Wn(g.type.render, !1);
      case 1:
        return Wn(g.type, !0);
      case 31:
        return Zt("Activity");
      default:
        return "";
    }
  }
  function gc(g) {
    try {
      var y = "",
        x = null;
      do ((y += Ho(g, x)), (x = g), (g = g.return));
      while (g);
      return y;
    } catch (E) {
      return (
        `
Error generating stack: ` +
        E.message +
        `
` +
        E.stack
      );
    }
  }
  var ea = Object.prototype.hasOwnProperty,
    ta = a.unstable_scheduleCallback,
    na = a.unstable_cancelCallback,
    yp = a.unstable_shouldYield,
    bp = a.unstable_requestPaint,
    En = a.unstable_now,
    wp = a.unstable_getCurrentPriorityLevel,
    hc = a.unstable_ImmediatePriority,
    _c = a.unstable_UserBlockingPriority,
    Bs = a.unstable_NormalPriority,
    xp = a.unstable_LowPriority,
    yc = a.unstable_IdlePriority,
    vp = a.log,
    Ep = a.unstable_setDisableYieldValue,
    Go = null,
    Sn = null;
  function hr(g) {
    if (
      (typeof vp == "function" && Ep(g),
      Sn && typeof Sn.setStrictMode == "function")
    )
      try {
        Sn.setStrictMode(Go, g);
      } catch {}
  }
  var Tn = Math.clz32 ? Math.clz32 : Ap,
    Sp = Math.log,
    Tp = Math.LN2;
  function Ap(g) {
    return ((g >>>= 0), g === 0 ? 32 : (31 - ((Sp(g) / Tp) | 0)) | 0);
  }
  var Vs = 256,
    zs = 262144,
    Fs = 4194304;
  function $r(g) {
    var y = g & 42;
    if (y !== 0) return y;
    switch (g & -g) {
      case 1:
        return 1;
      case 2:
        return 2;
      case 4:
        return 4;
      case 8:
        return 8;
      case 16:
        return 16;
      case 32:
        return 32;
      case 64:
        return 64;
      case 128:
        return 128;
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
        return g & 261888;
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return g & 3932160;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
        return g & 62914560;
      case 67108864:
        return 67108864;
      case 134217728:
        return 134217728;
      case 268435456:
        return 268435456;
      case 536870912:
        return 536870912;
      case 1073741824:
        return 0;
      default:
        return g;
    }
  }
  function $s(g, y, x) {
    var E = g.pendingLanes;
    if (E === 0) return 0;
    var V = 0,
      z = g.suspendedLanes,
      ne = g.pingedLanes;
    g = g.warmLanes;
    var je = E & 134217727;
    return (
      je !== 0
        ? ((E = je & ~z),
          E !== 0
            ? (V = $r(E))
            : ((ne &= je),
              ne !== 0
                ? (V = $r(ne))
                : x || ((x = je & ~g), x !== 0 && (V = $r(x)))))
        : ((je = E & ~z),
          je !== 0
            ? (V = $r(je))
            : ne !== 0
              ? (V = $r(ne))
              : x || ((x = E & ~g), x !== 0 && (V = $r(x)))),
      V === 0
        ? 0
        : y !== 0 &&
            y !== V &&
            (y & z) === 0 &&
            ((z = V & -V),
            (x = y & -y),
            z >= x || (z === 32 && (x & 4194048) !== 0))
          ? y
          : V
    );
  }
  function Wo(g, y) {
    return (g.pendingLanes & ~(g.suspendedLanes & ~g.pingedLanes) & y) === 0;
  }
  function Rp(g, y) {
    switch (g) {
      case 1:
      case 2:
      case 4:
      case 8:
      case 64:
        return y + 250;
      case 16:
      case 32:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return y + 5e3;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
        return -1;
      case 67108864:
      case 134217728:
      case 268435456:
      case 536870912:
      case 1073741824:
        return -1;
      default:
        return -1;
    }
  }
  function bc() {
    var g = Fs;
    return ((Fs <<= 1), (Fs & 62914560) === 0 && (Fs = 4194304), g);
  }
  function ra(g) {
    for (var y = [], x = 0; 31 > x; x++) y.push(g);
    return y;
  }
  function qo(g, y) {
    ((g.pendingLanes |= y),
      y !== 268435456 &&
        ((g.suspendedLanes = 0), (g.pingedLanes = 0), (g.warmLanes = 0)));
  }
  function Cp(g, y, x, E, V, z) {
    var ne = g.pendingLanes;
    ((g.pendingLanes = x),
      (g.suspendedLanes = 0),
      (g.pingedLanes = 0),
      (g.warmLanes = 0),
      (g.expiredLanes &= x),
      (g.entangledLanes &= x),
      (g.errorRecoveryDisabledLanes &= x),
      (g.shellSuspendCounter = 0));
    var je = g.entanglements,
      He = g.expirationTimes,
      Je = g.hiddenUpdates;
    for (x = ne & ~x; 0 < x; ) {
      var st = 31 - Tn(x),
        ft = 1 << st;
      ((je[st] = 0), (He[st] = -1));
      var et = Je[st];
      if (et !== null)
        for (Je[st] = null, st = 0; st < et.length; st++) {
          var rt = et[st];
          rt !== null && (rt.lane &= -536870913);
        }
      x &= ~ft;
    }
    (E !== 0 && wc(g, E, 0),
      z !== 0 &&
        V === 0 &&
        g.tag !== 0 &&
        (g.suspendedLanes |= z & ~(ne & ~y)));
  }
  function wc(g, y, x) {
    ((g.pendingLanes |= y), (g.suspendedLanes &= ~y));
    var E = 31 - Tn(y);
    ((g.entangledLanes |= y),
      (g.entanglements[E] = g.entanglements[E] | 1073741824 | (x & 261930)));
  }
  function xc(g, y) {
    var x = (g.entangledLanes |= y);
    for (g = g.entanglements; x; ) {
      var E = 31 - Tn(x),
        V = 1 << E;
      ((V & y) | (g[E] & y) && (g[E] |= y), (x &= ~V));
    }
  }
  function vc(g, y) {
    var x = y & -y;
    return (
      (x = (x & 42) !== 0 ? 1 : oa(x)),
      (x & (g.suspendedLanes | y)) !== 0 ? 0 : x
    );
  }
  function oa(g) {
    switch (g) {
      case 2:
        g = 1;
        break;
      case 8:
        g = 4;
        break;
      case 32:
        g = 16;
        break;
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
        g = 128;
        break;
      case 268435456:
        g = 134217728;
        break;
      default:
        g = 0;
    }
    return g;
  }
  function sa(g) {
    return (
      (g &= -g),
      2 < g ? (8 < g ? ((g & 134217727) !== 0 ? 32 : 268435456) : 8) : 2
    );
  }
  function Ec() {
    var g = Ye.p;
    return g !== 0 ? g : ((g = window.event), g === void 0 ? 32 : up(g.type));
  }
  function Sc(g, y) {
    var x = Ye.p;
    try {
      return ((Ye.p = g), y());
    } finally {
      Ye.p = x;
    }
  }
  var _r = Math.random().toString(36).slice(2),
    ln = "__reactFiber$" + _r,
    hn = "__reactProps$" + _r,
    so = "__reactContainer$" + _r,
    ia = "__reactEvents$" + _r,
    Mp = "__reactListeners$" + _r,
    Np = "__reactHandles$" + _r,
    Tc = "__reactResources$" + _r,
    Yo = "__reactMarker$" + _r;
  function aa(g) {
    (delete g[ln], delete g[hn], delete g[ia], delete g[Mp], delete g[Np]);
  }
  function io(g) {
    var y = g[ln];
    if (y) return y;
    for (var x = g.parentNode; x; ) {
      if ((y = x[so] || x[ln])) {
        if (
          ((x = y.alternate),
          y.child !== null || (x !== null && x.child !== null))
        )
          for (g = Yf(g); g !== null; ) {
            if ((x = g[ln])) return x;
            g = Yf(g);
          }
        return y;
      }
      ((g = x), (x = g.parentNode));
    }
    return null;
  }
  function ao(g) {
    if ((g = g[ln] || g[so])) {
      var y = g.tag;
      if (
        y === 5 ||
        y === 6 ||
        y === 13 ||
        y === 31 ||
        y === 26 ||
        y === 27 ||
        y === 3
      )
        return g;
    }
    return null;
  }
  function Ko(g) {
    var y = g.tag;
    if (y === 5 || y === 26 || y === 27 || y === 6) return g.stateNode;
    throw Error(_(33));
  }
  function lo(g) {
    var y = g[Tc];
    return (
      y ||
        (y = g[Tc] =
          { hoistableStyles: new Map(), hoistableScripts: new Map() }),
      y
    );
  }
  function sn(g) {
    g[Yo] = !0;
  }
  var Ac = new Set(),
    Rc = {};
  function kr(g, y) {
    (co(g, y), co(g + "Capture", y));
  }
  function co(g, y) {
    for (Rc[g] = y, g = 0; g < y.length; g++) Ac.add(y[g]);
  }
  var Op = RegExp(
      "^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$",
    ),
    Cc = {},
    Mc = {};
  function Ip(g) {
    return ea.call(Mc, g)
      ? !0
      : ea.call(Cc, g)
        ? !1
        : Op.test(g)
          ? (Mc[g] = !0)
          : ((Cc[g] = !0), !1);
  }
  function ks(g, y, x) {
    if (Ip(y))
      if (x === null) g.removeAttribute(y);
      else {
        switch (typeof x) {
          case "undefined":
          case "function":
          case "symbol":
            g.removeAttribute(y);
            return;
          case "boolean":
            var E = y.toLowerCase().slice(0, 5);
            if (E !== "data-" && E !== "aria-") {
              g.removeAttribute(y);
              return;
            }
        }
        g.setAttribute(y, "" + x);
      }
  }
  function Us(g, y, x) {
    if (x === null) g.removeAttribute(y);
    else {
      switch (typeof x) {
        case "undefined":
        case "function":
        case "symbol":
        case "boolean":
          g.removeAttribute(y);
          return;
      }
      g.setAttribute(y, "" + x);
    }
  }
  function Zn(g, y, x, E) {
    if (E === null) g.removeAttribute(x);
    else {
      switch (typeof E) {
        case "undefined":
        case "function":
        case "symbol":
        case "boolean":
          g.removeAttribute(x);
          return;
      }
      g.setAttributeNS(y, x, "" + E);
    }
  }
  function Dn(g) {
    switch (typeof g) {
      case "bigint":
      case "boolean":
      case "number":
      case "string":
      case "undefined":
        return g;
      case "object":
        return g;
      default:
        return "";
    }
  }
  function Nc(g) {
    var y = g.type;
    return (
      (g = g.nodeName) &&
      g.toLowerCase() === "input" &&
      (y === "checkbox" || y === "radio")
    );
  }
  function Dp(g, y, x) {
    var E = Object.getOwnPropertyDescriptor(g.constructor.prototype, y);
    if (
      !g.hasOwnProperty(y) &&
      typeof E < "u" &&
      typeof E.get == "function" &&
      typeof E.set == "function"
    ) {
      var V = E.get,
        z = E.set;
      return (
        Object.defineProperty(g, y, {
          configurable: !0,
          get: function () {
            return V.call(this);
          },
          set: function (ne) {
            ((x = "" + ne), z.call(this, ne));
          },
        }),
        Object.defineProperty(g, y, { enumerable: E.enumerable }),
        {
          getValue: function () {
            return x;
          },
          setValue: function (ne) {
            x = "" + ne;
          },
          stopTracking: function () {
            ((g._valueTracker = null), delete g[y]);
          },
        }
      );
    }
  }
  function la(g) {
    if (!g._valueTracker) {
      var y = Nc(g) ? "checked" : "value";
      g._valueTracker = Dp(g, y, "" + g[y]);
    }
  }
  function Oc(g) {
    if (!g) return !1;
    var y = g._valueTracker;
    if (!y) return !0;
    var x = y.getValue(),
      E = "";
    return (
      g && (E = Nc(g) ? (g.checked ? "true" : "false") : g.value),
      (g = E),
      g !== x ? (y.setValue(g), !0) : !1
    );
  }
  function Hs(g) {
    if (
      ((g = g || (typeof document < "u" ? document : void 0)), typeof g > "u")
    )
      return null;
    try {
      return g.activeElement || g.body;
    } catch {
      return g.body;
    }
  }
  var Lp = /[\n"\\]/g;
  function Ln(g) {
    return g.replace(Lp, function (y) {
      return "\\" + y.charCodeAt(0).toString(16) + " ";
    });
  }
  function ca(g, y, x, E, V, z, ne, je) {
    ((g.name = ""),
      ne != null &&
      typeof ne != "function" &&
      typeof ne != "symbol" &&
      typeof ne != "boolean"
        ? (g.type = ne)
        : g.removeAttribute("type"),
      y != null
        ? ne === "number"
          ? ((y === 0 && g.value === "") || g.value != y) &&
            (g.value = "" + Dn(y))
          : g.value !== "" + Dn(y) && (g.value = "" + Dn(y))
        : (ne !== "submit" && ne !== "reset") || g.removeAttribute("value"),
      y != null
        ? ua(g, ne, Dn(y))
        : x != null
          ? ua(g, ne, Dn(x))
          : E != null && g.removeAttribute("value"),
      V == null && z != null && (g.defaultChecked = !!z),
      V != null &&
        (g.checked = V && typeof V != "function" && typeof V != "symbol"),
      je != null &&
      typeof je != "function" &&
      typeof je != "symbol" &&
      typeof je != "boolean"
        ? (g.name = "" + Dn(je))
        : g.removeAttribute("name"));
  }
  function Ic(g, y, x, E, V, z, ne, je) {
    if (
      (z != null &&
        typeof z != "function" &&
        typeof z != "symbol" &&
        typeof z != "boolean" &&
        (g.type = z),
      y != null || x != null)
    ) {
      if (!((z !== "submit" && z !== "reset") || y != null)) {
        la(g);
        return;
      }
      ((x = x != null ? "" + Dn(x) : ""),
        (y = y != null ? "" + Dn(y) : x),
        je || y === g.value || (g.value = y),
        (g.defaultValue = y));
    }
    ((E = E ?? V),
      (E = typeof E != "function" && typeof E != "symbol" && !!E),
      (g.checked = je ? g.checked : !!E),
      (g.defaultChecked = !!E),
      ne != null &&
        typeof ne != "function" &&
        typeof ne != "symbol" &&
        typeof ne != "boolean" &&
        (g.name = ne),
      la(g));
  }
  function ua(g, y, x) {
    (y === "number" && Hs(g.ownerDocument) === g) ||
      g.defaultValue === "" + x ||
      (g.defaultValue = "" + x);
  }
  function uo(g, y, x, E) {
    if (((g = g.options), y)) {
      y = {};
      for (var V = 0; V < x.length; V++) y["$" + x[V]] = !0;
      for (x = 0; x < g.length; x++)
        ((V = y.hasOwnProperty("$" + g[x].value)),
          g[x].selected !== V && (g[x].selected = V),
          V && E && (g[x].defaultSelected = !0));
    } else {
      for (x = "" + Dn(x), y = null, V = 0; V < g.length; V++) {
        if (g[V].value === x) {
          ((g[V].selected = !0), E && (g[V].defaultSelected = !0));
          return;
        }
        y !== null || g[V].disabled || (y = g[V]);
      }
      y !== null && (y.selected = !0);
    }
  }
  function Dc(g, y, x) {
    if (
      y != null &&
      ((y = "" + Dn(y)), y !== g.value && (g.value = y), x == null)
    ) {
      g.defaultValue !== y && (g.defaultValue = y);
      return;
    }
    g.defaultValue = x != null ? "" + Dn(x) : "";
  }
  function Lc(g, y, x, E) {
    if (y == null) {
      if (E != null) {
        if (x != null) throw Error(_(92));
        if (at(E)) {
          if (1 < E.length) throw Error(_(93));
          E = E[0];
        }
        x = E;
      }
      (x == null && (x = ""), (y = x));
    }
    ((x = Dn(y)),
      (g.defaultValue = x),
      (E = g.textContent),
      E === x && E !== "" && E !== null && (g.value = E),
      la(g));
  }
  function fo(g, y) {
    if (y) {
      var x = g.firstChild;
      if (x && x === g.lastChild && x.nodeType === 3) {
        x.nodeValue = y;
        return;
      }
    }
    g.textContent = y;
  }
  var Pp = new Set(
    "animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp".split(
      " ",
    ),
  );
  function Pc(g, y, x) {
    var E = y.indexOf("--") === 0;
    x == null || typeof x == "boolean" || x === ""
      ? E
        ? g.setProperty(y, "")
        : y === "float"
          ? (g.cssFloat = "")
          : (g[y] = "")
      : E
        ? g.setProperty(y, x)
        : typeof x != "number" || x === 0 || Pp.has(y)
          ? y === "float"
            ? (g.cssFloat = x)
            : (g[y] = ("" + x).trim())
          : (g[y] = x + "px");
  }
  function jc(g, y, x) {
    if (y != null && typeof y != "object") throw Error(_(62));
    if (((g = g.style), x != null)) {
      for (var E in x)
        !x.hasOwnProperty(E) ||
          (y != null && y.hasOwnProperty(E)) ||
          (E.indexOf("--") === 0
            ? g.setProperty(E, "")
            : E === "float"
              ? (g.cssFloat = "")
              : (g[E] = ""));
      for (var V in y)
        ((E = y[V]), y.hasOwnProperty(V) && x[V] !== E && Pc(g, V, E));
    } else for (var z in y) y.hasOwnProperty(z) && Pc(g, z, y[z]);
  }
  function da(g) {
    if (g.indexOf("-") === -1) return !1;
    switch (g) {
      case "annotation-xml":
      case "color-profile":
      case "font-face":
      case "font-face-src":
      case "font-face-uri":
      case "font-face-format":
      case "font-face-name":
      case "missing-glyph":
        return !1;
      default:
        return !0;
    }
  }
  var jp = new Map([
      ["acceptCharset", "accept-charset"],
      ["htmlFor", "for"],
      ["httpEquiv", "http-equiv"],
      ["crossOrigin", "crossorigin"],
      ["accentHeight", "accent-height"],
      ["alignmentBaseline", "alignment-baseline"],
      ["arabicForm", "arabic-form"],
      ["baselineShift", "baseline-shift"],
      ["capHeight", "cap-height"],
      ["clipPath", "clip-path"],
      ["clipRule", "clip-rule"],
      ["colorInterpolation", "color-interpolation"],
      ["colorInterpolationFilters", "color-interpolation-filters"],
      ["colorProfile", "color-profile"],
      ["colorRendering", "color-rendering"],
      ["dominantBaseline", "dominant-baseline"],
      ["enableBackground", "enable-background"],
      ["fillOpacity", "fill-opacity"],
      ["fillRule", "fill-rule"],
      ["floodColor", "flood-color"],
      ["floodOpacity", "flood-opacity"],
      ["fontFamily", "font-family"],
      ["fontSize", "font-size"],
      ["fontSizeAdjust", "font-size-adjust"],
      ["fontStretch", "font-stretch"],
      ["fontStyle", "font-style"],
      ["fontVariant", "font-variant"],
      ["fontWeight", "font-weight"],
      ["glyphName", "glyph-name"],
      ["glyphOrientationHorizontal", "glyph-orientation-horizontal"],
      ["glyphOrientationVertical", "glyph-orientation-vertical"],
      ["horizAdvX", "horiz-adv-x"],
      ["horizOriginX", "horiz-origin-x"],
      ["imageRendering", "image-rendering"],
      ["letterSpacing", "letter-spacing"],
      ["lightingColor", "lighting-color"],
      ["markerEnd", "marker-end"],
      ["markerMid", "marker-mid"],
      ["markerStart", "marker-start"],
      ["overlinePosition", "overline-position"],
      ["overlineThickness", "overline-thickness"],
      ["paintOrder", "paint-order"],
      ["panose-1", "panose-1"],
      ["pointerEvents", "pointer-events"],
      ["renderingIntent", "rendering-intent"],
      ["shapeRendering", "shape-rendering"],
      ["stopColor", "stop-color"],
      ["stopOpacity", "stop-opacity"],
      ["strikethroughPosition", "strikethrough-position"],
      ["strikethroughThickness", "strikethrough-thickness"],
      ["strokeDasharray", "stroke-dasharray"],
      ["strokeDashoffset", "stroke-dashoffset"],
      ["strokeLinecap", "stroke-linecap"],
      ["strokeLinejoin", "stroke-linejoin"],
      ["strokeMiterlimit", "stroke-miterlimit"],
      ["strokeOpacity", "stroke-opacity"],
      ["strokeWidth", "stroke-width"],
      ["textAnchor", "text-anchor"],
      ["textDecoration", "text-decoration"],
      ["textRendering", "text-rendering"],
      ["transformOrigin", "transform-origin"],
      ["underlinePosition", "underline-position"],
      ["underlineThickness", "underline-thickness"],
      ["unicodeBidi", "unicode-bidi"],
      ["unicodeRange", "unicode-range"],
      ["unitsPerEm", "units-per-em"],
      ["vAlphabetic", "v-alphabetic"],
      ["vHanging", "v-hanging"],
      ["vIdeographic", "v-ideographic"],
      ["vMathematical", "v-mathematical"],
      ["vectorEffect", "vector-effect"],
      ["vertAdvY", "vert-adv-y"],
      ["vertOriginX", "vert-origin-x"],
      ["vertOriginY", "vert-origin-y"],
      ["wordSpacing", "word-spacing"],
      ["writingMode", "writing-mode"],
      ["xmlnsXlink", "xmlns:xlink"],
      ["xHeight", "x-height"],
    ]),
    Bp =
      /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*:/i;
  function Gs(g) {
    return Bp.test("" + g)
      ? "javascript:throw new Error('React has blocked a javascript: URL as a security precaution.')"
      : g;
  }
  function Jn() {}
  var fa = null;
  function pa(g) {
    return (
      (g = g.target || g.srcElement || window),
      g.correspondingUseElement && (g = g.correspondingUseElement),
      g.nodeType === 3 ? g.parentNode : g
    );
  }
  var po = null,
    mo = null;
  function Bc(g) {
    var y = ao(g);
    if (y && (g = y.stateNode)) {
      var x = g[hn] || null;
      e: switch (((g = y.stateNode), y.type)) {
        case "input":
          if (
            (ca(
              g,
              x.value,
              x.defaultValue,
              x.defaultValue,
              x.checked,
              x.defaultChecked,
              x.type,
              x.name,
            ),
            (y = x.name),
            x.type === "radio" && y != null)
          ) {
            for (x = g; x.parentNode; ) x = x.parentNode;
            for (
              x = x.querySelectorAll(
                'input[name="' + Ln("" + y) + '"][type="radio"]',
              ),
                y = 0;
              y < x.length;
              y++
            ) {
              var E = x[y];
              if (E !== g && E.form === g.form) {
                var V = E[hn] || null;
                if (!V) throw Error(_(90));
                ca(
                  E,
                  V.value,
                  V.defaultValue,
                  V.defaultValue,
                  V.checked,
                  V.defaultChecked,
                  V.type,
                  V.name,
                );
              }
            }
            for (y = 0; y < x.length; y++)
              ((E = x[y]), E.form === g.form && Oc(E));
          }
          break e;
        case "textarea":
          Dc(g, x.value, x.defaultValue);
          break e;
        case "select":
          ((y = x.value), y != null && uo(g, !!x.multiple, y, !1));
      }
    }
  }
  var ma = !1;
  function Vc(g, y, x) {
    if (ma) return g(y, x);
    ma = !0;
    try {
      var E = g(y);
      return E;
    } finally {
      if (
        ((ma = !1),
        (po !== null || mo !== null) &&
          (Ii(), po && ((y = po), (g = mo), (mo = po = null), Bc(y), g)))
      )
        for (y = 0; y < g.length; y++) Bc(g[y]);
    }
  }
  function Xo(g, y) {
    var x = g.stateNode;
    if (x === null) return null;
    var E = x[hn] || null;
    if (E === null) return null;
    x = E[y];
    e: switch (y) {
      case "onClick":
      case "onClickCapture":
      case "onDoubleClick":
      case "onDoubleClickCapture":
      case "onMouseDown":
      case "onMouseDownCapture":
      case "onMouseMove":
      case "onMouseMoveCapture":
      case "onMouseUp":
      case "onMouseUpCapture":
      case "onMouseEnter":
        ((E = !E.disabled) ||
          ((g = g.type),
          (E = !(
            g === "button" ||
            g === "input" ||
            g === "select" ||
            g === "textarea"
          ))),
          (g = !E));
        break e;
      default:
        g = !1;
    }
    if (g) return null;
    if (x && typeof x != "function") throw Error(_(231, y, typeof x));
    return x;
  }
  var Qn = !(
      typeof window > "u" ||
      typeof window.document > "u" ||
      typeof window.document.createElement > "u"
    ),
    ga = !1;
  if (Qn)
    try {
      var Zo = {};
      (Object.defineProperty(Zo, "passive", {
        get: function () {
          ga = !0;
        },
      }),
        window.addEventListener("test", Zo, Zo),
        window.removeEventListener("test", Zo, Zo));
    } catch {
      ga = !1;
    }
  var yr = null,
    ha = null,
    Ws = null;
  function zc() {
    if (Ws) return Ws;
    var g,
      y = ha,
      x = y.length,
      E,
      V = "value" in yr ? yr.value : yr.textContent,
      z = V.length;
    for (g = 0; g < x && y[g] === V[g]; g++);
    var ne = x - g;
    for (E = 1; E <= ne && y[x - E] === V[z - E]; E++);
    return (Ws = V.slice(g, 1 < E ? 1 - E : void 0));
  }
  function qs(g) {
    var y = g.keyCode;
    return (
      "charCode" in g
        ? ((g = g.charCode), g === 0 && y === 13 && (g = 13))
        : (g = y),
      g === 10 && (g = 13),
      32 <= g || g === 13 ? g : 0
    );
  }
  function Ys() {
    return !0;
  }
  function Fc() {
    return !1;
  }
  function _n(g) {
    function y(x, E, V, z, ne) {
      ((this._reactName = x),
        (this._targetInst = V),
        (this.type = E),
        (this.nativeEvent = z),
        (this.target = ne),
        (this.currentTarget = null));
      for (var je in g)
        g.hasOwnProperty(je) && ((x = g[je]), (this[je] = x ? x(z) : z[je]));
      return (
        (this.isDefaultPrevented = (
          z.defaultPrevented != null ? z.defaultPrevented : z.returnValue === !1
        )
          ? Ys
          : Fc),
        (this.isPropagationStopped = Fc),
        this
      );
    }
    return (
      q(y.prototype, {
        preventDefault: function () {
          this.defaultPrevented = !0;
          var x = this.nativeEvent;
          x &&
            (x.preventDefault
              ? x.preventDefault()
              : typeof x.returnValue != "unknown" && (x.returnValue = !1),
            (this.isDefaultPrevented = Ys));
        },
        stopPropagation: function () {
          var x = this.nativeEvent;
          x &&
            (x.stopPropagation
              ? x.stopPropagation()
              : typeof x.cancelBubble != "unknown" && (x.cancelBubble = !0),
            (this.isPropagationStopped = Ys));
        },
        persist: function () {},
        isPersistent: Ys,
      }),
      y
    );
  }
  var Ur = {
      eventPhase: 0,
      bubbles: 0,
      cancelable: 0,
      timeStamp: function (g) {
        return g.timeStamp || Date.now();
      },
      defaultPrevented: 0,
      isTrusted: 0,
    },
    Ks = _n(Ur),
    Jo = q({}, Ur, { view: 0, detail: 0 }),
    Vp = _n(Jo),
    _a,
    ya,
    Qo,
    Xs = q({}, Jo, {
      screenX: 0,
      screenY: 0,
      clientX: 0,
      clientY: 0,
      pageX: 0,
      pageY: 0,
      ctrlKey: 0,
      shiftKey: 0,
      altKey: 0,
      metaKey: 0,
      getModifierState: wa,
      button: 0,
      buttons: 0,
      relatedTarget: function (g) {
        return g.relatedTarget === void 0
          ? g.fromElement === g.srcElement
            ? g.toElement
            : g.fromElement
          : g.relatedTarget;
      },
      movementX: function (g) {
        return "movementX" in g
          ? g.movementX
          : (g !== Qo &&
              (Qo && g.type === "mousemove"
                ? ((_a = g.screenX - Qo.screenX), (ya = g.screenY - Qo.screenY))
                : (ya = _a = 0),
              (Qo = g)),
            _a);
      },
      movementY: function (g) {
        return "movementY" in g ? g.movementY : ya;
      },
    }),
    $c = _n(Xs),
    zp = q({}, Xs, { dataTransfer: 0 }),
    Fp = _n(zp),
    $p = q({}, Jo, { relatedTarget: 0 }),
    ba = _n($p),
    kp = q({}, Ur, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }),
    Up = _n(kp),
    Hp = q({}, Ur, {
      clipboardData: function (g) {
        return "clipboardData" in g ? g.clipboardData : window.clipboardData;
      },
    }),
    Gp = _n(Hp),
    Wp = q({}, Ur, { data: 0 }),
    kc = _n(Wp),
    qp = {
      Esc: "Escape",
      Spacebar: " ",
      Left: "ArrowLeft",
      Up: "ArrowUp",
      Right: "ArrowRight",
      Down: "ArrowDown",
      Del: "Delete",
      Win: "OS",
      Menu: "ContextMenu",
      Apps: "ContextMenu",
      Scroll: "ScrollLock",
      MozPrintableKey: "Unidentified",
    },
    Yp = {
      8: "Backspace",
      9: "Tab",
      12: "Clear",
      13: "Enter",
      16: "Shift",
      17: "Control",
      18: "Alt",
      19: "Pause",
      20: "CapsLock",
      27: "Escape",
      32: " ",
      33: "PageUp",
      34: "PageDown",
      35: "End",
      36: "Home",
      37: "ArrowLeft",
      38: "ArrowUp",
      39: "ArrowRight",
      40: "ArrowDown",
      45: "Insert",
      46: "Delete",
      112: "F1",
      113: "F2",
      114: "F3",
      115: "F4",
      116: "F5",
      117: "F6",
      118: "F7",
      119: "F8",
      120: "F9",
      121: "F10",
      122: "F11",
      123: "F12",
      144: "NumLock",
      145: "ScrollLock",
      224: "Meta",
    },
    Kp = {
      Alt: "altKey",
      Control: "ctrlKey",
      Meta: "metaKey",
      Shift: "shiftKey",
    };
  function Xp(g) {
    var y = this.nativeEvent;
    return y.getModifierState
      ? y.getModifierState(g)
      : (g = Kp[g])
        ? !!y[g]
        : !1;
  }
  function wa() {
    return Xp;
  }
  var Zp = q({}, Jo, {
      key: function (g) {
        if (g.key) {
          var y = qp[g.key] || g.key;
          if (y !== "Unidentified") return y;
        }
        return g.type === "keypress"
          ? ((g = qs(g)), g === 13 ? "Enter" : String.fromCharCode(g))
          : g.type === "keydown" || g.type === "keyup"
            ? Yp[g.keyCode] || "Unidentified"
            : "";
      },
      code: 0,
      location: 0,
      ctrlKey: 0,
      shiftKey: 0,
      altKey: 0,
      metaKey: 0,
      repeat: 0,
      locale: 0,
      getModifierState: wa,
      charCode: function (g) {
        return g.type === "keypress" ? qs(g) : 0;
      },
      keyCode: function (g) {
        return g.type === "keydown" || g.type === "keyup" ? g.keyCode : 0;
      },
      which: function (g) {
        return g.type === "keypress"
          ? qs(g)
          : g.type === "keydown" || g.type === "keyup"
            ? g.keyCode
            : 0;
      },
    }),
    Jp = _n(Zp),
    Qp = q({}, Xs, {
      pointerId: 0,
      width: 0,
      height: 0,
      pressure: 0,
      tangentialPressure: 0,
      tiltX: 0,
      tiltY: 0,
      twist: 0,
      pointerType: 0,
      isPrimary: 0,
    }),
    Uc = _n(Qp),
    em = q({}, Jo, {
      touches: 0,
      targetTouches: 0,
      changedTouches: 0,
      altKey: 0,
      metaKey: 0,
      ctrlKey: 0,
      shiftKey: 0,
      getModifierState: wa,
    }),
    tm = _n(em),
    nm = q({}, Ur, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }),
    rm = _n(nm),
    om = q({}, Xs, {
      deltaX: function (g) {
        return "deltaX" in g
          ? g.deltaX
          : "wheelDeltaX" in g
            ? -g.wheelDeltaX
            : 0;
      },
      deltaY: function (g) {
        return "deltaY" in g
          ? g.deltaY
          : "wheelDeltaY" in g
            ? -g.wheelDeltaY
            : "wheelDelta" in g
              ? -g.wheelDelta
              : 0;
      },
      deltaZ: 0,
      deltaMode: 0,
    }),
    sm = _n(om),
    im = q({}, Ur, { newState: 0, oldState: 0 }),
    am = _n(im),
    lm = [9, 13, 27, 32],
    xa = Qn && "CompositionEvent" in window,
    es = null;
  Qn && "documentMode" in document && (es = document.documentMode);
  var cm = Qn && "TextEvent" in window && !es,
    Hc = Qn && (!xa || (es && 8 < es && 11 >= es)),
    Gc = " ",
    Wc = !1;
  function qc(g, y) {
    switch (g) {
      case "keyup":
        return lm.indexOf(y.keyCode) !== -1;
      case "keydown":
        return y.keyCode !== 229;
      case "keypress":
      case "mousedown":
      case "focusout":
        return !0;
      default:
        return !1;
    }
  }
  function Yc(g) {
    return (
      (g = g.detail),
      typeof g == "object" && "data" in g ? g.data : null
    );
  }
  var go = !1;
  function um(g, y) {
    switch (g) {
      case "compositionend":
        return Yc(y);
      case "keypress":
        return y.which !== 32 ? null : ((Wc = !0), Gc);
      case "textInput":
        return ((g = y.data), g === Gc && Wc ? null : g);
      default:
        return null;
    }
  }
  function dm(g, y) {
    if (go)
      return g === "compositionend" || (!xa && qc(g, y))
        ? ((g = zc()), (Ws = ha = yr = null), (go = !1), g)
        : null;
    switch (g) {
      case "paste":
        return null;
      case "keypress":
        if (!(y.ctrlKey || y.altKey || y.metaKey) || (y.ctrlKey && y.altKey)) {
          if (y.char && 1 < y.char.length) return y.char;
          if (y.which) return String.fromCharCode(y.which);
        }
        return null;
      case "compositionend":
        return Hc && y.locale !== "ko" ? null : y.data;
      default:
        return null;
    }
  }
  var fm = {
    color: !0,
    date: !0,
    datetime: !0,
    "datetime-local": !0,
    email: !0,
    month: !0,
    number: !0,
    password: !0,
    range: !0,
    search: !0,
    tel: !0,
    text: !0,
    time: !0,
    url: !0,
    week: !0,
  };
  function Kc(g) {
    var y = g && g.nodeName && g.nodeName.toLowerCase();
    return y === "input" ? !!fm[g.type] : y === "textarea";
  }
  function Xc(g, y, x, E) {
    (po ? (mo ? mo.push(E) : (mo = [E])) : (po = E),
      (y = zi(y, "onChange")),
      0 < y.length &&
        ((x = new Ks("onChange", "change", null, x, E)),
        g.push({ event: x, listeners: y })));
  }
  var ts = null,
    ns = null;
  function pm(g) {
    Lf(g, 0);
  }
  function Zs(g) {
    var y = Ko(g);
    if (Oc(y)) return g;
  }
  function Zc(g, y) {
    if (g === "change") return y;
  }
  var Jc = !1;
  if (Qn) {
    var va;
    if (Qn) {
      var Ea = "oninput" in document;
      if (!Ea) {
        var Qc = document.createElement("div");
        (Qc.setAttribute("oninput", "return;"),
          (Ea = typeof Qc.oninput == "function"));
      }
      va = Ea;
    } else va = !1;
    Jc = va && (!document.documentMode || 9 < document.documentMode);
  }
  function eu() {
    ts && (ts.detachEvent("onpropertychange", tu), (ns = ts = null));
  }
  function tu(g) {
    if (g.propertyName === "value" && Zs(ns)) {
      var y = [];
      (Xc(y, ns, g, pa(g)), Vc(pm, y));
    }
  }
  function mm(g, y, x) {
    g === "focusin"
      ? (eu(), (ts = y), (ns = x), ts.attachEvent("onpropertychange", tu))
      : g === "focusout" && eu();
  }
  function gm(g) {
    if (g === "selectionchange" || g === "keyup" || g === "keydown")
      return Zs(ns);
  }
  function hm(g, y) {
    if (g === "click") return Zs(y);
  }
  function _m(g, y) {
    if (g === "input" || g === "change") return Zs(y);
  }
  function ym(g, y) {
    return (g === y && (g !== 0 || 1 / g === 1 / y)) || (g !== g && y !== y);
  }
  var An = typeof Object.is == "function" ? Object.is : ym;
  function rs(g, y) {
    if (An(g, y)) return !0;
    if (
      typeof g != "object" ||
      g === null ||
      typeof y != "object" ||
      y === null
    )
      return !1;
    var x = Object.keys(g),
      E = Object.keys(y);
    if (x.length !== E.length) return !1;
    for (E = 0; E < x.length; E++) {
      var V = x[E];
      if (!ea.call(y, V) || !An(g[V], y[V])) return !1;
    }
    return !0;
  }
  function nu(g) {
    for (; g && g.firstChild; ) g = g.firstChild;
    return g;
  }
  function ru(g, y) {
    var x = nu(g);
    g = 0;
    for (var E; x; ) {
      if (x.nodeType === 3) {
        if (((E = g + x.textContent.length), g <= y && E >= y))
          return { node: x, offset: y - g };
        g = E;
      }
      e: {
        for (; x; ) {
          if (x.nextSibling) {
            x = x.nextSibling;
            break e;
          }
          x = x.parentNode;
        }
        x = void 0;
      }
      x = nu(x);
    }
  }
  function ou(g, y) {
    return g && y
      ? g === y
        ? !0
        : g && g.nodeType === 3
          ? !1
          : y && y.nodeType === 3
            ? ou(g, y.parentNode)
            : "contains" in g
              ? g.contains(y)
              : g.compareDocumentPosition
                ? !!(g.compareDocumentPosition(y) & 16)
                : !1
      : !1;
  }
  function su(g) {
    g =
      g != null &&
      g.ownerDocument != null &&
      g.ownerDocument.defaultView != null
        ? g.ownerDocument.defaultView
        : window;
    for (var y = Hs(g.document); y instanceof g.HTMLIFrameElement; ) {
      try {
        var x = typeof y.contentWindow.location.href == "string";
      } catch {
        x = !1;
      }
      if (x) g = y.contentWindow;
      else break;
      y = Hs(g.document);
    }
    return y;
  }
  function Sa(g) {
    var y = g && g.nodeName && g.nodeName.toLowerCase();
    return (
      y &&
      ((y === "input" &&
        (g.type === "text" ||
          g.type === "search" ||
          g.type === "tel" ||
          g.type === "url" ||
          g.type === "password")) ||
        y === "textarea" ||
        g.contentEditable === "true")
    );
  }
  var bm = Qn && "documentMode" in document && 11 >= document.documentMode,
    ho = null,
    Ta = null,
    os = null,
    Aa = !1;
  function iu(g, y, x) {
    var E =
      x.window === x ? x.document : x.nodeType === 9 ? x : x.ownerDocument;
    Aa ||
      ho == null ||
      ho !== Hs(E) ||
      ((E = ho),
      "selectionStart" in E && Sa(E)
        ? (E = { start: E.selectionStart, end: E.selectionEnd })
        : ((E = (
            (E.ownerDocument && E.ownerDocument.defaultView) ||
            window
          ).getSelection()),
          (E = {
            anchorNode: E.anchorNode,
            anchorOffset: E.anchorOffset,
            focusNode: E.focusNode,
            focusOffset: E.focusOffset,
          })),
      (os && rs(os, E)) ||
        ((os = E),
        (E = zi(Ta, "onSelect")),
        0 < E.length &&
          ((y = new Ks("onSelect", "select", null, y, x)),
          g.push({ event: y, listeners: E }),
          (y.target = ho))));
  }
  function Hr(g, y) {
    var x = {};
    return (
      (x[g.toLowerCase()] = y.toLowerCase()),
      (x["Webkit" + g] = "webkit" + y),
      (x["Moz" + g] = "moz" + y),
      x
    );
  }
  var _o = {
      animationend: Hr("Animation", "AnimationEnd"),
      animationiteration: Hr("Animation", "AnimationIteration"),
      animationstart: Hr("Animation", "AnimationStart"),
      transitionrun: Hr("Transition", "TransitionRun"),
      transitionstart: Hr("Transition", "TransitionStart"),
      transitioncancel: Hr("Transition", "TransitionCancel"),
      transitionend: Hr("Transition", "TransitionEnd"),
    },
    Ra = {},
    au = {};
  Qn &&
    ((au = document.createElement("div").style),
    "AnimationEvent" in window ||
      (delete _o.animationend.animation,
      delete _o.animationiteration.animation,
      delete _o.animationstart.animation),
    "TransitionEvent" in window || delete _o.transitionend.transition);
  function Gr(g) {
    if (Ra[g]) return Ra[g];
    if (!_o[g]) return g;
    var y = _o[g],
      x;
    for (x in y) if (y.hasOwnProperty(x) && x in au) return (Ra[g] = y[x]);
    return g;
  }
  var lu = Gr("animationend"),
    cu = Gr("animationiteration"),
    uu = Gr("animationstart"),
    wm = Gr("transitionrun"),
    xm = Gr("transitionstart"),
    vm = Gr("transitioncancel"),
    du = Gr("transitionend"),
    fu = new Map(),
    Ca =
      "abort auxClick beforeToggle cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(
        " ",
      );
  Ca.push("scrollEnd");
  function Un(g, y) {
    (fu.set(g, y), kr(y, [g]));
  }
  var Js =
      typeof reportError == "function"
        ? reportError
        : function (g) {
            if (
              typeof window == "object" &&
              typeof window.ErrorEvent == "function"
            ) {
              var y = new window.ErrorEvent("error", {
                bubbles: !0,
                cancelable: !0,
                message:
                  typeof g == "object" &&
                  g !== null &&
                  typeof g.message == "string"
                    ? String(g.message)
                    : String(g),
                error: g,
              });
              if (!window.dispatchEvent(y)) return;
            } else if (
              typeof process == "object" &&
              typeof process.emit == "function"
            ) {
              process.emit("uncaughtException", g);
              return;
            }
            console.error(g);
          },
    Pn = [],
    yo = 0,
    Ma = 0;
  function Qs() {
    for (var g = yo, y = (Ma = yo = 0); y < g; ) {
      var x = Pn[y];
      Pn[y++] = null;
      var E = Pn[y];
      Pn[y++] = null;
      var V = Pn[y];
      Pn[y++] = null;
      var z = Pn[y];
      if (((Pn[y++] = null), E !== null && V !== null)) {
        var ne = E.pending;
        (ne === null ? (V.next = V) : ((V.next = ne.next), (ne.next = V)),
          (E.pending = V));
      }
      z !== 0 && pu(x, V, z);
    }
  }
  function ei(g, y, x, E) {
    ((Pn[yo++] = g),
      (Pn[yo++] = y),
      (Pn[yo++] = x),
      (Pn[yo++] = E),
      (Ma |= E),
      (g.lanes |= E),
      (g = g.alternate),
      g !== null && (g.lanes |= E));
  }
  function Na(g, y, x, E) {
    return (ei(g, y, x, E), ti(g));
  }
  function Wr(g, y) {
    return (ei(g, null, null, y), ti(g));
  }
  function pu(g, y, x) {
    g.lanes |= x;
    var E = g.alternate;
    E !== null && (E.lanes |= x);
    for (var V = !1, z = g.return; z !== null; )
      ((z.childLanes |= x),
        (E = z.alternate),
        E !== null && (E.childLanes |= x),
        z.tag === 22 &&
          ((g = z.stateNode), g === null || g._visibility & 1 || (V = !0)),
        (g = z),
        (z = z.return));
    return g.tag === 3
      ? ((z = g.stateNode),
        V &&
          y !== null &&
          ((V = 31 - Tn(x)),
          (g = z.hiddenUpdates),
          (E = g[V]),
          E === null ? (g[V] = [y]) : E.push(y),
          (y.lane = x | 536870912)),
        z)
      : null;
  }
  function ti(g) {
    if (50 < As) throw ((As = 0), (zl = null), Error(_(185)));
    for (var y = g.return; y !== null; ) ((g = y), (y = g.return));
    return g.tag === 3 ? g.stateNode : null;
  }
  var bo = {};
  function Em(g, y, x, E) {
    ((this.tag = g),
      (this.key = x),
      (this.sibling =
        this.child =
        this.return =
        this.stateNode =
        this.type =
        this.elementType =
          null),
      (this.index = 0),
      (this.refCleanup = this.ref = null),
      (this.pendingProps = y),
      (this.dependencies =
        this.memoizedState =
        this.updateQueue =
        this.memoizedProps =
          null),
      (this.mode = E),
      (this.subtreeFlags = this.flags = 0),
      (this.deletions = null),
      (this.childLanes = this.lanes = 0),
      (this.alternate = null));
  }
  function Rn(g, y, x, E) {
    return new Em(g, y, x, E);
  }
  function Oa(g) {
    return ((g = g.prototype), !(!g || !g.isReactComponent));
  }
  function er(g, y) {
    var x = g.alternate;
    return (
      x === null
        ? ((x = Rn(g.tag, y, g.key, g.mode)),
          (x.elementType = g.elementType),
          (x.type = g.type),
          (x.stateNode = g.stateNode),
          (x.alternate = g),
          (g.alternate = x))
        : ((x.pendingProps = y),
          (x.type = g.type),
          (x.flags = 0),
          (x.subtreeFlags = 0),
          (x.deletions = null)),
      (x.flags = g.flags & 65011712),
      (x.childLanes = g.childLanes),
      (x.lanes = g.lanes),
      (x.child = g.child),
      (x.memoizedProps = g.memoizedProps),
      (x.memoizedState = g.memoizedState),
      (x.updateQueue = g.updateQueue),
      (y = g.dependencies),
      (x.dependencies =
        y === null ? null : { lanes: y.lanes, firstContext: y.firstContext }),
      (x.sibling = g.sibling),
      (x.index = g.index),
      (x.ref = g.ref),
      (x.refCleanup = g.refCleanup),
      x
    );
  }
  function mu(g, y) {
    g.flags &= 65011714;
    var x = g.alternate;
    return (
      x === null
        ? ((g.childLanes = 0),
          (g.lanes = y),
          (g.child = null),
          (g.subtreeFlags = 0),
          (g.memoizedProps = null),
          (g.memoizedState = null),
          (g.updateQueue = null),
          (g.dependencies = null),
          (g.stateNode = null))
        : ((g.childLanes = x.childLanes),
          (g.lanes = x.lanes),
          (g.child = x.child),
          (g.subtreeFlags = 0),
          (g.deletions = null),
          (g.memoizedProps = x.memoizedProps),
          (g.memoizedState = x.memoizedState),
          (g.updateQueue = x.updateQueue),
          (g.type = x.type),
          (y = x.dependencies),
          (g.dependencies =
            y === null
              ? null
              : { lanes: y.lanes, firstContext: y.firstContext })),
      g
    );
  }
  function ni(g, y, x, E, V, z) {
    var ne = 0;
    if (((E = g), typeof g == "function")) Oa(g) && (ne = 1);
    else if (typeof g == "string")
      ne = Cg(g, x, lt.current)
        ? 26
        : g === "html" || g === "head" || g === "body"
          ? 27
          : 5;
    else
      e: switch (g) {
        case pt:
          return (
            (g = Rn(31, x, y, V)),
            (g.elementType = pt),
            (g.lanes = z),
            g
          );
        case re:
          return qr(x.children, V, z, y);
        case Oe:
          ((ne = 8), (V |= 24));
          break;
        case Le:
          return (
            (g = Rn(12, x, y, V | 2)),
            (g.elementType = Le),
            (g.lanes = z),
            g
          );
        case Ge:
          return (
            (g = Rn(13, x, y, V)),
            (g.elementType = Ge),
            (g.lanes = z),
            g
          );
        case Ke:
          return (
            (g = Rn(19, x, y, V)),
            (g.elementType = Ke),
            (g.lanes = z),
            g
          );
        default:
          if (typeof g == "object" && g !== null)
            switch (g.$$typeof) {
              case Ve:
                ne = 10;
                break e;
              case Be:
                ne = 9;
                break e;
              case ze:
                ne = 11;
                break e;
              case qe:
                ne = 14;
                break e;
              case nt:
                ((ne = 16), (E = null));
                break e;
            }
          ((ne = 29),
            (x = Error(_(130, g === null ? "null" : typeof g, ""))),
            (E = null));
      }
    return (
      (y = Rn(ne, x, y, V)),
      (y.elementType = g),
      (y.type = E),
      (y.lanes = z),
      y
    );
  }
  function qr(g, y, x, E) {
    return ((g = Rn(7, g, E, y)), (g.lanes = x), g);
  }
  function Ia(g, y, x) {
    return ((g = Rn(6, g, null, y)), (g.lanes = x), g);
  }
  function gu(g) {
    var y = Rn(18, null, null, 0);
    return ((y.stateNode = g), y);
  }
  function Da(g, y, x) {
    return (
      (y = Rn(4, g.children !== null ? g.children : [], g.key, y)),
      (y.lanes = x),
      (y.stateNode = {
        containerInfo: g.containerInfo,
        pendingChildren: null,
        implementation: g.implementation,
      }),
      y
    );
  }
  var hu = new WeakMap();
  function jn(g, y) {
    if (typeof g == "object" && g !== null) {
      var x = hu.get(g);
      return x !== void 0
        ? x
        : ((y = { value: g, source: y, stack: gc(y) }), hu.set(g, y), y);
    }
    return { value: g, source: y, stack: gc(y) };
  }
  var wo = [],
    xo = 0,
    ri = null,
    ss = 0,
    Bn = [],
    Vn = 0,
    br = null,
    qn = 1,
    Yn = "";
  function tr(g, y) {
    ((wo[xo++] = ss), (wo[xo++] = ri), (ri = g), (ss = y));
  }
  function _u(g, y, x) {
    ((Bn[Vn++] = qn), (Bn[Vn++] = Yn), (Bn[Vn++] = br), (br = g));
    var E = qn;
    g = Yn;
    var V = 32 - Tn(E) - 1;
    ((E &= ~(1 << V)), (x += 1));
    var z = 32 - Tn(y) + V;
    if (30 < z) {
      var ne = V - (V % 5);
      ((z = (E & ((1 << ne) - 1)).toString(32)),
        (E >>= ne),
        (V -= ne),
        (qn = (1 << (32 - Tn(y) + V)) | (x << V) | E),
        (Yn = z + g));
    } else ((qn = (1 << z) | (x << V) | E), (Yn = g));
  }
  function La(g) {
    g.return !== null && (tr(g, 1), _u(g, 1, 0));
  }
  function Pa(g) {
    for (; g === ri; )
      ((ri = wo[--xo]), (wo[xo] = null), (ss = wo[--xo]), (wo[xo] = null));
    for (; g === br; )
      ((br = Bn[--Vn]),
        (Bn[Vn] = null),
        (Yn = Bn[--Vn]),
        (Bn[Vn] = null),
        (qn = Bn[--Vn]),
        (Bn[Vn] = null));
  }
  function yu(g, y) {
    ((Bn[Vn++] = qn),
      (Bn[Vn++] = Yn),
      (Bn[Vn++] = br),
      (qn = y.id),
      (Yn = y.overflow),
      (br = g));
  }
  var un = null,
    Gt = null,
    Dt = !1,
    wr = null,
    zn = !1,
    ja = Error(_(519));
  function xr(g) {
    var y = Error(
      _(
        418,
        1 < arguments.length && arguments[1] !== void 0 && arguments[1]
          ? "text"
          : "HTML",
        "",
      ),
    );
    throw (is(jn(y, g)), ja);
  }
  function bu(g) {
    var y = g.stateNode,
      x = g.type,
      E = g.memoizedProps;
    switch (((y[ln] = g), (y[hn] = E), x)) {
      case "dialog":
        (Nt("cancel", y), Nt("close", y));
        break;
      case "iframe":
      case "object":
      case "embed":
        Nt("load", y);
        break;
      case "video":
      case "audio":
        for (x = 0; x < Cs.length; x++) Nt(Cs[x], y);
        break;
      case "source":
        Nt("error", y);
        break;
      case "img":
      case "image":
      case "link":
        (Nt("error", y), Nt("load", y));
        break;
      case "details":
        Nt("toggle", y);
        break;
      case "input":
        (Nt("invalid", y),
          Ic(
            y,
            E.value,
            E.defaultValue,
            E.checked,
            E.defaultChecked,
            E.type,
            E.name,
            !0,
          ));
        break;
      case "select":
        Nt("invalid", y);
        break;
      case "textarea":
        (Nt("invalid", y), Lc(y, E.value, E.defaultValue, E.children));
    }
    ((x = E.children),
      (typeof x != "string" && typeof x != "number" && typeof x != "bigint") ||
      y.textContent === "" + x ||
      E.suppressHydrationWarning === !0 ||
      Vf(y.textContent, x)
        ? (E.popover != null && (Nt("beforetoggle", y), Nt("toggle", y)),
          E.onScroll != null && Nt("scroll", y),
          E.onScrollEnd != null && Nt("scrollend", y),
          E.onClick != null && (y.onclick = Jn),
          (y = !0))
        : (y = !1),
      y || xr(g, !0));
  }
  function wu(g) {
    for (un = g.return; un; )
      switch (un.tag) {
        case 5:
        case 31:
        case 13:
          zn = !1;
          return;
        case 27:
        case 3:
          zn = !0;
          return;
        default:
          un = un.return;
      }
  }
  function vo(g) {
    if (g !== un) return !1;
    if (!Dt) return (wu(g), (Dt = !0), !1);
    var y = g.tag,
      x;
    if (
      ((x = y !== 3 && y !== 27) &&
        ((x = y === 5) &&
          ((x = g.type),
          (x =
            !(x !== "form" && x !== "button") || ec(g.type, g.memoizedProps))),
        (x = !x)),
      x && Gt && xr(g),
      wu(g),
      y === 13)
    ) {
      if (((g = g.memoizedState), (g = g !== null ? g.dehydrated : null), !g))
        throw Error(_(317));
      Gt = qf(g);
    } else if (y === 31) {
      if (((g = g.memoizedState), (g = g !== null ? g.dehydrated : null), !g))
        throw Error(_(317));
      Gt = qf(g);
    } else
      y === 27
        ? ((y = Gt), Pr(g.type) ? ((g = sc), (sc = null), (Gt = g)) : (Gt = y))
        : (Gt = un ? $n(g.stateNode.nextSibling) : null);
    return !0;
  }
  function Yr() {
    ((Gt = un = null), (Dt = !1));
  }
  function Ba() {
    var g = wr;
    return (
      g !== null &&
        (xn === null ? (xn = g) : xn.push.apply(xn, g), (wr = null)),
      g
    );
  }
  function is(g) {
    wr === null ? (wr = [g]) : wr.push(g);
  }
  var Va = Fe(null),
    Kr = null,
    nr = null;
  function vr(g, y, x) {
    (ot(Va, y._currentValue), (y._currentValue = x));
  }
  function rr(g) {
    ((g._currentValue = Va.current), Ue(Va));
  }
  function za(g, y, x) {
    for (; g !== null; ) {
      var E = g.alternate;
      if (
        ((g.childLanes & y) !== y
          ? ((g.childLanes |= y), E !== null && (E.childLanes |= y))
          : E !== null && (E.childLanes & y) !== y && (E.childLanes |= y),
        g === x)
      )
        break;
      g = g.return;
    }
  }
  function Fa(g, y, x, E) {
    var V = g.child;
    for (V !== null && (V.return = g); V !== null; ) {
      var z = V.dependencies;
      if (z !== null) {
        var ne = V.child;
        z = z.firstContext;
        e: for (; z !== null; ) {
          var je = z;
          z = V;
          for (var He = 0; He < y.length; He++)
            if (je.context === y[He]) {
              ((z.lanes |= x),
                (je = z.alternate),
                je !== null && (je.lanes |= x),
                za(z.return, x, g),
                E || (ne = null));
              break e;
            }
          z = je.next;
        }
      } else if (V.tag === 18) {
        if (((ne = V.return), ne === null)) throw Error(_(341));
        ((ne.lanes |= x),
          (z = ne.alternate),
          z !== null && (z.lanes |= x),
          za(ne, x, g),
          (ne = null));
      } else ne = V.child;
      if (ne !== null) ne.return = V;
      else
        for (ne = V; ne !== null; ) {
          if (ne === g) {
            ne = null;
            break;
          }
          if (((V = ne.sibling), V !== null)) {
            ((V.return = ne.return), (ne = V));
            break;
          }
          ne = ne.return;
        }
      V = ne;
    }
  }
  function Eo(g, y, x, E) {
    g = null;
    for (var V = y, z = !1; V !== null; ) {
      if (!z) {
        if ((V.flags & 524288) !== 0) z = !0;
        else if ((V.flags & 262144) !== 0) break;
      }
      if (V.tag === 10) {
        var ne = V.alternate;
        if (ne === null) throw Error(_(387));
        if (((ne = ne.memoizedProps), ne !== null)) {
          var je = V.type;
          An(V.pendingProps.value, ne.value) ||
            (g !== null ? g.push(je) : (g = [je]));
        }
      } else if (V === it.current) {
        if (((ne = V.alternate), ne === null)) throw Error(_(387));
        ne.memoizedState.memoizedState !== V.memoizedState.memoizedState &&
          (g !== null ? g.push(Ds) : (g = [Ds]));
      }
      V = V.return;
    }
    (g !== null && Fa(y, g, x, E), (y.flags |= 262144));
  }
  function oi(g) {
    for (g = g.firstContext; g !== null; ) {
      if (!An(g.context._currentValue, g.memoizedValue)) return !0;
      g = g.next;
    }
    return !1;
  }
  function Xr(g) {
    ((Kr = g),
      (nr = null),
      (g = g.dependencies),
      g !== null && (g.firstContext = null));
  }
  function dn(g) {
    return xu(Kr, g);
  }
  function si(g, y) {
    return (Kr === null && Xr(g), xu(g, y));
  }
  function xu(g, y) {
    var x = y._currentValue;
    if (((y = { context: y, memoizedValue: x, next: null }), nr === null)) {
      if (g === null) throw Error(_(308));
      ((nr = y),
        (g.dependencies = { lanes: 0, firstContext: y }),
        (g.flags |= 524288));
    } else nr = nr.next = y;
    return x;
  }
  var Sm =
      typeof AbortController < "u"
        ? AbortController
        : function () {
            var g = [],
              y = (this.signal = {
                aborted: !1,
                addEventListener: function (x, E) {
                  g.push(E);
                },
              });
            this.abort = function () {
              ((y.aborted = !0),
                g.forEach(function (x) {
                  return x();
                }));
            };
          },
    Tm = a.unstable_scheduleCallback,
    Am = a.unstable_NormalPriority,
    en = {
      $$typeof: Ve,
      Consumer: null,
      Provider: null,
      _currentValue: null,
      _currentValue2: null,
      _threadCount: 0,
    };
  function $a() {
    return { controller: new Sm(), data: new Map(), refCount: 0 };
  }
  function as(g) {
    (g.refCount--,
      g.refCount === 0 &&
        Tm(Am, function () {
          g.controller.abort();
        }));
  }
  var ls = null,
    ka = 0,
    So = 0,
    To = null;
  function Rm(g, y) {
    if (ls === null) {
      var x = (ls = []);
      ((ka = 0),
        (So = Gl()),
        (To = {
          status: "pending",
          value: void 0,
          then: function (E) {
            x.push(E);
          },
        }));
    }
    return (ka++, y.then(vu, vu), y);
  }
  function vu() {
    if (--ka === 0 && ls !== null) {
      To !== null && (To.status = "fulfilled");
      var g = ls;
      ((ls = null), (So = 0), (To = null));
      for (var y = 0; y < g.length; y++) (0, g[y])();
    }
  }
  function Cm(g, y) {
    var x = [],
      E = {
        status: "pending",
        value: null,
        reason: null,
        then: function (V) {
          x.push(V);
        },
      };
    return (
      g.then(
        function () {
          ((E.status = "fulfilled"), (E.value = y));
          for (var V = 0; V < x.length; V++) (0, x[V])(y);
        },
        function (V) {
          for (E.status = "rejected", E.reason = V, V = 0; V < x.length; V++)
            (0, x[V])(void 0);
        },
      ),
      E
    );
  }
  var Eu = $e.S;
  $e.S = function (g, y) {
    ((lf = En()),
      typeof y == "object" &&
        y !== null &&
        typeof y.then == "function" &&
        Rm(g, y),
      Eu !== null && Eu(g, y));
  };
  var Zr = Fe(null);
  function Ua() {
    var g = Zr.current;
    return g !== null ? g : Ht.pooledCache;
  }
  function ii(g, y) {
    y === null ? ot(Zr, Zr.current) : ot(Zr, y.pool);
  }
  function Su() {
    var g = Ua();
    return g === null ? null : { parent: en._currentValue, pool: g };
  }
  var Ao = Error(_(460)),
    Ha = Error(_(474)),
    ai = Error(_(542)),
    li = { then: function () {} };
  function Tu(g) {
    return ((g = g.status), g === "fulfilled" || g === "rejected");
  }
  function Au(g, y, x) {
    switch (
      ((x = g[x]),
      x === void 0 ? g.push(y) : x !== y && (y.then(Jn, Jn), (y = x)),
      y.status)
    ) {
      case "fulfilled":
        return y.value;
      case "rejected":
        throw ((g = y.reason), Cu(g), g);
      default:
        if (typeof y.status == "string") y.then(Jn, Jn);
        else {
          if (((g = Ht), g !== null && 100 < g.shellSuspendCounter))
            throw Error(_(482));
          ((g = y),
            (g.status = "pending"),
            g.then(
              function (E) {
                if (y.status === "pending") {
                  var V = y;
                  ((V.status = "fulfilled"), (V.value = E));
                }
              },
              function (E) {
                if (y.status === "pending") {
                  var V = y;
                  ((V.status = "rejected"), (V.reason = E));
                }
              },
            ));
        }
        switch (y.status) {
          case "fulfilled":
            return y.value;
          case "rejected":
            throw ((g = y.reason), Cu(g), g);
        }
        throw ((Qr = y), Ao);
    }
  }
  function Jr(g) {
    try {
      var y = g._init;
      return y(g._payload);
    } catch (x) {
      throw x !== null && typeof x == "object" && typeof x.then == "function"
        ? ((Qr = x), Ao)
        : x;
    }
  }
  var Qr = null;
  function Ru() {
    if (Qr === null) throw Error(_(459));
    var g = Qr;
    return ((Qr = null), g);
  }
  function Cu(g) {
    if (g === Ao || g === ai) throw Error(_(483));
  }
  var Ro = null,
    cs = 0;
  function ci(g) {
    var y = cs;
    return ((cs += 1), Ro === null && (Ro = []), Au(Ro, g, y));
  }
  function us(g, y) {
    ((y = y.props.ref), (g.ref = y !== void 0 ? y : null));
  }
  function ui(g, y) {
    throw y.$$typeof === Q
      ? Error(_(525))
      : ((g = Object.prototype.toString.call(y)),
        Error(
          _(
            31,
            g === "[object Object]"
              ? "object with keys {" + Object.keys(y).join(", ") + "}"
              : g,
          ),
        ));
  }
  function Mu(g) {
    function y(Xe, We) {
      if (g) {
        var Ze = Xe.deletions;
        Ze === null ? ((Xe.deletions = [We]), (Xe.flags |= 16)) : Ze.push(We);
      }
    }
    function x(Xe, We) {
      if (!g) return null;
      for (; We !== null; ) (y(Xe, We), (We = We.sibling));
      return null;
    }
    function E(Xe) {
      for (var We = new Map(); Xe !== null; )
        (Xe.key !== null ? We.set(Xe.key, Xe) : We.set(Xe.index, Xe),
          (Xe = Xe.sibling));
      return We;
    }
    function V(Xe, We) {
      return ((Xe = er(Xe, We)), (Xe.index = 0), (Xe.sibling = null), Xe);
    }
    function z(Xe, We, Ze) {
      return (
        (Xe.index = Ze),
        g
          ? ((Ze = Xe.alternate),
            Ze !== null
              ? ((Ze = Ze.index), Ze < We ? ((Xe.flags |= 67108866), We) : Ze)
              : ((Xe.flags |= 67108866), We))
          : ((Xe.flags |= 1048576), We)
      );
    }
    function ne(Xe) {
      return (g && Xe.alternate === null && (Xe.flags |= 67108866), Xe);
    }
    function je(Xe, We, Ze, ct) {
      return We === null || We.tag !== 6
        ? ((We = Ia(Ze, Xe.mode, ct)), (We.return = Xe), We)
        : ((We = V(We, Ze)), (We.return = Xe), We);
    }
    function He(Xe, We, Ze, ct) {
      var St = Ze.type;
      return St === re
        ? st(Xe, We, Ze.props.children, ct, Ze.key)
        : We !== null &&
            (We.elementType === St ||
              (typeof St == "object" &&
                St !== null &&
                St.$$typeof === nt &&
                Jr(St) === We.type))
          ? ((We = V(We, Ze.props)), us(We, Ze), (We.return = Xe), We)
          : ((We = ni(Ze.type, Ze.key, Ze.props, null, Xe.mode, ct)),
            us(We, Ze),
            (We.return = Xe),
            We);
    }
    function Je(Xe, We, Ze, ct) {
      return We === null ||
        We.tag !== 4 ||
        We.stateNode.containerInfo !== Ze.containerInfo ||
        We.stateNode.implementation !== Ze.implementation
        ? ((We = Da(Ze, Xe.mode, ct)), (We.return = Xe), We)
        : ((We = V(We, Ze.children || [])), (We.return = Xe), We);
    }
    function st(Xe, We, Ze, ct, St) {
      return We === null || We.tag !== 7
        ? ((We = qr(Ze, Xe.mode, ct, St)), (We.return = Xe), We)
        : ((We = V(We, Ze)), (We.return = Xe), We);
    }
    function ft(Xe, We, Ze) {
      if (
        (typeof We == "string" && We !== "") ||
        typeof We == "number" ||
        typeof We == "bigint"
      )
        return ((We = Ia("" + We, Xe.mode, Ze)), (We.return = Xe), We);
      if (typeof We == "object" && We !== null) {
        switch (We.$$typeof) {
          case te:
            return (
              (Ze = ni(We.type, We.key, We.props, null, Xe.mode, Ze)),
              us(Ze, We),
              (Ze.return = Xe),
              Ze
            );
          case se:
            return ((We = Da(We, Xe.mode, Ze)), (We.return = Xe), We);
          case nt:
            return ((We = Jr(We)), ft(Xe, We, Ze));
        }
        if (at(We) || dt(We))
          return ((We = qr(We, Xe.mode, Ze, null)), (We.return = Xe), We);
        if (typeof We.then == "function") return ft(Xe, ci(We), Ze);
        if (We.$$typeof === Ve) return ft(Xe, si(Xe, We), Ze);
        ui(Xe, We);
      }
      return null;
    }
    function et(Xe, We, Ze, ct) {
      var St = We !== null ? We.key : null;
      if (
        (typeof Ze == "string" && Ze !== "") ||
        typeof Ze == "number" ||
        typeof Ze == "bigint"
      )
        return St !== null ? null : je(Xe, We, "" + Ze, ct);
      if (typeof Ze == "object" && Ze !== null) {
        switch (Ze.$$typeof) {
          case te:
            return Ze.key === St ? He(Xe, We, Ze, ct) : null;
          case se:
            return Ze.key === St ? Je(Xe, We, Ze, ct) : null;
          case nt:
            return ((Ze = Jr(Ze)), et(Xe, We, Ze, ct));
        }
        if (at(Ze) || dt(Ze))
          return St !== null ? null : st(Xe, We, Ze, ct, null);
        if (typeof Ze.then == "function") return et(Xe, We, ci(Ze), ct);
        if (Ze.$$typeof === Ve) return et(Xe, We, si(Xe, Ze), ct);
        ui(Xe, Ze);
      }
      return null;
    }
    function rt(Xe, We, Ze, ct, St) {
      if (
        (typeof ct == "string" && ct !== "") ||
        typeof ct == "number" ||
        typeof ct == "bigint"
      )
        return ((Xe = Xe.get(Ze) || null), je(We, Xe, "" + ct, St));
      if (typeof ct == "object" && ct !== null) {
        switch (ct.$$typeof) {
          case te:
            return (
              (Xe = Xe.get(ct.key === null ? Ze : ct.key) || null),
              He(We, Xe, ct, St)
            );
          case se:
            return (
              (Xe = Xe.get(ct.key === null ? Ze : ct.key) || null),
              Je(We, Xe, ct, St)
            );
          case nt:
            return ((ct = Jr(ct)), rt(Xe, We, Ze, ct, St));
        }
        if (at(ct) || dt(ct))
          return ((Xe = Xe.get(Ze) || null), st(We, Xe, ct, St, null));
        if (typeof ct.then == "function") return rt(Xe, We, Ze, ci(ct), St);
        if (ct.$$typeof === Ve) return rt(Xe, We, Ze, si(We, ct), St);
        ui(We, ct);
      }
      return null;
    }
    function wt(Xe, We, Ze, ct) {
      for (
        var St = null, Pt = null, vt = We, Ct = (We = 0), It = null;
        vt !== null && Ct < Ze.length;
        Ct++
      ) {
        vt.index > Ct ? ((It = vt), (vt = null)) : (It = vt.sibling);
        var jt = et(Xe, vt, Ze[Ct], ct);
        if (jt === null) {
          vt === null && (vt = It);
          break;
        }
        (g && vt && jt.alternate === null && y(Xe, vt),
          (We = z(jt, We, Ct)),
          Pt === null ? (St = jt) : (Pt.sibling = jt),
          (Pt = jt),
          (vt = It));
      }
      if (Ct === Ze.length) return (x(Xe, vt), Dt && tr(Xe, Ct), St);
      if (vt === null) {
        for (; Ct < Ze.length; Ct++)
          ((vt = ft(Xe, Ze[Ct], ct)),
            vt !== null &&
              ((We = z(vt, We, Ct)),
              Pt === null ? (St = vt) : (Pt.sibling = vt),
              (Pt = vt)));
        return (Dt && tr(Xe, Ct), St);
      }
      for (vt = E(vt); Ct < Ze.length; Ct++)
        ((It = rt(vt, Xe, Ct, Ze[Ct], ct)),
          It !== null &&
            (g &&
              It.alternate !== null &&
              vt.delete(It.key === null ? Ct : It.key),
            (We = z(It, We, Ct)),
            Pt === null ? (St = It) : (Pt.sibling = It),
            (Pt = It)));
      return (
        g &&
          vt.forEach(function (Fr) {
            return y(Xe, Fr);
          }),
        Dt && tr(Xe, Ct),
        St
      );
    }
    function Tt(Xe, We, Ze, ct) {
      if (Ze == null) throw Error(_(151));
      for (
        var St = null,
          Pt = null,
          vt = We,
          Ct = (We = 0),
          It = null,
          jt = Ze.next();
        vt !== null && !jt.done;
        Ct++, jt = Ze.next()
      ) {
        vt.index > Ct ? ((It = vt), (vt = null)) : (It = vt.sibling);
        var Fr = et(Xe, vt, jt.value, ct);
        if (Fr === null) {
          vt === null && (vt = It);
          break;
        }
        (g && vt && Fr.alternate === null && y(Xe, vt),
          (We = z(Fr, We, Ct)),
          Pt === null ? (St = Fr) : (Pt.sibling = Fr),
          (Pt = Fr),
          (vt = It));
      }
      if (jt.done) return (x(Xe, vt), Dt && tr(Xe, Ct), St);
      if (vt === null) {
        for (; !jt.done; Ct++, jt = Ze.next())
          ((jt = ft(Xe, jt.value, ct)),
            jt !== null &&
              ((We = z(jt, We, Ct)),
              Pt === null ? (St = jt) : (Pt.sibling = jt),
              (Pt = jt)));
        return (Dt && tr(Xe, Ct), St);
      }
      for (vt = E(vt); !jt.done; Ct++, jt = Ze.next())
        ((jt = rt(vt, Xe, Ct, jt.value, ct)),
          jt !== null &&
            (g &&
              jt.alternate !== null &&
              vt.delete(jt.key === null ? Ct : jt.key),
            (We = z(jt, We, Ct)),
            Pt === null ? (St = jt) : (Pt.sibling = jt),
            (Pt = jt)));
      return (
        g &&
          vt.forEach(function (zg) {
            return y(Xe, zg);
          }),
        Dt && tr(Xe, Ct),
        St
      );
    }
    function Ut(Xe, We, Ze, ct) {
      if (
        (typeof Ze == "object" &&
          Ze !== null &&
          Ze.type === re &&
          Ze.key === null &&
          (Ze = Ze.props.children),
        typeof Ze == "object" && Ze !== null)
      ) {
        switch (Ze.$$typeof) {
          case te:
            e: {
              for (var St = Ze.key; We !== null; ) {
                if (We.key === St) {
                  if (((St = Ze.type), St === re)) {
                    if (We.tag === 7) {
                      (x(Xe, We.sibling),
                        (ct = V(We, Ze.props.children)),
                        (ct.return = Xe),
                        (Xe = ct));
                      break e;
                    }
                  } else if (
                    We.elementType === St ||
                    (typeof St == "object" &&
                      St !== null &&
                      St.$$typeof === nt &&
                      Jr(St) === We.type)
                  ) {
                    (x(Xe, We.sibling),
                      (ct = V(We, Ze.props)),
                      us(ct, Ze),
                      (ct.return = Xe),
                      (Xe = ct));
                    break e;
                  }
                  x(Xe, We);
                  break;
                } else y(Xe, We);
                We = We.sibling;
              }
              Ze.type === re
                ? ((ct = qr(Ze.props.children, Xe.mode, ct, Ze.key)),
                  (ct.return = Xe),
                  (Xe = ct))
                : ((ct = ni(Ze.type, Ze.key, Ze.props, null, Xe.mode, ct)),
                  us(ct, Ze),
                  (ct.return = Xe),
                  (Xe = ct));
            }
            return ne(Xe);
          case se:
            e: {
              for (St = Ze.key; We !== null; ) {
                if (We.key === St)
                  if (
                    We.tag === 4 &&
                    We.stateNode.containerInfo === Ze.containerInfo &&
                    We.stateNode.implementation === Ze.implementation
                  ) {
                    (x(Xe, We.sibling),
                      (ct = V(We, Ze.children || [])),
                      (ct.return = Xe),
                      (Xe = ct));
                    break e;
                  } else {
                    x(Xe, We);
                    break;
                  }
                else y(Xe, We);
                We = We.sibling;
              }
              ((ct = Da(Ze, Xe.mode, ct)), (ct.return = Xe), (Xe = ct));
            }
            return ne(Xe);
          case nt:
            return ((Ze = Jr(Ze)), Ut(Xe, We, Ze, ct));
        }
        if (at(Ze)) return wt(Xe, We, Ze, ct);
        if (dt(Ze)) {
          if (((St = dt(Ze)), typeof St != "function")) throw Error(_(150));
          return ((Ze = St.call(Ze)), Tt(Xe, We, Ze, ct));
        }
        if (typeof Ze.then == "function") return Ut(Xe, We, ci(Ze), ct);
        if (Ze.$$typeof === Ve) return Ut(Xe, We, si(Xe, Ze), ct);
        ui(Xe, Ze);
      }
      return (typeof Ze == "string" && Ze !== "") ||
        typeof Ze == "number" ||
        typeof Ze == "bigint"
        ? ((Ze = "" + Ze),
          We !== null && We.tag === 6
            ? (x(Xe, We.sibling), (ct = V(We, Ze)), (ct.return = Xe), (Xe = ct))
            : (x(Xe, We),
              (ct = Ia(Ze, Xe.mode, ct)),
              (ct.return = Xe),
              (Xe = ct)),
          ne(Xe))
        : x(Xe, We);
    }
    return function (Xe, We, Ze, ct) {
      try {
        cs = 0;
        var St = Ut(Xe, We, Ze, ct);
        return ((Ro = null), St);
      } catch (vt) {
        if (vt === Ao || vt === ai) throw vt;
        var Pt = Rn(29, vt, null, Xe.mode);
        return ((Pt.lanes = ct), (Pt.return = Xe), Pt);
      } finally {
      }
    };
  }
  var eo = Mu(!0),
    Nu = Mu(!1),
    Er = !1;
  function Ga(g) {
    g.updateQueue = {
      baseState: g.memoizedState,
      firstBaseUpdate: null,
      lastBaseUpdate: null,
      shared: { pending: null, lanes: 0, hiddenCallbacks: null },
      callbacks: null,
    };
  }
  function Wa(g, y) {
    ((g = g.updateQueue),
      y.updateQueue === g &&
        (y.updateQueue = {
          baseState: g.baseState,
          firstBaseUpdate: g.firstBaseUpdate,
          lastBaseUpdate: g.lastBaseUpdate,
          shared: g.shared,
          callbacks: null,
        }));
  }
  function Sr(g) {
    return { lane: g, tag: 0, payload: null, callback: null, next: null };
  }
  function Tr(g, y, x) {
    var E = g.updateQueue;
    if (E === null) return null;
    if (((E = E.shared), (Bt & 2) !== 0)) {
      var V = E.pending;
      return (
        V === null ? (y.next = y) : ((y.next = V.next), (V.next = y)),
        (E.pending = y),
        (y = ti(g)),
        pu(g, null, x),
        y
      );
    }
    return (ei(g, E, y, x), ti(g));
  }
  function ds(g, y, x) {
    if (
      ((y = y.updateQueue), y !== null && ((y = y.shared), (x & 4194048) !== 0))
    ) {
      var E = y.lanes;
      ((E &= g.pendingLanes), (x |= E), (y.lanes = x), xc(g, x));
    }
  }
  function qa(g, y) {
    var x = g.updateQueue,
      E = g.alternate;
    if (E !== null && ((E = E.updateQueue), x === E)) {
      var V = null,
        z = null;
      if (((x = x.firstBaseUpdate), x !== null)) {
        do {
          var ne = {
            lane: x.lane,
            tag: x.tag,
            payload: x.payload,
            callback: null,
            next: null,
          };
          (z === null ? (V = z = ne) : (z = z.next = ne), (x = x.next));
        } while (x !== null);
        z === null ? (V = z = y) : (z = z.next = y);
      } else V = z = y;
      ((x = {
        baseState: E.baseState,
        firstBaseUpdate: V,
        lastBaseUpdate: z,
        shared: E.shared,
        callbacks: E.callbacks,
      }),
        (g.updateQueue = x));
      return;
    }
    ((g = x.lastBaseUpdate),
      g === null ? (x.firstBaseUpdate = y) : (g.next = y),
      (x.lastBaseUpdate = y));
  }
  var Ya = !1;
  function fs() {
    if (Ya) {
      var g = To;
      if (g !== null) throw g;
    }
  }
  function ps(g, y, x, E) {
    Ya = !1;
    var V = g.updateQueue;
    Er = !1;
    var z = V.firstBaseUpdate,
      ne = V.lastBaseUpdate,
      je = V.shared.pending;
    if (je !== null) {
      V.shared.pending = null;
      var He = je,
        Je = He.next;
      ((He.next = null), ne === null ? (z = Je) : (ne.next = Je), (ne = He));
      var st = g.alternate;
      st !== null &&
        ((st = st.updateQueue),
        (je = st.lastBaseUpdate),
        je !== ne &&
          (je === null ? (st.firstBaseUpdate = Je) : (je.next = Je),
          (st.lastBaseUpdate = He)));
    }
    if (z !== null) {
      var ft = V.baseState;
      ((ne = 0), (st = Je = He = null), (je = z));
      do {
        var et = je.lane & -536870913,
          rt = et !== je.lane;
        if (rt ? (Ot & et) === et : (E & et) === et) {
          (et !== 0 && et === So && (Ya = !0),
            st !== null &&
              (st = st.next =
                {
                  lane: 0,
                  tag: je.tag,
                  payload: je.payload,
                  callback: null,
                  next: null,
                }));
          e: {
            var wt = g,
              Tt = je;
            et = y;
            var Ut = x;
            switch (Tt.tag) {
              case 1:
                if (((wt = Tt.payload), typeof wt == "function")) {
                  ft = wt.call(Ut, ft, et);
                  break e;
                }
                ft = wt;
                break e;
              case 3:
                wt.flags = (wt.flags & -65537) | 128;
              case 0:
                if (
                  ((wt = Tt.payload),
                  (et = typeof wt == "function" ? wt.call(Ut, ft, et) : wt),
                  et == null)
                )
                  break e;
                ft = q({}, ft, et);
                break e;
              case 2:
                Er = !0;
            }
          }
          ((et = je.callback),
            et !== null &&
              ((g.flags |= 64),
              rt && (g.flags |= 8192),
              (rt = V.callbacks),
              rt === null ? (V.callbacks = [et]) : rt.push(et)));
        } else
          ((rt = {
            lane: et,
            tag: je.tag,
            payload: je.payload,
            callback: je.callback,
            next: null,
          }),
            st === null ? ((Je = st = rt), (He = ft)) : (st = st.next = rt),
            (ne |= et));
        if (((je = je.next), je === null)) {
          if (((je = V.shared.pending), je === null)) break;
          ((rt = je),
            (je = rt.next),
            (rt.next = null),
            (V.lastBaseUpdate = rt),
            (V.shared.pending = null));
        }
      } while (!0);
      (st === null && (He = ft),
        (V.baseState = He),
        (V.firstBaseUpdate = Je),
        (V.lastBaseUpdate = st),
        z === null && (V.shared.lanes = 0),
        (Nr |= ne),
        (g.lanes = ne),
        (g.memoizedState = ft));
    }
  }
  function Ou(g, y) {
    if (typeof g != "function") throw Error(_(191, g));
    g.call(y);
  }
  function Iu(g, y) {
    var x = g.callbacks;
    if (x !== null)
      for (g.callbacks = null, g = 0; g < x.length; g++) Ou(x[g], y);
  }
  var Co = Fe(null),
    di = Fe(0);
  function Du(g, y) {
    ((g = pr), ot(di, g), ot(Co, y), (pr = g | y.baseLanes));
  }
  function Ka() {
    (ot(di, pr), ot(Co, Co.current));
  }
  function Xa() {
    ((pr = di.current), Ue(Co), Ue(di));
  }
  var Cn = Fe(null),
    Fn = null;
  function Ar(g) {
    var y = g.alternate;
    (ot(Jt, Jt.current & 1),
      ot(Cn, g),
      Fn === null &&
        (y === null || Co.current !== null || y.memoizedState !== null) &&
        (Fn = g));
  }
  function Za(g) {
    (ot(Jt, Jt.current), ot(Cn, g), Fn === null && (Fn = g));
  }
  function Lu(g) {
    g.tag === 22
      ? (ot(Jt, Jt.current), ot(Cn, g), Fn === null && (Fn = g))
      : Rr();
  }
  function Rr() {
    (ot(Jt, Jt.current), ot(Cn, Cn.current));
  }
  function Mn(g) {
    (Ue(Cn), Fn === g && (Fn = null), Ue(Jt));
  }
  var Jt = Fe(0);
  function fi(g) {
    for (var y = g; y !== null; ) {
      if (y.tag === 13) {
        var x = y.memoizedState;
        if (x !== null && ((x = x.dehydrated), x === null || rc(x) || oc(x)))
          return y;
      } else if (
        y.tag === 19 &&
        (y.memoizedProps.revealOrder === "forwards" ||
          y.memoizedProps.revealOrder === "backwards" ||
          y.memoizedProps.revealOrder === "unstable_legacy-backwards" ||
          y.memoizedProps.revealOrder === "together")
      ) {
        if ((y.flags & 128) !== 0) return y;
      } else if (y.child !== null) {
        ((y.child.return = y), (y = y.child));
        continue;
      }
      if (y === g) break;
      for (; y.sibling === null; ) {
        if (y.return === null || y.return === g) return null;
        y = y.return;
      }
      ((y.sibling.return = y.return), (y = y.sibling));
    }
    return null;
  }
  var or = 0,
    Rt = null,
    $t = null,
    tn = null,
    pi = !1,
    Mo = !1,
    to = !1,
    mi = 0,
    ms = 0,
    No = null,
    Mm = 0;
  function Kt() {
    throw Error(_(321));
  }
  function Ja(g, y) {
    if (y === null) return !1;
    for (var x = 0; x < y.length && x < g.length; x++)
      if (!An(g[x], y[x])) return !1;
    return !0;
  }
  function Qa(g, y, x, E, V, z) {
    return (
      (or = z),
      (Rt = y),
      (y.memoizedState = null),
      (y.updateQueue = null),
      (y.lanes = 0),
      ($e.H = g === null || g.memoizedState === null ? yd : ml),
      (to = !1),
      (z = x(E, V)),
      (to = !1),
      Mo && (z = ju(y, x, E, V)),
      Pu(g),
      z
    );
  }
  function Pu(g) {
    $e.H = _s;
    var y = $t !== null && $t.next !== null;
    if (((or = 0), (tn = $t = Rt = null), (pi = !1), (ms = 0), (No = null), y))
      throw Error(_(300));
    g === null ||
      nn ||
      ((g = g.dependencies), g !== null && oi(g) && (nn = !0));
  }
  function ju(g, y, x, E) {
    Rt = g;
    var V = 0;
    do {
      if ((Mo && (No = null), (ms = 0), (Mo = !1), 25 <= V))
        throw Error(_(301));
      if (((V += 1), (tn = $t = null), g.updateQueue != null)) {
        var z = g.updateQueue;
        ((z.lastEffect = null),
          (z.events = null),
          (z.stores = null),
          z.memoCache != null && (z.memoCache.index = 0));
      }
      (($e.H = bd), (z = y(x, E)));
    } while (Mo);
    return z;
  }
  function Nm() {
    var g = $e.H,
      y = g.useState()[0];
    return (
      (y = typeof y.then == "function" ? gs(y) : y),
      (g = g.useState()[0]),
      ($t !== null ? $t.memoizedState : null) !== g && (Rt.flags |= 1024),
      y
    );
  }
  function el() {
    var g = mi !== 0;
    return ((mi = 0), g);
  }
  function tl(g, y, x) {
    ((y.updateQueue = g.updateQueue), (y.flags &= -2053), (g.lanes &= ~x));
  }
  function nl(g) {
    if (pi) {
      for (g = g.memoizedState; g !== null; ) {
        var y = g.queue;
        (y !== null && (y.pending = null), (g = g.next));
      }
      pi = !1;
    }
    ((or = 0), (tn = $t = Rt = null), (Mo = !1), (ms = mi = 0), (No = null));
  }
  function mn() {
    var g = {
      memoizedState: null,
      baseState: null,
      baseQueue: null,
      queue: null,
      next: null,
    };
    return (tn === null ? (Rt.memoizedState = tn = g) : (tn = tn.next = g), tn);
  }
  function Qt() {
    if ($t === null) {
      var g = Rt.alternate;
      g = g !== null ? g.memoizedState : null;
    } else g = $t.next;
    var y = tn === null ? Rt.memoizedState : tn.next;
    if (y !== null) ((tn = y), ($t = g));
    else {
      if (g === null)
        throw Rt.alternate === null ? Error(_(467)) : Error(_(310));
      (($t = g),
        (g = {
          memoizedState: $t.memoizedState,
          baseState: $t.baseState,
          baseQueue: $t.baseQueue,
          queue: $t.queue,
          next: null,
        }),
        tn === null ? (Rt.memoizedState = tn = g) : (tn = tn.next = g));
    }
    return tn;
  }
  function gi() {
    return { lastEffect: null, events: null, stores: null, memoCache: null };
  }
  function gs(g) {
    var y = ms;
    return (
      (ms += 1),
      No === null && (No = []),
      (g = Au(No, g, y)),
      (y = Rt),
      (tn === null ? y.memoizedState : tn.next) === null &&
        ((y = y.alternate),
        ($e.H = y === null || y.memoizedState === null ? yd : ml)),
      g
    );
  }
  function hi(g) {
    if (g !== null && typeof g == "object") {
      if (typeof g.then == "function") return gs(g);
      if (g.$$typeof === Ve) return dn(g);
    }
    throw Error(_(438, String(g)));
  }
  function rl(g) {
    var y = null,
      x = Rt.updateQueue;
    if ((x !== null && (y = x.memoCache), y == null)) {
      var E = Rt.alternate;
      E !== null &&
        ((E = E.updateQueue),
        E !== null &&
          ((E = E.memoCache),
          E != null &&
            (y = {
              data: E.data.map(function (V) {
                return V.slice();
              }),
              index: 0,
            })));
    }
    if (
      (y == null && (y = { data: [], index: 0 }),
      x === null && ((x = gi()), (Rt.updateQueue = x)),
      (x.memoCache = y),
      (x = y.data[y.index]),
      x === void 0)
    )
      for (x = y.data[y.index] = Array(g), E = 0; E < g; E++) x[E] = gt;
    return (y.index++, x);
  }
  function sr(g, y) {
    return typeof y == "function" ? y(g) : y;
  }
  function _i(g) {
    var y = Qt();
    return ol(y, $t, g);
  }
  function ol(g, y, x) {
    var E = g.queue;
    if (E === null) throw Error(_(311));
    E.lastRenderedReducer = x;
    var V = g.baseQueue,
      z = E.pending;
    if (z !== null) {
      if (V !== null) {
        var ne = V.next;
        ((V.next = z.next), (z.next = ne));
      }
      ((y.baseQueue = V = z), (E.pending = null));
    }
    if (((z = g.baseState), V === null)) g.memoizedState = z;
    else {
      y = V.next;
      var je = (ne = null),
        He = null,
        Je = y,
        st = !1;
      do {
        var ft = Je.lane & -536870913;
        if (ft !== Je.lane ? (Ot & ft) === ft : (or & ft) === ft) {
          var et = Je.revertLane;
          if (et === 0)
            (He !== null &&
              (He = He.next =
                {
                  lane: 0,
                  revertLane: 0,
                  gesture: null,
                  action: Je.action,
                  hasEagerState: Je.hasEagerState,
                  eagerState: Je.eagerState,
                  next: null,
                }),
              ft === So && (st = !0));
          else if ((or & et) === et) {
            ((Je = Je.next), et === So && (st = !0));
            continue;
          } else
            ((ft = {
              lane: 0,
              revertLane: Je.revertLane,
              gesture: null,
              action: Je.action,
              hasEagerState: Je.hasEagerState,
              eagerState: Je.eagerState,
              next: null,
            }),
              He === null ? ((je = He = ft), (ne = z)) : (He = He.next = ft),
              (Rt.lanes |= et),
              (Nr |= et));
          ((ft = Je.action),
            to && x(z, ft),
            (z = Je.hasEagerState ? Je.eagerState : x(z, ft)));
        } else
          ((et = {
            lane: ft,
            revertLane: Je.revertLane,
            gesture: Je.gesture,
            action: Je.action,
            hasEagerState: Je.hasEagerState,
            eagerState: Je.eagerState,
            next: null,
          }),
            He === null ? ((je = He = et), (ne = z)) : (He = He.next = et),
            (Rt.lanes |= ft),
            (Nr |= ft));
        Je = Je.next;
      } while (Je !== null && Je !== y);
      if (
        (He === null ? (ne = z) : (He.next = je),
        !An(z, g.memoizedState) && ((nn = !0), st && ((x = To), x !== null)))
      )
        throw x;
      ((g.memoizedState = z),
        (g.baseState = ne),
        (g.baseQueue = He),
        (E.lastRenderedState = z));
    }
    return (V === null && (E.lanes = 0), [g.memoizedState, E.dispatch]);
  }
  function sl(g) {
    var y = Qt(),
      x = y.queue;
    if (x === null) throw Error(_(311));
    x.lastRenderedReducer = g;
    var E = x.dispatch,
      V = x.pending,
      z = y.memoizedState;
    if (V !== null) {
      x.pending = null;
      var ne = (V = V.next);
      do ((z = g(z, ne.action)), (ne = ne.next));
      while (ne !== V);
      (An(z, y.memoizedState) || (nn = !0),
        (y.memoizedState = z),
        y.baseQueue === null && (y.baseState = z),
        (x.lastRenderedState = z));
    }
    return [z, E];
  }
  function Bu(g, y, x) {
    var E = Rt,
      V = Qt(),
      z = Dt;
    if (z) {
      if (x === void 0) throw Error(_(407));
      x = x();
    } else x = y();
    var ne = !An(($t || V).memoizedState, x);
    if (
      (ne && ((V.memoizedState = x), (nn = !0)),
      (V = V.queue),
      ll(Fu.bind(null, E, V, g), [g]),
      V.getSnapshot !== y || ne || (tn !== null && tn.memoizedState.tag & 1))
    ) {
      if (
        ((E.flags |= 2048),
        Oo(9, { destroy: void 0 }, zu.bind(null, E, V, x, y), null),
        Ht === null)
      )
        throw Error(_(349));
      z || (or & 127) !== 0 || Vu(E, y, x);
    }
    return x;
  }
  function Vu(g, y, x) {
    ((g.flags |= 16384),
      (g = { getSnapshot: y, value: x }),
      (y = Rt.updateQueue),
      y === null
        ? ((y = gi()), (Rt.updateQueue = y), (y.stores = [g]))
        : ((x = y.stores), x === null ? (y.stores = [g]) : x.push(g)));
  }
  function zu(g, y, x, E) {
    ((y.value = x), (y.getSnapshot = E), $u(y) && ku(g));
  }
  function Fu(g, y, x) {
    return x(function () {
      $u(y) && ku(g);
    });
  }
  function $u(g) {
    var y = g.getSnapshot;
    g = g.value;
    try {
      var x = y();
      return !An(g, x);
    } catch {
      return !0;
    }
  }
  function ku(g) {
    var y = Wr(g, 2);
    y !== null && vn(y, g, 2);
  }
  function il(g) {
    var y = mn();
    if (typeof g == "function") {
      var x = g;
      if (((g = x()), to)) {
        hr(!0);
        try {
          x();
        } finally {
          hr(!1);
        }
      }
    }
    return (
      (y.memoizedState = y.baseState = g),
      (y.queue = {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: sr,
        lastRenderedState: g,
      }),
      y
    );
  }
  function Uu(g, y, x, E) {
    return ((g.baseState = x), ol(g, $t, typeof E == "function" ? E : sr));
  }
  function Om(g, y, x, E, V) {
    if (wi(g)) throw Error(_(485));
    if (((g = y.action), g !== null)) {
      var z = {
        payload: V,
        action: g,
        next: null,
        isTransition: !0,
        status: "pending",
        value: null,
        reason: null,
        listeners: [],
        then: function (ne) {
          z.listeners.push(ne);
        },
      };
      ($e.T !== null ? x(!0) : (z.isTransition = !1),
        E(z),
        (x = y.pending),
        x === null
          ? ((z.next = y.pending = z), Hu(y, z))
          : ((z.next = x.next), (y.pending = x.next = z)));
    }
  }
  function Hu(g, y) {
    var x = y.action,
      E = y.payload,
      V = g.state;
    if (y.isTransition) {
      var z = $e.T,
        ne = {};
      $e.T = ne;
      try {
        var je = x(V, E),
          He = $e.S;
        (He !== null && He(ne, je), Gu(g, y, je));
      } catch (Je) {
        al(g, y, Je);
      } finally {
        (z !== null && ne.types !== null && (z.types = ne.types), ($e.T = z));
      }
    } else
      try {
        ((z = x(V, E)), Gu(g, y, z));
      } catch (Je) {
        al(g, y, Je);
      }
  }
  function Gu(g, y, x) {
    x !== null && typeof x == "object" && typeof x.then == "function"
      ? x.then(
          function (E) {
            Wu(g, y, E);
          },
          function (E) {
            return al(g, y, E);
          },
        )
      : Wu(g, y, x);
  }
  function Wu(g, y, x) {
    ((y.status = "fulfilled"),
      (y.value = x),
      qu(y),
      (g.state = x),
      (y = g.pending),
      y !== null &&
        ((x = y.next),
        x === y ? (g.pending = null) : ((x = x.next), (y.next = x), Hu(g, x))));
  }
  function al(g, y, x) {
    var E = g.pending;
    if (((g.pending = null), E !== null)) {
      E = E.next;
      do ((y.status = "rejected"), (y.reason = x), qu(y), (y = y.next));
      while (y !== E);
    }
    g.action = null;
  }
  function qu(g) {
    g = g.listeners;
    for (var y = 0; y < g.length; y++) (0, g[y])();
  }
  function Yu(g, y) {
    return y;
  }
  function Ku(g, y) {
    if (Dt) {
      var x = Ht.formState;
      if (x !== null) {
        e: {
          var E = Rt;
          if (Dt) {
            if (Gt) {
              t: {
                for (var V = Gt, z = zn; V.nodeType !== 8; ) {
                  if (!z) {
                    V = null;
                    break t;
                  }
                  if (((V = $n(V.nextSibling)), V === null)) {
                    V = null;
                    break t;
                  }
                }
                ((z = V.data), (V = z === "F!" || z === "F" ? V : null));
              }
              if (V) {
                ((Gt = $n(V.nextSibling)), (E = V.data === "F!"));
                break e;
              }
            }
            xr(E);
          }
          E = !1;
        }
        E && (y = x[0]);
      }
    }
    return (
      (x = mn()),
      (x.memoizedState = x.baseState = y),
      (E = {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: Yu,
        lastRenderedState: y,
      }),
      (x.queue = E),
      (x = gd.bind(null, Rt, E)),
      (E.dispatch = x),
      (E = il(!1)),
      (z = pl.bind(null, Rt, !1, E.queue)),
      (E = mn()),
      (V = { state: y, dispatch: null, action: g, pending: null }),
      (E.queue = V),
      (x = Om.bind(null, Rt, V, z, x)),
      (V.dispatch = x),
      (E.memoizedState = g),
      [y, x, !1]
    );
  }
  function Xu(g) {
    var y = Qt();
    return Zu(y, $t, g);
  }
  function Zu(g, y, x) {
    if (
      ((y = ol(g, y, Yu)[0]),
      (g = _i(sr)[0]),
      typeof y == "object" && y !== null && typeof y.then == "function")
    )
      try {
        var E = gs(y);
      } catch (ne) {
        throw ne === Ao ? ai : ne;
      }
    else E = y;
    y = Qt();
    var V = y.queue,
      z = V.dispatch;
    return (
      x !== y.memoizedState &&
        ((Rt.flags |= 2048),
        Oo(9, { destroy: void 0 }, Im.bind(null, V, x), null)),
      [E, z, g]
    );
  }
  function Im(g, y) {
    g.action = y;
  }
  function Ju(g) {
    var y = Qt(),
      x = $t;
    if (x !== null) return Zu(y, x, g);
    (Qt(), (y = y.memoizedState), (x = Qt()));
    var E = x.queue.dispatch;
    return ((x.memoizedState = g), [y, E, !1]);
  }
  function Oo(g, y, x, E) {
    return (
      (g = { tag: g, create: x, deps: E, inst: y, next: null }),
      (y = Rt.updateQueue),
      y === null && ((y = gi()), (Rt.updateQueue = y)),
      (x = y.lastEffect),
      x === null
        ? (y.lastEffect = g.next = g)
        : ((E = x.next), (x.next = g), (g.next = E), (y.lastEffect = g)),
      g
    );
  }
  function Qu() {
    return Qt().memoizedState;
  }
  function yi(g, y, x, E) {
    var V = mn();
    ((Rt.flags |= g),
      (V.memoizedState = Oo(
        1 | y,
        { destroy: void 0 },
        x,
        E === void 0 ? null : E,
      )));
  }
  function bi(g, y, x, E) {
    var V = Qt();
    E = E === void 0 ? null : E;
    var z = V.memoizedState.inst;
    $t !== null && E !== null && Ja(E, $t.memoizedState.deps)
      ? (V.memoizedState = Oo(y, z, x, E))
      : ((Rt.flags |= g), (V.memoizedState = Oo(1 | y, z, x, E)));
  }
  function ed(g, y) {
    yi(8390656, 8, g, y);
  }
  function ll(g, y) {
    bi(2048, 8, g, y);
  }
  function Dm(g) {
    Rt.flags |= 4;
    var y = Rt.updateQueue;
    if (y === null) ((y = gi()), (Rt.updateQueue = y), (y.events = [g]));
    else {
      var x = y.events;
      x === null ? (y.events = [g]) : x.push(g);
    }
  }
  function td(g) {
    var y = Qt().memoizedState;
    return (
      Dm({ ref: y, nextImpl: g }),
      function () {
        if ((Bt & 2) !== 0) throw Error(_(440));
        return y.impl.apply(void 0, arguments);
      }
    );
  }
  function nd(g, y) {
    return bi(4, 2, g, y);
  }
  function rd(g, y) {
    return bi(4, 4, g, y);
  }
  function od(g, y) {
    if (typeof y == "function") {
      g = g();
      var x = y(g);
      return function () {
        typeof x == "function" ? x() : y(null);
      };
    }
    if (y != null)
      return (
        (g = g()),
        (y.current = g),
        function () {
          y.current = null;
        }
      );
  }
  function sd(g, y, x) {
    ((x = x != null ? x.concat([g]) : null), bi(4, 4, od.bind(null, y, g), x));
  }
  function cl() {}
  function ad(g, y) {
    var x = Qt();
    y = y === void 0 ? null : y;
    var E = x.memoizedState;
    return y !== null && Ja(y, E[1]) ? E[0] : ((x.memoizedState = [g, y]), g);
  }
  function ld(g, y) {
    var x = Qt();
    y = y === void 0 ? null : y;
    var E = x.memoizedState;
    if (y !== null && Ja(y, E[1])) return E[0];
    if (((E = g()), to)) {
      hr(!0);
      try {
        g();
      } finally {
        hr(!1);
      }
    }
    return ((x.memoizedState = [E, y]), E);
  }
  function ul(g, y, x) {
    return x === void 0 || ((or & 1073741824) !== 0 && (Ot & 261930) === 0)
      ? (g.memoizedState = y)
      : ((g.memoizedState = x), (g = uf()), (Rt.lanes |= g), (Nr |= g), x);
  }
  function cd(g, y, x, E) {
    return An(x, y)
      ? x
      : Co.current !== null
        ? ((g = ul(g, x, E)), An(g, y) || (nn = !0), g)
        : (or & 42) === 0 || ((or & 1073741824) !== 0 && (Ot & 261930) === 0)
          ? ((nn = !0), (g.memoizedState = x))
          : ((g = uf()), (Rt.lanes |= g), (Nr |= g), y);
  }
  function ud(g, y, x, E, V) {
    var z = Ye.p;
    Ye.p = z !== 0 && 8 > z ? z : 8;
    var ne = $e.T,
      je = {};
    (($e.T = je), pl(g, !1, y, x));
    try {
      var He = V(),
        Je = $e.S;
      if (
        (Je !== null && Je(je, He),
        He !== null && typeof He == "object" && typeof He.then == "function")
      ) {
        var st = Cm(He, E);
        hs(g, y, st, In(g));
      } else hs(g, y, E, In(g));
    } catch (ft) {
      hs(g, y, { then: function () {}, status: "rejected", reason: ft }, In());
    } finally {
      ((Ye.p = z),
        ne !== null && je.types !== null && (ne.types = je.types),
        ($e.T = ne));
    }
  }
  function Lm() {}
  function dl(g, y, x, E) {
    if (g.tag !== 5) throw Error(_(476));
    var V = dd(g).queue;
    ud(
      g,
      V,
      y,
      Qe,
      x === null
        ? Lm
        : function () {
            return (fd(g), x(E));
          },
    );
  }
  function dd(g) {
    var y = g.memoizedState;
    if (y !== null) return y;
    y = {
      memoizedState: Qe,
      baseState: Qe,
      baseQueue: null,
      queue: {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: sr,
        lastRenderedState: Qe,
      },
      next: null,
    };
    var x = {};
    return (
      (y.next = {
        memoizedState: x,
        baseState: x,
        baseQueue: null,
        queue: {
          pending: null,
          lanes: 0,
          dispatch: null,
          lastRenderedReducer: sr,
          lastRenderedState: x,
        },
        next: null,
      }),
      (g.memoizedState = y),
      (g = g.alternate),
      g !== null && (g.memoizedState = y),
      y
    );
  }
  function fd(g) {
    var y = dd(g);
    (y.next === null && (y = g.alternate.memoizedState),
      hs(g, y.next.queue, {}, In()));
  }
  function fl() {
    return dn(Ds);
  }
  function pd() {
    return Qt().memoizedState;
  }
  function md() {
    return Qt().memoizedState;
  }
  function Pm(g) {
    for (var y = g.return; y !== null; ) {
      switch (y.tag) {
        case 24:
        case 3:
          var x = In();
          g = Sr(x);
          var E = Tr(y, g, x);
          (E !== null && (vn(E, y, x), ds(E, y, x)),
            (y = { cache: $a() }),
            (g.payload = y));
          return;
      }
      y = y.return;
    }
  }
  function jm(g, y, x) {
    var E = In();
    ((x = {
      lane: E,
      revertLane: 0,
      gesture: null,
      action: x,
      hasEagerState: !1,
      eagerState: null,
      next: null,
    }),
      wi(g)
        ? hd(y, x)
        : ((x = Na(g, y, x, E)), x !== null && (vn(x, g, E), _d(x, y, E))));
  }
  function gd(g, y, x) {
    var E = In();
    hs(g, y, x, E);
  }
  function hs(g, y, x, E) {
    var V = {
      lane: E,
      revertLane: 0,
      gesture: null,
      action: x,
      hasEagerState: !1,
      eagerState: null,
      next: null,
    };
    if (wi(g)) hd(y, V);
    else {
      var z = g.alternate;
      if (
        g.lanes === 0 &&
        (z === null || z.lanes === 0) &&
        ((z = y.lastRenderedReducer), z !== null)
      )
        try {
          var ne = y.lastRenderedState,
            je = z(ne, x);
          if (((V.hasEagerState = !0), (V.eagerState = je), An(je, ne)))
            return (ei(g, y, V, 0), Ht === null && Qs(), !1);
        } catch {
        } finally {
        }
      if (((x = Na(g, y, V, E)), x !== null))
        return (vn(x, g, E), _d(x, y, E), !0);
    }
    return !1;
  }
  function pl(g, y, x, E) {
    if (
      ((E = {
        lane: 2,
        revertLane: Gl(),
        gesture: null,
        action: E,
        hasEagerState: !1,
        eagerState: null,
        next: null,
      }),
      wi(g))
    ) {
      if (y) throw Error(_(479));
    } else ((y = Na(g, x, E, 2)), y !== null && vn(y, g, 2));
  }
  function wi(g) {
    var y = g.alternate;
    return g === Rt || (y !== null && y === Rt);
  }
  function hd(g, y) {
    Mo = pi = !0;
    var x = g.pending;
    (x === null ? (y.next = y) : ((y.next = x.next), (x.next = y)),
      (g.pending = y));
  }
  function _d(g, y, x) {
    if ((x & 4194048) !== 0) {
      var E = y.lanes;
      ((E &= g.pendingLanes), (x |= E), (y.lanes = x), xc(g, x));
    }
  }
  var _s = {
    readContext: dn,
    use: hi,
    useCallback: Kt,
    useContext: Kt,
    useEffect: Kt,
    useImperativeHandle: Kt,
    useLayoutEffect: Kt,
    useInsertionEffect: Kt,
    useMemo: Kt,
    useReducer: Kt,
    useRef: Kt,
    useState: Kt,
    useDebugValue: Kt,
    useDeferredValue: Kt,
    useTransition: Kt,
    useSyncExternalStore: Kt,
    useId: Kt,
    useHostTransitionStatus: Kt,
    useFormState: Kt,
    useActionState: Kt,
    useOptimistic: Kt,
    useMemoCache: Kt,
    useCacheRefresh: Kt,
  };
  _s.useEffectEvent = Kt;
  var yd = {
      readContext: dn,
      use: hi,
      useCallback: function (g, y) {
        return ((mn().memoizedState = [g, y === void 0 ? null : y]), g);
      },
      useContext: dn,
      useEffect: ed,
      useImperativeHandle: function (g, y, x) {
        ((x = x != null ? x.concat([g]) : null),
          yi(4194308, 4, od.bind(null, y, g), x));
      },
      useLayoutEffect: function (g, y) {
        return yi(4194308, 4, g, y);
      },
      useInsertionEffect: function (g, y) {
        yi(4, 2, g, y);
      },
      useMemo: function (g, y) {
        var x = mn();
        y = y === void 0 ? null : y;
        var E = g();
        if (to) {
          hr(!0);
          try {
            g();
          } finally {
            hr(!1);
          }
        }
        return ((x.memoizedState = [E, y]), E);
      },
      useReducer: function (g, y, x) {
        var E = mn();
        if (x !== void 0) {
          var V = x(y);
          if (to) {
            hr(!0);
            try {
              x(y);
            } finally {
              hr(!1);
            }
          }
        } else V = y;
        return (
          (E.memoizedState = E.baseState = V),
          (g = {
            pending: null,
            lanes: 0,
            dispatch: null,
            lastRenderedReducer: g,
            lastRenderedState: V,
          }),
          (E.queue = g),
          (g = g.dispatch = jm.bind(null, Rt, g)),
          [E.memoizedState, g]
        );
      },
      useRef: function (g) {
        var y = mn();
        return ((g = { current: g }), (y.memoizedState = g));
      },
      useState: function (g) {
        g = il(g);
        var y = g.queue,
          x = gd.bind(null, Rt, y);
        return ((y.dispatch = x), [g.memoizedState, x]);
      },
      useDebugValue: cl,
      useDeferredValue: function (g, y) {
        var x = mn();
        return ul(x, g, y);
      },
      useTransition: function () {
        var g = il(!1);
        return (
          (g = ud.bind(null, Rt, g.queue, !0, !1)),
          (mn().memoizedState = g),
          [!1, g]
        );
      },
      useSyncExternalStore: function (g, y, x) {
        var E = Rt,
          V = mn();
        if (Dt) {
          if (x === void 0) throw Error(_(407));
          x = x();
        } else {
          if (((x = y()), Ht === null)) throw Error(_(349));
          (Ot & 127) !== 0 || Vu(E, y, x);
        }
        V.memoizedState = x;
        var z = { value: x, getSnapshot: y };
        return (
          (V.queue = z),
          ed(Fu.bind(null, E, z, g), [g]),
          (E.flags |= 2048),
          Oo(9, { destroy: void 0 }, zu.bind(null, E, z, x, y), null),
          x
        );
      },
      useId: function () {
        var g = mn(),
          y = Ht.identifierPrefix;
        if (Dt) {
          var x = Yn,
            E = qn;
          ((x = (E & ~(1 << (32 - Tn(E) - 1))).toString(32) + x),
            (y = "_" + y + "R_" + x),
            (x = mi++),
            0 < x && (y += "H" + x.toString(32)),
            (y += "_"));
        } else ((x = Mm++), (y = "_" + y + "r_" + x.toString(32) + "_"));
        return (g.memoizedState = y);
      },
      useHostTransitionStatus: fl,
      useFormState: Ku,
      useActionState: Ku,
      useOptimistic: function (g) {
        var y = mn();
        y.memoizedState = y.baseState = g;
        var x = {
          pending: null,
          lanes: 0,
          dispatch: null,
          lastRenderedReducer: null,
          lastRenderedState: null,
        };
        return (
          (y.queue = x),
          (y = pl.bind(null, Rt, !0, x)),
          (x.dispatch = y),
          [g, y]
        );
      },
      useMemoCache: rl,
      useCacheRefresh: function () {
        return (mn().memoizedState = Pm.bind(null, Rt));
      },
      useEffectEvent: function (g) {
        var y = mn(),
          x = { impl: g };
        return (
          (y.memoizedState = x),
          function () {
            if ((Bt & 2) !== 0) throw Error(_(440));
            return x.impl.apply(void 0, arguments);
          }
        );
      },
    },
    ml = {
      readContext: dn,
      use: hi,
      useCallback: ad,
      useContext: dn,
      useEffect: ll,
      useImperativeHandle: sd,
      useInsertionEffect: nd,
      useLayoutEffect: rd,
      useMemo: ld,
      useReducer: _i,
      useRef: Qu,
      useState: function () {
        return _i(sr);
      },
      useDebugValue: cl,
      useDeferredValue: function (g, y) {
        var x = Qt();
        return cd(x, $t.memoizedState, g, y);
      },
      useTransition: function () {
        var g = _i(sr)[0],
          y = Qt().memoizedState;
        return [typeof g == "boolean" ? g : gs(g), y];
      },
      useSyncExternalStore: Bu,
      useId: pd,
      useHostTransitionStatus: fl,
      useFormState: Xu,
      useActionState: Xu,
      useOptimistic: function (g, y) {
        var x = Qt();
        return Uu(x, $t, g, y);
      },
      useMemoCache: rl,
      useCacheRefresh: md,
    };
  ml.useEffectEvent = td;
  var bd = {
    readContext: dn,
    use: hi,
    useCallback: ad,
    useContext: dn,
    useEffect: ll,
    useImperativeHandle: sd,
    useInsertionEffect: nd,
    useLayoutEffect: rd,
    useMemo: ld,
    useReducer: sl,
    useRef: Qu,
    useState: function () {
      return sl(sr);
    },
    useDebugValue: cl,
    useDeferredValue: function (g, y) {
      var x = Qt();
      return $t === null ? ul(x, g, y) : cd(x, $t.memoizedState, g, y);
    },
    useTransition: function () {
      var g = sl(sr)[0],
        y = Qt().memoizedState;
      return [typeof g == "boolean" ? g : gs(g), y];
    },
    useSyncExternalStore: Bu,
    useId: pd,
    useHostTransitionStatus: fl,
    useFormState: Ju,
    useActionState: Ju,
    useOptimistic: function (g, y) {
      var x = Qt();
      return $t !== null
        ? Uu(x, $t, g, y)
        : ((x.baseState = g), [g, x.queue.dispatch]);
    },
    useMemoCache: rl,
    useCacheRefresh: md,
  };
  bd.useEffectEvent = td;
  function gl(g, y, x, E) {
    ((y = g.memoizedState),
      (x = x(E, y)),
      (x = x == null ? y : q({}, y, x)),
      (g.memoizedState = x),
      g.lanes === 0 && (g.updateQueue.baseState = x));
  }
  var hl = {
    enqueueSetState: function (g, y, x) {
      g = g._reactInternals;
      var E = In(),
        V = Sr(E);
      ((V.payload = y),
        x != null && (V.callback = x),
        (y = Tr(g, V, E)),
        y !== null && (vn(y, g, E), ds(y, g, E)));
    },
    enqueueReplaceState: function (g, y, x) {
      g = g._reactInternals;
      var E = In(),
        V = Sr(E);
      ((V.tag = 1),
        (V.payload = y),
        x != null && (V.callback = x),
        (y = Tr(g, V, E)),
        y !== null && (vn(y, g, E), ds(y, g, E)));
    },
    enqueueForceUpdate: function (g, y) {
      g = g._reactInternals;
      var x = In(),
        E = Sr(x);
      ((E.tag = 2),
        y != null && (E.callback = y),
        (y = Tr(g, E, x)),
        y !== null && (vn(y, g, x), ds(y, g, x)));
    },
  };
  function wd(g, y, x, E, V, z, ne) {
    return (
      (g = g.stateNode),
      typeof g.shouldComponentUpdate == "function"
        ? g.shouldComponentUpdate(E, z, ne)
        : y.prototype && y.prototype.isPureReactComponent
          ? !rs(x, E) || !rs(V, z)
          : !0
    );
  }
  function xd(g, y, x, E) {
    ((g = y.state),
      typeof y.componentWillReceiveProps == "function" &&
        y.componentWillReceiveProps(x, E),
      typeof y.UNSAFE_componentWillReceiveProps == "function" &&
        y.UNSAFE_componentWillReceiveProps(x, E),
      y.state !== g && hl.enqueueReplaceState(y, y.state, null));
  }
  function no(g, y) {
    var x = y;
    if ("ref" in y) {
      x = {};
      for (var E in y) E !== "ref" && (x[E] = y[E]);
    }
    if ((g = g.defaultProps)) {
      x === y && (x = q({}, x));
      for (var V in g) x[V] === void 0 && (x[V] = g[V]);
    }
    return x;
  }
  function vd(g) {
    Js(g);
  }
  function Ed(g) {
    console.error(g);
  }
  function Sd(g) {
    Js(g);
  }
  function xi(g, y) {
    try {
      var x = g.onUncaughtError;
      x(y.value, { componentStack: y.stack });
    } catch (E) {
      setTimeout(function () {
        throw E;
      });
    }
  }
  function Td(g, y, x) {
    try {
      var E = g.onCaughtError;
      E(x.value, {
        componentStack: x.stack,
        errorBoundary: y.tag === 1 ? y.stateNode : null,
      });
    } catch (V) {
      setTimeout(function () {
        throw V;
      });
    }
  }
  function _l(g, y, x) {
    return (
      (x = Sr(x)),
      (x.tag = 3),
      (x.payload = { element: null }),
      (x.callback = function () {
        xi(g, y);
      }),
      x
    );
  }
  function Ad(g) {
    return ((g = Sr(g)), (g.tag = 3), g);
  }
  function Rd(g, y, x, E) {
    var V = x.type.getDerivedStateFromError;
    if (typeof V == "function") {
      var z = E.value;
      ((g.payload = function () {
        return V(z);
      }),
        (g.callback = function () {
          Td(y, x, E);
        }));
    }
    var ne = x.stateNode;
    ne !== null &&
      typeof ne.componentDidCatch == "function" &&
      (g.callback = function () {
        (Td(y, x, E),
          typeof V != "function" &&
            (Or === null ? (Or = new Set([this])) : Or.add(this)));
        var je = E.stack;
        this.componentDidCatch(E.value, {
          componentStack: je !== null ? je : "",
        });
      });
  }
  function Bm(g, y, x, E, V) {
    if (
      ((x.flags |= 32768),
      E !== null && typeof E == "object" && typeof E.then == "function")
    ) {
      if (
        ((y = x.alternate),
        y !== null && Eo(y, x, V, !0),
        (x = Cn.current),
        x !== null)
      ) {
        switch (x.tag) {
          case 31:
          case 13:
            return (
              Fn === null ? Di() : x.alternate === null && Xt === 0 && (Xt = 3),
              (x.flags &= -257),
              (x.flags |= 65536),
              (x.lanes = V),
              E === li
                ? (x.flags |= 16384)
                : ((y = x.updateQueue),
                  y === null ? (x.updateQueue = new Set([E])) : y.add(E),
                  kl(g, E, V)),
              !1
            );
          case 22:
            return (
              (x.flags |= 65536),
              E === li
                ? (x.flags |= 16384)
                : ((y = x.updateQueue),
                  y === null
                    ? ((y = {
                        transitions: null,
                        markerInstances: null,
                        retryQueue: new Set([E]),
                      }),
                      (x.updateQueue = y))
                    : ((x = y.retryQueue),
                      x === null ? (y.retryQueue = new Set([E])) : x.add(E)),
                  kl(g, E, V)),
              !1
            );
        }
        throw Error(_(435, x.tag));
      }
      return (kl(g, E, V), Di(), !1);
    }
    if (Dt)
      return (
        (y = Cn.current),
        y !== null
          ? ((y.flags & 65536) === 0 && (y.flags |= 256),
            (y.flags |= 65536),
            (y.lanes = V),
            E !== ja && ((g = Error(_(422), { cause: E })), is(jn(g, x))))
          : (E !== ja && ((y = Error(_(423), { cause: E })), is(jn(y, x))),
            (g = g.current.alternate),
            (g.flags |= 65536),
            (V &= -V),
            (g.lanes |= V),
            (E = jn(E, x)),
            (V = _l(g.stateNode, E, V)),
            qa(g, V),
            Xt !== 4 && (Xt = 2)),
        !1
      );
    var z = Error(_(520), { cause: E });
    if (
      ((z = jn(z, x)),
      Ts === null ? (Ts = [z]) : Ts.push(z),
      Xt !== 4 && (Xt = 2),
      y === null)
    )
      return !0;
    ((E = jn(E, x)), (x = y));
    do {
      switch (x.tag) {
        case 3:
          return (
            (x.flags |= 65536),
            (g = V & -V),
            (x.lanes |= g),
            (g = _l(x.stateNode, E, g)),
            qa(x, g),
            !1
          );
        case 1:
          if (
            ((y = x.type),
            (z = x.stateNode),
            (x.flags & 128) === 0 &&
              (typeof y.getDerivedStateFromError == "function" ||
                (z !== null &&
                  typeof z.componentDidCatch == "function" &&
                  (Or === null || !Or.has(z)))))
          )
            return (
              (x.flags |= 65536),
              (V &= -V),
              (x.lanes |= V),
              (V = Ad(V)),
              Rd(V, g, x, E),
              qa(x, V),
              !1
            );
      }
      x = x.return;
    } while (x !== null);
    return !1;
  }
  var yl = Error(_(461)),
    nn = !1;
  function fn(g, y, x, E) {
    y.child = g === null ? Nu(y, null, x, E) : eo(y, g.child, x, E);
  }
  function Cd(g, y, x, E, V) {
    x = x.render;
    var z = y.ref;
    if ("ref" in E) {
      var ne = {};
      for (var je in E) je !== "ref" && (ne[je] = E[je]);
    } else ne = E;
    return (
      Xr(y),
      (E = Qa(g, y, x, ne, z, V)),
      (je = el()),
      g !== null && !nn
        ? (tl(g, y, V), ir(g, y, V))
        : (Dt && je && La(y), (y.flags |= 1), fn(g, y, E, V), y.child)
    );
  }
  function Md(g, y, x, E, V) {
    if (g === null) {
      var z = x.type;
      return typeof z == "function" &&
        !Oa(z) &&
        z.defaultProps === void 0 &&
        x.compare === null
        ? ((y.tag = 15), (y.type = z), Nd(g, y, z, E, V))
        : ((g = ni(x.type, null, E, y, y.mode, V)),
          (g.ref = y.ref),
          (g.return = y),
          (y.child = g));
    }
    if (((z = g.child), !Al(g, V))) {
      var ne = z.memoizedProps;
      if (
        ((x = x.compare),
        (x = x !== null ? x : rs),
        x(ne, E) && g.ref === y.ref)
      )
        return ir(g, y, V);
    }
    return (
      (y.flags |= 1),
      (g = er(z, E)),
      (g.ref = y.ref),
      (g.return = y),
      (y.child = g)
    );
  }
  function Nd(g, y, x, E, V) {
    if (g !== null) {
      var z = g.memoizedProps;
      if (rs(z, E) && g.ref === y.ref)
        if (((nn = !1), (y.pendingProps = E = z), Al(g, V)))
          (g.flags & 131072) !== 0 && (nn = !0);
        else return ((y.lanes = g.lanes), ir(g, y, V));
    }
    return bl(g, y, x, E, V);
  }
  function Od(g, y, x, E) {
    var V = E.children,
      z = g !== null ? g.memoizedState : null;
    if (
      (g === null &&
        y.stateNode === null &&
        (y.stateNode = {
          _visibility: 1,
          _pendingMarkers: null,
          _retryCache: null,
          _transitions: null,
        }),
      E.mode === "hidden")
    ) {
      if ((y.flags & 128) !== 0) {
        if (((z = z !== null ? z.baseLanes | x : x), g !== null)) {
          for (E = y.child = g.child, V = 0; E !== null; )
            ((V = V | E.lanes | E.childLanes), (E = E.sibling));
          E = V & ~z;
        } else ((E = 0), (y.child = null));
        return Id(g, y, z, x, E);
      }
      if ((x & 536870912) !== 0)
        ((y.memoizedState = { baseLanes: 0, cachePool: null }),
          g !== null && ii(y, z !== null ? z.cachePool : null),
          z !== null ? Du(y, z) : Ka(),
          Lu(y));
      else
        return (
          (E = y.lanes = 536870912),
          Id(g, y, z !== null ? z.baseLanes | x : x, x, E)
        );
    } else
      z !== null
        ? (ii(y, z.cachePool), Du(y, z), Rr(), (y.memoizedState = null))
        : (g !== null && ii(y, null), Ka(), Rr());
    return (fn(g, y, V, x), y.child);
  }
  function ys(g, y) {
    return (
      (g !== null && g.tag === 22) ||
        y.stateNode !== null ||
        (y.stateNode = {
          _visibility: 1,
          _pendingMarkers: null,
          _retryCache: null,
          _transitions: null,
        }),
      y.sibling
    );
  }
  function Id(g, y, x, E, V) {
    var z = Ua();
    return (
      (z = z === null ? null : { parent: en._currentValue, pool: z }),
      (y.memoizedState = { baseLanes: x, cachePool: z }),
      g !== null && ii(y, null),
      Ka(),
      Lu(y),
      g !== null && Eo(g, y, E, !0),
      (y.childLanes = V),
      null
    );
  }
  function vi(g, y) {
    return (
      (y = Si({ mode: y.mode, children: y.children }, g.mode)),
      (y.ref = g.ref),
      (g.child = y),
      (y.return = g),
      y
    );
  }
  function Dd(g, y, x) {
    return (
      eo(y, g.child, null, x),
      (g = vi(y, y.pendingProps)),
      (g.flags |= 2),
      Mn(y),
      (y.memoizedState = null),
      g
    );
  }
  function Vm(g, y, x) {
    var E = y.pendingProps,
      V = (y.flags & 128) !== 0;
    if (((y.flags &= -129), g === null)) {
      if (Dt) {
        if (E.mode === "hidden")
          return ((g = vi(y, E)), (y.lanes = 536870912), ys(null, g));
        if (
          (Za(y),
          (g = Gt)
            ? ((g = Wf(g, zn)),
              (g = g !== null && g.data === "&" ? g : null),
              g !== null &&
                ((y.memoizedState = {
                  dehydrated: g,
                  treeContext: br !== null ? { id: qn, overflow: Yn } : null,
                  retryLane: 536870912,
                  hydrationErrors: null,
                }),
                (x = gu(g)),
                (x.return = y),
                (y.child = x),
                (un = y),
                (Gt = null)))
            : (g = null),
          g === null)
        )
          throw xr(y);
        return ((y.lanes = 536870912), null);
      }
      return vi(y, E);
    }
    var z = g.memoizedState;
    if (z !== null) {
      var ne = z.dehydrated;
      if ((Za(y), V))
        if (y.flags & 256) ((y.flags &= -257), (y = Dd(g, y, x)));
        else if (y.memoizedState !== null)
          ((y.child = g.child), (y.flags |= 128), (y = null));
        else throw Error(_(558));
      else if (
        (nn || Eo(g, y, x, !1), (V = (x & g.childLanes) !== 0), nn || V)
      ) {
        if (
          ((E = Ht),
          E !== null && ((ne = vc(E, x)), ne !== 0 && ne !== z.retryLane))
        )
          throw ((z.retryLane = ne), Wr(g, ne), vn(E, g, ne), yl);
        (Di(), (y = Dd(g, y, x)));
      } else
        ((g = z.treeContext),
          (Gt = $n(ne.nextSibling)),
          (un = y),
          (Dt = !0),
          (wr = null),
          (zn = !1),
          g !== null && yu(y, g),
          (y = vi(y, E)),
          (y.flags |= 4096));
      return y;
    }
    return (
      (g = er(g.child, { mode: E.mode, children: E.children })),
      (g.ref = y.ref),
      (y.child = g),
      (g.return = y),
      g
    );
  }
  function Ei(g, y) {
    var x = y.ref;
    if (x === null) g !== null && g.ref !== null && (y.flags |= 4194816);
    else {
      if (typeof x != "function" && typeof x != "object") throw Error(_(284));
      (g === null || g.ref !== x) && (y.flags |= 4194816);
    }
  }
  function bl(g, y, x, E, V) {
    return (
      Xr(y),
      (x = Qa(g, y, x, E, void 0, V)),
      (E = el()),
      g !== null && !nn
        ? (tl(g, y, V), ir(g, y, V))
        : (Dt && E && La(y), (y.flags |= 1), fn(g, y, x, V), y.child)
    );
  }
  function Ld(g, y, x, E, V, z) {
    return (
      Xr(y),
      (y.updateQueue = null),
      (x = ju(y, E, x, V)),
      Pu(g),
      (E = el()),
      g !== null && !nn
        ? (tl(g, y, z), ir(g, y, z))
        : (Dt && E && La(y), (y.flags |= 1), fn(g, y, x, z), y.child)
    );
  }
  function Pd(g, y, x, E, V) {
    if ((Xr(y), y.stateNode === null)) {
      var z = bo,
        ne = x.contextType;
      (typeof ne == "object" && ne !== null && (z = dn(ne)),
        (z = new x(E, z)),
        (y.memoizedState =
          z.state !== null && z.state !== void 0 ? z.state : null),
        (z.updater = hl),
        (y.stateNode = z),
        (z._reactInternals = y),
        (z = y.stateNode),
        (z.props = E),
        (z.state = y.memoizedState),
        (z.refs = {}),
        Ga(y),
        (ne = x.contextType),
        (z.context = typeof ne == "object" && ne !== null ? dn(ne) : bo),
        (z.state = y.memoizedState),
        (ne = x.getDerivedStateFromProps),
        typeof ne == "function" &&
          (gl(y, x, ne, E), (z.state = y.memoizedState)),
        typeof x.getDerivedStateFromProps == "function" ||
          typeof z.getSnapshotBeforeUpdate == "function" ||
          (typeof z.UNSAFE_componentWillMount != "function" &&
            typeof z.componentWillMount != "function") ||
          ((ne = z.state),
          typeof z.componentWillMount == "function" && z.componentWillMount(),
          typeof z.UNSAFE_componentWillMount == "function" &&
            z.UNSAFE_componentWillMount(),
          ne !== z.state && hl.enqueueReplaceState(z, z.state, null),
          ps(y, E, z, V),
          fs(),
          (z.state = y.memoizedState)),
        typeof z.componentDidMount == "function" && (y.flags |= 4194308),
        (E = !0));
    } else if (g === null) {
      z = y.stateNode;
      var je = y.memoizedProps,
        He = no(x, je);
      z.props = He;
      var Je = z.context,
        st = x.contextType;
      ((ne = bo), typeof st == "object" && st !== null && (ne = dn(st)));
      var ft = x.getDerivedStateFromProps;
      ((st =
        typeof ft == "function" ||
        typeof z.getSnapshotBeforeUpdate == "function"),
        (je = y.pendingProps !== je),
        st ||
          (typeof z.UNSAFE_componentWillReceiveProps != "function" &&
            typeof z.componentWillReceiveProps != "function") ||
          ((je || Je !== ne) && xd(y, z, E, ne)),
        (Er = !1));
      var et = y.memoizedState;
      ((z.state = et),
        ps(y, E, z, V),
        fs(),
        (Je = y.memoizedState),
        je || et !== Je || Er
          ? (typeof ft == "function" &&
              (gl(y, x, ft, E), (Je = y.memoizedState)),
            (He = Er || wd(y, x, He, E, et, Je, ne))
              ? (st ||
                  (typeof z.UNSAFE_componentWillMount != "function" &&
                    typeof z.componentWillMount != "function") ||
                  (typeof z.componentWillMount == "function" &&
                    z.componentWillMount(),
                  typeof z.UNSAFE_componentWillMount == "function" &&
                    z.UNSAFE_componentWillMount()),
                typeof z.componentDidMount == "function" &&
                  (y.flags |= 4194308))
              : (typeof z.componentDidMount == "function" &&
                  (y.flags |= 4194308),
                (y.memoizedProps = E),
                (y.memoizedState = Je)),
            (z.props = E),
            (z.state = Je),
            (z.context = ne),
            (E = He))
          : (typeof z.componentDidMount == "function" && (y.flags |= 4194308),
            (E = !1)));
    } else {
      ((z = y.stateNode),
        Wa(g, y),
        (ne = y.memoizedProps),
        (st = no(x, ne)),
        (z.props = st),
        (ft = y.pendingProps),
        (et = z.context),
        (Je = x.contextType),
        (He = bo),
        typeof Je == "object" && Je !== null && (He = dn(Je)),
        (je = x.getDerivedStateFromProps),
        (Je =
          typeof je == "function" ||
          typeof z.getSnapshotBeforeUpdate == "function") ||
          (typeof z.UNSAFE_componentWillReceiveProps != "function" &&
            typeof z.componentWillReceiveProps != "function") ||
          ((ne !== ft || et !== He) && xd(y, z, E, He)),
        (Er = !1),
        (et = y.memoizedState),
        (z.state = et),
        ps(y, E, z, V),
        fs());
      var rt = y.memoizedState;
      ne !== ft ||
      et !== rt ||
      Er ||
      (g !== null && g.dependencies !== null && oi(g.dependencies))
        ? (typeof je == "function" && (gl(y, x, je, E), (rt = y.memoizedState)),
          (st =
            Er ||
            wd(y, x, st, E, et, rt, He) ||
            (g !== null && g.dependencies !== null && oi(g.dependencies)))
            ? (Je ||
                (typeof z.UNSAFE_componentWillUpdate != "function" &&
                  typeof z.componentWillUpdate != "function") ||
                (typeof z.componentWillUpdate == "function" &&
                  z.componentWillUpdate(E, rt, He),
                typeof z.UNSAFE_componentWillUpdate == "function" &&
                  z.UNSAFE_componentWillUpdate(E, rt, He)),
              typeof z.componentDidUpdate == "function" && (y.flags |= 4),
              typeof z.getSnapshotBeforeUpdate == "function" &&
                (y.flags |= 1024))
            : (typeof z.componentDidUpdate != "function" ||
                (ne === g.memoizedProps && et === g.memoizedState) ||
                (y.flags |= 4),
              typeof z.getSnapshotBeforeUpdate != "function" ||
                (ne === g.memoizedProps && et === g.memoizedState) ||
                (y.flags |= 1024),
              (y.memoizedProps = E),
              (y.memoizedState = rt)),
          (z.props = E),
          (z.state = rt),
          (z.context = He),
          (E = st))
        : (typeof z.componentDidUpdate != "function" ||
            (ne === g.memoizedProps && et === g.memoizedState) ||
            (y.flags |= 4),
          typeof z.getSnapshotBeforeUpdate != "function" ||
            (ne === g.memoizedProps && et === g.memoizedState) ||
            (y.flags |= 1024),
          (E = !1));
    }
    return (
      (z = E),
      Ei(g, y),
      (E = (y.flags & 128) !== 0),
      z || E
        ? ((z = y.stateNode),
          (x =
            E && typeof x.getDerivedStateFromError != "function"
              ? null
              : z.render()),
          (y.flags |= 1),
          g !== null && E
            ? ((y.child = eo(y, g.child, null, V)),
              (y.child = eo(y, null, x, V)))
            : fn(g, y, x, V),
          (y.memoizedState = z.state),
          (g = y.child))
        : (g = ir(g, y, V)),
      g
    );
  }
  function jd(g, y, x, E) {
    return (Yr(), (y.flags |= 256), fn(g, y, x, E), y.child);
  }
  var wl = {
    dehydrated: null,
    treeContext: null,
    retryLane: 0,
    hydrationErrors: null,
  };
  function xl(g) {
    return { baseLanes: g, cachePool: Su() };
  }
  function vl(g, y, x) {
    return ((g = g !== null ? g.childLanes & ~x : 0), y && (g |= On), g);
  }
  function Bd(g, y, x) {
    var E = y.pendingProps,
      V = !1,
      z = (y.flags & 128) !== 0,
      ne;
    if (
      ((ne = z) ||
        (ne =
          g !== null && g.memoizedState === null ? !1 : (Jt.current & 2) !== 0),
      ne && ((V = !0), (y.flags &= -129)),
      (ne = (y.flags & 32) !== 0),
      (y.flags &= -33),
      g === null)
    ) {
      if (Dt) {
        if (
          (V ? Ar(y) : Rr(),
          (g = Gt)
            ? ((g = Wf(g, zn)),
              (g = g !== null && g.data !== "&" ? g : null),
              g !== null &&
                ((y.memoizedState = {
                  dehydrated: g,
                  treeContext: br !== null ? { id: qn, overflow: Yn } : null,
                  retryLane: 536870912,
                  hydrationErrors: null,
                }),
                (x = gu(g)),
                (x.return = y),
                (y.child = x),
                (un = y),
                (Gt = null)))
            : (g = null),
          g === null)
        )
          throw xr(y);
        return (oc(g) ? (y.lanes = 32) : (y.lanes = 536870912), null);
      }
      var je = E.children;
      return (
        (E = E.fallback),
        V
          ? (Rr(),
            (V = y.mode),
            (je = Si({ mode: "hidden", children: je }, V)),
            (E = qr(E, V, x, null)),
            (je.return = y),
            (E.return = y),
            (je.sibling = E),
            (y.child = je),
            (E = y.child),
            (E.memoizedState = xl(x)),
            (E.childLanes = vl(g, ne, x)),
            (y.memoizedState = wl),
            ys(null, E))
          : (Ar(y), El(y, je))
      );
    }
    var He = g.memoizedState;
    if (He !== null && ((je = He.dehydrated), je !== null)) {
      if (z)
        y.flags & 256
          ? (Ar(y), (y.flags &= -257), (y = Sl(g, y, x)))
          : y.memoizedState !== null
            ? (Rr(), (y.child = g.child), (y.flags |= 128), (y = null))
            : (Rr(),
              (je = E.fallback),
              (V = y.mode),
              (E = Si({ mode: "visible", children: E.children }, V)),
              (je = qr(je, V, x, null)),
              (je.flags |= 2),
              (E.return = y),
              (je.return = y),
              (E.sibling = je),
              (y.child = E),
              eo(y, g.child, null, x),
              (E = y.child),
              (E.memoizedState = xl(x)),
              (E.childLanes = vl(g, ne, x)),
              (y.memoizedState = wl),
              (y = ys(null, E)));
      else if ((Ar(y), oc(je))) {
        if (((ne = je.nextSibling && je.nextSibling.dataset), ne))
          var Je = ne.dgst;
        ((ne = Je),
          (E = Error(_(419))),
          (E.stack = ""),
          (E.digest = ne),
          is({ value: E, source: null, stack: null }),
          (y = Sl(g, y, x)));
      } else if (
        (nn || Eo(g, y, x, !1), (ne = (x & g.childLanes) !== 0), nn || ne)
      ) {
        if (
          ((ne = Ht),
          ne !== null && ((E = vc(ne, x)), E !== 0 && E !== He.retryLane))
        )
          throw ((He.retryLane = E), Wr(g, E), vn(ne, g, E), yl);
        (rc(je) || Di(), (y = Sl(g, y, x)));
      } else
        rc(je)
          ? ((y.flags |= 192), (y.child = g.child), (y = null))
          : ((g = He.treeContext),
            (Gt = $n(je.nextSibling)),
            (un = y),
            (Dt = !0),
            (wr = null),
            (zn = !1),
            g !== null && yu(y, g),
            (y = El(y, E.children)),
            (y.flags |= 4096));
      return y;
    }
    return V
      ? (Rr(),
        (je = E.fallback),
        (V = y.mode),
        (He = g.child),
        (Je = He.sibling),
        (E = er(He, { mode: "hidden", children: E.children })),
        (E.subtreeFlags = He.subtreeFlags & 65011712),
        Je !== null
          ? (je = er(Je, je))
          : ((je = qr(je, V, x, null)), (je.flags |= 2)),
        (je.return = y),
        (E.return = y),
        (E.sibling = je),
        (y.child = E),
        ys(null, E),
        (E = y.child),
        (je = g.child.memoizedState),
        je === null
          ? (je = xl(x))
          : ((V = je.cachePool),
            V !== null
              ? ((He = en._currentValue),
                (V = V.parent !== He ? { parent: He, pool: He } : V))
              : (V = Su()),
            (je = { baseLanes: je.baseLanes | x, cachePool: V })),
        (E.memoizedState = je),
        (E.childLanes = vl(g, ne, x)),
        (y.memoizedState = wl),
        ys(g.child, E))
      : (Ar(y),
        (x = g.child),
        (g = x.sibling),
        (x = er(x, { mode: "visible", children: E.children })),
        (x.return = y),
        (x.sibling = null),
        g !== null &&
          ((ne = y.deletions),
          ne === null ? ((y.deletions = [g]), (y.flags |= 16)) : ne.push(g)),
        (y.child = x),
        (y.memoizedState = null),
        x);
  }
  function El(g, y) {
    return (
      (y = Si({ mode: "visible", children: y }, g.mode)),
      (y.return = g),
      (g.child = y)
    );
  }
  function Si(g, y) {
    return ((g = Rn(22, g, null, y)), (g.lanes = 0), g);
  }
  function Sl(g, y, x) {
    return (
      eo(y, g.child, null, x),
      (g = El(y, y.pendingProps.children)),
      (g.flags |= 2),
      (y.memoizedState = null),
      g
    );
  }
  function Vd(g, y, x) {
    g.lanes |= y;
    var E = g.alternate;
    (E !== null && (E.lanes |= y), za(g.return, y, x));
  }
  function Tl(g, y, x, E, V, z) {
    var ne = g.memoizedState;
    ne === null
      ? (g.memoizedState = {
          isBackwards: y,
          rendering: null,
          renderingStartTime: 0,
          last: E,
          tail: x,
          tailMode: V,
          treeForkCount: z,
        })
      : ((ne.isBackwards = y),
        (ne.rendering = null),
        (ne.renderingStartTime = 0),
        (ne.last = E),
        (ne.tail = x),
        (ne.tailMode = V),
        (ne.treeForkCount = z));
  }
  function zd(g, y, x) {
    var E = y.pendingProps,
      V = E.revealOrder,
      z = E.tail;
    E = E.children;
    var ne = Jt.current,
      je = (ne & 2) !== 0;
    if (
      (je ? ((ne = (ne & 1) | 2), (y.flags |= 128)) : (ne &= 1),
      ot(Jt, ne),
      fn(g, y, E, x),
      (E = Dt ? ss : 0),
      !je && g !== null && (g.flags & 128) !== 0)
    )
      e: for (g = y.child; g !== null; ) {
        if (g.tag === 13) g.memoizedState !== null && Vd(g, x, y);
        else if (g.tag === 19) Vd(g, x, y);
        else if (g.child !== null) {
          ((g.child.return = g), (g = g.child));
          continue;
        }
        if (g === y) break e;
        for (; g.sibling === null; ) {
          if (g.return === null || g.return === y) break e;
          g = g.return;
        }
        ((g.sibling.return = g.return), (g = g.sibling));
      }
    switch (V) {
      case "forwards":
        for (x = y.child, V = null; x !== null; )
          ((g = x.alternate),
            g !== null && fi(g) === null && (V = x),
            (x = x.sibling));
        ((x = V),
          x === null
            ? ((V = y.child), (y.child = null))
            : ((V = x.sibling), (x.sibling = null)),
          Tl(y, !1, V, x, z, E));
        break;
      case "backwards":
      case "unstable_legacy-backwards":
        for (x = null, V = y.child, y.child = null; V !== null; ) {
          if (((g = V.alternate), g !== null && fi(g) === null)) {
            y.child = V;
            break;
          }
          ((g = V.sibling), (V.sibling = x), (x = V), (V = g));
        }
        Tl(y, !0, x, null, z, E);
        break;
      case "together":
        Tl(y, !1, null, null, void 0, E);
        break;
      default:
        y.memoizedState = null;
    }
    return y.child;
  }
  function ir(g, y, x) {
    if (
      (g !== null && (y.dependencies = g.dependencies),
      (Nr |= y.lanes),
      (x & y.childLanes) === 0)
    )
      if (g !== null) {
        if ((Eo(g, y, x, !1), (x & y.childLanes) === 0)) return null;
      } else return null;
    if (g !== null && y.child !== g.child) throw Error(_(153));
    if (y.child !== null) {
      for (
        g = y.child, x = er(g, g.pendingProps), y.child = x, x.return = y;
        g.sibling !== null;

      )
        ((g = g.sibling),
          (x = x.sibling = er(g, g.pendingProps)),
          (x.return = y));
      x.sibling = null;
    }
    return y.child;
  }
  function Al(g, y) {
    return (g.lanes & y) !== 0
      ? !0
      : ((g = g.dependencies), !!(g !== null && oi(g)));
  }
  function zm(g, y, x) {
    switch (y.tag) {
      case 3:
        (Et(y, y.stateNode.containerInfo),
          vr(y, en, g.memoizedState.cache),
          Yr());
        break;
      case 27:
      case 5:
        At(y);
        break;
      case 4:
        Et(y, y.stateNode.containerInfo);
        break;
      case 10:
        vr(y, y.type, y.memoizedProps.value);
        break;
      case 31:
        if (y.memoizedState !== null) return ((y.flags |= 128), Za(y), null);
        break;
      case 13:
        var E = y.memoizedState;
        if (E !== null)
          return E.dehydrated !== null
            ? (Ar(y), (y.flags |= 128), null)
            : (x & y.child.childLanes) !== 0
              ? Bd(g, y, x)
              : (Ar(y), (g = ir(g, y, x)), g !== null ? g.sibling : null);
        Ar(y);
        break;
      case 19:
        var V = (g.flags & 128) !== 0;
        if (
          ((E = (x & y.childLanes) !== 0),
          E || (Eo(g, y, x, !1), (E = (x & y.childLanes) !== 0)),
          V)
        ) {
          if (E) return zd(g, y, x);
          y.flags |= 128;
        }
        if (
          ((V = y.memoizedState),
          V !== null &&
            ((V.rendering = null), (V.tail = null), (V.lastEffect = null)),
          ot(Jt, Jt.current),
          E)
        )
          break;
        return null;
      case 22:
        return ((y.lanes = 0), Od(g, y, x, y.pendingProps));
      case 24:
        vr(y, en, g.memoizedState.cache);
    }
    return ir(g, y, x);
  }
  function Fd(g, y, x) {
    if (g !== null)
      if (g.memoizedProps !== y.pendingProps) nn = !0;
      else {
        if (!Al(g, x) && (y.flags & 128) === 0) return ((nn = !1), zm(g, y, x));
        nn = (g.flags & 131072) !== 0;
      }
    else ((nn = !1), Dt && (y.flags & 1048576) !== 0 && _u(y, ss, y.index));
    switch (((y.lanes = 0), y.tag)) {
      case 16:
        e: {
          var E = y.pendingProps;
          if (((g = Jr(y.elementType)), (y.type = g), typeof g == "function"))
            Oa(g)
              ? ((E = no(g, E)), (y.tag = 1), (y = Pd(null, y, g, E, x)))
              : ((y.tag = 0), (y = bl(null, y, g, E, x)));
          else {
            if (g != null) {
              var V = g.$$typeof;
              if (V === ze) {
                ((y.tag = 11), (y = Cd(null, y, g, E, x)));
                break e;
              } else if (V === qe) {
                ((y.tag = 14), (y = Md(null, y, g, E, x)));
                break e;
              }
            }
            throw ((y = bt(g) || g), Error(_(306, y, "")));
          }
        }
        return y;
      case 0:
        return bl(g, y, y.type, y.pendingProps, x);
      case 1:
        return ((E = y.type), (V = no(E, y.pendingProps)), Pd(g, y, E, V, x));
      case 3:
        e: {
          if ((Et(y, y.stateNode.containerInfo), g === null))
            throw Error(_(387));
          E = y.pendingProps;
          var z = y.memoizedState;
          ((V = z.element), Wa(g, y), ps(y, E, null, x));
          var ne = y.memoizedState;
          if (
            ((E = ne.cache),
            vr(y, en, E),
            E !== z.cache && Fa(y, [en], x, !0),
            fs(),
            (E = ne.element),
            z.isDehydrated)
          )
            if (
              ((z = { element: E, isDehydrated: !1, cache: ne.cache }),
              (y.updateQueue.baseState = z),
              (y.memoizedState = z),
              y.flags & 256)
            ) {
              y = jd(g, y, E, x);
              break e;
            } else if (E !== V) {
              ((V = jn(Error(_(424)), y)), is(V), (y = jd(g, y, E, x)));
              break e;
            } else {
              switch (((g = y.stateNode.containerInfo), g.nodeType)) {
                case 9:
                  g = g.body;
                  break;
                default:
                  g = g.nodeName === "HTML" ? g.ownerDocument.body : g;
              }
              for (
                Gt = $n(g.firstChild),
                  un = y,
                  Dt = !0,
                  wr = null,
                  zn = !0,
                  x = Nu(y, null, E, x),
                  y.child = x;
                x;

              )
                ((x.flags = (x.flags & -3) | 4096), (x = x.sibling));
            }
          else {
            if ((Yr(), E === V)) {
              y = ir(g, y, x);
              break e;
            }
            fn(g, y, E, x);
          }
          y = y.child;
        }
        return y;
      case 26:
        return (
          Ei(g, y),
          g === null
            ? (x = Jf(y.type, null, y.pendingProps, null))
              ? (y.memoizedState = x)
              : Dt ||
                ((x = y.type),
                (g = y.pendingProps),
                (E = Fi(yt.current).createElement(x)),
                (E[ln] = y),
                (E[hn] = g),
                pn(E, x, g),
                sn(E),
                (y.stateNode = E))
            : (y.memoizedState = Jf(
                y.type,
                g.memoizedProps,
                y.pendingProps,
                g.memoizedState,
              )),
          null
        );
      case 27:
        return (
          At(y),
          g === null &&
            Dt &&
            ((E = y.stateNode = Kf(y.type, y.pendingProps, yt.current)),
            (un = y),
            (zn = !0),
            (V = Gt),
            Pr(y.type) ? ((sc = V), (Gt = $n(E.firstChild))) : (Gt = V)),
          fn(g, y, y.pendingProps.children, x),
          Ei(g, y),
          g === null && (y.flags |= 4194304),
          y.child
        );
      case 5:
        return (
          g === null &&
            Dt &&
            ((V = E = Gt) &&
              ((E = gg(E, y.type, y.pendingProps, zn)),
              E !== null
                ? ((y.stateNode = E),
                  (un = y),
                  (Gt = $n(E.firstChild)),
                  (zn = !1),
                  (V = !0))
                : (V = !1)),
            V || xr(y)),
          At(y),
          (V = y.type),
          (z = y.pendingProps),
          (ne = g !== null ? g.memoizedProps : null),
          (E = z.children),
          ec(V, z) ? (E = null) : ne !== null && ec(V, ne) && (y.flags |= 32),
          y.memoizedState !== null &&
            ((V = Qa(g, y, Nm, null, null, x)), (Ds._currentValue = V)),
          Ei(g, y),
          fn(g, y, E, x),
          y.child
        );
      case 6:
        return (
          g === null &&
            Dt &&
            ((g = x = Gt) &&
              ((x = hg(x, y.pendingProps, zn)),
              x !== null
                ? ((y.stateNode = x), (un = y), (Gt = null), (g = !0))
                : (g = !1)),
            g || xr(y)),
          null
        );
      case 13:
        return Bd(g, y, x);
      case 4:
        return (
          Et(y, y.stateNode.containerInfo),
          (E = y.pendingProps),
          g === null ? (y.child = eo(y, null, E, x)) : fn(g, y, E, x),
          y.child
        );
      case 11:
        return Cd(g, y, y.type, y.pendingProps, x);
      case 7:
        return (fn(g, y, y.pendingProps, x), y.child);
      case 8:
        return (fn(g, y, y.pendingProps.children, x), y.child);
      case 12:
        return (fn(g, y, y.pendingProps.children, x), y.child);
      case 10:
        return (
          (E = y.pendingProps),
          vr(y, y.type, E.value),
          fn(g, y, E.children, x),
          y.child
        );
      case 9:
        return (
          (V = y.type._context),
          (E = y.pendingProps.children),
          Xr(y),
          (V = dn(V)),
          (E = E(V)),
          (y.flags |= 1),
          fn(g, y, E, x),
          y.child
        );
      case 14:
        return Md(g, y, y.type, y.pendingProps, x);
      case 15:
        return Nd(g, y, y.type, y.pendingProps, x);
      case 19:
        return zd(g, y, x);
      case 31:
        return Vm(g, y, x);
      case 22:
        return Od(g, y, x, y.pendingProps);
      case 24:
        return (
          Xr(y),
          (E = dn(en)),
          g === null
            ? ((V = Ua()),
              V === null &&
                ((V = Ht),
                (z = $a()),
                (V.pooledCache = z),
                z.refCount++,
                z !== null && (V.pooledCacheLanes |= x),
                (V = z)),
              (y.memoizedState = { parent: E, cache: V }),
              Ga(y),
              vr(y, en, V))
            : ((g.lanes & x) !== 0 && (Wa(g, y), ps(y, null, null, x), fs()),
              (V = g.memoizedState),
              (z = y.memoizedState),
              V.parent !== E
                ? ((V = { parent: E, cache: E }),
                  (y.memoizedState = V),
                  y.lanes === 0 &&
                    (y.memoizedState = y.updateQueue.baseState = V),
                  vr(y, en, E))
                : ((E = z.cache),
                  vr(y, en, E),
                  E !== V.cache && Fa(y, [en], x, !0))),
          fn(g, y, y.pendingProps.children, x),
          y.child
        );
      case 29:
        throw y.pendingProps;
    }
    throw Error(_(156, y.tag));
  }
  function ar(g) {
    g.flags |= 4;
  }
  function Rl(g, y, x, E, V) {
    if (((y = (g.mode & 32) !== 0) && (y = !1), y)) {
      if (((g.flags |= 16777216), (V & 335544128) === V))
        if (g.stateNode.complete) g.flags |= 8192;
        else if (mf()) g.flags |= 8192;
        else throw ((Qr = li), Ha);
    } else g.flags &= -16777217;
  }
  function $d(g, y) {
    if (y.type !== "stylesheet" || (y.state.loading & 4) !== 0)
      g.flags &= -16777217;
    else if (((g.flags |= 16777216), !rp(y)))
      if (mf()) g.flags |= 8192;
      else throw ((Qr = li), Ha);
  }
  function Ti(g, y) {
    (y !== null && (g.flags |= 4),
      g.flags & 16384 &&
        ((y = g.tag !== 22 ? bc() : 536870912), (g.lanes |= y), (Po |= y)));
  }
  function bs(g, y) {
    if (!Dt)
      switch (g.tailMode) {
        case "hidden":
          y = g.tail;
          for (var x = null; y !== null; )
            (y.alternate !== null && (x = y), (y = y.sibling));
          x === null ? (g.tail = null) : (x.sibling = null);
          break;
        case "collapsed":
          x = g.tail;
          for (var E = null; x !== null; )
            (x.alternate !== null && (E = x), (x = x.sibling));
          E === null
            ? y || g.tail === null
              ? (g.tail = null)
              : (g.tail.sibling = null)
            : (E.sibling = null);
      }
  }
  function Wt(g) {
    var y = g.alternate !== null && g.alternate.child === g.child,
      x = 0,
      E = 0;
    if (y)
      for (var V = g.child; V !== null; )
        ((x |= V.lanes | V.childLanes),
          (E |= V.subtreeFlags & 65011712),
          (E |= V.flags & 65011712),
          (V.return = g),
          (V = V.sibling));
    else
      for (V = g.child; V !== null; )
        ((x |= V.lanes | V.childLanes),
          (E |= V.subtreeFlags),
          (E |= V.flags),
          (V.return = g),
          (V = V.sibling));
    return ((g.subtreeFlags |= E), (g.childLanes = x), y);
  }
  function Fm(g, y, x) {
    var E = y.pendingProps;
    switch ((Pa(y), y.tag)) {
      case 16:
      case 15:
      case 0:
      case 11:
      case 7:
      case 8:
      case 12:
      case 9:
      case 14:
        return (Wt(y), null);
      case 1:
        return (Wt(y), null);
      case 3:
        return (
          (x = y.stateNode),
          (E = null),
          g !== null && (E = g.memoizedState.cache),
          y.memoizedState.cache !== E && (y.flags |= 2048),
          rr(en),
          xt(),
          x.pendingContext &&
            ((x.context = x.pendingContext), (x.pendingContext = null)),
          (g === null || g.child === null) &&
            (vo(y)
              ? ar(y)
              : g === null ||
                (g.memoizedState.isDehydrated && (y.flags & 256) === 0) ||
                ((y.flags |= 1024), Ba())),
          Wt(y),
          null
        );
      case 26:
        var V = y.type,
          z = y.memoizedState;
        return (
          g === null
            ? (ar(y),
              z !== null ? (Wt(y), $d(y, z)) : (Wt(y), Rl(y, V, null, E, x)))
            : z
              ? z !== g.memoizedState
                ? (ar(y), Wt(y), $d(y, z))
                : (Wt(y), (y.flags &= -16777217))
              : ((g = g.memoizedProps),
                g !== E && ar(y),
                Wt(y),
                Rl(y, V, g, E, x)),
          null
        );
      case 27:
        if (
          (Lt(y),
          (x = yt.current),
          (V = y.type),
          g !== null && y.stateNode != null)
        )
          g.memoizedProps !== E && ar(y);
        else {
          if (!E) {
            if (y.stateNode === null) throw Error(_(166));
            return (Wt(y), null);
          }
          ((g = lt.current),
            vo(y) ? bu(y) : ((g = Kf(V, E, x)), (y.stateNode = g), ar(y)));
        }
        return (Wt(y), null);
      case 5:
        if ((Lt(y), (V = y.type), g !== null && y.stateNode != null))
          g.memoizedProps !== E && ar(y);
        else {
          if (!E) {
            if (y.stateNode === null) throw Error(_(166));
            return (Wt(y), null);
          }
          if (((z = lt.current), vo(y))) bu(y);
          else {
            var ne = Fi(yt.current);
            switch (z) {
              case 1:
                z = ne.createElementNS("http://www.w3.org/2000/svg", V);
                break;
              case 2:
                z = ne.createElementNS("http://www.w3.org/1998/Math/MathML", V);
                break;
              default:
                switch (V) {
                  case "svg":
                    z = ne.createElementNS("http://www.w3.org/2000/svg", V);
                    break;
                  case "math":
                    z = ne.createElementNS(
                      "http://www.w3.org/1998/Math/MathML",
                      V,
                    );
                    break;
                  case "script":
                    ((z = ne.createElement("div")),
                      (z.innerHTML = "<script><\/script>"),
                      (z = z.removeChild(z.firstChild)));
                    break;
                  case "select":
                    ((z =
                      typeof E.is == "string"
                        ? ne.createElement("select", { is: E.is })
                        : ne.createElement("select")),
                      E.multiple
                        ? (z.multiple = !0)
                        : E.size && (z.size = E.size));
                    break;
                  default:
                    z =
                      typeof E.is == "string"
                        ? ne.createElement(V, { is: E.is })
                        : ne.createElement(V);
                }
            }
            ((z[ln] = y), (z[hn] = E));
            e: for (ne = y.child; ne !== null; ) {
              if (ne.tag === 5 || ne.tag === 6) z.appendChild(ne.stateNode);
              else if (ne.tag !== 4 && ne.tag !== 27 && ne.child !== null) {
                ((ne.child.return = ne), (ne = ne.child));
                continue;
              }
              if (ne === y) break e;
              for (; ne.sibling === null; ) {
                if (ne.return === null || ne.return === y) break e;
                ne = ne.return;
              }
              ((ne.sibling.return = ne.return), (ne = ne.sibling));
            }
            y.stateNode = z;
            e: switch ((pn(z, V, E), V)) {
              case "button":
              case "input":
              case "select":
              case "textarea":
                E = !!E.autoFocus;
                break e;
              case "img":
                E = !0;
                break e;
              default:
                E = !1;
            }
            E && ar(y);
          }
        }
        return (
          Wt(y),
          Rl(y, y.type, g === null ? null : g.memoizedProps, y.pendingProps, x),
          null
        );
      case 6:
        if (g && y.stateNode != null) g.memoizedProps !== E && ar(y);
        else {
          if (typeof E != "string" && y.stateNode === null) throw Error(_(166));
          if (((g = yt.current), vo(y))) {
            if (
              ((g = y.stateNode),
              (x = y.memoizedProps),
              (E = null),
              (V = un),
              V !== null)
            )
              switch (V.tag) {
                case 27:
                case 5:
                  E = V.memoizedProps;
              }
            ((g[ln] = y),
              (g = !!(
                g.nodeValue === x ||
                (E !== null && E.suppressHydrationWarning === !0) ||
                Vf(g.nodeValue, x)
              )),
              g || xr(y, !0));
          } else
            ((g = Fi(g).createTextNode(E)), (g[ln] = y), (y.stateNode = g));
        }
        return (Wt(y), null);
      case 31:
        if (((x = y.memoizedState), g === null || g.memoizedState !== null)) {
          if (((E = vo(y)), x !== null)) {
            if (g === null) {
              if (!E) throw Error(_(318));
              if (
                ((g = y.memoizedState),
                (g = g !== null ? g.dehydrated : null),
                !g)
              )
                throw Error(_(557));
              g[ln] = y;
            } else
              (Yr(),
                (y.flags & 128) === 0 && (y.memoizedState = null),
                (y.flags |= 4));
            (Wt(y), (g = !1));
          } else
            ((x = Ba()),
              g !== null &&
                g.memoizedState !== null &&
                (g.memoizedState.hydrationErrors = x),
              (g = !0));
          if (!g) return y.flags & 256 ? (Mn(y), y) : (Mn(y), null);
          if ((y.flags & 128) !== 0) throw Error(_(558));
        }
        return (Wt(y), null);
      case 13:
        if (
          ((E = y.memoizedState),
          g === null ||
            (g.memoizedState !== null && g.memoizedState.dehydrated !== null))
        ) {
          if (((V = vo(y)), E !== null && E.dehydrated !== null)) {
            if (g === null) {
              if (!V) throw Error(_(318));
              if (
                ((V = y.memoizedState),
                (V = V !== null ? V.dehydrated : null),
                !V)
              )
                throw Error(_(317));
              V[ln] = y;
            } else
              (Yr(),
                (y.flags & 128) === 0 && (y.memoizedState = null),
                (y.flags |= 4));
            (Wt(y), (V = !1));
          } else
            ((V = Ba()),
              g !== null &&
                g.memoizedState !== null &&
                (g.memoizedState.hydrationErrors = V),
              (V = !0));
          if (!V) return y.flags & 256 ? (Mn(y), y) : (Mn(y), null);
        }
        return (
          Mn(y),
          (y.flags & 128) !== 0
            ? ((y.lanes = x), y)
            : ((x = E !== null),
              (g = g !== null && g.memoizedState !== null),
              x &&
                ((E = y.child),
                (V = null),
                E.alternate !== null &&
                  E.alternate.memoizedState !== null &&
                  E.alternate.memoizedState.cachePool !== null &&
                  (V = E.alternate.memoizedState.cachePool.pool),
                (z = null),
                E.memoizedState !== null &&
                  E.memoizedState.cachePool !== null &&
                  (z = E.memoizedState.cachePool.pool),
                z !== V && (E.flags |= 2048)),
              x !== g && x && (y.child.flags |= 8192),
              Ti(y, y.updateQueue),
              Wt(y),
              null)
        );
      case 4:
        return (xt(), g === null && Kl(y.stateNode.containerInfo), Wt(y), null);
      case 10:
        return (rr(y.type), Wt(y), null);
      case 19:
        if ((Ue(Jt), (E = y.memoizedState), E === null)) return (Wt(y), null);
        if (((V = (y.flags & 128) !== 0), (z = E.rendering), z === null))
          if (V) bs(E, !1);
          else {
            if (Xt !== 0 || (g !== null && (g.flags & 128) !== 0))
              for (g = y.child; g !== null; ) {
                if (((z = fi(g)), z !== null)) {
                  for (
                    y.flags |= 128,
                      bs(E, !1),
                      g = z.updateQueue,
                      y.updateQueue = g,
                      Ti(y, g),
                      y.subtreeFlags = 0,
                      g = x,
                      x = y.child;
                    x !== null;

                  )
                    (mu(x, g), (x = x.sibling));
                  return (
                    ot(Jt, (Jt.current & 1) | 2),
                    Dt && tr(y, E.treeForkCount),
                    y.child
                  );
                }
                g = g.sibling;
              }
            E.tail !== null &&
              En() > Ni &&
              ((y.flags |= 128), (V = !0), bs(E, !1), (y.lanes = 4194304));
          }
        else {
          if (!V)
            if (((g = fi(z)), g !== null)) {
              if (
                ((y.flags |= 128),
                (V = !0),
                (g = g.updateQueue),
                (y.updateQueue = g),
                Ti(y, g),
                bs(E, !0),
                E.tail === null &&
                  E.tailMode === "hidden" &&
                  !z.alternate &&
                  !Dt)
              )
                return (Wt(y), null);
            } else
              2 * En() - E.renderingStartTime > Ni &&
                x !== 536870912 &&
                ((y.flags |= 128), (V = !0), bs(E, !1), (y.lanes = 4194304));
          E.isBackwards
            ? ((z.sibling = y.child), (y.child = z))
            : ((g = E.last),
              g !== null ? (g.sibling = z) : (y.child = z),
              (E.last = z));
        }
        return E.tail !== null
          ? ((g = E.tail),
            (E.rendering = g),
            (E.tail = g.sibling),
            (E.renderingStartTime = En()),
            (g.sibling = null),
            (x = Jt.current),
            ot(Jt, V ? (x & 1) | 2 : x & 1),
            Dt && tr(y, E.treeForkCount),
            g)
          : (Wt(y), null);
      case 22:
      case 23:
        return (
          Mn(y),
          Xa(),
          (E = y.memoizedState !== null),
          g !== null
            ? (g.memoizedState !== null) !== E && (y.flags |= 8192)
            : E && (y.flags |= 8192),
          E
            ? (x & 536870912) !== 0 &&
              (y.flags & 128) === 0 &&
              (Wt(y), y.subtreeFlags & 6 && (y.flags |= 8192))
            : Wt(y),
          (x = y.updateQueue),
          x !== null && Ti(y, x.retryQueue),
          (x = null),
          g !== null &&
            g.memoizedState !== null &&
            g.memoizedState.cachePool !== null &&
            (x = g.memoizedState.cachePool.pool),
          (E = null),
          y.memoizedState !== null &&
            y.memoizedState.cachePool !== null &&
            (E = y.memoizedState.cachePool.pool),
          E !== x && (y.flags |= 2048),
          g !== null && Ue(Zr),
          null
        );
      case 24:
        return (
          (x = null),
          g !== null && (x = g.memoizedState.cache),
          y.memoizedState.cache !== x && (y.flags |= 2048),
          rr(en),
          Wt(y),
          null
        );
      case 25:
        return null;
      case 30:
        return null;
    }
    throw Error(_(156, y.tag));
  }
  function $m(g, y) {
    switch ((Pa(y), y.tag)) {
      case 1:
        return (
          (g = y.flags),
          g & 65536 ? ((y.flags = (g & -65537) | 128), y) : null
        );
      case 3:
        return (
          rr(en),
          xt(),
          (g = y.flags),
          (g & 65536) !== 0 && (g & 128) === 0
            ? ((y.flags = (g & -65537) | 128), y)
            : null
        );
      case 26:
      case 27:
      case 5:
        return (Lt(y), null);
      case 31:
        if (y.memoizedState !== null) {
          if ((Mn(y), y.alternate === null)) throw Error(_(340));
          Yr();
        }
        return (
          (g = y.flags),
          g & 65536 ? ((y.flags = (g & -65537) | 128), y) : null
        );
      case 13:
        if (
          (Mn(y), (g = y.memoizedState), g !== null && g.dehydrated !== null)
        ) {
          if (y.alternate === null) throw Error(_(340));
          Yr();
        }
        return (
          (g = y.flags),
          g & 65536 ? ((y.flags = (g & -65537) | 128), y) : null
        );
      case 19:
        return (Ue(Jt), null);
      case 4:
        return (xt(), null);
      case 10:
        return (rr(y.type), null);
      case 22:
      case 23:
        return (
          Mn(y),
          Xa(),
          g !== null && Ue(Zr),
          (g = y.flags),
          g & 65536 ? ((y.flags = (g & -65537) | 128), y) : null
        );
      case 24:
        return (rr(en), null);
      case 25:
        return null;
      default:
        return null;
    }
  }
  function kd(g, y) {
    switch ((Pa(y), y.tag)) {
      case 3:
        (rr(en), xt());
        break;
      case 26:
      case 27:
      case 5:
        Lt(y);
        break;
      case 4:
        xt();
        break;
      case 31:
        y.memoizedState !== null && Mn(y);
        break;
      case 13:
        Mn(y);
        break;
      case 19:
        Ue(Jt);
        break;
      case 10:
        rr(y.type);
        break;
      case 22:
      case 23:
        (Mn(y), Xa(), g !== null && Ue(Zr));
        break;
      case 24:
        rr(en);
    }
  }
  function ws(g, y) {
    try {
      var x = y.updateQueue,
        E = x !== null ? x.lastEffect : null;
      if (E !== null) {
        var V = E.next;
        x = V;
        do {
          if ((x.tag & g) === g) {
            E = void 0;
            var z = x.create,
              ne = x.inst;
            ((E = z()), (ne.destroy = E));
          }
          x = x.next;
        } while (x !== V);
      }
    } catch (je) {
      Ft(y, y.return, je);
    }
  }
  function Cr(g, y, x) {
    try {
      var E = y.updateQueue,
        V = E !== null ? E.lastEffect : null;
      if (V !== null) {
        var z = V.next;
        E = z;
        do {
          if ((E.tag & g) === g) {
            var ne = E.inst,
              je = ne.destroy;
            if (je !== void 0) {
              ((ne.destroy = void 0), (V = y));
              var He = x,
                Je = je;
              try {
                Je();
              } catch (st) {
                Ft(V, He, st);
              }
            }
          }
          E = E.next;
        } while (E !== z);
      }
    } catch (st) {
      Ft(y, y.return, st);
    }
  }
  function Ud(g) {
    var y = g.updateQueue;
    if (y !== null) {
      var x = g.stateNode;
      try {
        Iu(y, x);
      } catch (E) {
        Ft(g, g.return, E);
      }
    }
  }
  function Hd(g, y, x) {
    ((x.props = no(g.type, g.memoizedProps)), (x.state = g.memoizedState));
    try {
      x.componentWillUnmount();
    } catch (E) {
      Ft(g, y, E);
    }
  }
  function xs(g, y) {
    try {
      var x = g.ref;
      if (x !== null) {
        switch (g.tag) {
          case 26:
          case 27:
          case 5:
            var E = g.stateNode;
            break;
          case 30:
            E = g.stateNode;
            break;
          default:
            E = g.stateNode;
        }
        typeof x == "function" ? (g.refCleanup = x(E)) : (x.current = E);
      }
    } catch (V) {
      Ft(g, y, V);
    }
  }
  function Kn(g, y) {
    var x = g.ref,
      E = g.refCleanup;
    if (x !== null)
      if (typeof E == "function")
        try {
          E();
        } catch (V) {
          Ft(g, y, V);
        } finally {
          ((g.refCleanup = null),
            (g = g.alternate),
            g != null && (g.refCleanup = null));
        }
      else if (typeof x == "function")
        try {
          x(null);
        } catch (V) {
          Ft(g, y, V);
        }
      else x.current = null;
  }
  function Gd(g) {
    var y = g.type,
      x = g.memoizedProps,
      E = g.stateNode;
    try {
      e: switch (y) {
        case "button":
        case "input":
        case "select":
        case "textarea":
          x.autoFocus && E.focus();
          break e;
        case "img":
          x.src ? (E.src = x.src) : x.srcSet && (E.srcset = x.srcSet);
      }
    } catch (V) {
      Ft(g, g.return, V);
    }
  }
  function Cl(g, y, x) {
    try {
      var E = g.stateNode;
      (cg(E, g.type, x, y), (E[hn] = y));
    } catch (V) {
      Ft(g, g.return, V);
    }
  }
  function Wd(g) {
    return (
      g.tag === 5 ||
      g.tag === 3 ||
      g.tag === 26 ||
      (g.tag === 27 && Pr(g.type)) ||
      g.tag === 4
    );
  }
  function Ml(g) {
    e: for (;;) {
      for (; g.sibling === null; ) {
        if (g.return === null || Wd(g.return)) return null;
        g = g.return;
      }
      for (
        g.sibling.return = g.return, g = g.sibling;
        g.tag !== 5 && g.tag !== 6 && g.tag !== 18;

      ) {
        if (
          (g.tag === 27 && Pr(g.type)) ||
          g.flags & 2 ||
          g.child === null ||
          g.tag === 4
        )
          continue e;
        ((g.child.return = g), (g = g.child));
      }
      if (!(g.flags & 2)) return g.stateNode;
    }
  }
  function Nl(g, y, x) {
    var E = g.tag;
    if (E === 5 || E === 6)
      ((g = g.stateNode),
        y
          ? (x.nodeType === 9
              ? x.body
              : x.nodeName === "HTML"
                ? x.ownerDocument.body
                : x
            ).insertBefore(g, y)
          : ((y =
              x.nodeType === 9
                ? x.body
                : x.nodeName === "HTML"
                  ? x.ownerDocument.body
                  : x),
            y.appendChild(g),
            (x = x._reactRootContainer),
            x != null || y.onclick !== null || (y.onclick = Jn)));
    else if (
      E !== 4 &&
      (E === 27 && Pr(g.type) && ((x = g.stateNode), (y = null)),
      (g = g.child),
      g !== null)
    )
      for (Nl(g, y, x), g = g.sibling; g !== null; )
        (Nl(g, y, x), (g = g.sibling));
  }
  function Ai(g, y, x) {
    var E = g.tag;
    if (E === 5 || E === 6)
      ((g = g.stateNode), y ? x.insertBefore(g, y) : x.appendChild(g));
    else if (
      E !== 4 &&
      (E === 27 && Pr(g.type) && (x = g.stateNode), (g = g.child), g !== null)
    )
      for (Ai(g, y, x), g = g.sibling; g !== null; )
        (Ai(g, y, x), (g = g.sibling));
  }
  function qd(g) {
    var y = g.stateNode,
      x = g.memoizedProps;
    try {
      for (var E = g.type, V = y.attributes; V.length; )
        y.removeAttributeNode(V[0]);
      (pn(y, E, x), (y[ln] = g), (y[hn] = x));
    } catch (z) {
      Ft(g, g.return, z);
    }
  }
  var lr = !1,
    rn = !1,
    Ol = !1,
    Yd = typeof WeakSet == "function" ? WeakSet : Set,
    an = null;
  function km(g, y) {
    if (((g = g.containerInfo), (Jl = qi), (g = su(g)), Sa(g))) {
      if ("selectionStart" in g)
        var x = { start: g.selectionStart, end: g.selectionEnd };
      else
        e: {
          x = ((x = g.ownerDocument) && x.defaultView) || window;
          var E = x.getSelection && x.getSelection();
          if (E && E.rangeCount !== 0) {
            x = E.anchorNode;
            var V = E.anchorOffset,
              z = E.focusNode;
            E = E.focusOffset;
            try {
              (x.nodeType, z.nodeType);
            } catch {
              x = null;
              break e;
            }
            var ne = 0,
              je = -1,
              He = -1,
              Je = 0,
              st = 0,
              ft = g,
              et = null;
            t: for (;;) {
              for (
                var rt;
                ft !== x || (V !== 0 && ft.nodeType !== 3) || (je = ne + V),
                  ft !== z || (E !== 0 && ft.nodeType !== 3) || (He = ne + E),
                  ft.nodeType === 3 && (ne += ft.nodeValue.length),
                  (rt = ft.firstChild) !== null;

              )
                ((et = ft), (ft = rt));
              for (;;) {
                if (ft === g) break t;
                if (
                  (et === x && ++Je === V && (je = ne),
                  et === z && ++st === E && (He = ne),
                  (rt = ft.nextSibling) !== null)
                )
                  break;
                ((ft = et), (et = ft.parentNode));
              }
              ft = rt;
            }
            x = je === -1 || He === -1 ? null : { start: je, end: He };
          } else x = null;
        }
      x = x || { start: 0, end: 0 };
    } else x = null;
    for (
      Ql = { focusedElem: g, selectionRange: x }, qi = !1, an = y;
      an !== null;

    )
      if (
        ((y = an), (g = y.child), (y.subtreeFlags & 1028) !== 0 && g !== null)
      )
        ((g.return = y), (an = g));
      else
        for (; an !== null; ) {
          switch (((y = an), (z = y.alternate), (g = y.flags), y.tag)) {
            case 0:
              if (
                (g & 4) !== 0 &&
                ((g = y.updateQueue),
                (g = g !== null ? g.events : null),
                g !== null)
              )
                for (x = 0; x < g.length; x++)
                  ((V = g[x]), (V.ref.impl = V.nextImpl));
              break;
            case 11:
            case 15:
              break;
            case 1:
              if ((g & 1024) !== 0 && z !== null) {
                ((g = void 0),
                  (x = y),
                  (V = z.memoizedProps),
                  (z = z.memoizedState),
                  (E = x.stateNode));
                try {
                  var wt = no(x.type, V);
                  ((g = E.getSnapshotBeforeUpdate(wt, z)),
                    (E.__reactInternalSnapshotBeforeUpdate = g));
                } catch (Tt) {
                  Ft(x, x.return, Tt);
                }
              }
              break;
            case 3:
              if ((g & 1024) !== 0) {
                if (
                  ((g = y.stateNode.containerInfo), (x = g.nodeType), x === 9)
                )
                  nc(g);
                else if (x === 1)
                  switch (g.nodeName) {
                    case "HEAD":
                    case "HTML":
                    case "BODY":
                      nc(g);
                      break;
                    default:
                      g.textContent = "";
                  }
              }
              break;
            case 5:
            case 26:
            case 27:
            case 6:
            case 4:
            case 17:
              break;
            default:
              if ((g & 1024) !== 0) throw Error(_(163));
          }
          if (((g = y.sibling), g !== null)) {
            ((g.return = y.return), (an = g));
            break;
          }
          an = y.return;
        }
  }
  function Kd(g, y, x) {
    var E = x.flags;
    switch (x.tag) {
      case 0:
      case 11:
      case 15:
        (dr(g, x), E & 4 && ws(5, x));
        break;
      case 1:
        if ((dr(g, x), E & 4))
          if (((g = x.stateNode), y === null))
            try {
              g.componentDidMount();
            } catch (ne) {
              Ft(x, x.return, ne);
            }
          else {
            var V = no(x.type, y.memoizedProps);
            y = y.memoizedState;
            try {
              g.componentDidUpdate(V, y, g.__reactInternalSnapshotBeforeUpdate);
            } catch (ne) {
              Ft(x, x.return, ne);
            }
          }
        (E & 64 && Ud(x), E & 512 && xs(x, x.return));
        break;
      case 3:
        if ((dr(g, x), E & 64 && ((g = x.updateQueue), g !== null))) {
          if (((y = null), x.child !== null))
            switch (x.child.tag) {
              case 27:
              case 5:
                y = x.child.stateNode;
                break;
              case 1:
                y = x.child.stateNode;
            }
          try {
            Iu(g, y);
          } catch (ne) {
            Ft(x, x.return, ne);
          }
        }
        break;
      case 27:
        y === null && E & 4 && qd(x);
      case 26:
      case 5:
        (dr(g, x), y === null && E & 4 && Gd(x), E & 512 && xs(x, x.return));
        break;
      case 12:
        dr(g, x);
        break;
      case 31:
        (dr(g, x), E & 4 && Jd(g, x));
        break;
      case 13:
        (dr(g, x),
          E & 4 && Qd(g, x),
          E & 64 &&
            ((g = x.memoizedState),
            g !== null &&
              ((g = g.dehydrated),
              g !== null && ((x = Zm.bind(null, x)), _g(g, x)))));
        break;
      case 22:
        if (((E = x.memoizedState !== null || lr), !E)) {
          ((y = (y !== null && y.memoizedState !== null) || rn), (V = lr));
          var z = rn;
          ((lr = E),
            (rn = y) && !z ? fr(g, x, (x.subtreeFlags & 8772) !== 0) : dr(g, x),
            (lr = V),
            (rn = z));
        }
        break;
      case 30:
        break;
      default:
        dr(g, x);
    }
  }
  function Xd(g) {
    var y = g.alternate;
    (y !== null && ((g.alternate = null), Xd(y)),
      (g.child = null),
      (g.deletions = null),
      (g.sibling = null),
      g.tag === 5 && ((y = g.stateNode), y !== null && aa(y)),
      (g.stateNode = null),
      (g.return = null),
      (g.dependencies = null),
      (g.memoizedProps = null),
      (g.memoizedState = null),
      (g.pendingProps = null),
      (g.stateNode = null),
      (g.updateQueue = null));
  }
  var qt = null,
    yn = !1;
  function ur(g, y, x) {
    for (x = x.child; x !== null; ) (Zd(g, y, x), (x = x.sibling));
  }
  function Zd(g, y, x) {
    if (Sn && typeof Sn.onCommitFiberUnmount == "function")
      try {
        Sn.onCommitFiberUnmount(Go, x);
      } catch {}
    switch (x.tag) {
      case 26:
        (rn || Kn(x, y),
          ur(g, y, x),
          x.memoizedState
            ? x.memoizedState.count--
            : x.stateNode && ((x = x.stateNode), x.parentNode.removeChild(x)));
        break;
      case 27:
        rn || Kn(x, y);
        var E = qt,
          V = yn;
        (Pr(x.type) && ((qt = x.stateNode), (yn = !1)),
          ur(g, y, x),
          Ns(x.stateNode),
          (qt = E),
          (yn = V));
        break;
      case 5:
        rn || Kn(x, y);
      case 6:
        if (
          ((E = qt),
          (V = yn),
          (qt = null),
          ur(g, y, x),
          (qt = E),
          (yn = V),
          qt !== null)
        )
          if (yn)
            try {
              (qt.nodeType === 9
                ? qt.body
                : qt.nodeName === "HTML"
                  ? qt.ownerDocument.body
                  : qt
              ).removeChild(x.stateNode);
            } catch (z) {
              Ft(x, y, z);
            }
          else
            try {
              qt.removeChild(x.stateNode);
            } catch (z) {
              Ft(x, y, z);
            }
        break;
      case 18:
        qt !== null &&
          (yn
            ? ((g = qt),
              Hf(
                g.nodeType === 9
                  ? g.body
                  : g.nodeName === "HTML"
                    ? g.ownerDocument.body
                    : g,
                x.stateNode,
              ),
              Uo(g))
            : Hf(qt, x.stateNode));
        break;
      case 4:
        ((E = qt),
          (V = yn),
          (qt = x.stateNode.containerInfo),
          (yn = !0),
          ur(g, y, x),
          (qt = E),
          (yn = V));
        break;
      case 0:
      case 11:
      case 14:
      case 15:
        (Cr(2, x, y), rn || Cr(4, x, y), ur(g, y, x));
        break;
      case 1:
        (rn ||
          (Kn(x, y),
          (E = x.stateNode),
          typeof E.componentWillUnmount == "function" && Hd(x, y, E)),
          ur(g, y, x));
        break;
      case 21:
        ur(g, y, x);
        break;
      case 22:
        ((rn = (E = rn) || x.memoizedState !== null), ur(g, y, x), (rn = E));
        break;
      default:
        ur(g, y, x);
    }
  }
  function Jd(g, y) {
    if (
      y.memoizedState === null &&
      ((g = y.alternate), g !== null && ((g = g.memoizedState), g !== null))
    ) {
      g = g.dehydrated;
      try {
        Uo(g);
      } catch (x) {
        Ft(y, y.return, x);
      }
    }
  }
  function Qd(g, y) {
    if (
      y.memoizedState === null &&
      ((g = y.alternate),
      g !== null &&
        ((g = g.memoizedState), g !== null && ((g = g.dehydrated), g !== null)))
    )
      try {
        Uo(g);
      } catch (x) {
        Ft(y, y.return, x);
      }
  }
  function Um(g) {
    switch (g.tag) {
      case 31:
      case 13:
      case 19:
        var y = g.stateNode;
        return (y === null && (y = g.stateNode = new Yd()), y);
      case 22:
        return (
          (g = g.stateNode),
          (y = g._retryCache),
          y === null && (y = g._retryCache = new Yd()),
          y
        );
      default:
        throw Error(_(435, g.tag));
    }
  }
  function Ri(g, y) {
    var x = Um(g);
    y.forEach(function (E) {
      if (!x.has(E)) {
        x.add(E);
        var V = Jm.bind(null, g, E);
        E.then(V, V);
      }
    });
  }
  function bn(g, y) {
    var x = y.deletions;
    if (x !== null)
      for (var E = 0; E < x.length; E++) {
        var V = x[E],
          z = g,
          ne = y,
          je = ne;
        e: for (; je !== null; ) {
          switch (je.tag) {
            case 27:
              if (Pr(je.type)) {
                ((qt = je.stateNode), (yn = !1));
                break e;
              }
              break;
            case 5:
              ((qt = je.stateNode), (yn = !1));
              break e;
            case 3:
            case 4:
              ((qt = je.stateNode.containerInfo), (yn = !0));
              break e;
          }
          je = je.return;
        }
        if (qt === null) throw Error(_(160));
        (Zd(z, ne, V),
          (qt = null),
          (yn = !1),
          (z = V.alternate),
          z !== null && (z.return = null),
          (V.return = null));
      }
    if (y.subtreeFlags & 13886)
      for (y = y.child; y !== null; ) (ef(y, g), (y = y.sibling));
  }
  var Hn = null;
  function ef(g, y) {
    var x = g.alternate,
      E = g.flags;
    switch (g.tag) {
      case 0:
      case 11:
      case 14:
      case 15:
        (bn(y, g),
          wn(g),
          E & 4 && (Cr(3, g, g.return), ws(3, g), Cr(5, g, g.return)));
        break;
      case 1:
        (bn(y, g),
          wn(g),
          E & 512 && (rn || x === null || Kn(x, x.return)),
          E & 64 &&
            lr &&
            ((g = g.updateQueue),
            g !== null &&
              ((E = g.callbacks),
              E !== null &&
                ((x = g.shared.hiddenCallbacks),
                (g.shared.hiddenCallbacks = x === null ? E : x.concat(E))))));
        break;
      case 26:
        var V = Hn;
        if (
          (bn(y, g),
          wn(g),
          E & 512 && (rn || x === null || Kn(x, x.return)),
          E & 4)
        ) {
          var z = x !== null ? x.memoizedState : null;
          if (((E = g.memoizedState), x === null))
            if (E === null)
              if (g.stateNode === null) {
                e: {
                  ((E = g.type),
                    (x = g.memoizedProps),
                    (V = V.ownerDocument || V));
                  t: switch (E) {
                    case "title":
                      ((z = V.getElementsByTagName("title")[0]),
                        (!z ||
                          z[Yo] ||
                          z[ln] ||
                          z.namespaceURI === "http://www.w3.org/2000/svg" ||
                          z.hasAttribute("itemprop")) &&
                          ((z = V.createElement(E)),
                          V.head.insertBefore(
                            z,
                            V.querySelector("head > title"),
                          )),
                        pn(z, E, x),
                        (z[ln] = g),
                        sn(z),
                        (E = z));
                      break e;
                    case "link":
                      var ne = tp("link", "href", V).get(E + (x.href || ""));
                      if (ne) {
                        for (var je = 0; je < ne.length; je++)
                          if (
                            ((z = ne[je]),
                            z.getAttribute("href") ===
                              (x.href == null || x.href === ""
                                ? null
                                : x.href) &&
                              z.getAttribute("rel") ===
                                (x.rel == null ? null : x.rel) &&
                              z.getAttribute("title") ===
                                (x.title == null ? null : x.title) &&
                              z.getAttribute("crossorigin") ===
                                (x.crossOrigin == null ? null : x.crossOrigin))
                          ) {
                            ne.splice(je, 1);
                            break t;
                          }
                      }
                      ((z = V.createElement(E)),
                        pn(z, E, x),
                        V.head.appendChild(z));
                      break;
                    case "meta":
                      if (
                        (ne = tp("meta", "content", V).get(
                          E + (x.content || ""),
                        ))
                      ) {
                        for (je = 0; je < ne.length; je++)
                          if (
                            ((z = ne[je]),
                            z.getAttribute("content") ===
                              (x.content == null ? null : "" + x.content) &&
                              z.getAttribute("name") ===
                                (x.name == null ? null : x.name) &&
                              z.getAttribute("property") ===
                                (x.property == null ? null : x.property) &&
                              z.getAttribute("http-equiv") ===
                                (x.httpEquiv == null ? null : x.httpEquiv) &&
                              z.getAttribute("charset") ===
                                (x.charSet == null ? null : x.charSet))
                          ) {
                            ne.splice(je, 1);
                            break t;
                          }
                      }
                      ((z = V.createElement(E)),
                        pn(z, E, x),
                        V.head.appendChild(z));
                      break;
                    default:
                      throw Error(_(468, E));
                  }
                  ((z[ln] = g), sn(z), (E = z));
                }
                g.stateNode = E;
              } else np(V, g.type, g.stateNode);
            else g.stateNode = ep(V, E, g.memoizedProps);
          else
            z !== E
              ? (z === null
                  ? x.stateNode !== null &&
                    ((x = x.stateNode), x.parentNode.removeChild(x))
                  : z.count--,
                E === null
                  ? np(V, g.type, g.stateNode)
                  : ep(V, E, g.memoizedProps))
              : E === null &&
                g.stateNode !== null &&
                Cl(g, g.memoizedProps, x.memoizedProps);
        }
        break;
      case 27:
        (bn(y, g),
          wn(g),
          E & 512 && (rn || x === null || Kn(x, x.return)),
          x !== null && E & 4 && Cl(g, g.memoizedProps, x.memoizedProps));
        break;
      case 5:
        if (
          (bn(y, g),
          wn(g),
          E & 512 && (rn || x === null || Kn(x, x.return)),
          g.flags & 32)
        ) {
          V = g.stateNode;
          try {
            fo(V, "");
          } catch (wt) {
            Ft(g, g.return, wt);
          }
        }
        (E & 4 &&
          g.stateNode != null &&
          ((V = g.memoizedProps), Cl(g, V, x !== null ? x.memoizedProps : V)),
          E & 1024 && (Ol = !0));
        break;
      case 6:
        if ((bn(y, g), wn(g), E & 4)) {
          if (g.stateNode === null) throw Error(_(162));
          ((E = g.memoizedProps), (x = g.stateNode));
          try {
            x.nodeValue = E;
          } catch (wt) {
            Ft(g, g.return, wt);
          }
        }
        break;
      case 3:
        if (
          ((Ui = null),
          (V = Hn),
          (Hn = $i(y.containerInfo)),
          bn(y, g),
          (Hn = V),
          wn(g),
          E & 4 && x !== null && x.memoizedState.isDehydrated)
        )
          try {
            Uo(y.containerInfo);
          } catch (wt) {
            Ft(g, g.return, wt);
          }
        Ol && ((Ol = !1), tf(g));
        break;
      case 4:
        ((E = Hn),
          (Hn = $i(g.stateNode.containerInfo)),
          bn(y, g),
          wn(g),
          (Hn = E));
        break;
      case 12:
        (bn(y, g), wn(g));
        break;
      case 31:
        (bn(y, g),
          wn(g),
          E & 4 &&
            ((E = g.updateQueue),
            E !== null && ((g.updateQueue = null), Ri(g, E))));
        break;
      case 13:
        (bn(y, g),
          wn(g),
          g.child.flags & 8192 &&
            (g.memoizedState !== null) !=
              (x !== null && x.memoizedState !== null) &&
            (Mi = En()),
          E & 4 &&
            ((E = g.updateQueue),
            E !== null && ((g.updateQueue = null), Ri(g, E))));
        break;
      case 22:
        V = g.memoizedState !== null;
        var He = x !== null && x.memoizedState !== null,
          Je = lr,
          st = rn;
        if (
          ((lr = Je || V),
          (rn = st || He),
          bn(y, g),
          (rn = st),
          (lr = Je),
          wn(g),
          E & 8192)
        )
          e: for (
            y = g.stateNode,
              y._visibility = V ? y._visibility & -2 : y._visibility | 1,
              V && (x === null || He || lr || rn || ro(g)),
              x = null,
              y = g;
            ;

          ) {
            if (y.tag === 5 || y.tag === 26) {
              if (x === null) {
                He = x = y;
                try {
                  if (((z = He.stateNode), V))
                    ((ne = z.style),
                      typeof ne.setProperty == "function"
                        ? ne.setProperty("display", "none", "important")
                        : (ne.display = "none"));
                  else {
                    je = He.stateNode;
                    var ft = He.memoizedProps.style,
                      et =
                        ft != null && ft.hasOwnProperty("display")
                          ? ft.display
                          : null;
                    je.style.display =
                      et == null || typeof et == "boolean"
                        ? ""
                        : ("" + et).trim();
                  }
                } catch (wt) {
                  Ft(He, He.return, wt);
                }
              }
            } else if (y.tag === 6) {
              if (x === null) {
                He = y;
                try {
                  He.stateNode.nodeValue = V ? "" : He.memoizedProps;
                } catch (wt) {
                  Ft(He, He.return, wt);
                }
              }
            } else if (y.tag === 18) {
              if (x === null) {
                He = y;
                try {
                  var rt = He.stateNode;
                  V ? Gf(rt, !0) : Gf(He.stateNode, !1);
                } catch (wt) {
                  Ft(He, He.return, wt);
                }
              }
            } else if (
              ((y.tag !== 22 && y.tag !== 23) ||
                y.memoizedState === null ||
                y === g) &&
              y.child !== null
            ) {
              ((y.child.return = y), (y = y.child));
              continue;
            }
            if (y === g) break e;
            for (; y.sibling === null; ) {
              if (y.return === null || y.return === g) break e;
              (x === y && (x = null), (y = y.return));
            }
            (x === y && (x = null),
              (y.sibling.return = y.return),
              (y = y.sibling));
          }
        E & 4 &&
          ((E = g.updateQueue),
          E !== null &&
            ((x = E.retryQueue),
            x !== null && ((E.retryQueue = null), Ri(g, x))));
        break;
      case 19:
        (bn(y, g),
          wn(g),
          E & 4 &&
            ((E = g.updateQueue),
            E !== null && ((g.updateQueue = null), Ri(g, E))));
        break;
      case 30:
        break;
      case 21:
        break;
      default:
        (bn(y, g), wn(g));
    }
  }
  function wn(g) {
    var y = g.flags;
    if (y & 2) {
      try {
        for (var x, E = g.return; E !== null; ) {
          if (Wd(E)) {
            x = E;
            break;
          }
          E = E.return;
        }
        if (x == null) throw Error(_(160));
        switch (x.tag) {
          case 27:
            var V = x.stateNode,
              z = Ml(g);
            Ai(g, z, V);
            break;
          case 5:
            var ne = x.stateNode;
            x.flags & 32 && (fo(ne, ""), (x.flags &= -33));
            var je = Ml(g);
            Ai(g, je, ne);
            break;
          case 3:
          case 4:
            var He = x.stateNode.containerInfo,
              Je = Ml(g);
            Nl(g, Je, He);
            break;
          default:
            throw Error(_(161));
        }
      } catch (st) {
        Ft(g, g.return, st);
      }
      g.flags &= -3;
    }
    y & 4096 && (g.flags &= -4097);
  }
  function tf(g) {
    if (g.subtreeFlags & 1024)
      for (g = g.child; g !== null; ) {
        var y = g;
        (tf(y),
          y.tag === 5 && y.flags & 1024 && y.stateNode.reset(),
          (g = g.sibling));
      }
  }
  function dr(g, y) {
    if (y.subtreeFlags & 8772)
      for (y = y.child; y !== null; ) (Kd(g, y.alternate, y), (y = y.sibling));
  }
  function ro(g) {
    for (g = g.child; g !== null; ) {
      var y = g;
      switch (y.tag) {
        case 0:
        case 11:
        case 14:
        case 15:
          (Cr(4, y, y.return), ro(y));
          break;
        case 1:
          Kn(y, y.return);
          var x = y.stateNode;
          (typeof x.componentWillUnmount == "function" && Hd(y, y.return, x),
            ro(y));
          break;
        case 27:
          Ns(y.stateNode);
        case 26:
        case 5:
          (Kn(y, y.return), ro(y));
          break;
        case 22:
          y.memoizedState === null && ro(y);
          break;
        case 30:
          ro(y);
          break;
        default:
          ro(y);
      }
      g = g.sibling;
    }
  }
  function fr(g, y, x) {
    for (x = x && (y.subtreeFlags & 8772) !== 0, y = y.child; y !== null; ) {
      var E = y.alternate,
        V = g,
        z = y,
        ne = z.flags;
      switch (z.tag) {
        case 0:
        case 11:
        case 15:
          (fr(V, z, x), ws(4, z));
          break;
        case 1:
          if (
            (fr(V, z, x),
            (E = z),
            (V = E.stateNode),
            typeof V.componentDidMount == "function")
          )
            try {
              V.componentDidMount();
            } catch (Je) {
              Ft(E, E.return, Je);
            }
          if (((E = z), (V = E.updateQueue), V !== null)) {
            var je = E.stateNode;
            try {
              var He = V.shared.hiddenCallbacks;
              if (He !== null)
                for (V.shared.hiddenCallbacks = null, V = 0; V < He.length; V++)
                  Ou(He[V], je);
            } catch (Je) {
              Ft(E, E.return, Je);
            }
          }
          (x && ne & 64 && Ud(z), xs(z, z.return));
          break;
        case 27:
          qd(z);
        case 26:
        case 5:
          (fr(V, z, x), x && E === null && ne & 4 && Gd(z), xs(z, z.return));
          break;
        case 12:
          fr(V, z, x);
          break;
        case 31:
          (fr(V, z, x), x && ne & 4 && Jd(V, z));
          break;
        case 13:
          (fr(V, z, x), x && ne & 4 && Qd(V, z));
          break;
        case 22:
          (z.memoizedState === null && fr(V, z, x), xs(z, z.return));
          break;
        case 30:
          break;
        default:
          fr(V, z, x);
      }
      y = y.sibling;
    }
  }
  function Il(g, y) {
    var x = null;
    (g !== null &&
      g.memoizedState !== null &&
      g.memoizedState.cachePool !== null &&
      (x = g.memoizedState.cachePool.pool),
      (g = null),
      y.memoizedState !== null &&
        y.memoizedState.cachePool !== null &&
        (g = y.memoizedState.cachePool.pool),
      g !== x && (g != null && g.refCount++, x != null && as(x)));
  }
  function Dl(g, y) {
    ((g = null),
      y.alternate !== null && (g = y.alternate.memoizedState.cache),
      (y = y.memoizedState.cache),
      y !== g && (y.refCount++, g != null && as(g)));
  }
  function Gn(g, y, x, E) {
    if (y.subtreeFlags & 10256)
      for (y = y.child; y !== null; ) (nf(g, y, x, E), (y = y.sibling));
  }
  function nf(g, y, x, E) {
    var V = y.flags;
    switch (y.tag) {
      case 0:
      case 11:
      case 15:
        (Gn(g, y, x, E), V & 2048 && ws(9, y));
        break;
      case 1:
        Gn(g, y, x, E);
        break;
      case 3:
        (Gn(g, y, x, E),
          V & 2048 &&
            ((g = null),
            y.alternate !== null && (g = y.alternate.memoizedState.cache),
            (y = y.memoizedState.cache),
            y !== g && (y.refCount++, g != null && as(g))));
        break;
      case 12:
        if (V & 2048) {
          (Gn(g, y, x, E), (g = y.stateNode));
          try {
            var z = y.memoizedProps,
              ne = z.id,
              je = z.onPostCommit;
            typeof je == "function" &&
              je(
                ne,
                y.alternate === null ? "mount" : "update",
                g.passiveEffectDuration,
                -0,
              );
          } catch (He) {
            Ft(y, y.return, He);
          }
        } else Gn(g, y, x, E);
        break;
      case 31:
        Gn(g, y, x, E);
        break;
      case 13:
        Gn(g, y, x, E);
        break;
      case 23:
        break;
      case 22:
        ((z = y.stateNode),
          (ne = y.alternate),
          y.memoizedState !== null
            ? z._visibility & 2
              ? Gn(g, y, x, E)
              : vs(g, y)
            : z._visibility & 2
              ? Gn(g, y, x, E)
              : ((z._visibility |= 2),
                Io(g, y, x, E, (y.subtreeFlags & 10256) !== 0 || !1)),
          V & 2048 && Il(ne, y));
        break;
      case 24:
        (Gn(g, y, x, E), V & 2048 && Dl(y.alternate, y));
        break;
      default:
        Gn(g, y, x, E);
    }
  }
  function Io(g, y, x, E, V) {
    for (
      V = V && ((y.subtreeFlags & 10256) !== 0 || !1), y = y.child;
      y !== null;

    ) {
      var z = g,
        ne = y,
        je = x,
        He = E,
        Je = ne.flags;
      switch (ne.tag) {
        case 0:
        case 11:
        case 15:
          (Io(z, ne, je, He, V), ws(8, ne));
          break;
        case 23:
          break;
        case 22:
          var st = ne.stateNode;
          (ne.memoizedState !== null
            ? st._visibility & 2
              ? Io(z, ne, je, He, V)
              : vs(z, ne)
            : ((st._visibility |= 2), Io(z, ne, je, He, V)),
            V && Je & 2048 && Il(ne.alternate, ne));
          break;
        case 24:
          (Io(z, ne, je, He, V), V && Je & 2048 && Dl(ne.alternate, ne));
          break;
        default:
          Io(z, ne, je, He, V);
      }
      y = y.sibling;
    }
  }
  function vs(g, y) {
    if (y.subtreeFlags & 10256)
      for (y = y.child; y !== null; ) {
        var x = g,
          E = y,
          V = E.flags;
        switch (E.tag) {
          case 22:
            (vs(x, E), V & 2048 && Il(E.alternate, E));
            break;
          case 24:
            (vs(x, E), V & 2048 && Dl(E.alternate, E));
            break;
          default:
            vs(x, E);
        }
        y = y.sibling;
      }
  }
  var Es = 8192;
  function Do(g, y, x) {
    if (g.subtreeFlags & Es)
      for (g = g.child; g !== null; ) (rf(g, y, x), (g = g.sibling));
  }
  function rf(g, y, x) {
    switch (g.tag) {
      case 26:
        (Do(g, y, x),
          g.flags & Es &&
            g.memoizedState !== null &&
            Mg(x, Hn, g.memoizedState, g.memoizedProps));
        break;
      case 5:
        Do(g, y, x);
        break;
      case 3:
      case 4:
        var E = Hn;
        ((Hn = $i(g.stateNode.containerInfo)), Do(g, y, x), (Hn = E));
        break;
      case 22:
        g.memoizedState === null &&
          ((E = g.alternate),
          E !== null && E.memoizedState !== null
            ? ((E = Es), (Es = 16777216), Do(g, y, x), (Es = E))
            : Do(g, y, x));
        break;
      default:
        Do(g, y, x);
    }
  }
  function of(g) {
    var y = g.alternate;
    if (y !== null && ((g = y.child), g !== null)) {
      y.child = null;
      do ((y = g.sibling), (g.sibling = null), (g = y));
      while (g !== null);
    }
  }
  function Ss(g) {
    var y = g.deletions;
    if ((g.flags & 16) !== 0) {
      if (y !== null)
        for (var x = 0; x < y.length; x++) {
          var E = y[x];
          ((an = E), af(E, g));
        }
      of(g);
    }
    if (g.subtreeFlags & 10256)
      for (g = g.child; g !== null; ) (sf(g), (g = g.sibling));
  }
  function sf(g) {
    switch (g.tag) {
      case 0:
      case 11:
      case 15:
        (Ss(g), g.flags & 2048 && Cr(9, g, g.return));
        break;
      case 3:
        Ss(g);
        break;
      case 12:
        Ss(g);
        break;
      case 22:
        var y = g.stateNode;
        g.memoizedState !== null &&
        y._visibility & 2 &&
        (g.return === null || g.return.tag !== 13)
          ? ((y._visibility &= -3), Ci(g))
          : Ss(g);
        break;
      default:
        Ss(g);
    }
  }
  function Ci(g) {
    var y = g.deletions;
    if ((g.flags & 16) !== 0) {
      if (y !== null)
        for (var x = 0; x < y.length; x++) {
          var E = y[x];
          ((an = E), af(E, g));
        }
      of(g);
    }
    for (g = g.child; g !== null; ) {
      switch (((y = g), y.tag)) {
        case 0:
        case 11:
        case 15:
          (Cr(8, y, y.return), Ci(y));
          break;
        case 22:
          ((x = y.stateNode),
            x._visibility & 2 && ((x._visibility &= -3), Ci(y)));
          break;
        default:
          Ci(y);
      }
      g = g.sibling;
    }
  }
  function af(g, y) {
    for (; an !== null; ) {
      var x = an;
      switch (x.tag) {
        case 0:
        case 11:
        case 15:
          Cr(8, x, y);
          break;
        case 23:
        case 22:
          if (x.memoizedState !== null && x.memoizedState.cachePool !== null) {
            var E = x.memoizedState.cachePool.pool;
            E != null && E.refCount++;
          }
          break;
        case 24:
          as(x.memoizedState.cache);
      }
      if (((E = x.child), E !== null)) ((E.return = x), (an = E));
      else
        e: for (x = g; an !== null; ) {
          E = an;
          var V = E.sibling,
            z = E.return;
          if ((Xd(E), E === x)) {
            an = null;
            break e;
          }
          if (V !== null) {
            ((V.return = z), (an = V));
            break e;
          }
          an = z;
        }
    }
  }
  var Hm = {
      getCacheForType: function (g) {
        var y = dn(en),
          x = y.data.get(g);
        return (x === void 0 && ((x = g()), y.data.set(g, x)), x);
      },
      cacheSignal: function () {
        return dn(en).controller.signal;
      },
    },
    Gm = typeof WeakMap == "function" ? WeakMap : Map,
    Bt = 0,
    Ht = null,
    Mt = null,
    Ot = 0,
    zt = 0,
    Nn = null,
    Mr = !1,
    Lo = !1,
    Ll = !1,
    pr = 0,
    Xt = 0,
    Nr = 0,
    oo = 0,
    Pl = 0,
    On = 0,
    Po = 0,
    Ts = null,
    xn = null,
    jl = !1,
    Mi = 0,
    lf = 0,
    Ni = 1 / 0,
    Oi = null,
    Or = null,
    on = 0,
    Ir = null,
    jo = null,
    mr = 0,
    Bl = 0,
    Vl = null,
    cf = null,
    As = 0,
    zl = null;
  function In() {
    return (Bt & 2) !== 0 && Ot !== 0 ? Ot & -Ot : $e.T !== null ? Gl() : Ec();
  }
  function uf() {
    if (On === 0)
      if ((Ot & 536870912) === 0 || Dt) {
        var g = zs;
        ((zs <<= 1), (zs & 3932160) === 0 && (zs = 262144), (On = g));
      } else On = 536870912;
    return ((g = Cn.current), g !== null && (g.flags |= 32), On);
  }
  function vn(g, y, x) {
    (((g === Ht && (zt === 2 || zt === 9)) || g.cancelPendingCommit !== null) &&
      (Bo(g, 0), Dr(g, Ot, On, !1)),
      qo(g, x),
      ((Bt & 2) === 0 || g !== Ht) &&
        (g === Ht &&
          ((Bt & 2) === 0 && (oo |= x), Xt === 4 && Dr(g, Ot, On, !1)),
        Xn(g)));
  }
  function df(g, y, x) {
    if ((Bt & 6) !== 0) throw Error(_(327));
    var E = (!x && (y & 127) === 0 && (y & g.expiredLanes) === 0) || Wo(g, y),
      V = E ? Ym(g, y) : $l(g, y, !0),
      z = E;
    do {
      if (V === 0) {
        Lo && !E && Dr(g, y, 0, !1);
        break;
      } else {
        if (((x = g.current.alternate), z && !Wm(x))) {
          ((V = $l(g, y, !1)), (z = !1));
          continue;
        }
        if (V === 2) {
          if (((z = y), g.errorRecoveryDisabledLanes & z)) var ne = 0;
          else
            ((ne = g.pendingLanes & -536870913),
              (ne = ne !== 0 ? ne : ne & 536870912 ? 536870912 : 0));
          if (ne !== 0) {
            y = ne;
            e: {
              var je = g;
              V = Ts;
              var He = je.current.memoizedState.isDehydrated;
              if (
                (He && (Bo(je, ne).flags |= 256),
                (ne = $l(je, ne, !1)),
                ne !== 2)
              ) {
                if (Ll && !He) {
                  ((je.errorRecoveryDisabledLanes |= z), (oo |= z), (V = 4));
                  break e;
                }
                ((z = xn),
                  (xn = V),
                  z !== null &&
                    (xn === null ? (xn = z) : xn.push.apply(xn, z)));
              }
              V = ne;
            }
            if (((z = !1), V !== 2)) continue;
          }
        }
        if (V === 1) {
          (Bo(g, 0), Dr(g, y, 0, !0));
          break;
        }
        e: {
          switch (((E = g), (z = V), z)) {
            case 0:
            case 1:
              throw Error(_(345));
            case 4:
              if ((y & 4194048) !== y) break;
            case 6:
              Dr(E, y, On, !Mr);
              break e;
            case 2:
              xn = null;
              break;
            case 3:
            case 5:
              break;
            default:
              throw Error(_(329));
          }
          if ((y & 62914560) === y && ((V = Mi + 300 - En()), 10 < V)) {
            if ((Dr(E, y, On, !Mr), $s(E, 0, !0) !== 0)) break e;
            ((mr = y),
              (E.timeoutHandle = kf(
                ff.bind(
                  null,
                  E,
                  x,
                  xn,
                  Oi,
                  jl,
                  y,
                  On,
                  oo,
                  Po,
                  Mr,
                  z,
                  "Throttled",
                  -0,
                  0,
                ),
                V,
              )));
            break e;
          }
          ff(E, x, xn, Oi, jl, y, On, oo, Po, Mr, z, null, -0, 0);
        }
      }
      break;
    } while (!0);
    Xn(g);
  }
  function ff(g, y, x, E, V, z, ne, je, He, Je, st, ft, et, rt) {
    if (
      ((g.timeoutHandle = -1),
      (ft = y.subtreeFlags),
      ft & 8192 || (ft & 16785408) === 16785408)
    ) {
      ((ft = {
        stylesheets: null,
        count: 0,
        imgCount: 0,
        imgBytes: 0,
        suspenseyImages: [],
        waitingForImages: !0,
        waitingForViewTransition: !1,
        unsuspend: Jn,
      }),
        rf(y, z, ft));
      var wt =
        (z & 62914560) === z ? Mi - En() : (z & 4194048) === z ? lf - En() : 0;
      if (((wt = Ng(ft, wt)), wt !== null)) {
        ((mr = z),
          (g.cancelPendingCommit = wt(
            wf.bind(null, g, y, z, x, E, V, ne, je, He, st, ft, null, et, rt),
          )),
          Dr(g, z, ne, !Je));
        return;
      }
    }
    wf(g, y, z, x, E, V, ne, je, He);
  }
  function Wm(g) {
    for (var y = g; ; ) {
      var x = y.tag;
      if (
        (x === 0 || x === 11 || x === 15) &&
        y.flags & 16384 &&
        ((x = y.updateQueue), x !== null && ((x = x.stores), x !== null))
      )
        for (var E = 0; E < x.length; E++) {
          var V = x[E],
            z = V.getSnapshot;
          V = V.value;
          try {
            if (!An(z(), V)) return !1;
          } catch {
            return !1;
          }
        }
      if (((x = y.child), y.subtreeFlags & 16384 && x !== null))
        ((x.return = y), (y = x));
      else {
        if (y === g) break;
        for (; y.sibling === null; ) {
          if (y.return === null || y.return === g) return !0;
          y = y.return;
        }
        ((y.sibling.return = y.return), (y = y.sibling));
      }
    }
    return !0;
  }
  function Dr(g, y, x, E) {
    ((y &= ~Pl),
      (y &= ~oo),
      (g.suspendedLanes |= y),
      (g.pingedLanes &= ~y),
      E && (g.warmLanes |= y),
      (E = g.expirationTimes));
    for (var V = y; 0 < V; ) {
      var z = 31 - Tn(V),
        ne = 1 << z;
      ((E[z] = -1), (V &= ~ne));
    }
    x !== 0 && wc(g, x, y);
  }
  function Ii() {
    return (Bt & 6) === 0 ? (Rs(0), !1) : !0;
  }
  function Fl() {
    if (Mt !== null) {
      if (zt === 0) var g = Mt.return;
      else ((g = Mt), (nr = Kr = null), nl(g), (Ro = null), (cs = 0), (g = Mt));
      for (; g !== null; ) (kd(g.alternate, g), (g = g.return));
      Mt = null;
    }
  }
  function Bo(g, y) {
    var x = g.timeoutHandle;
    (x !== -1 && ((g.timeoutHandle = -1), fg(x)),
      (x = g.cancelPendingCommit),
      x !== null && ((g.cancelPendingCommit = null), x()),
      (mr = 0),
      Fl(),
      (Ht = g),
      (Mt = x = er(g.current, null)),
      (Ot = y),
      (zt = 0),
      (Nn = null),
      (Mr = !1),
      (Lo = Wo(g, y)),
      (Ll = !1),
      (Po = On = Pl = oo = Nr = Xt = 0),
      (xn = Ts = null),
      (jl = !1),
      (y & 8) !== 0 && (y |= y & 32));
    var E = g.entangledLanes;
    if (E !== 0)
      for (g = g.entanglements, E &= y; 0 < E; ) {
        var V = 31 - Tn(E),
          z = 1 << V;
        ((y |= g[V]), (E &= ~z));
      }
    return ((pr = y), Qs(), x);
  }
  function pf(g, y) {
    ((Rt = null),
      ($e.H = _s),
      y === Ao || y === ai
        ? ((y = Ru()), (zt = 3))
        : y === Ha
          ? ((y = Ru()), (zt = 4))
          : (zt =
              y === yl
                ? 8
                : y !== null &&
                    typeof y == "object" &&
                    typeof y.then == "function"
                  ? 6
                  : 1),
      (Nn = y),
      Mt === null && ((Xt = 1), xi(g, jn(y, g.current))));
  }
  function mf() {
    var g = Cn.current;
    return g === null
      ? !0
      : (Ot & 4194048) === Ot
        ? Fn === null
        : (Ot & 62914560) === Ot || (Ot & 536870912) !== 0
          ? g === Fn
          : !1;
  }
  function gf() {
    var g = $e.H;
    return (($e.H = _s), g === null ? _s : g);
  }
  function hf() {
    var g = $e.A;
    return (($e.A = Hm), g);
  }
  function Di() {
    ((Xt = 4),
      Mr || ((Ot & 4194048) !== Ot && Cn.current !== null) || (Lo = !0),
      ((Nr & 134217727) === 0 && (oo & 134217727) === 0) ||
        Ht === null ||
        Dr(Ht, Ot, On, !1));
  }
  function $l(g, y, x) {
    var E = Bt;
    Bt |= 2;
    var V = gf(),
      z = hf();
    ((Ht !== g || Ot !== y) && ((Oi = null), Bo(g, y)), (y = !1));
    var ne = Xt;
    e: do
      try {
        if (zt !== 0 && Mt !== null) {
          var je = Mt,
            He = Nn;
          switch (zt) {
            case 8:
              (Fl(), (ne = 6));
              break e;
            case 3:
            case 2:
            case 9:
            case 6:
              Cn.current === null && (y = !0);
              var Je = zt;
              if (((zt = 0), (Nn = null), Vo(g, je, He, Je), x && Lo)) {
                ne = 0;
                break e;
              }
              break;
            default:
              ((Je = zt), (zt = 0), (Nn = null), Vo(g, je, He, Je));
          }
        }
        (qm(), (ne = Xt));
        break;
      } catch (st) {
        pf(g, st);
      }
    while (!0);
    return (
      y && g.shellSuspendCounter++,
      (nr = Kr = null),
      (Bt = E),
      ($e.H = V),
      ($e.A = z),
      Mt === null && ((Ht = null), (Ot = 0), Qs()),
      ne
    );
  }
  function qm() {
    for (; Mt !== null; ) _f(Mt);
  }
  function Ym(g, y) {
    var x = Bt;
    Bt |= 2;
    var E = gf(),
      V = hf();
    Ht !== g || Ot !== y
      ? ((Oi = null), (Ni = En() + 500), Bo(g, y))
      : (Lo = Wo(g, y));
    e: do
      try {
        if (zt !== 0 && Mt !== null) {
          y = Mt;
          var z = Nn;
          t: switch (zt) {
            case 1:
              ((zt = 0), (Nn = null), Vo(g, y, z, 1));
              break;
            case 2:
            case 9:
              if (Tu(z)) {
                ((zt = 0), (Nn = null), yf(y));
                break;
              }
              ((y = function () {
                ((zt !== 2 && zt !== 9) || Ht !== g || (zt = 7), Xn(g));
              }),
                z.then(y, y));
              break e;
            case 3:
              zt = 7;
              break e;
            case 4:
              zt = 5;
              break e;
            case 7:
              Tu(z)
                ? ((zt = 0), (Nn = null), yf(y))
                : ((zt = 0), (Nn = null), Vo(g, y, z, 7));
              break;
            case 5:
              var ne = null;
              switch (Mt.tag) {
                case 26:
                  ne = Mt.memoizedState;
                case 5:
                case 27:
                  var je = Mt;
                  if (ne ? rp(ne) : je.stateNode.complete) {
                    ((zt = 0), (Nn = null));
                    var He = je.sibling;
                    if (He !== null) Mt = He;
                    else {
                      var Je = je.return;
                      Je !== null ? ((Mt = Je), Li(Je)) : (Mt = null);
                    }
                    break t;
                  }
              }
              ((zt = 0), (Nn = null), Vo(g, y, z, 5));
              break;
            case 6:
              ((zt = 0), (Nn = null), Vo(g, y, z, 6));
              break;
            case 8:
              (Fl(), (Xt = 6));
              break e;
            default:
              throw Error(_(462));
          }
        }
        Km();
        break;
      } catch (st) {
        pf(g, st);
      }
    while (!0);
    return (
      (nr = Kr = null),
      ($e.H = E),
      ($e.A = V),
      (Bt = x),
      Mt !== null ? 0 : ((Ht = null), (Ot = 0), Qs(), Xt)
    );
  }
  function Km() {
    for (; Mt !== null && !yp(); ) _f(Mt);
  }
  function _f(g) {
    var y = Fd(g.alternate, g, pr);
    ((g.memoizedProps = g.pendingProps), y === null ? Li(g) : (Mt = y));
  }
  function yf(g) {
    var y = g,
      x = y.alternate;
    switch (y.tag) {
      case 15:
      case 0:
        y = Ld(x, y, y.pendingProps, y.type, void 0, Ot);
        break;
      case 11:
        y = Ld(x, y, y.pendingProps, y.type.render, y.ref, Ot);
        break;
      case 5:
        nl(y);
      default:
        (kd(x, y), (y = Mt = mu(y, pr)), (y = Fd(x, y, pr)));
    }
    ((g.memoizedProps = g.pendingProps), y === null ? Li(g) : (Mt = y));
  }
  function Vo(g, y, x, E) {
    ((nr = Kr = null), nl(y), (Ro = null), (cs = 0));
    var V = y.return;
    try {
      if (Bm(g, V, y, x, Ot)) {
        ((Xt = 1), xi(g, jn(x, g.current)), (Mt = null));
        return;
      }
    } catch (z) {
      if (V !== null) throw ((Mt = V), z);
      ((Xt = 1), xi(g, jn(x, g.current)), (Mt = null));
      return;
    }
    y.flags & 32768
      ? (Dt || E === 1
          ? (g = !0)
          : Lo || (Ot & 536870912) !== 0
            ? (g = !1)
            : ((Mr = g = !0),
              (E === 2 || E === 9 || E === 3 || E === 6) &&
                ((E = Cn.current),
                E !== null && E.tag === 13 && (E.flags |= 16384))),
        bf(y, g))
      : Li(y);
  }
  function Li(g) {
    var y = g;
    do {
      if ((y.flags & 32768) !== 0) {
        bf(y, Mr);
        return;
      }
      g = y.return;
      var x = Fm(y.alternate, y, pr);
      if (x !== null) {
        Mt = x;
        return;
      }
      if (((y = y.sibling), y !== null)) {
        Mt = y;
        return;
      }
      Mt = y = g;
    } while (y !== null);
    Xt === 0 && (Xt = 5);
  }
  function bf(g, y) {
    do {
      var x = $m(g.alternate, g);
      if (x !== null) {
        ((x.flags &= 32767), (Mt = x));
        return;
      }
      if (
        ((x = g.return),
        x !== null &&
          ((x.flags |= 32768), (x.subtreeFlags = 0), (x.deletions = null)),
        !y && ((g = g.sibling), g !== null))
      ) {
        Mt = g;
        return;
      }
      Mt = g = x;
    } while (g !== null);
    ((Xt = 6), (Mt = null));
  }
  function wf(g, y, x, E, V, z, ne, je, He) {
    g.cancelPendingCommit = null;
    do Pi();
    while (on !== 0);
    if ((Bt & 6) !== 0) throw Error(_(327));
    if (y !== null) {
      if (y === g.current) throw Error(_(177));
      if (
        ((z = y.lanes | y.childLanes),
        (z |= Ma),
        Cp(g, x, z, ne, je, He),
        g === Ht && ((Mt = Ht = null), (Ot = 0)),
        (jo = y),
        (Ir = g),
        (mr = x),
        (Bl = z),
        (Vl = V),
        (cf = E),
        (y.subtreeFlags & 10256) !== 0 || (y.flags & 10256) !== 0
          ? ((g.callbackNode = null),
            (g.callbackPriority = 0),
            Qm(Bs, function () {
              return (Tf(), null);
            }))
          : ((g.callbackNode = null), (g.callbackPriority = 0)),
        (E = (y.flags & 13878) !== 0),
        (y.subtreeFlags & 13878) !== 0 || E)
      ) {
        ((E = $e.T),
          ($e.T = null),
          (V = Ye.p),
          (Ye.p = 2),
          (ne = Bt),
          (Bt |= 4));
        try {
          km(g, y, x);
        } finally {
          ((Bt = ne), (Ye.p = V), ($e.T = E));
        }
      }
      ((on = 1), xf(), vf(), Ef());
    }
  }
  function xf() {
    if (on === 1) {
      on = 0;
      var g = Ir,
        y = jo,
        x = (y.flags & 13878) !== 0;
      if ((y.subtreeFlags & 13878) !== 0 || x) {
        ((x = $e.T), ($e.T = null));
        var E = Ye.p;
        Ye.p = 2;
        var V = Bt;
        Bt |= 4;
        try {
          ef(y, g);
          var z = Ql,
            ne = su(g.containerInfo),
            je = z.focusedElem,
            He = z.selectionRange;
          if (
            ne !== je &&
            je &&
            je.ownerDocument &&
            ou(je.ownerDocument.documentElement, je)
          ) {
            if (He !== null && Sa(je)) {
              var Je = He.start,
                st = He.end;
              if ((st === void 0 && (st = Je), "selectionStart" in je))
                ((je.selectionStart = Je),
                  (je.selectionEnd = Math.min(st, je.value.length)));
              else {
                var ft = je.ownerDocument || document,
                  et = (ft && ft.defaultView) || window;
                if (et.getSelection) {
                  var rt = et.getSelection(),
                    wt = je.textContent.length,
                    Tt = Math.min(He.start, wt),
                    Ut = He.end === void 0 ? Tt : Math.min(He.end, wt);
                  !rt.extend && Tt > Ut && ((ne = Ut), (Ut = Tt), (Tt = ne));
                  var Xe = ru(je, Tt),
                    We = ru(je, Ut);
                  if (
                    Xe &&
                    We &&
                    (rt.rangeCount !== 1 ||
                      rt.anchorNode !== Xe.node ||
                      rt.anchorOffset !== Xe.offset ||
                      rt.focusNode !== We.node ||
                      rt.focusOffset !== We.offset)
                  ) {
                    var Ze = ft.createRange();
                    (Ze.setStart(Xe.node, Xe.offset),
                      rt.removeAllRanges(),
                      Tt > Ut
                        ? (rt.addRange(Ze), rt.extend(We.node, We.offset))
                        : (Ze.setEnd(We.node, We.offset), rt.addRange(Ze)));
                  }
                }
              }
            }
            for (ft = [], rt = je; (rt = rt.parentNode); )
              rt.nodeType === 1 &&
                ft.push({
                  element: rt,
                  left: rt.scrollLeft,
                  top: rt.scrollTop,
                });
            for (
              typeof je.focus == "function" && je.focus(), je = 0;
              je < ft.length;
              je++
            ) {
              var ct = ft[je];
              ((ct.element.scrollLeft = ct.left),
                (ct.element.scrollTop = ct.top));
            }
          }
          ((qi = !!Jl), (Ql = Jl = null));
        } finally {
          ((Bt = V), (Ye.p = E), ($e.T = x));
        }
      }
      ((g.current = y), (on = 2));
    }
  }
  function vf() {
    if (on === 2) {
      on = 0;
      var g = Ir,
        y = jo,
        x = (y.flags & 8772) !== 0;
      if ((y.subtreeFlags & 8772) !== 0 || x) {
        ((x = $e.T), ($e.T = null));
        var E = Ye.p;
        Ye.p = 2;
        var V = Bt;
        Bt |= 4;
        try {
          Kd(g, y.alternate, y);
        } finally {
          ((Bt = V), (Ye.p = E), ($e.T = x));
        }
      }
      on = 3;
    }
  }
  function Ef() {
    if (on === 4 || on === 3) {
      ((on = 0), bp());
      var g = Ir,
        y = jo,
        x = mr,
        E = cf;
      (y.subtreeFlags & 10256) !== 0 || (y.flags & 10256) !== 0
        ? (on = 5)
        : ((on = 0), (jo = Ir = null), Sf(g, g.pendingLanes));
      var V = g.pendingLanes;
      if (
        (V === 0 && (Or = null),
        sa(x),
        (y = y.stateNode),
        Sn && typeof Sn.onCommitFiberRoot == "function")
      )
        try {
          Sn.onCommitFiberRoot(Go, y, void 0, (y.current.flags & 128) === 128);
        } catch {}
      if (E !== null) {
        ((y = $e.T), (V = Ye.p), (Ye.p = 2), ($e.T = null));
        try {
          for (var z = g.onRecoverableError, ne = 0; ne < E.length; ne++) {
            var je = E[ne];
            z(je.value, { componentStack: je.stack });
          }
        } finally {
          (($e.T = y), (Ye.p = V));
        }
      }
      ((mr & 3) !== 0 && Pi(),
        Xn(g),
        (V = g.pendingLanes),
        (x & 261930) !== 0 && (V & 42) !== 0
          ? g === zl
            ? As++
            : ((As = 0), (zl = g))
          : (As = 0),
        Rs(0));
    }
  }
  function Sf(g, y) {
    (g.pooledCacheLanes &= y) === 0 &&
      ((y = g.pooledCache), y != null && ((g.pooledCache = null), as(y)));
  }
  function Pi() {
    return (xf(), vf(), Ef(), Tf());
  }
  function Tf() {
    if (on !== 5) return !1;
    var g = Ir,
      y = Bl;
    Bl = 0;
    var x = sa(mr),
      E = $e.T,
      V = Ye.p;
    try {
      ((Ye.p = 32 > x ? 32 : x), ($e.T = null), (x = Vl), (Vl = null));
      var z = Ir,
        ne = mr;
      if (((on = 0), (jo = Ir = null), (mr = 0), (Bt & 6) !== 0))
        throw Error(_(331));
      var je = Bt;
      if (
        ((Bt |= 4),
        sf(z.current),
        nf(z, z.current, ne, x),
        (Bt = je),
        Rs(0, !1),
        Sn && typeof Sn.onPostCommitFiberRoot == "function")
      )
        try {
          Sn.onPostCommitFiberRoot(Go, z);
        } catch {}
      return !0;
    } finally {
      ((Ye.p = V), ($e.T = E), Sf(g, y));
    }
  }
  function Af(g, y, x) {
    ((y = jn(x, y)),
      (y = _l(g.stateNode, y, 2)),
      (g = Tr(g, y, 2)),
      g !== null && (qo(g, 2), Xn(g)));
  }
  function Ft(g, y, x) {
    if (g.tag === 3) Af(g, g, x);
    else
      for (; y !== null; ) {
        if (y.tag === 3) {
          Af(y, g, x);
          break;
        } else if (y.tag === 1) {
          var E = y.stateNode;
          if (
            typeof y.type.getDerivedStateFromError == "function" ||
            (typeof E.componentDidCatch == "function" &&
              (Or === null || !Or.has(E)))
          ) {
            ((g = jn(x, g)),
              (x = Ad(2)),
              (E = Tr(y, x, 2)),
              E !== null && (Rd(x, E, y, g), qo(E, 2), Xn(E)));
            break;
          }
        }
        y = y.return;
      }
  }
  function kl(g, y, x) {
    var E = g.pingCache;
    if (E === null) {
      E = g.pingCache = new Gm();
      var V = new Set();
      E.set(y, V);
    } else ((V = E.get(y)), V === void 0 && ((V = new Set()), E.set(y, V)));
    V.has(x) ||
      ((Ll = !0), V.add(x), (g = Xm.bind(null, g, y, x)), y.then(g, g));
  }
  function Xm(g, y, x) {
    var E = g.pingCache;
    (E !== null && E.delete(y),
      (g.pingedLanes |= g.suspendedLanes & x),
      (g.warmLanes &= ~x),
      Ht === g &&
        (Ot & x) === x &&
        (Xt === 4 || (Xt === 3 && (Ot & 62914560) === Ot && 300 > En() - Mi)
          ? (Bt & 2) === 0 && Bo(g, 0)
          : (Pl |= x),
        Po === Ot && (Po = 0)),
      Xn(g));
  }
  function Rf(g, y) {
    (y === 0 && (y = bc()), (g = Wr(g, y)), g !== null && (qo(g, y), Xn(g)));
  }
  function Zm(g) {
    var y = g.memoizedState,
      x = 0;
    (y !== null && (x = y.retryLane), Rf(g, x));
  }
  function Jm(g, y) {
    var x = 0;
    switch (g.tag) {
      case 31:
      case 13:
        var E = g.stateNode,
          V = g.memoizedState;
        V !== null && (x = V.retryLane);
        break;
      case 19:
        E = g.stateNode;
        break;
      case 22:
        E = g.stateNode._retryCache;
        break;
      default:
        throw Error(_(314));
    }
    (E !== null && E.delete(y), Rf(g, x));
  }
  function Qm(g, y) {
    return ta(g, y);
  }
  var ji = null,
    zo = null,
    Ul = !1,
    Bi = !1,
    Hl = !1,
    Lr = 0;
  function Xn(g) {
    (g !== zo &&
      g.next === null &&
      (zo === null ? (ji = zo = g) : (zo = zo.next = g)),
      (Bi = !0),
      Ul || ((Ul = !0), tg()));
  }
  function Rs(g, y) {
    if (!Hl && Bi) {
      Hl = !0;
      do
        for (var x = !1, E = ji; E !== null; ) {
          if (g !== 0) {
            var V = E.pendingLanes;
            if (V === 0) var z = 0;
            else {
              var ne = E.suspendedLanes,
                je = E.pingedLanes;
              ((z = (1 << (31 - Tn(42 | g) + 1)) - 1),
                (z &= V & ~(ne & ~je)),
                (z = z & 201326741 ? (z & 201326741) | 1 : z ? z | 2 : 0));
            }
            z !== 0 && ((x = !0), Of(E, z));
          } else
            ((z = Ot),
              (z = $s(
                E,
                E === Ht ? z : 0,
                E.cancelPendingCommit !== null || E.timeoutHandle !== -1,
              )),
              (z & 3) === 0 || Wo(E, z) || ((x = !0), Of(E, z)));
          E = E.next;
        }
      while (x);
      Hl = !1;
    }
  }
  function eg() {
    Cf();
  }
  function Cf() {
    Bi = Ul = !1;
    var g = 0;
    Lr !== 0 && dg() && (g = Lr);
    for (var y = En(), x = null, E = ji; E !== null; ) {
      var V = E.next,
        z = Mf(E, y);
      (z === 0
        ? ((E.next = null),
          x === null ? (ji = V) : (x.next = V),
          V === null && (zo = x))
        : ((x = E), (g !== 0 || (z & 3) !== 0) && (Bi = !0)),
        (E = V));
    }
    ((on !== 0 && on !== 5) || Rs(g), Lr !== 0 && (Lr = 0));
  }
  function Mf(g, y) {
    for (
      var x = g.suspendedLanes,
        E = g.pingedLanes,
        V = g.expirationTimes,
        z = g.pendingLanes & -62914561;
      0 < z;

    ) {
      var ne = 31 - Tn(z),
        je = 1 << ne,
        He = V[ne];
      (He === -1
        ? ((je & x) === 0 || (je & E) !== 0) && (V[ne] = Rp(je, y))
        : He <= y && (g.expiredLanes |= je),
        (z &= ~je));
    }
    if (
      ((y = Ht),
      (x = Ot),
      (x = $s(
        g,
        g === y ? x : 0,
        g.cancelPendingCommit !== null || g.timeoutHandle !== -1,
      )),
      (E = g.callbackNode),
      x === 0 ||
        (g === y && (zt === 2 || zt === 9)) ||
        g.cancelPendingCommit !== null)
    )
      return (
        E !== null && E !== null && na(E),
        (g.callbackNode = null),
        (g.callbackPriority = 0)
      );
    if ((x & 3) === 0 || Wo(g, x)) {
      if (((y = x & -x), y === g.callbackPriority)) return y;
      switch ((E !== null && na(E), sa(x))) {
        case 2:
        case 8:
          x = _c;
          break;
        case 32:
          x = Bs;
          break;
        case 268435456:
          x = yc;
          break;
        default:
          x = Bs;
      }
      return (
        (E = Nf.bind(null, g)),
        (x = ta(x, E)),
        (g.callbackPriority = y),
        (g.callbackNode = x),
        y
      );
    }
    return (
      E !== null && E !== null && na(E),
      (g.callbackPriority = 2),
      (g.callbackNode = null),
      2
    );
  }
  function Nf(g, y) {
    if (on !== 0 && on !== 5)
      return ((g.callbackNode = null), (g.callbackPriority = 0), null);
    var x = g.callbackNode;
    if (Pi() && g.callbackNode !== x) return null;
    var E = Ot;
    return (
      (E = $s(
        g,
        g === Ht ? E : 0,
        g.cancelPendingCommit !== null || g.timeoutHandle !== -1,
      )),
      E === 0
        ? null
        : (df(g, E, y),
          Mf(g, En()),
          g.callbackNode != null && g.callbackNode === x
            ? Nf.bind(null, g)
            : null)
    );
  }
  function Of(g, y) {
    if (Pi()) return null;
    df(g, y, !0);
  }
  function tg() {
    pg(function () {
      (Bt & 6) !== 0 ? ta(hc, eg) : Cf();
    });
  }
  function Gl() {
    if (Lr === 0) {
      var g = So;
      (g === 0 && ((g = Vs), (Vs <<= 1), (Vs & 261888) === 0 && (Vs = 256)),
        (Lr = g));
    }
    return Lr;
  }
  function If(g) {
    return g == null || typeof g == "symbol" || typeof g == "boolean"
      ? null
      : typeof g == "function"
        ? g
        : Gs("" + g);
  }
  function Df(g, y) {
    var x = y.ownerDocument.createElement("input");
    return (
      (x.name = y.name),
      (x.value = y.value),
      g.id && x.setAttribute("form", g.id),
      y.parentNode.insertBefore(x, y),
      (g = new FormData(g)),
      x.parentNode.removeChild(x),
      g
    );
  }
  function ng(g, y, x, E, V) {
    if (y === "submit" && x && x.stateNode === V) {
      var z = If((V[hn] || null).action),
        ne = E.submitter;
      ne &&
        ((y = (y = ne[hn] || null)
          ? If(y.formAction)
          : ne.getAttribute("formAction")),
        y !== null && ((z = y), (ne = null)));
      var je = new Ks("action", "action", null, E, V);
      g.push({
        event: je,
        listeners: [
          {
            instance: null,
            listener: function () {
              if (E.defaultPrevented) {
                if (Lr !== 0) {
                  var He = ne ? Df(V, ne) : new FormData(V);
                  dl(
                    x,
                    { pending: !0, data: He, method: V.method, action: z },
                    null,
                    He,
                  );
                }
              } else
                typeof z == "function" &&
                  (je.preventDefault(),
                  (He = ne ? Df(V, ne) : new FormData(V)),
                  dl(
                    x,
                    { pending: !0, data: He, method: V.method, action: z },
                    z,
                    He,
                  ));
            },
            currentTarget: V,
          },
        ],
      });
    }
  }
  for (var Wl = 0; Wl < Ca.length; Wl++) {
    var ql = Ca[Wl],
      rg = ql.toLowerCase(),
      og = ql[0].toUpperCase() + ql.slice(1);
    Un(rg, "on" + og);
  }
  (Un(lu, "onAnimationEnd"),
    Un(cu, "onAnimationIteration"),
    Un(uu, "onAnimationStart"),
    Un("dblclick", "onDoubleClick"),
    Un("focusin", "onFocus"),
    Un("focusout", "onBlur"),
    Un(wm, "onTransitionRun"),
    Un(xm, "onTransitionStart"),
    Un(vm, "onTransitionCancel"),
    Un(du, "onTransitionEnd"),
    co("onMouseEnter", ["mouseout", "mouseover"]),
    co("onMouseLeave", ["mouseout", "mouseover"]),
    co("onPointerEnter", ["pointerout", "pointerover"]),
    co("onPointerLeave", ["pointerout", "pointerover"]),
    kr(
      "onChange",
      "change click focusin focusout input keydown keyup selectionchange".split(
        " ",
      ),
    ),
    kr(
      "onSelect",
      "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(
        " ",
      ),
    ),
    kr("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]),
    kr(
      "onCompositionEnd",
      "compositionend focusout keydown keypress keyup mousedown".split(" "),
    ),
    kr(
      "onCompositionStart",
      "compositionstart focusout keydown keypress keyup mousedown".split(" "),
    ),
    kr(
      "onCompositionUpdate",
      "compositionupdate focusout keydown keypress keyup mousedown".split(" "),
    ));
  var Cs =
      "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(
        " ",
      ),
    sg = new Set(
      "beforetoggle cancel close invalid load scroll scrollend toggle"
        .split(" ")
        .concat(Cs),
    );
  function Lf(g, y) {
    y = (y & 4) !== 0;
    for (var x = 0; x < g.length; x++) {
      var E = g[x],
        V = E.event;
      E = E.listeners;
      e: {
        var z = void 0;
        if (y)
          for (var ne = E.length - 1; 0 <= ne; ne--) {
            var je = E[ne],
              He = je.instance,
              Je = je.currentTarget;
            if (((je = je.listener), He !== z && V.isPropagationStopped()))
              break e;
            ((z = je), (V.currentTarget = Je));
            try {
              z(V);
            } catch (st) {
              Js(st);
            }
            ((V.currentTarget = null), (z = He));
          }
        else
          for (ne = 0; ne < E.length; ne++) {
            if (
              ((je = E[ne]),
              (He = je.instance),
              (Je = je.currentTarget),
              (je = je.listener),
              He !== z && V.isPropagationStopped())
            )
              break e;
            ((z = je), (V.currentTarget = Je));
            try {
              z(V);
            } catch (st) {
              Js(st);
            }
            ((V.currentTarget = null), (z = He));
          }
      }
    }
  }
  function Nt(g, y) {
    var x = y[ia];
    x === void 0 && (x = y[ia] = new Set());
    var E = g + "__bubble";
    x.has(E) || (Pf(y, g, 2, !1), x.add(E));
  }
  function Yl(g, y, x) {
    var E = 0;
    (y && (E |= 4), Pf(x, g, E, y));
  }
  var Vi = "_reactListening" + Math.random().toString(36).slice(2);
  function Kl(g) {
    if (!g[Vi]) {
      ((g[Vi] = !0),
        Ac.forEach(function (x) {
          x !== "selectionchange" && (sg.has(x) || Yl(x, !1, g), Yl(x, !0, g));
        }));
      var y = g.nodeType === 9 ? g : g.ownerDocument;
      y === null || y[Vi] || ((y[Vi] = !0), Yl("selectionchange", !1, y));
    }
  }
  function Pf(g, y, x, E) {
    switch (up(y)) {
      case 2:
        var V = Dg;
        break;
      case 8:
        V = Lg;
        break;
      default:
        V = uc;
    }
    ((x = V.bind(null, y, x, g)),
      (V = void 0),
      !ga ||
        (y !== "touchstart" && y !== "touchmove" && y !== "wheel") ||
        (V = !0),
      E
        ? V !== void 0
          ? g.addEventListener(y, x, { capture: !0, passive: V })
          : g.addEventListener(y, x, !0)
        : V !== void 0
          ? g.addEventListener(y, x, { passive: V })
          : g.addEventListener(y, x, !1));
  }
  function Xl(g, y, x, E, V) {
    var z = E;
    if ((y & 1) === 0 && (y & 2) === 0 && E !== null)
      e: for (;;) {
        if (E === null) return;
        var ne = E.tag;
        if (ne === 3 || ne === 4) {
          var je = E.stateNode.containerInfo;
          if (je === V) break;
          if (ne === 4)
            for (ne = E.return; ne !== null; ) {
              var He = ne.tag;
              if ((He === 3 || He === 4) && ne.stateNode.containerInfo === V)
                return;
              ne = ne.return;
            }
          for (; je !== null; ) {
            if (((ne = io(je)), ne === null)) return;
            if (
              ((He = ne.tag), He === 5 || He === 6 || He === 26 || He === 27)
            ) {
              E = z = ne;
              continue e;
            }
            je = je.parentNode;
          }
        }
        E = E.return;
      }
    Vc(function () {
      var Je = z,
        st = pa(x),
        ft = [];
      e: {
        var et = fu.get(g);
        if (et !== void 0) {
          var rt = Ks,
            wt = g;
          switch (g) {
            case "keypress":
              if (qs(x) === 0) break e;
            case "keydown":
            case "keyup":
              rt = Jp;
              break;
            case "focusin":
              ((wt = "focus"), (rt = ba));
              break;
            case "focusout":
              ((wt = "blur"), (rt = ba));
              break;
            case "beforeblur":
            case "afterblur":
              rt = ba;
              break;
            case "click":
              if (x.button === 2) break e;
            case "auxclick":
            case "dblclick":
            case "mousedown":
            case "mousemove":
            case "mouseup":
            case "mouseout":
            case "mouseover":
            case "contextmenu":
              rt = $c;
              break;
            case "drag":
            case "dragend":
            case "dragenter":
            case "dragexit":
            case "dragleave":
            case "dragover":
            case "dragstart":
            case "drop":
              rt = Fp;
              break;
            case "touchcancel":
            case "touchend":
            case "touchmove":
            case "touchstart":
              rt = tm;
              break;
            case lu:
            case cu:
            case uu:
              rt = Up;
              break;
            case du:
              rt = rm;
              break;
            case "scroll":
            case "scrollend":
              rt = Vp;
              break;
            case "wheel":
              rt = sm;
              break;
            case "copy":
            case "cut":
            case "paste":
              rt = Gp;
              break;
            case "gotpointercapture":
            case "lostpointercapture":
            case "pointercancel":
            case "pointerdown":
            case "pointermove":
            case "pointerout":
            case "pointerover":
            case "pointerup":
              rt = Uc;
              break;
            case "toggle":
            case "beforetoggle":
              rt = am;
          }
          var Tt = (y & 4) !== 0,
            Ut = !Tt && (g === "scroll" || g === "scrollend"),
            Xe = Tt ? (et !== null ? et + "Capture" : null) : et;
          Tt = [];
          for (var We = Je, Ze; We !== null; ) {
            var ct = We;
            if (
              ((Ze = ct.stateNode),
              (ct = ct.tag),
              (ct !== 5 && ct !== 26 && ct !== 27) ||
                Ze === null ||
                Xe === null ||
                ((ct = Xo(We, Xe)), ct != null && Tt.push(Ms(We, ct, Ze))),
              Ut)
            )
              break;
            We = We.return;
          }
          0 < Tt.length &&
            ((et = new rt(et, wt, null, x, st)),
            ft.push({ event: et, listeners: Tt }));
        }
      }
      if ((y & 7) === 0) {
        e: {
          if (
            ((et = g === "mouseover" || g === "pointerover"),
            (rt = g === "mouseout" || g === "pointerout"),
            et &&
              x !== fa &&
              (wt = x.relatedTarget || x.fromElement) &&
              (io(wt) || wt[so]))
          )
            break e;
          if (
            (rt || et) &&
            ((et =
              st.window === st
                ? st
                : (et = st.ownerDocument)
                  ? et.defaultView || et.parentWindow
                  : window),
            rt
              ? ((wt = x.relatedTarget || x.toElement),
                (rt = Je),
                (wt = wt ? io(wt) : null),
                wt !== null &&
                  ((Ut = v(wt)),
                  (Tt = wt.tag),
                  wt !== Ut || (Tt !== 5 && Tt !== 27 && Tt !== 6)) &&
                  (wt = null))
              : ((rt = null), (wt = Je)),
            rt !== wt)
          ) {
            if (
              ((Tt = $c),
              (ct = "onMouseLeave"),
              (Xe = "onMouseEnter"),
              (We = "mouse"),
              (g === "pointerout" || g === "pointerover") &&
                ((Tt = Uc),
                (ct = "onPointerLeave"),
                (Xe = "onPointerEnter"),
                (We = "pointer")),
              (Ut = rt == null ? et : Ko(rt)),
              (Ze = wt == null ? et : Ko(wt)),
              (et = new Tt(ct, We + "leave", rt, x, st)),
              (et.target = Ut),
              (et.relatedTarget = Ze),
              (ct = null),
              io(st) === Je &&
                ((Tt = new Tt(Xe, We + "enter", wt, x, st)),
                (Tt.target = Ze),
                (Tt.relatedTarget = Ut),
                (ct = Tt)),
              (Ut = ct),
              rt && wt)
            )
              t: {
                for (
                  Tt = ig, Xe = rt, We = wt, Ze = 0, ct = Xe;
                  ct;
                  ct = Tt(ct)
                )
                  Ze++;
                ct = 0;
                for (var St = We; St; St = Tt(St)) ct++;
                for (; 0 < Ze - ct; ) ((Xe = Tt(Xe)), Ze--);
                for (; 0 < ct - Ze; ) ((We = Tt(We)), ct--);
                for (; Ze--; ) {
                  if (Xe === We || (We !== null && Xe === We.alternate)) {
                    Tt = Xe;
                    break t;
                  }
                  ((Xe = Tt(Xe)), (We = Tt(We)));
                }
                Tt = null;
              }
            else Tt = null;
            (rt !== null && jf(ft, et, rt, Tt, !1),
              wt !== null && Ut !== null && jf(ft, Ut, wt, Tt, !0));
          }
        }
        e: {
          if (
            ((et = Je ? Ko(Je) : window),
            (rt = et.nodeName && et.nodeName.toLowerCase()),
            rt === "select" || (rt === "input" && et.type === "file"))
          )
            var Pt = Zc;
          else if (Kc(et))
            if (Jc) Pt = _m;
            else {
              Pt = gm;
              var vt = mm;
            }
          else
            ((rt = et.nodeName),
              !rt ||
              rt.toLowerCase() !== "input" ||
              (et.type !== "checkbox" && et.type !== "radio")
                ? Je && da(Je.elementType) && (Pt = Zc)
                : (Pt = hm));
          if (Pt && (Pt = Pt(g, Je))) {
            Xc(ft, Pt, x, st);
            break e;
          }
          (vt && vt(g, et, Je),
            g === "focusout" &&
              Je &&
              et.type === "number" &&
              Je.memoizedProps.value != null &&
              ua(et, "number", et.value));
        }
        switch (((vt = Je ? Ko(Je) : window), g)) {
          case "focusin":
            (Kc(vt) || vt.contentEditable === "true") &&
              ((ho = vt), (Ta = Je), (os = null));
            break;
          case "focusout":
            os = Ta = ho = null;
            break;
          case "mousedown":
            Aa = !0;
            break;
          case "contextmenu":
          case "mouseup":
          case "dragend":
            ((Aa = !1), iu(ft, x, st));
            break;
          case "selectionchange":
            if (bm) break;
          case "keydown":
          case "keyup":
            iu(ft, x, st);
        }
        var Ct;
        if (xa)
          e: {
            switch (g) {
              case "compositionstart":
                var It = "onCompositionStart";
                break e;
              case "compositionend":
                It = "onCompositionEnd";
                break e;
              case "compositionupdate":
                It = "onCompositionUpdate";
                break e;
            }
            It = void 0;
          }
        else
          go
            ? qc(g, x) && (It = "onCompositionEnd")
            : g === "keydown" &&
              x.keyCode === 229 &&
              (It = "onCompositionStart");
        (It &&
          (Hc &&
            x.locale !== "ko" &&
            (go || It !== "onCompositionStart"
              ? It === "onCompositionEnd" && go && (Ct = zc())
              : ((yr = st),
                (ha = "value" in yr ? yr.value : yr.textContent),
                (go = !0))),
          (vt = zi(Je, It)),
          0 < vt.length &&
            ((It = new kc(It, g, null, x, st)),
            ft.push({ event: It, listeners: vt }),
            Ct
              ? (It.data = Ct)
              : ((Ct = Yc(x)), Ct !== null && (It.data = Ct)))),
          (Ct = cm ? um(g, x) : dm(g, x)) &&
            ((It = zi(Je, "onBeforeInput")),
            0 < It.length &&
              ((vt = new kc("onBeforeInput", "beforeinput", null, x, st)),
              ft.push({ event: vt, listeners: It }),
              (vt.data = Ct))),
          ng(ft, g, Je, x, st));
      }
      Lf(ft, y);
    });
  }
  function Ms(g, y, x) {
    return { instance: g, listener: y, currentTarget: x };
  }
  function zi(g, y) {
    for (var x = y + "Capture", E = []; g !== null; ) {
      var V = g,
        z = V.stateNode;
      if (
        ((V = V.tag),
        (V !== 5 && V !== 26 && V !== 27) ||
          z === null ||
          ((V = Xo(g, x)),
          V != null && E.unshift(Ms(g, V, z)),
          (V = Xo(g, y)),
          V != null && E.push(Ms(g, V, z))),
        g.tag === 3)
      )
        return E;
      g = g.return;
    }
    return [];
  }
  function ig(g) {
    if (g === null) return null;
    do g = g.return;
    while (g && g.tag !== 5 && g.tag !== 27);
    return g || null;
  }
  function jf(g, y, x, E, V) {
    for (var z = y._reactName, ne = []; x !== null && x !== E; ) {
      var je = x,
        He = je.alternate,
        Je = je.stateNode;
      if (((je = je.tag), He !== null && He === E)) break;
      ((je !== 5 && je !== 26 && je !== 27) ||
        Je === null ||
        ((He = Je),
        V
          ? ((Je = Xo(x, z)), Je != null && ne.unshift(Ms(x, Je, He)))
          : V || ((Je = Xo(x, z)), Je != null && ne.push(Ms(x, Je, He)))),
        (x = x.return));
    }
    ne.length !== 0 && g.push({ event: y, listeners: ne });
  }
  var ag = /\r\n?/g,
    lg = /\u0000|\uFFFD/g;
  function Bf(g) {
    return (typeof g == "string" ? g : "" + g)
      .replace(
        ag,
        `
`,
      )
      .replace(lg, "");
  }
  function Vf(g, y) {
    return ((y = Bf(y)), Bf(g) === y);
  }
  function kt(g, y, x, E, V, z) {
    switch (x) {
      case "children":
        typeof E == "string"
          ? y === "body" || (y === "textarea" && E === "") || fo(g, E)
          : (typeof E == "number" || typeof E == "bigint") &&
            y !== "body" &&
            fo(g, "" + E);
        break;
      case "className":
        Us(g, "class", E);
        break;
      case "tabIndex":
        Us(g, "tabindex", E);
        break;
      case "dir":
      case "role":
      case "viewBox":
      case "width":
      case "height":
        Us(g, x, E);
        break;
      case "style":
        jc(g, E, z);
        break;
      case "data":
        if (y !== "object") {
          Us(g, "data", E);
          break;
        }
      case "src":
      case "href":
        if (E === "" && (y !== "a" || x !== "href")) {
          g.removeAttribute(x);
          break;
        }
        if (
          E == null ||
          typeof E == "function" ||
          typeof E == "symbol" ||
          typeof E == "boolean"
        ) {
          g.removeAttribute(x);
          break;
        }
        ((E = Gs("" + E)), g.setAttribute(x, E));
        break;
      case "action":
      case "formAction":
        if (typeof E == "function") {
          g.setAttribute(
            x,
            "javascript:throw new Error('A React form was unexpectedly submitted. If you called form.submit() manually, consider using form.requestSubmit() instead. If you\\'re trying to use event.stopPropagation() in a submit event handler, consider also calling event.preventDefault().')",
          );
          break;
        } else
          typeof z == "function" &&
            (x === "formAction"
              ? (y !== "input" && kt(g, y, "name", V.name, V, null),
                kt(g, y, "formEncType", V.formEncType, V, null),
                kt(g, y, "formMethod", V.formMethod, V, null),
                kt(g, y, "formTarget", V.formTarget, V, null))
              : (kt(g, y, "encType", V.encType, V, null),
                kt(g, y, "method", V.method, V, null),
                kt(g, y, "target", V.target, V, null)));
        if (E == null || typeof E == "symbol" || typeof E == "boolean") {
          g.removeAttribute(x);
          break;
        }
        ((E = Gs("" + E)), g.setAttribute(x, E));
        break;
      case "onClick":
        E != null && (g.onclick = Jn);
        break;
      case "onScroll":
        E != null && Nt("scroll", g);
        break;
      case "onScrollEnd":
        E != null && Nt("scrollend", g);
        break;
      case "dangerouslySetInnerHTML":
        if (E != null) {
          if (typeof E != "object" || !("__html" in E)) throw Error(_(61));
          if (((x = E.__html), x != null)) {
            if (V.children != null) throw Error(_(60));
            g.innerHTML = x;
          }
        }
        break;
      case "multiple":
        g.multiple = E && typeof E != "function" && typeof E != "symbol";
        break;
      case "muted":
        g.muted = E && typeof E != "function" && typeof E != "symbol";
        break;
      case "suppressContentEditableWarning":
      case "suppressHydrationWarning":
      case "defaultValue":
      case "defaultChecked":
      case "innerHTML":
      case "ref":
        break;
      case "autoFocus":
        break;
      case "xlinkHref":
        if (
          E == null ||
          typeof E == "function" ||
          typeof E == "boolean" ||
          typeof E == "symbol"
        ) {
          g.removeAttribute("xlink:href");
          break;
        }
        ((x = Gs("" + E)),
          g.setAttributeNS("http://www.w3.org/1999/xlink", "xlink:href", x));
        break;
      case "contentEditable":
      case "spellCheck":
      case "draggable":
      case "value":
      case "autoReverse":
      case "externalResourcesRequired":
      case "focusable":
      case "preserveAlpha":
        E != null && typeof E != "function" && typeof E != "symbol"
          ? g.setAttribute(x, "" + E)
          : g.removeAttribute(x);
        break;
      case "inert":
      case "allowFullScreen":
      case "async":
      case "autoPlay":
      case "controls":
      case "default":
      case "defer":
      case "disabled":
      case "disablePictureInPicture":
      case "disableRemotePlayback":
      case "formNoValidate":
      case "hidden":
      case "loop":
      case "noModule":
      case "noValidate":
      case "open":
      case "playsInline":
      case "readOnly":
      case "required":
      case "reversed":
      case "scoped":
      case "seamless":
      case "itemScope":
        E && typeof E != "function" && typeof E != "symbol"
          ? g.setAttribute(x, "")
          : g.removeAttribute(x);
        break;
      case "capture":
      case "download":
        E === !0
          ? g.setAttribute(x, "")
          : E !== !1 &&
              E != null &&
              typeof E != "function" &&
              typeof E != "symbol"
            ? g.setAttribute(x, E)
            : g.removeAttribute(x);
        break;
      case "cols":
      case "rows":
      case "size":
      case "span":
        E != null &&
        typeof E != "function" &&
        typeof E != "symbol" &&
        !isNaN(E) &&
        1 <= E
          ? g.setAttribute(x, E)
          : g.removeAttribute(x);
        break;
      case "rowSpan":
      case "start":
        E == null || typeof E == "function" || typeof E == "symbol" || isNaN(E)
          ? g.removeAttribute(x)
          : g.setAttribute(x, E);
        break;
      case "popover":
        (Nt("beforetoggle", g), Nt("toggle", g), ks(g, "popover", E));
        break;
      case "xlinkActuate":
        Zn(g, "http://www.w3.org/1999/xlink", "xlink:actuate", E);
        break;
      case "xlinkArcrole":
        Zn(g, "http://www.w3.org/1999/xlink", "xlink:arcrole", E);
        break;
      case "xlinkRole":
        Zn(g, "http://www.w3.org/1999/xlink", "xlink:role", E);
        break;
      case "xlinkShow":
        Zn(g, "http://www.w3.org/1999/xlink", "xlink:show", E);
        break;
      case "xlinkTitle":
        Zn(g, "http://www.w3.org/1999/xlink", "xlink:title", E);
        break;
      case "xlinkType":
        Zn(g, "http://www.w3.org/1999/xlink", "xlink:type", E);
        break;
      case "xmlBase":
        Zn(g, "http://www.w3.org/XML/1998/namespace", "xml:base", E);
        break;
      case "xmlLang":
        Zn(g, "http://www.w3.org/XML/1998/namespace", "xml:lang", E);
        break;
      case "xmlSpace":
        Zn(g, "http://www.w3.org/XML/1998/namespace", "xml:space", E);
        break;
      case "is":
        ks(g, "is", E);
        break;
      case "innerText":
      case "textContent":
        break;
      default:
        (!(2 < x.length) ||
          (x[0] !== "o" && x[0] !== "O") ||
          (x[1] !== "n" && x[1] !== "N")) &&
          ((x = jp.get(x) || x), ks(g, x, E));
    }
  }
  function Zl(g, y, x, E, V, z) {
    switch (x) {
      case "style":
        jc(g, E, z);
        break;
      case "dangerouslySetInnerHTML":
        if (E != null) {
          if (typeof E != "object" || !("__html" in E)) throw Error(_(61));
          if (((x = E.__html), x != null)) {
            if (V.children != null) throw Error(_(60));
            g.innerHTML = x;
          }
        }
        break;
      case "children":
        typeof E == "string"
          ? fo(g, E)
          : (typeof E == "number" || typeof E == "bigint") && fo(g, "" + E);
        break;
      case "onScroll":
        E != null && Nt("scroll", g);
        break;
      case "onScrollEnd":
        E != null && Nt("scrollend", g);
        break;
      case "onClick":
        E != null && (g.onclick = Jn);
        break;
      case "suppressContentEditableWarning":
      case "suppressHydrationWarning":
      case "innerHTML":
      case "ref":
        break;
      case "innerText":
      case "textContent":
        break;
      default:
        if (!Rc.hasOwnProperty(x))
          e: {
            if (
              x[0] === "o" &&
              x[1] === "n" &&
              ((V = x.endsWith("Capture")),
              (y = x.slice(2, V ? x.length - 7 : void 0)),
              (z = g[hn] || null),
              (z = z != null ? z[x] : null),
              typeof z == "function" && g.removeEventListener(y, z, V),
              typeof E == "function")
            ) {
              (typeof z != "function" &&
                z !== null &&
                (x in g
                  ? (g[x] = null)
                  : g.hasAttribute(x) && g.removeAttribute(x)),
                g.addEventListener(y, E, V));
              break e;
            }
            x in g
              ? (g[x] = E)
              : E === !0
                ? g.setAttribute(x, "")
                : ks(g, x, E);
          }
    }
  }
  function pn(g, y, x) {
    switch (y) {
      case "div":
      case "span":
      case "svg":
      case "path":
      case "a":
      case "g":
      case "p":
      case "li":
        break;
      case "img":
        (Nt("error", g), Nt("load", g));
        var E = !1,
          V = !1,
          z;
        for (z in x)
          if (x.hasOwnProperty(z)) {
            var ne = x[z];
            if (ne != null)
              switch (z) {
                case "src":
                  E = !0;
                  break;
                case "srcSet":
                  V = !0;
                  break;
                case "children":
                case "dangerouslySetInnerHTML":
                  throw Error(_(137, y));
                default:
                  kt(g, y, z, ne, x, null);
              }
          }
        (V && kt(g, y, "srcSet", x.srcSet, x, null),
          E && kt(g, y, "src", x.src, x, null));
        return;
      case "input":
        Nt("invalid", g);
        var je = (z = ne = V = null),
          He = null,
          Je = null;
        for (E in x)
          if (x.hasOwnProperty(E)) {
            var st = x[E];
            if (st != null)
              switch (E) {
                case "name":
                  V = st;
                  break;
                case "type":
                  ne = st;
                  break;
                case "checked":
                  He = st;
                  break;
                case "defaultChecked":
                  Je = st;
                  break;
                case "value":
                  z = st;
                  break;
                case "defaultValue":
                  je = st;
                  break;
                case "children":
                case "dangerouslySetInnerHTML":
                  if (st != null) throw Error(_(137, y));
                  break;
                default:
                  kt(g, y, E, st, x, null);
              }
          }
        Ic(g, z, je, He, Je, ne, V, !1);
        return;
      case "select":
        (Nt("invalid", g), (E = ne = z = null));
        for (V in x)
          if (x.hasOwnProperty(V) && ((je = x[V]), je != null))
            switch (V) {
              case "value":
                z = je;
                break;
              case "defaultValue":
                ne = je;
                break;
              case "multiple":
                E = je;
              default:
                kt(g, y, V, je, x, null);
            }
        ((y = z),
          (x = ne),
          (g.multiple = !!E),
          y != null ? uo(g, !!E, y, !1) : x != null && uo(g, !!E, x, !0));
        return;
      case "textarea":
        (Nt("invalid", g), (z = V = E = null));
        for (ne in x)
          if (x.hasOwnProperty(ne) && ((je = x[ne]), je != null))
            switch (ne) {
              case "value":
                E = je;
                break;
              case "defaultValue":
                V = je;
                break;
              case "children":
                z = je;
                break;
              case "dangerouslySetInnerHTML":
                if (je != null) throw Error(_(91));
                break;
              default:
                kt(g, y, ne, je, x, null);
            }
        Lc(g, E, V, z);
        return;
      case "option":
        for (He in x)
          if (x.hasOwnProperty(He) && ((E = x[He]), E != null))
            switch (He) {
              case "selected":
                g.selected =
                  E && typeof E != "function" && typeof E != "symbol";
                break;
              default:
                kt(g, y, He, E, x, null);
            }
        return;
      case "dialog":
        (Nt("beforetoggle", g),
          Nt("toggle", g),
          Nt("cancel", g),
          Nt("close", g));
        break;
      case "iframe":
      case "object":
        Nt("load", g);
        break;
      case "video":
      case "audio":
        for (E = 0; E < Cs.length; E++) Nt(Cs[E], g);
        break;
      case "image":
        (Nt("error", g), Nt("load", g));
        break;
      case "details":
        Nt("toggle", g);
        break;
      case "embed":
      case "source":
      case "link":
        (Nt("error", g), Nt("load", g));
      case "area":
      case "base":
      case "br":
      case "col":
      case "hr":
      case "keygen":
      case "meta":
      case "param":
      case "track":
      case "wbr":
      case "menuitem":
        for (Je in x)
          if (x.hasOwnProperty(Je) && ((E = x[Je]), E != null))
            switch (Je) {
              case "children":
              case "dangerouslySetInnerHTML":
                throw Error(_(137, y));
              default:
                kt(g, y, Je, E, x, null);
            }
        return;
      default:
        if (da(y)) {
          for (st in x)
            x.hasOwnProperty(st) &&
              ((E = x[st]), E !== void 0 && Zl(g, y, st, E, x, void 0));
          return;
        }
    }
    for (je in x)
      x.hasOwnProperty(je) &&
        ((E = x[je]), E != null && kt(g, y, je, E, x, null));
  }
  function cg(g, y, x, E) {
    switch (y) {
      case "div":
      case "span":
      case "svg":
      case "path":
      case "a":
      case "g":
      case "p":
      case "li":
        break;
      case "input":
        var V = null,
          z = null,
          ne = null,
          je = null,
          He = null,
          Je = null,
          st = null;
        for (rt in x) {
          var ft = x[rt];
          if (x.hasOwnProperty(rt) && ft != null)
            switch (rt) {
              case "checked":
                break;
              case "value":
                break;
              case "defaultValue":
                He = ft;
              default:
                E.hasOwnProperty(rt) || kt(g, y, rt, null, E, ft);
            }
        }
        for (var et in E) {
          var rt = E[et];
          if (
            ((ft = x[et]), E.hasOwnProperty(et) && (rt != null || ft != null))
          )
            switch (et) {
              case "type":
                z = rt;
                break;
              case "name":
                V = rt;
                break;
              case "checked":
                Je = rt;
                break;
              case "defaultChecked":
                st = rt;
                break;
              case "value":
                ne = rt;
                break;
              case "defaultValue":
                je = rt;
                break;
              case "children":
              case "dangerouslySetInnerHTML":
                if (rt != null) throw Error(_(137, y));
                break;
              default:
                rt !== ft && kt(g, y, et, rt, E, ft);
            }
        }
        ca(g, ne, je, He, Je, st, z, V);
        return;
      case "select":
        rt = ne = je = et = null;
        for (z in x)
          if (((He = x[z]), x.hasOwnProperty(z) && He != null))
            switch (z) {
              case "value":
                break;
              case "multiple":
                rt = He;
              default:
                E.hasOwnProperty(z) || kt(g, y, z, null, E, He);
            }
        for (V in E)
          if (
            ((z = E[V]),
            (He = x[V]),
            E.hasOwnProperty(V) && (z != null || He != null))
          )
            switch (V) {
              case "value":
                et = z;
                break;
              case "defaultValue":
                je = z;
                break;
              case "multiple":
                ne = z;
              default:
                z !== He && kt(g, y, V, z, E, He);
            }
        ((y = je),
          (x = ne),
          (E = rt),
          et != null
            ? uo(g, !!x, et, !1)
            : !!E != !!x &&
              (y != null ? uo(g, !!x, y, !0) : uo(g, !!x, x ? [] : "", !1)));
        return;
      case "textarea":
        rt = et = null;
        for (je in x)
          if (
            ((V = x[je]),
            x.hasOwnProperty(je) && V != null && !E.hasOwnProperty(je))
          )
            switch (je) {
              case "value":
                break;
              case "children":
                break;
              default:
                kt(g, y, je, null, E, V);
            }
        for (ne in E)
          if (
            ((V = E[ne]),
            (z = x[ne]),
            E.hasOwnProperty(ne) && (V != null || z != null))
          )
            switch (ne) {
              case "value":
                et = V;
                break;
              case "defaultValue":
                rt = V;
                break;
              case "children":
                break;
              case "dangerouslySetInnerHTML":
                if (V != null) throw Error(_(91));
                break;
              default:
                V !== z && kt(g, y, ne, V, E, z);
            }
        Dc(g, et, rt);
        return;
      case "option":
        for (var wt in x)
          if (
            ((et = x[wt]),
            x.hasOwnProperty(wt) && et != null && !E.hasOwnProperty(wt))
          )
            switch (wt) {
              case "selected":
                g.selected = !1;
                break;
              default:
                kt(g, y, wt, null, E, et);
            }
        for (He in E)
          if (
            ((et = E[He]),
            (rt = x[He]),
            E.hasOwnProperty(He) && et !== rt && (et != null || rt != null))
          )
            switch (He) {
              case "selected":
                g.selected =
                  et && typeof et != "function" && typeof et != "symbol";
                break;
              default:
                kt(g, y, He, et, E, rt);
            }
        return;
      case "img":
      case "link":
      case "area":
      case "base":
      case "br":
      case "col":
      case "embed":
      case "hr":
      case "keygen":
      case "meta":
      case "param":
      case "source":
      case "track":
      case "wbr":
      case "menuitem":
        for (var Tt in x)
          ((et = x[Tt]),
            x.hasOwnProperty(Tt) &&
              et != null &&
              !E.hasOwnProperty(Tt) &&
              kt(g, y, Tt, null, E, et));
        for (Je in E)
          if (
            ((et = E[Je]),
            (rt = x[Je]),
            E.hasOwnProperty(Je) && et !== rt && (et != null || rt != null))
          )
            switch (Je) {
              case "children":
              case "dangerouslySetInnerHTML":
                if (et != null) throw Error(_(137, y));
                break;
              default:
                kt(g, y, Je, et, E, rt);
            }
        return;
      default:
        if (da(y)) {
          for (var Ut in x)
            ((et = x[Ut]),
              x.hasOwnProperty(Ut) &&
                et !== void 0 &&
                !E.hasOwnProperty(Ut) &&
                Zl(g, y, Ut, void 0, E, et));
          for (st in E)
            ((et = E[st]),
              (rt = x[st]),
              !E.hasOwnProperty(st) ||
                et === rt ||
                (et === void 0 && rt === void 0) ||
                Zl(g, y, st, et, E, rt));
          return;
        }
    }
    for (var Xe in x)
      ((et = x[Xe]),
        x.hasOwnProperty(Xe) &&
          et != null &&
          !E.hasOwnProperty(Xe) &&
          kt(g, y, Xe, null, E, et));
    for (ft in E)
      ((et = E[ft]),
        (rt = x[ft]),
        !E.hasOwnProperty(ft) ||
          et === rt ||
          (et == null && rt == null) ||
          kt(g, y, ft, et, E, rt));
  }
  function zf(g) {
    switch (g) {
      case "css":
      case "script":
      case "font":
      case "img":
      case "image":
      case "input":
      case "link":
        return !0;
      default:
        return !1;
    }
  }
  function ug() {
    if (typeof performance.getEntriesByType == "function") {
      for (
        var g = 0, y = 0, x = performance.getEntriesByType("resource"), E = 0;
        E < x.length;
        E++
      ) {
        var V = x[E],
          z = V.transferSize,
          ne = V.initiatorType,
          je = V.duration;
        if (z && je && zf(ne)) {
          for (ne = 0, je = V.responseEnd, E += 1; E < x.length; E++) {
            var He = x[E],
              Je = He.startTime;
            if (Je > je) break;
            var st = He.transferSize,
              ft = He.initiatorType;
            st &&
              zf(ft) &&
              ((He = He.responseEnd),
              (ne += st * (He < je ? 1 : (je - Je) / (He - Je))));
          }
          if ((--E, (y += (8 * (z + ne)) / (V.duration / 1e3)), g++, 10 < g))
            break;
        }
      }
      if (0 < g) return y / g / 1e6;
    }
    return navigator.connection &&
      ((g = navigator.connection.downlink), typeof g == "number")
      ? g
      : 5;
  }
  var Jl = null,
    Ql = null;
  function Fi(g) {
    return g.nodeType === 9 ? g : g.ownerDocument;
  }
  function Ff(g) {
    switch (g) {
      case "http://www.w3.org/2000/svg":
        return 1;
      case "http://www.w3.org/1998/Math/MathML":
        return 2;
      default:
        return 0;
    }
  }
  function $f(g, y) {
    if (g === 0)
      switch (y) {
        case "svg":
          return 1;
        case "math":
          return 2;
        default:
          return 0;
      }
    return g === 1 && y === "foreignObject" ? 0 : g;
  }
  function ec(g, y) {
    return (
      g === "textarea" ||
      g === "noscript" ||
      typeof y.children == "string" ||
      typeof y.children == "number" ||
      typeof y.children == "bigint" ||
      (typeof y.dangerouslySetInnerHTML == "object" &&
        y.dangerouslySetInnerHTML !== null &&
        y.dangerouslySetInnerHTML.__html != null)
    );
  }
  var tc = null;
  function dg() {
    var g = window.event;
    return g && g.type === "popstate"
      ? g === tc
        ? !1
        : ((tc = g), !0)
      : ((tc = null), !1);
  }
  var kf = typeof setTimeout == "function" ? setTimeout : void 0,
    fg = typeof clearTimeout == "function" ? clearTimeout : void 0,
    Uf = typeof Promise == "function" ? Promise : void 0,
    pg =
      typeof queueMicrotask == "function"
        ? queueMicrotask
        : typeof Uf < "u"
          ? function (g) {
              return Uf.resolve(null).then(g).catch(mg);
            }
          : kf;
  function mg(g) {
    setTimeout(function () {
      throw g;
    });
  }
  function Pr(g) {
    return g === "head";
  }
  function Hf(g, y) {
    var x = y,
      E = 0;
    do {
      var V = x.nextSibling;
      if ((g.removeChild(x), V && V.nodeType === 8))
        if (((x = V.data), x === "/$" || x === "/&")) {
          if (E === 0) {
            (g.removeChild(V), Uo(y));
            return;
          }
          E--;
        } else if (
          x === "$" ||
          x === "$?" ||
          x === "$~" ||
          x === "$!" ||
          x === "&"
        )
          E++;
        else if (x === "html") Ns(g.ownerDocument.documentElement);
        else if (x === "head") {
          ((x = g.ownerDocument.head), Ns(x));
          for (var z = x.firstChild; z; ) {
            var ne = z.nextSibling,
              je = z.nodeName;
            (z[Yo] ||
              je === "SCRIPT" ||
              je === "STYLE" ||
              (je === "LINK" && z.rel.toLowerCase() === "stylesheet") ||
              x.removeChild(z),
              (z = ne));
          }
        } else x === "body" && Ns(g.ownerDocument.body);
      x = V;
    } while (x);
    Uo(y);
  }
  function Gf(g, y) {
    var x = g;
    g = 0;
    do {
      var E = x.nextSibling;
      if (
        (x.nodeType === 1
          ? y
            ? ((x._stashedDisplay = x.style.display),
              (x.style.display = "none"))
            : ((x.style.display = x._stashedDisplay || ""),
              x.getAttribute("style") === "" && x.removeAttribute("style"))
          : x.nodeType === 3 &&
            (y
              ? ((x._stashedText = x.nodeValue), (x.nodeValue = ""))
              : (x.nodeValue = x._stashedText || "")),
        E && E.nodeType === 8)
      )
        if (((x = E.data), x === "/$")) {
          if (g === 0) break;
          g--;
        } else (x !== "$" && x !== "$?" && x !== "$~" && x !== "$!") || g++;
      x = E;
    } while (x);
  }
  function nc(g) {
    var y = g.firstChild;
    for (y && y.nodeType === 10 && (y = y.nextSibling); y; ) {
      var x = y;
      switch (((y = y.nextSibling), x.nodeName)) {
        case "HTML":
        case "HEAD":
        case "BODY":
          (nc(x), aa(x));
          continue;
        case "SCRIPT":
        case "STYLE":
          continue;
        case "LINK":
          if (x.rel.toLowerCase() === "stylesheet") continue;
      }
      g.removeChild(x);
    }
  }
  function gg(g, y, x, E) {
    for (; g.nodeType === 1; ) {
      var V = x;
      if (g.nodeName.toLowerCase() !== y.toLowerCase()) {
        if (!E && (g.nodeName !== "INPUT" || g.type !== "hidden")) break;
      } else if (E) {
        if (!g[Yo])
          switch (y) {
            case "meta":
              if (!g.hasAttribute("itemprop")) break;
              return g;
            case "link":
              if (
                ((z = g.getAttribute("rel")),
                z === "stylesheet" && g.hasAttribute("data-precedence"))
              )
                break;
              if (
                z !== V.rel ||
                g.getAttribute("href") !==
                  (V.href == null || V.href === "" ? null : V.href) ||
                g.getAttribute("crossorigin") !==
                  (V.crossOrigin == null ? null : V.crossOrigin) ||
                g.getAttribute("title") !== (V.title == null ? null : V.title)
              )
                break;
              return g;
            case "style":
              if (g.hasAttribute("data-precedence")) break;
              return g;
            case "script":
              if (
                ((z = g.getAttribute("src")),
                (z !== (V.src == null ? null : V.src) ||
                  g.getAttribute("type") !== (V.type == null ? null : V.type) ||
                  g.getAttribute("crossorigin") !==
                    (V.crossOrigin == null ? null : V.crossOrigin)) &&
                  z &&
                  g.hasAttribute("async") &&
                  !g.hasAttribute("itemprop"))
              )
                break;
              return g;
            default:
              return g;
          }
      } else if (y === "input" && g.type === "hidden") {
        var z = V.name == null ? null : "" + V.name;
        if (V.type === "hidden" && g.getAttribute("name") === z) return g;
      } else return g;
      if (((g = $n(g.nextSibling)), g === null)) break;
    }
    return null;
  }
  function hg(g, y, x) {
    if (y === "") return null;
    for (; g.nodeType !== 3; )
      if (
        ((g.nodeType !== 1 || g.nodeName !== "INPUT" || g.type !== "hidden") &&
          !x) ||
        ((g = $n(g.nextSibling)), g === null)
      )
        return null;
    return g;
  }
  function Wf(g, y) {
    for (; g.nodeType !== 8; )
      if (
        ((g.nodeType !== 1 || g.nodeName !== "INPUT" || g.type !== "hidden") &&
          !y) ||
        ((g = $n(g.nextSibling)), g === null)
      )
        return null;
    return g;
  }
  function rc(g) {
    return g.data === "$?" || g.data === "$~";
  }
  function oc(g) {
    return (
      g.data === "$!" ||
      (g.data === "$?" && g.ownerDocument.readyState !== "loading")
    );
  }
  function _g(g, y) {
    var x = g.ownerDocument;
    if (g.data === "$~") g._reactRetry = y;
    else if (g.data !== "$?" || x.readyState !== "loading") y();
    else {
      var E = function () {
        (y(), x.removeEventListener("DOMContentLoaded", E));
      };
      (x.addEventListener("DOMContentLoaded", E), (g._reactRetry = E));
    }
  }
  function $n(g) {
    for (; g != null; g = g.nextSibling) {
      var y = g.nodeType;
      if (y === 1 || y === 3) break;
      if (y === 8) {
        if (
          ((y = g.data),
          y === "$" ||
            y === "$!" ||
            y === "$?" ||
            y === "$~" ||
            y === "&" ||
            y === "F!" ||
            y === "F")
        )
          break;
        if (y === "/$" || y === "/&") return null;
      }
    }
    return g;
  }
  var sc = null;
  function qf(g) {
    g = g.nextSibling;
    for (var y = 0; g; ) {
      if (g.nodeType === 8) {
        var x = g.data;
        if (x === "/$" || x === "/&") {
          if (y === 0) return $n(g.nextSibling);
          y--;
        } else
          (x !== "$" && x !== "$!" && x !== "$?" && x !== "$~" && x !== "&") ||
            y++;
      }
      g = g.nextSibling;
    }
    return null;
  }
  function Yf(g) {
    g = g.previousSibling;
    for (var y = 0; g; ) {
      if (g.nodeType === 8) {
        var x = g.data;
        if (x === "$" || x === "$!" || x === "$?" || x === "$~" || x === "&") {
          if (y === 0) return g;
          y--;
        } else (x !== "/$" && x !== "/&") || y++;
      }
      g = g.previousSibling;
    }
    return null;
  }
  function Kf(g, y, x) {
    switch (((y = Fi(x)), g)) {
      case "html":
        if (((g = y.documentElement), !g)) throw Error(_(452));
        return g;
      case "head":
        if (((g = y.head), !g)) throw Error(_(453));
        return g;
      case "body":
        if (((g = y.body), !g)) throw Error(_(454));
        return g;
      default:
        throw Error(_(451));
    }
  }
  function Ns(g) {
    for (var y = g.attributes; y.length; ) g.removeAttributeNode(y[0]);
    aa(g);
  }
  var kn = new Map(),
    Xf = new Set();
  function $i(g) {
    return typeof g.getRootNode == "function"
      ? g.getRootNode()
      : g.nodeType === 9
        ? g
        : g.ownerDocument;
  }
  var gr = Ye.d;
  Ye.d = { f: yg, r: bg, D: wg, C: xg, L: vg, m: Eg, X: Tg, S: Sg, M: Ag };
  function yg() {
    var g = gr.f(),
      y = Ii();
    return g || y;
  }
  function bg(g) {
    var y = ao(g);
    y !== null && y.tag === 5 && y.type === "form" ? fd(y) : gr.r(g);
  }
  var Fo = typeof document > "u" ? null : document;
  function Zf(g, y, x) {
    var E = Fo;
    if (E && typeof y == "string" && y) {
      var V = Ln(y);
      ((V = 'link[rel="' + g + '"][href="' + V + '"]'),
        typeof x == "string" && (V += '[crossorigin="' + x + '"]'),
        Xf.has(V) ||
          (Xf.add(V),
          (g = { rel: g, crossOrigin: x, href: y }),
          E.querySelector(V) === null &&
            ((y = E.createElement("link")),
            pn(y, "link", g),
            sn(y),
            E.head.appendChild(y))));
    }
  }
  function wg(g) {
    (gr.D(g), Zf("dns-prefetch", g, null));
  }
  function xg(g, y) {
    (gr.C(g, y), Zf("preconnect", g, y));
  }
  function vg(g, y, x) {
    gr.L(g, y, x);
    var E = Fo;
    if (E && g && y) {
      var V = 'link[rel="preload"][as="' + Ln(y) + '"]';
      y === "image" && x && x.imageSrcSet
        ? ((V += '[imagesrcset="' + Ln(x.imageSrcSet) + '"]'),
          typeof x.imageSizes == "string" &&
            (V += '[imagesizes="' + Ln(x.imageSizes) + '"]'))
        : (V += '[href="' + Ln(g) + '"]');
      var z = V;
      switch (y) {
        case "style":
          z = $o(g);
          break;
        case "script":
          z = ko(g);
      }
      kn.has(z) ||
        ((g = q(
          {
            rel: "preload",
            href: y === "image" && x && x.imageSrcSet ? void 0 : g,
            as: y,
          },
          x,
        )),
        kn.set(z, g),
        E.querySelector(V) !== null ||
          (y === "style" && E.querySelector(Os(z))) ||
          (y === "script" && E.querySelector(Is(z))) ||
          ((y = E.createElement("link")),
          pn(y, "link", g),
          sn(y),
          E.head.appendChild(y)));
    }
  }
  function Eg(g, y) {
    gr.m(g, y);
    var x = Fo;
    if (x && g) {
      var E = y && typeof y.as == "string" ? y.as : "script",
        V =
          'link[rel="modulepreload"][as="' + Ln(E) + '"][href="' + Ln(g) + '"]',
        z = V;
      switch (E) {
        case "audioworklet":
        case "paintworklet":
        case "serviceworker":
        case "sharedworker":
        case "worker":
        case "script":
          z = ko(g);
      }
      if (
        !kn.has(z) &&
        ((g = q({ rel: "modulepreload", href: g }, y)),
        kn.set(z, g),
        x.querySelector(V) === null)
      ) {
        switch (E) {
          case "audioworklet":
          case "paintworklet":
          case "serviceworker":
          case "sharedworker":
          case "worker":
          case "script":
            if (x.querySelector(Is(z))) return;
        }
        ((E = x.createElement("link")),
          pn(E, "link", g),
          sn(E),
          x.head.appendChild(E));
      }
    }
  }
  function Sg(g, y, x) {
    gr.S(g, y, x);
    var E = Fo;
    if (E && g) {
      var V = lo(E).hoistableStyles,
        z = $o(g);
      y = y || "default";
      var ne = V.get(z);
      if (!ne) {
        var je = { loading: 0, preload: null };
        if ((ne = E.querySelector(Os(z)))) je.loading = 5;
        else {
          ((g = q({ rel: "stylesheet", href: g, "data-precedence": y }, x)),
            (x = kn.get(z)) && ic(g, x));
          var He = (ne = E.createElement("link"));
          (sn(He),
            pn(He, "link", g),
            (He._p = new Promise(function (Je, st) {
              ((He.onload = Je), (He.onerror = st));
            })),
            He.addEventListener("load", function () {
              je.loading |= 1;
            }),
            He.addEventListener("error", function () {
              je.loading |= 2;
            }),
            (je.loading |= 4),
            ki(ne, y, E));
        }
        ((ne = { type: "stylesheet", instance: ne, count: 1, state: je }),
          V.set(z, ne));
      }
    }
  }
  function Tg(g, y) {
    gr.X(g, y);
    var x = Fo;
    if (x && g) {
      var E = lo(x).hoistableScripts,
        V = ko(g),
        z = E.get(V);
      z ||
        ((z = x.querySelector(Is(V))),
        z ||
          ((g = q({ src: g, async: !0 }, y)),
          (y = kn.get(V)) && ac(g, y),
          (z = x.createElement("script")),
          sn(z),
          pn(z, "link", g),
          x.head.appendChild(z)),
        (z = { type: "script", instance: z, count: 1, state: null }),
        E.set(V, z));
    }
  }
  function Ag(g, y) {
    gr.M(g, y);
    var x = Fo;
    if (x && g) {
      var E = lo(x).hoistableScripts,
        V = ko(g),
        z = E.get(V);
      z ||
        ((z = x.querySelector(Is(V))),
        z ||
          ((g = q({ src: g, async: !0, type: "module" }, y)),
          (y = kn.get(V)) && ac(g, y),
          (z = x.createElement("script")),
          sn(z),
          pn(z, "link", g),
          x.head.appendChild(z)),
        (z = { type: "script", instance: z, count: 1, state: null }),
        E.set(V, z));
    }
  }
  function Jf(g, y, x, E) {
    var V = (V = yt.current) ? $i(V) : null;
    if (!V) throw Error(_(446));
    switch (g) {
      case "meta":
      case "title":
        return null;
      case "style":
        return typeof x.precedence == "string" && typeof x.href == "string"
          ? ((y = $o(x.href)),
            (x = lo(V).hoistableStyles),
            (E = x.get(y)),
            E ||
              ((E = { type: "style", instance: null, count: 0, state: null }),
              x.set(y, E)),
            E)
          : { type: "void", instance: null, count: 0, state: null };
      case "link":
        if (
          x.rel === "stylesheet" &&
          typeof x.href == "string" &&
          typeof x.precedence == "string"
        ) {
          g = $o(x.href);
          var z = lo(V).hoistableStyles,
            ne = z.get(g);
          if (
            (ne ||
              ((V = V.ownerDocument || V),
              (ne = {
                type: "stylesheet",
                instance: null,
                count: 0,
                state: { loading: 0, preload: null },
              }),
              z.set(g, ne),
              (z = V.querySelector(Os(g))) &&
                !z._p &&
                ((ne.instance = z), (ne.state.loading = 5)),
              kn.has(g) ||
                ((x = {
                  rel: "preload",
                  as: "style",
                  href: x.href,
                  crossOrigin: x.crossOrigin,
                  integrity: x.integrity,
                  media: x.media,
                  hrefLang: x.hrefLang,
                  referrerPolicy: x.referrerPolicy,
                }),
                kn.set(g, x),
                z || Rg(V, g, x, ne.state))),
            y && E === null)
          )
            throw Error(_(528, ""));
          return ne;
        }
        if (y && E !== null) throw Error(_(529, ""));
        return null;
      case "script":
        return (
          (y = x.async),
          (x = x.src),
          typeof x == "string" &&
          y &&
          typeof y != "function" &&
          typeof y != "symbol"
            ? ((y = ko(x)),
              (x = lo(V).hoistableScripts),
              (E = x.get(y)),
              E ||
                ((E = {
                  type: "script",
                  instance: null,
                  count: 0,
                  state: null,
                }),
                x.set(y, E)),
              E)
            : { type: "void", instance: null, count: 0, state: null }
        );
      default:
        throw Error(_(444, g));
    }
  }
  function $o(g) {
    return 'href="' + Ln(g) + '"';
  }
  function Os(g) {
    return 'link[rel="stylesheet"][' + g + "]";
  }
  function Qf(g) {
    return q({}, g, { "data-precedence": g.precedence, precedence: null });
  }
  function Rg(g, y, x, E) {
    g.querySelector('link[rel="preload"][as="style"][' + y + "]")
      ? (E.loading = 1)
      : ((y = g.createElement("link")),
        (E.preload = y),
        y.addEventListener("load", function () {
          return (E.loading |= 1);
        }),
        y.addEventListener("error", function () {
          return (E.loading |= 2);
        }),
        pn(y, "link", x),
        sn(y),
        g.head.appendChild(y));
  }
  function ko(g) {
    return '[src="' + Ln(g) + '"]';
  }
  function Is(g) {
    return "script[async]" + g;
  }
  function ep(g, y, x) {
    if ((y.count++, y.instance === null))
      switch (y.type) {
        case "style":
          var E = g.querySelector('style[data-href~="' + Ln(x.href) + '"]');
          if (E) return ((y.instance = E), sn(E), E);
          var V = q({}, x, {
            "data-href": x.href,
            "data-precedence": x.precedence,
            href: null,
            precedence: null,
          });
          return (
            (E = (g.ownerDocument || g).createElement("style")),
            sn(E),
            pn(E, "style", V),
            ki(E, x.precedence, g),
            (y.instance = E)
          );
        case "stylesheet":
          V = $o(x.href);
          var z = g.querySelector(Os(V));
          if (z) return ((y.state.loading |= 4), (y.instance = z), sn(z), z);
          ((E = Qf(x)),
            (V = kn.get(V)) && ic(E, V),
            (z = (g.ownerDocument || g).createElement("link")),
            sn(z));
          var ne = z;
          return (
            (ne._p = new Promise(function (je, He) {
              ((ne.onload = je), (ne.onerror = He));
            })),
            pn(z, "link", E),
            (y.state.loading |= 4),
            ki(z, x.precedence, g),
            (y.instance = z)
          );
        case "script":
          return (
            (z = ko(x.src)),
            (V = g.querySelector(Is(z)))
              ? ((y.instance = V), sn(V), V)
              : ((E = x),
                (V = kn.get(z)) && ((E = q({}, x)), ac(E, V)),
                (g = g.ownerDocument || g),
                (V = g.createElement("script")),
                sn(V),
                pn(V, "link", E),
                g.head.appendChild(V),
                (y.instance = V))
          );
        case "void":
          return null;
        default:
          throw Error(_(443, y.type));
      }
    else
      y.type === "stylesheet" &&
        (y.state.loading & 4) === 0 &&
        ((E = y.instance), (y.state.loading |= 4), ki(E, x.precedence, g));
    return y.instance;
  }
  function ki(g, y, x) {
    for (
      var E = x.querySelectorAll(
          'link[rel="stylesheet"][data-precedence],style[data-precedence]',
        ),
        V = E.length ? E[E.length - 1] : null,
        z = V,
        ne = 0;
      ne < E.length;
      ne++
    ) {
      var je = E[ne];
      if (je.dataset.precedence === y) z = je;
      else if (z !== V) break;
    }
    z
      ? z.parentNode.insertBefore(g, z.nextSibling)
      : ((y = x.nodeType === 9 ? x.head : x), y.insertBefore(g, y.firstChild));
  }
  function ic(g, y) {
    (g.crossOrigin == null && (g.crossOrigin = y.crossOrigin),
      g.referrerPolicy == null && (g.referrerPolicy = y.referrerPolicy),
      g.title == null && (g.title = y.title));
  }
  function ac(g, y) {
    (g.crossOrigin == null && (g.crossOrigin = y.crossOrigin),
      g.referrerPolicy == null && (g.referrerPolicy = y.referrerPolicy),
      g.integrity == null && (g.integrity = y.integrity));
  }
  var Ui = null;
  function tp(g, y, x) {
    if (Ui === null) {
      var E = new Map(),
        V = (Ui = new Map());
      V.set(x, E);
    } else ((V = Ui), (E = V.get(x)), E || ((E = new Map()), V.set(x, E)));
    if (E.has(g)) return E;
    for (
      E.set(g, null), x = x.getElementsByTagName(g), V = 0;
      V < x.length;
      V++
    ) {
      var z = x[V];
      if (
        !(
          z[Yo] ||
          z[ln] ||
          (g === "link" && z.getAttribute("rel") === "stylesheet")
        ) &&
        z.namespaceURI !== "http://www.w3.org/2000/svg"
      ) {
        var ne = z.getAttribute(y) || "";
        ne = g + ne;
        var je = E.get(ne);
        je ? je.push(z) : E.set(ne, [z]);
      }
    }
    return E;
  }
  function np(g, y, x) {
    ((g = g.ownerDocument || g),
      g.head.insertBefore(
        x,
        y === "title" ? g.querySelector("head > title") : null,
      ));
  }
  function Cg(g, y, x) {
    if (x === 1 || y.itemProp != null) return !1;
    switch (g) {
      case "meta":
      case "title":
        return !0;
      case "style":
        if (
          typeof y.precedence != "string" ||
          typeof y.href != "string" ||
          y.href === ""
        )
          break;
        return !0;
      case "link":
        if (
          typeof y.rel != "string" ||
          typeof y.href != "string" ||
          y.href === "" ||
          y.onLoad ||
          y.onError
        )
          break;
        switch (y.rel) {
          case "stylesheet":
            return (
              (g = y.disabled),
              typeof y.precedence == "string" && g == null
            );
          default:
            return !0;
        }
      case "script":
        if (
          y.async &&
          typeof y.async != "function" &&
          typeof y.async != "symbol" &&
          !y.onLoad &&
          !y.onError &&
          y.src &&
          typeof y.src == "string"
        )
          return !0;
    }
    return !1;
  }
  function rp(g) {
    return !(g.type === "stylesheet" && (g.state.loading & 3) === 0);
  }
  function Mg(g, y, x, E) {
    if (
      x.type === "stylesheet" &&
      (typeof E.media != "string" || matchMedia(E.media).matches !== !1) &&
      (x.state.loading & 4) === 0
    ) {
      if (x.instance === null) {
        var V = $o(E.href),
          z = y.querySelector(Os(V));
        if (z) {
          ((y = z._p),
            y !== null &&
              typeof y == "object" &&
              typeof y.then == "function" &&
              (g.count++, (g = Hi.bind(g)), y.then(g, g)),
            (x.state.loading |= 4),
            (x.instance = z),
            sn(z));
          return;
        }
        ((z = y.ownerDocument || y),
          (E = Qf(E)),
          (V = kn.get(V)) && ic(E, V),
          (z = z.createElement("link")),
          sn(z));
        var ne = z;
        ((ne._p = new Promise(function (je, He) {
          ((ne.onload = je), (ne.onerror = He));
        })),
          pn(z, "link", E),
          (x.instance = z));
      }
      (g.stylesheets === null && (g.stylesheets = new Map()),
        g.stylesheets.set(x, y),
        (y = x.state.preload) &&
          (x.state.loading & 3) === 0 &&
          (g.count++,
          (x = Hi.bind(g)),
          y.addEventListener("load", x),
          y.addEventListener("error", x)));
    }
  }
  var lc = 0;
  function Ng(g, y) {
    return (
      g.stylesheets && g.count === 0 && Wi(g, g.stylesheets),
      0 < g.count || 0 < g.imgCount
        ? function (x) {
            var E = setTimeout(function () {
              if ((g.stylesheets && Wi(g, g.stylesheets), g.unsuspend)) {
                var z = g.unsuspend;
                ((g.unsuspend = null), z());
              }
            }, 6e4 + y);
            0 < g.imgBytes && lc === 0 && (lc = 62500 * ug());
            var V = setTimeout(
              function () {
                if (
                  ((g.waitingForImages = !1),
                  g.count === 0 &&
                    (g.stylesheets && Wi(g, g.stylesheets), g.unsuspend))
                ) {
                  var z = g.unsuspend;
                  ((g.unsuspend = null), z());
                }
              },
              (g.imgBytes > lc ? 50 : 800) + y,
            );
            return (
              (g.unsuspend = x),
              function () {
                ((g.unsuspend = null), clearTimeout(E), clearTimeout(V));
              }
            );
          }
        : null
    );
  }
  function Hi() {
    if (
      (this.count--,
      this.count === 0 && (this.imgCount === 0 || !this.waitingForImages))
    ) {
      if (this.stylesheets) Wi(this, this.stylesheets);
      else if (this.unsuspend) {
        var g = this.unsuspend;
        ((this.unsuspend = null), g());
      }
    }
  }
  var Gi = null;
  function Wi(g, y) {
    ((g.stylesheets = null),
      g.unsuspend !== null &&
        (g.count++,
        (Gi = new Map()),
        y.forEach(Og, g),
        (Gi = null),
        Hi.call(g)));
  }
  function Og(g, y) {
    if (!(y.state.loading & 4)) {
      var x = Gi.get(g);
      if (x) var E = x.get(null);
      else {
        ((x = new Map()), Gi.set(g, x));
        for (
          var V = g.querySelectorAll(
              "link[data-precedence],style[data-precedence]",
            ),
            z = 0;
          z < V.length;
          z++
        ) {
          var ne = V[z];
          (ne.nodeName === "LINK" || ne.getAttribute("media") !== "not all") &&
            (x.set(ne.dataset.precedence, ne), (E = ne));
        }
        E && x.set(null, E);
      }
      ((V = y.instance),
        (ne = V.getAttribute("data-precedence")),
        (z = x.get(ne) || E),
        z === E && x.set(null, V),
        x.set(ne, V),
        this.count++,
        (E = Hi.bind(this)),
        V.addEventListener("load", E),
        V.addEventListener("error", E),
        z
          ? z.parentNode.insertBefore(V, z.nextSibling)
          : ((g = g.nodeType === 9 ? g.head : g),
            g.insertBefore(V, g.firstChild)),
        (y.state.loading |= 4));
    }
  }
  var Ds = {
    $$typeof: Ve,
    Provider: null,
    Consumer: null,
    _currentValue: Qe,
    _currentValue2: Qe,
    _threadCount: 0,
  };
  function Ig(g, y, x, E, V, z, ne, je, He) {
    ((this.tag = 1),
      (this.containerInfo = g),
      (this.pingCache = this.current = this.pendingChildren = null),
      (this.timeoutHandle = -1),
      (this.callbackNode =
        this.next =
        this.pendingContext =
        this.context =
        this.cancelPendingCommit =
          null),
      (this.callbackPriority = 0),
      (this.expirationTimes = ra(-1)),
      (this.entangledLanes =
        this.shellSuspendCounter =
        this.errorRecoveryDisabledLanes =
        this.expiredLanes =
        this.warmLanes =
        this.pingedLanes =
        this.suspendedLanes =
        this.pendingLanes =
          0),
      (this.entanglements = ra(0)),
      (this.hiddenUpdates = ra(null)),
      (this.identifierPrefix = E),
      (this.onUncaughtError = V),
      (this.onCaughtError = z),
      (this.onRecoverableError = ne),
      (this.pooledCache = null),
      (this.pooledCacheLanes = 0),
      (this.formState = He),
      (this.incompleteTransitions = new Map()));
  }
  function op(g, y, x, E, V, z, ne, je, He, Je, st, ft) {
    return (
      (g = new Ig(g, y, x, ne, He, Je, st, ft, je)),
      (y = 1),
      z === !0 && (y |= 24),
      (z = Rn(3, null, null, y)),
      (g.current = z),
      (z.stateNode = g),
      (y = $a()),
      y.refCount++,
      (g.pooledCache = y),
      y.refCount++,
      (z.memoizedState = { element: E, isDehydrated: x, cache: y }),
      Ga(z),
      g
    );
  }
  function sp(g) {
    return g ? ((g = bo), g) : bo;
  }
  function ip(g, y, x, E, V, z) {
    ((V = sp(V)),
      E.context === null ? (E.context = V) : (E.pendingContext = V),
      (E = Sr(y)),
      (E.payload = { element: x }),
      (z = z === void 0 ? null : z),
      z !== null && (E.callback = z),
      (x = Tr(g, E, y)),
      x !== null && (vn(x, g, y), ds(x, g, y)));
  }
  function ap(g, y) {
    if (((g = g.memoizedState), g !== null && g.dehydrated !== null)) {
      var x = g.retryLane;
      g.retryLane = x !== 0 && x < y ? x : y;
    }
  }
  function cc(g, y) {
    (ap(g, y), (g = g.alternate) && ap(g, y));
  }
  function lp(g) {
    if (g.tag === 13 || g.tag === 31) {
      var y = Wr(g, 67108864);
      (y !== null && vn(y, g, 67108864), cc(g, 67108864));
    }
  }
  function cp(g) {
    if (g.tag === 13 || g.tag === 31) {
      var y = In();
      y = oa(y);
      var x = Wr(g, y);
      (x !== null && vn(x, g, y), cc(g, y));
    }
  }
  var qi = !0;
  function Dg(g, y, x, E) {
    var V = $e.T;
    $e.T = null;
    var z = Ye.p;
    try {
      ((Ye.p = 2), uc(g, y, x, E));
    } finally {
      ((Ye.p = z), ($e.T = V));
    }
  }
  function Lg(g, y, x, E) {
    var V = $e.T;
    $e.T = null;
    var z = Ye.p;
    try {
      ((Ye.p = 8), uc(g, y, x, E));
    } finally {
      ((Ye.p = z), ($e.T = V));
    }
  }
  function uc(g, y, x, E) {
    if (qi) {
      var V = dc(E);
      if (V === null) (Xl(g, y, E, Yi, x), dp(g, E));
      else if (jg(V, g, y, x, E)) E.stopPropagation();
      else if ((dp(g, E), y & 4 && -1 < Pg.indexOf(g))) {
        for (; V !== null; ) {
          var z = ao(V);
          if (z !== null)
            switch (z.tag) {
              case 3:
                if (((z = z.stateNode), z.current.memoizedState.isDehydrated)) {
                  var ne = $r(z.pendingLanes);
                  if (ne !== 0) {
                    var je = z;
                    for (je.pendingLanes |= 2, je.entangledLanes |= 2; ne; ) {
                      var He = 1 << (31 - Tn(ne));
                      ((je.entanglements[1] |= He), (ne &= ~He));
                    }
                    (Xn(z), (Bt & 6) === 0 && ((Ni = En() + 500), Rs(0)));
                  }
                }
                break;
              case 31:
              case 13:
                ((je = Wr(z, 2)), je !== null && vn(je, z, 2), Ii(), cc(z, 2));
            }
          if (((z = dc(E)), z === null && Xl(g, y, E, Yi, x), z === V)) break;
          V = z;
        }
        V !== null && E.stopPropagation();
      } else Xl(g, y, E, null, x);
    }
  }
  function dc(g) {
    return ((g = pa(g)), fc(g));
  }
  var Yi = null;
  function fc(g) {
    if (((Yi = null), (g = io(g)), g !== null)) {
      var y = v(g);
      if (y === null) g = null;
      else {
        var x = y.tag;
        if (x === 13) {
          if (((g = S(y)), g !== null)) return g;
          g = null;
        } else if (x === 31) {
          if (((g = R(y)), g !== null)) return g;
          g = null;
        } else if (x === 3) {
          if (y.stateNode.current.memoizedState.isDehydrated)
            return y.tag === 3 ? y.stateNode.containerInfo : null;
          g = null;
        } else y !== g && (g = null);
      }
    }
    return ((Yi = g), null);
  }
  function up(g) {
    switch (g) {
      case "beforetoggle":
      case "cancel":
      case "click":
      case "close":
      case "contextmenu":
      case "copy":
      case "cut":
      case "auxclick":
      case "dblclick":
      case "dragend":
      case "dragstart":
      case "drop":
      case "focusin":
      case "focusout":
      case "input":
      case "invalid":
      case "keydown":
      case "keypress":
      case "keyup":
      case "mousedown":
      case "mouseup":
      case "paste":
      case "pause":
      case "play":
      case "pointercancel":
      case "pointerdown":
      case "pointerup":
      case "ratechange":
      case "reset":
      case "resize":
      case "seeked":
      case "submit":
      case "toggle":
      case "touchcancel":
      case "touchend":
      case "touchstart":
      case "volumechange":
      case "change":
      case "selectionchange":
      case "textInput":
      case "compositionstart":
      case "compositionend":
      case "compositionupdate":
      case "beforeblur":
      case "afterblur":
      case "beforeinput":
      case "blur":
      case "fullscreenchange":
      case "focus":
      case "hashchange":
      case "popstate":
      case "select":
      case "selectstart":
        return 2;
      case "drag":
      case "dragenter":
      case "dragexit":
      case "dragleave":
      case "dragover":
      case "mousemove":
      case "mouseout":
      case "mouseover":
      case "pointermove":
      case "pointerout":
      case "pointerover":
      case "scroll":
      case "touchmove":
      case "wheel":
      case "mouseenter":
      case "mouseleave":
      case "pointerenter":
      case "pointerleave":
        return 8;
      case "message":
        switch (wp()) {
          case hc:
            return 2;
          case _c:
            return 8;
          case Bs:
          case xp:
            return 32;
          case yc:
            return 268435456;
          default:
            return 32;
        }
      default:
        return 32;
    }
  }
  var pc = !1,
    jr = null,
    Br = null,
    Vr = null,
    Ls = new Map(),
    Ps = new Map(),
    zr = [],
    Pg =
      "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset".split(
        " ",
      );
  function dp(g, y) {
    switch (g) {
      case "focusin":
      case "focusout":
        jr = null;
        break;
      case "dragenter":
      case "dragleave":
        Br = null;
        break;
      case "mouseover":
      case "mouseout":
        Vr = null;
        break;
      case "pointerover":
      case "pointerout":
        Ls.delete(y.pointerId);
        break;
      case "gotpointercapture":
      case "lostpointercapture":
        Ps.delete(y.pointerId);
    }
  }
  function js(g, y, x, E, V, z) {
    return g === null || g.nativeEvent !== z
      ? ((g = {
          blockedOn: y,
          domEventName: x,
          eventSystemFlags: E,
          nativeEvent: z,
          targetContainers: [V],
        }),
        y !== null && ((y = ao(y)), y !== null && lp(y)),
        g)
      : ((g.eventSystemFlags |= E),
        (y = g.targetContainers),
        V !== null && y.indexOf(V) === -1 && y.push(V),
        g);
  }
  function jg(g, y, x, E, V) {
    switch (y) {
      case "focusin":
        return ((jr = js(jr, g, y, x, E, V)), !0);
      case "dragenter":
        return ((Br = js(Br, g, y, x, E, V)), !0);
      case "mouseover":
        return ((Vr = js(Vr, g, y, x, E, V)), !0);
      case "pointerover":
        var z = V.pointerId;
        return (Ls.set(z, js(Ls.get(z) || null, g, y, x, E, V)), !0);
      case "gotpointercapture":
        return (
          (z = V.pointerId),
          Ps.set(z, js(Ps.get(z) || null, g, y, x, E, V)),
          !0
        );
    }
    return !1;
  }
  function fp(g) {
    var y = io(g.target);
    if (y !== null) {
      var x = v(y);
      if (x !== null) {
        if (((y = x.tag), y === 13)) {
          if (((y = S(x)), y !== null)) {
            ((g.blockedOn = y),
              Sc(g.priority, function () {
                cp(x);
              }));
            return;
          }
        } else if (y === 31) {
          if (((y = R(x)), y !== null)) {
            ((g.blockedOn = y),
              Sc(g.priority, function () {
                cp(x);
              }));
            return;
          }
        } else if (y === 3 && x.stateNode.current.memoizedState.isDehydrated) {
          g.blockedOn = x.tag === 3 ? x.stateNode.containerInfo : null;
          return;
        }
      }
    }
    g.blockedOn = null;
  }
  function Ki(g) {
    if (g.blockedOn !== null) return !1;
    for (var y = g.targetContainers; 0 < y.length; ) {
      var x = dc(g.nativeEvent);
      if (x === null) {
        x = g.nativeEvent;
        var E = new x.constructor(x.type, x);
        ((fa = E), x.target.dispatchEvent(E), (fa = null));
      } else return ((y = ao(x)), y !== null && lp(y), (g.blockedOn = x), !1);
      y.shift();
    }
    return !0;
  }
  function pp(g, y, x) {
    Ki(g) && x.delete(y);
  }
  function Bg() {
    ((pc = !1),
      jr !== null && Ki(jr) && (jr = null),
      Br !== null && Ki(Br) && (Br = null),
      Vr !== null && Ki(Vr) && (Vr = null),
      Ls.forEach(pp),
      Ps.forEach(pp));
  }
  function Xi(g, y) {
    g.blockedOn === y &&
      ((g.blockedOn = null),
      pc ||
        ((pc = !0),
        a.unstable_scheduleCallback(a.unstable_NormalPriority, Bg)));
  }
  var Zi = null;
  function mp(g) {
    Zi !== g &&
      ((Zi = g),
      a.unstable_scheduleCallback(a.unstable_NormalPriority, function () {
        Zi === g && (Zi = null);
        for (var y = 0; y < g.length; y += 3) {
          var x = g[y],
            E = g[y + 1],
            V = g[y + 2];
          if (typeof E != "function") {
            if (fc(E || x) === null) continue;
            break;
          }
          var z = ao(x);
          z !== null &&
            (g.splice(y, 3),
            (y -= 3),
            dl(z, { pending: !0, data: V, method: x.method, action: E }, E, V));
        }
      }));
  }
  function Uo(g) {
    function y(He) {
      return Xi(He, g);
    }
    (jr !== null && Xi(jr, g),
      Br !== null && Xi(Br, g),
      Vr !== null && Xi(Vr, g),
      Ls.forEach(y),
      Ps.forEach(y));
    for (var x = 0; x < zr.length; x++) {
      var E = zr[x];
      E.blockedOn === g && (E.blockedOn = null);
    }
    for (; 0 < zr.length && ((x = zr[0]), x.blockedOn === null); )
      (fp(x), x.blockedOn === null && zr.shift());
    if (((x = (g.ownerDocument || g).$$reactFormReplay), x != null))
      for (E = 0; E < x.length; E += 3) {
        var V = x[E],
          z = x[E + 1],
          ne = V[hn] || null;
        if (typeof z == "function") ne || mp(x);
        else if (ne) {
          var je = null;
          if (z && z.hasAttribute("formAction")) {
            if (((V = z), (ne = z[hn] || null))) je = ne.formAction;
            else if (fc(V) !== null) continue;
          } else je = ne.action;
          (typeof je == "function"
            ? (x[E + 1] = je)
            : (x.splice(E, 3), (E -= 3)),
            mp(x));
        }
      }
  }
  function gp() {
    function g(z) {
      z.canIntercept &&
        z.info === "react-transition" &&
        z.intercept({
          handler: function () {
            return new Promise(function (ne) {
              return (V = ne);
            });
          },
          focusReset: "manual",
          scroll: "manual",
        });
    }
    function y() {
      (V !== null && (V(), (V = null)), E || setTimeout(x, 20));
    }
    function x() {
      if (!E && !navigation.transition) {
        var z = navigation.currentEntry;
        z &&
          z.url != null &&
          navigation.navigate(z.url, {
            state: z.getState(),
            info: "react-transition",
            history: "replace",
          });
      }
    }
    if (typeof navigation == "object") {
      var E = !1,
        V = null;
      return (
        navigation.addEventListener("navigate", g),
        navigation.addEventListener("navigatesuccess", y),
        navigation.addEventListener("navigateerror", y),
        setTimeout(x, 100),
        function () {
          ((E = !0),
            navigation.removeEventListener("navigate", g),
            navigation.removeEventListener("navigatesuccess", y),
            navigation.removeEventListener("navigateerror", y),
            V !== null && (V(), (V = null)));
        }
      );
    }
  }
  function mc(g) {
    this._internalRoot = g;
  }
  ((Ji.prototype.render = mc.prototype.render =
    function (g) {
      var y = this._internalRoot;
      if (y === null) throw Error(_(409));
      var x = y.current,
        E = In();
      ip(x, E, g, y, null, null);
    }),
    (Ji.prototype.unmount = mc.prototype.unmount =
      function () {
        var g = this._internalRoot;
        if (g !== null) {
          this._internalRoot = null;
          var y = g.containerInfo;
          (ip(g.current, 2, null, g, null, null), Ii(), (y[so] = null));
        }
      }));
  function Ji(g) {
    this._internalRoot = g;
  }
  Ji.prototype.unstable_scheduleHydration = function (g) {
    if (g) {
      var y = Ec();
      g = { blockedOn: null, target: g, priority: y };
      for (var x = 0; x < zr.length && y !== 0 && y < zr[x].priority; x++);
      (zr.splice(x, 0, g), x === 0 && fp(g));
    }
  };
  var hp = e.version;
  if (hp !== "19.2.3") throw Error(_(527, hp, "19.2.3"));
  Ye.findDOMNode = function (g) {
    var y = g._reactInternals;
    if (y === void 0)
      throw typeof g.render == "function"
        ? Error(_(188))
        : ((g = Object.keys(g).join(",")), Error(_(268, g)));
    return (
      (g = j(y)),
      (g = g !== null ? F(g) : null),
      (g = g === null ? null : g.stateNode),
      g
    );
  };
  var Vg = {
    bundleType: 0,
    version: "19.2.3",
    rendererPackageName: "react-dom",
    currentDispatcherRef: $e,
    reconcilerVersion: "19.2.3",
  };
  if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") {
    var Qi = __REACT_DEVTOOLS_GLOBAL_HOOK__;
    if (!Qi.isDisabled && Qi.supportsFiber)
      try {
        ((Go = Qi.inject(Vg)), (Sn = Qi));
      } catch {}
  }
  return (
    (reactDomClient_production.createRoot = function (g, y) {
      if (!w(g)) throw Error(_(299));
      var x = !1,
        E = "",
        V = vd,
        z = Ed,
        ne = Sd;
      return (
        y != null &&
          (y.unstable_strictMode === !0 && (x = !0),
          y.identifierPrefix !== void 0 && (E = y.identifierPrefix),
          y.onUncaughtError !== void 0 && (V = y.onUncaughtError),
          y.onCaughtError !== void 0 && (z = y.onCaughtError),
          y.onRecoverableError !== void 0 && (ne = y.onRecoverableError)),
        (y = op(g, 1, !1, null, null, x, E, null, V, z, ne, gp)),
        (g[so] = y.current),
        Kl(g),
        new mc(y)
      );
    }),
    (reactDomClient_production.hydrateRoot = function (g, y, x) {
      if (!w(g)) throw Error(_(299));
      var E = !1,
        V = "",
        z = vd,
        ne = Ed,
        je = Sd,
        He = null;
      return (
        x != null &&
          (x.unstable_strictMode === !0 && (E = !0),
          x.identifierPrefix !== void 0 && (V = x.identifierPrefix),
          x.onUncaughtError !== void 0 && (z = x.onUncaughtError),
          x.onCaughtError !== void 0 && (ne = x.onCaughtError),
          x.onRecoverableError !== void 0 && (je = x.onRecoverableError),
          x.formState !== void 0 && (He = x.formState)),
        (y = op(g, 1, !0, y, x ?? null, E, V, He, z, ne, je, gp)),
        (y.context = sp(null)),
        (x = y.current),
        (E = In()),
        (E = oa(E)),
        (V = Sr(E)),
        (V.callback = null),
        Tr(x, V, E),
        (x = E),
        (y.current.lanes = x),
        qo(y, x),
        Xn(y),
        (g[so] = y.current),
        Kl(g),
        new Ji(y)
      );
    }),
    (reactDomClient_production.version = "19.2.3"),
    reactDomClient_production
  );
}
var hasRequiredClient;
function requireClient() {
  if (hasRequiredClient) return client.exports;
  hasRequiredClient = 1;
  function a() {
    if (
      !(
        typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" ||
        typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function"
      )
    )
      try {
        __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(a);
      } catch (e) {
        console.error(e);
      }
  }
  return (
    a(),
    (client.exports = requireReactDomClient_production()),
    client.exports
  );
}
var clientExports = requireClient();
function r$6(a) {
  var e,
    f,
    _ = "";
  if (typeof a == "string" || typeof a == "number") _ += a;
  else if (typeof a == "object")
    if (Array.isArray(a)) {
      var w = a.length;
      for (e = 0; e < w; e++)
        a[e] && (f = r$6(a[e])) && (_ && (_ += " "), (_ += f));
    } else for (f in a) a[f] && (_ && (_ += " "), (_ += f));
  return _;
}
function clsx() {
  for (var a, e, f = 0, _ = "", w = arguments.length; f < w; f++)
    (a = arguments[f]) && (e = r$6(a)) && (_ && (_ += " "), (_ += e));
  return _;
}
const falsyToString = (a) =>
    typeof a == "boolean" ? `${a}` : a === 0 ? "0" : a,
  cx = clsx,
  cva = (a, e) => (f) => {
    var _;
    if (e?.variants == null) return cx(a, f?.class, f?.className);
    const { variants: w, defaultVariants: v } = e,
      S = Object.keys(w).map((j) => {
        const F = f?.[j],
          q = v?.[j];
        if (F === null) return null;
        const Q = falsyToString(F) || falsyToString(q);
        return w[j][Q];
      }),
      R =
        f &&
        Object.entries(f).reduce((j, F) => {
          let [q, Q] = F;
          return (Q === void 0 || (j[q] = Q), j);
        }, {}),
      O =
        e == null || (_ = e.compoundVariants) === null || _ === void 0
          ? void 0
          : _.reduce((j, F) => {
              let { class: q, className: Q, ...te } = F;
              return Object.entries(te).every((se) => {
                let [re, Oe] = se;
                return Array.isArray(Oe)
                  ? Oe.includes({ ...v, ...R }[re])
                  : { ...v, ...R }[re] === Oe;
              })
                ? [...j, q, Q]
                : j;
            }, []);
    return cx(a, S, O, f?.class, f?.className);
  };
/**
 * @license lucide-react v0.446.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const toKebabCase = (a) =>
    a.replace(/([a-z0-9])([A-Z])/g, "$1-$2").toLowerCase(),
  mergeClasses = (...a) =>
    a.filter((e, f, _) => !!e && _.indexOf(e) === f).join(" ");
/**
 * @license lucide-react v0.446.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ var defaultAttributes = {
  xmlns: "http://www.w3.org/2000/svg",
  width: 24,
  height: 24,
  viewBox: "0 0 24 24",
  fill: "none",
  stroke: "currentColor",
  strokeWidth: 2,
  strokeLinecap: "round",
  strokeLinejoin: "round",
};
/**
 * @license lucide-react v0.446.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const Icon$1 = reactExports.forwardRef(
  (
    {
      color: a = "currentColor",
      size: e = 24,
      strokeWidth: f = 2,
      absoluteStrokeWidth: _,
      className: w = "",
      children: v,
      iconNode: S,
      ...R
    },
    O,
  ) =>
    reactExports.createElement(
      "svg",
      {
        ref: O,
        ...defaultAttributes,
        width: e,
        height: e,
        stroke: a,
        strokeWidth: _ ? (Number(f) * 24) / Number(e) : f,
        className: mergeClasses("lucide", w),
        ...R,
      },
      [
        ...S.map(([j, F]) => reactExports.createElement(j, F)),
        ...(Array.isArray(v) ? v : [v]),
      ],
    ),
);
/**
 * @license lucide-react v0.446.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const createLucideIcon = (a, e) => {
  const f = reactExports.forwardRef(({ className: _, ...w }, v) =>
    reactExports.createElement(Icon$1, {
      ref: v,
      iconNode: e,
      className: mergeClasses(`lucide-${toKebabCase(a)}`, _),
      ...w,
    }),
  );
  return ((f.displayName = `${a}`), f);
};
/**
 * @license lucide-react v0.446.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const Check = createLucideIcon("Check", [
  ["path", { d: "M20 6 9 17l-5-5", key: "1gmf2c" }],
]);
/**
 * @license lucide-react v0.446.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const ChevronDown = createLucideIcon("ChevronDown", [
  ["path", { d: "m6 9 6 6 6-6", key: "qrunsl" }],
]);
/**
 * @license lucide-react v0.446.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const ChevronRight = createLucideIcon("ChevronRight", [
  ["path", { d: "m9 18 6-6-6-6", key: "mthhwq" }],
]);
/**
 * @license lucide-react v0.446.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const ChevronUp = createLucideIcon("ChevronUp", [
  ["path", { d: "m18 15-6-6-6 6", key: "153udz" }],
]);
/**
 * @license lucide-react v0.446.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const Circle = createLucideIcon("Circle", [
  ["circle", { cx: "12", cy: "12", r: "10", key: "1mglay" }],
]);
/**
 * @license lucide-react v0.446.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const LoaderCircle = createLucideIcon("LoaderCircle", [
  ["path", { d: "M21 12a9 9 0 1 1-6.219-8.56", key: "13zald" }],
]);
/**
 * @license lucide-react v0.446.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const PanelLeft = createLucideIcon("PanelLeft", [
  [
    "rect",
    { width: "18", height: "18", x: "3", y: "3", rx: "2", key: "afitv7" },
  ],
  ["path", { d: "M9 3v18", key: "fh3hqa" }],
]);
/**
 * @license lucide-react v0.446.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const Search = createLucideIcon("Search", [
  ["circle", { cx: "11", cy: "11", r: "8", key: "4ej97u" }],
  ["path", { d: "m21 21-4.3-4.3", key: "1qie3q" }],
]);
/**
 * @license lucide-react v0.446.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const Send = createLucideIcon("Send", [
  [
    "path",
    {
      d: "M14.536 21.686a.5.5 0 0 0 .937-.024l6.5-19a.496.496 0 0 0-.635-.635l-19 6.5a.5.5 0 0 0-.024.937l7.93 3.18a2 2 0 0 1 1.112 1.11z",
      key: "1ffxy3",
    },
  ],
  ["path", { d: "m21.854 2.147-10.94 10.939", key: "12cjpa" }],
]);
/**
 * @license lucide-react v0.446.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const Square = createLucideIcon("Square", [
  [
    "rect",
    { width: "18", height: "18", x: "3", y: "3", rx: "2", key: "afitv7" },
  ],
]);
/**
 * @license lucide-react v0.446.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const X$1 = createLucideIcon("X", [
  ["path", { d: "M18 6 6 18", key: "1bl5f8" }],
  ["path", { d: "m6 6 12 12", key: "d8bk6v" }],
]);
function setRef(a, e) {
  if (typeof a == "function") return a(e);
  a != null && (a.current = e);
}
function composeRefs(...a) {
  return (e) => {
    let f = !1;
    const _ = a.map((w) => {
      const v = setRef(w, e);
      return (!f && typeof v == "function" && (f = !0), v);
    });
    if (f)
      return () => {
        for (let w = 0; w < _.length; w++) {
          const v = _[w];
          typeof v == "function" ? v() : setRef(a[w], null);
        }
      };
  };
}
function useComposedRefs(...a) {
  return reactExports.useCallback(composeRefs(...a), a);
}
var REACT_LAZY_TYPE = Symbol.for("react.lazy"),
  use = React[" use ".trim().toString()];
function isPromiseLike(a) {
  return typeof a == "object" && a !== null && "then" in a;
}
function isLazyComponent(a) {
  return (
    a != null &&
    typeof a == "object" &&
    "$$typeof" in a &&
    a.$$typeof === REACT_LAZY_TYPE &&
    "_payload" in a &&
    isPromiseLike(a._payload)
  );
}
function createSlot$5(a) {
  const e = createSlotClone$5(a),
    f = reactExports.forwardRef((_, w) => {
      let { children: v, ...S } = _;
      isLazyComponent(v) && typeof use == "function" && (v = use(v._payload));
      const R = reactExports.Children.toArray(v),
        O = R.find(isSlottable$5);
      if (O) {
        const j = O.props.children,
          F = R.map((q) =>
            q === O
              ? reactExports.Children.count(j) > 1
                ? reactExports.Children.only(null)
                : reactExports.isValidElement(j)
                  ? j.props.children
                  : null
              : q,
          );
        return jsxRuntimeExports.jsx(e, {
          ...S,
          ref: w,
          children: reactExports.isValidElement(j)
            ? reactExports.cloneElement(j, void 0, F)
            : null,
        });
      }
      return jsxRuntimeExports.jsx(e, { ...S, ref: w, children: v });
    });
  return ((f.displayName = `${a}.Slot`), f);
}
var Slot$3 = createSlot$5("Slot");
function createSlotClone$5(a) {
  const e = reactExports.forwardRef((f, _) => {
    let { children: w, ...v } = f;
    if (
      (isLazyComponent(w) && typeof use == "function" && (w = use(w._payload)),
      reactExports.isValidElement(w))
    ) {
      const S = getElementRef$6(w),
        R = mergeProps$5(v, w.props);
      return (
        w.type !== reactExports.Fragment && (R.ref = _ ? composeRefs(_, S) : S),
        reactExports.cloneElement(w, R)
      );
    }
    return reactExports.Children.count(w) > 1
      ? reactExports.Children.only(null)
      : null;
  });
  return ((e.displayName = `${a}.SlotClone`), e);
}
var SLOTTABLE_IDENTIFIER$6 = Symbol("radix.slottable");
function isSlottable$5(a) {
  return (
    reactExports.isValidElement(a) &&
    typeof a.type == "function" &&
    "__radixId" in a.type &&
    a.type.__radixId === SLOTTABLE_IDENTIFIER$6
  );
}
function mergeProps$5(a, e) {
  const f = { ...e };
  for (const _ in e) {
    const w = a[_],
      v = e[_];
    /^on[A-Z]/.test(_)
      ? w && v
        ? (f[_] = (...R) => {
            const O = v(...R);
            return (w(...R), O);
          })
        : w && (f[_] = w)
      : _ === "style"
        ? (f[_] = { ...w, ...v })
        : _ === "className" && (f[_] = [w, v].filter(Boolean).join(" "));
  }
  return { ...a, ...f };
}
function getElementRef$6(a) {
  let e = Object.getOwnPropertyDescriptor(a.props, "ref")?.get,
    f = e && "isReactWarning" in e && e.isReactWarning;
  return f
    ? a.ref
    : ((e = Object.getOwnPropertyDescriptor(a, "ref")?.get),
      (f = e && "isReactWarning" in e && e.isReactWarning),
      f ? a.props.ref : a.props.ref || a.ref);
}
const CLASS_PART_SEPARATOR = "-",
  createClassGroupUtils = (a) => {
    const e = createClassMap(a),
      { conflictingClassGroups: f, conflictingClassGroupModifiers: _ } = a;
    return {
      getClassGroupId: (S) => {
        const R = S.split(CLASS_PART_SEPARATOR);
        return (
          R[0] === "" && R.length !== 1 && R.shift(),
          getGroupRecursive(R, e) || getGroupIdForArbitraryProperty(S)
        );
      },
      getConflictingClassGroupIds: (S, R) => {
        const O = f[S] || [];
        return R && _[S] ? [...O, ..._[S]] : O;
      },
    };
  },
  getGroupRecursive = (a, e) => {
    if (a.length === 0) return e.classGroupId;
    const f = a[0],
      _ = e.nextPart.get(f),
      w = _ ? getGroupRecursive(a.slice(1), _) : void 0;
    if (w) return w;
    if (e.validators.length === 0) return;
    const v = a.join(CLASS_PART_SEPARATOR);
    return e.validators.find(({ validator: S }) => S(v))?.classGroupId;
  },
  arbitraryPropertyRegex = /^\[(.+)\]$/,
  getGroupIdForArbitraryProperty = (a) => {
    if (arbitraryPropertyRegex.test(a)) {
      const e = arbitraryPropertyRegex.exec(a)[1],
        f = e?.substring(0, e.indexOf(":"));
      if (f) return "arbitrary.." + f;
    }
  },
  createClassMap = (a) => {
    const { theme: e, prefix: f } = a,
      _ = { nextPart: new Map(), validators: [] };
    return (
      getPrefixedClassGroupEntries(Object.entries(a.classGroups), f).forEach(
        ([v, S]) => {
          processClassesRecursively(S, _, v, e);
        },
      ),
      _
    );
  },
  processClassesRecursively = (a, e, f, _) => {
    a.forEach((w) => {
      if (typeof w == "string") {
        const v = w === "" ? e : getPart(e, w);
        v.classGroupId = f;
        return;
      }
      if (typeof w == "function") {
        if (isThemeGetter(w)) {
          processClassesRecursively(w(_), e, f, _);
          return;
        }
        e.validators.push({ validator: w, classGroupId: f });
        return;
      }
      Object.entries(w).forEach(([v, S]) => {
        processClassesRecursively(S, getPart(e, v), f, _);
      });
    });
  },
  getPart = (a, e) => {
    let f = a;
    return (
      e.split(CLASS_PART_SEPARATOR).forEach((_) => {
        (f.nextPart.has(_) ||
          f.nextPart.set(_, { nextPart: new Map(), validators: [] }),
          (f = f.nextPart.get(_)));
      }),
      f
    );
  },
  isThemeGetter = (a) => a.isThemeGetter,
  getPrefixedClassGroupEntries = (a, e) =>
    e
      ? a.map(([f, _]) => {
          const w = _.map((v) =>
            typeof v == "string"
              ? e + v
              : typeof v == "object"
                ? Object.fromEntries(
                    Object.entries(v).map(([S, R]) => [e + S, R]),
                  )
                : v,
          );
          return [f, w];
        })
      : a,
  createLruCache = (a) => {
    if (a < 1) return { get: () => {}, set: () => {} };
    let e = 0,
      f = new Map(),
      _ = new Map();
    const w = (v, S) => {
      (f.set(v, S), e++, e > a && ((e = 0), (_ = f), (f = new Map())));
    };
    return {
      get(v) {
        let S = f.get(v);
        if (S !== void 0) return S;
        if ((S = _.get(v)) !== void 0) return (w(v, S), S);
      },
      set(v, S) {
        f.has(v) ? f.set(v, S) : w(v, S);
      },
    };
  },
  IMPORTANT_MODIFIER = "!",
  createParseClassName = (a) => {
    const { separator: e, experimentalParseClassName: f } = a,
      _ = e.length === 1,
      w = e[0],
      v = e.length,
      S = (R) => {
        const O = [];
        let j = 0,
          F = 0,
          q;
        for (let Oe = 0; Oe < R.length; Oe++) {
          let Le = R[Oe];
          if (j === 0) {
            if (Le === w && (_ || R.slice(Oe, Oe + v) === e)) {
              (O.push(R.slice(F, Oe)), (F = Oe + v));
              continue;
            }
            if (Le === "/") {
              q = Oe;
              continue;
            }
          }
          Le === "[" ? j++ : Le === "]" && j--;
        }
        const Q = O.length === 0 ? R : R.substring(F),
          te = Q.startsWith(IMPORTANT_MODIFIER),
          se = te ? Q.substring(1) : Q,
          re = q && q > F ? q - F : void 0;
        return {
          modifiers: O,
          hasImportantModifier: te,
          baseClassName: se,
          maybePostfixModifierPosition: re,
        };
      };
    return f ? (R) => f({ className: R, parseClassName: S }) : S;
  },
  sortModifiers = (a) => {
    if (a.length <= 1) return a;
    const e = [];
    let f = [];
    return (
      a.forEach((_) => {
        _[0] === "[" ? (e.push(...f.sort(), _), (f = [])) : f.push(_);
      }),
      e.push(...f.sort()),
      e
    );
  },
  createConfigUtils = (a) => ({
    cache: createLruCache(a.cacheSize),
    parseClassName: createParseClassName(a),
    ...createClassGroupUtils(a),
  }),
  SPLIT_CLASSES_REGEX = /\s+/,
  mergeClassList = (a, e) => {
    const {
        parseClassName: f,
        getClassGroupId: _,
        getConflictingClassGroupIds: w,
      } = e,
      v = [],
      S = a.trim().split(SPLIT_CLASSES_REGEX);
    let R = "";
    for (let O = S.length - 1; O >= 0; O -= 1) {
      const j = S[O],
        {
          modifiers: F,
          hasImportantModifier: q,
          baseClassName: Q,
          maybePostfixModifierPosition: te,
        } = f(j);
      let se = !!te,
        re = _(se ? Q.substring(0, te) : Q);
      if (!re) {
        if (!se) {
          R = j + (R.length > 0 ? " " + R : R);
          continue;
        }
        if (((re = _(Q)), !re)) {
          R = j + (R.length > 0 ? " " + R : R);
          continue;
        }
        se = !1;
      }
      const Oe = sortModifiers(F).join(":"),
        Le = q ? Oe + IMPORTANT_MODIFIER : Oe,
        Be = Le + re;
      if (v.includes(Be)) continue;
      v.push(Be);
      const Ve = w(re, se);
      for (let ze = 0; ze < Ve.length; ++ze) {
        const Ge = Ve[ze];
        v.push(Le + Ge);
      }
      R = j + (R.length > 0 ? " " + R : R);
    }
    return R;
  };
function twJoin() {
  let a = 0,
    e,
    f,
    _ = "";
  for (; a < arguments.length; )
    (e = arguments[a++]) && (f = toValue(e)) && (_ && (_ += " "), (_ += f));
  return _;
}
const toValue = (a) => {
  if (typeof a == "string") return a;
  let e,
    f = "";
  for (let _ = 0; _ < a.length; _++)
    a[_] && (e = toValue(a[_])) && (f && (f += " "), (f += e));
  return f;
};
function createTailwindMerge(a, ...e) {
  let f,
    _,
    w,
    v = S;
  function S(O) {
    const j = e.reduce((F, q) => q(F), a());
    return (
      (f = createConfigUtils(j)),
      (_ = f.cache.get),
      (w = f.cache.set),
      (v = R),
      R(O)
    );
  }
  function R(O) {
    const j = _(O);
    if (j) return j;
    const F = mergeClassList(O, f);
    return (w(O, F), F);
  }
  return function () {
    return v(twJoin.apply(null, arguments));
  };
}
const fromTheme = (a) => {
    const e = (f) => f[a] || [];
    return ((e.isThemeGetter = !0), e);
  },
  arbitraryValueRegex = /^\[(?:([a-z-]+):)?(.+)\]$/i,
  fractionRegex = /^\d+\/\d+$/,
  stringLengths = new Set(["px", "full", "screen"]),
  tshirtUnitRegex = /^(\d+(\.\d+)?)?(xs|sm|md|lg|xl)$/,
  lengthUnitRegex =
    /\d+(%|px|r?em|[sdl]?v([hwib]|min|max)|pt|pc|in|cm|mm|cap|ch|ex|r?lh|cq(w|h|i|b|min|max))|\b(calc|min|max|clamp)\(.+\)|^0$/,
  colorFunctionRegex = /^(rgba?|hsla?|hwb|(ok)?(lab|lch))\(.+\)$/,
  shadowRegex =
    /^(inset_)?-?((\d+)?\.?(\d+)[a-z]+|0)_-?((\d+)?\.?(\d+)[a-z]+|0)/,
  imageRegex =
    /^(url|image|image-set|cross-fade|element|(repeating-)?(linear|radial|conic)-gradient)\(.+\)$/,
  isLength = (a) =>
    isNumber(a) || stringLengths.has(a) || fractionRegex.test(a),
  isArbitraryLength = (a) => getIsArbitraryValue(a, "length", isLengthOnly),
  isNumber = (a) => !!a && !Number.isNaN(Number(a)),
  isArbitraryNumber = (a) => getIsArbitraryValue(a, "number", isNumber),
  isInteger = (a) => !!a && Number.isInteger(Number(a)),
  isPercent = (a) => a.endsWith("%") && isNumber(a.slice(0, -1)),
  isArbitraryValue = (a) => arbitraryValueRegex.test(a),
  isTshirtSize = (a) => tshirtUnitRegex.test(a),
  sizeLabels = new Set(["length", "size", "percentage"]),
  isArbitrarySize = (a) => getIsArbitraryValue(a, sizeLabels, isNever),
  isArbitraryPosition = (a) => getIsArbitraryValue(a, "position", isNever),
  imageLabels = new Set(["image", "url"]),
  isArbitraryImage = (a) => getIsArbitraryValue(a, imageLabels, isImage),
  isArbitraryShadow = (a) => getIsArbitraryValue(a, "", isShadow),
  isAny = () => !0,
  getIsArbitraryValue = (a, e, f) => {
    const _ = arbitraryValueRegex.exec(a);
    return _
      ? _[1]
        ? typeof e == "string"
          ? _[1] === e
          : e.has(_[1])
        : f(_[2])
      : !1;
  },
  isLengthOnly = (a) => lengthUnitRegex.test(a) && !colorFunctionRegex.test(a),
  isNever = () => !1,
  isShadow = (a) => shadowRegex.test(a),
  isImage = (a) => imageRegex.test(a),
  getDefaultConfig = () => {
    const a = fromTheme("colors"),
      e = fromTheme("spacing"),
      f = fromTheme("blur"),
      _ = fromTheme("brightness"),
      w = fromTheme("borderColor"),
      v = fromTheme("borderRadius"),
      S = fromTheme("borderSpacing"),
      R = fromTheme("borderWidth"),
      O = fromTheme("contrast"),
      j = fromTheme("grayscale"),
      F = fromTheme("hueRotate"),
      q = fromTheme("invert"),
      Q = fromTheme("gap"),
      te = fromTheme("gradientColorStops"),
      se = fromTheme("gradientColorStopPositions"),
      re = fromTheme("inset"),
      Oe = fromTheme("margin"),
      Le = fromTheme("opacity"),
      Be = fromTheme("padding"),
      Ve = fromTheme("saturate"),
      ze = fromTheme("scale"),
      Ge = fromTheme("sepia"),
      Ke = fromTheme("skew"),
      qe = fromTheme("space"),
      nt = fromTheme("translate"),
      pt = () => ["auto", "contain", "none"],
      gt = () => ["auto", "hidden", "clip", "visible", "scroll"],
      mt = () => ["auto", isArbitraryValue, e],
      dt = () => [isArbitraryValue, e],
      _t = () => ["", isLength, isArbitraryLength],
      bt = () => ["auto", isNumber, isArbitraryValue],
      at = () => [
        "bottom",
        "center",
        "left",
        "left-bottom",
        "left-top",
        "right",
        "right-bottom",
        "right-top",
        "top",
      ],
      $e = () => ["solid", "dashed", "dotted", "double", "none"],
      Ye = () => [
        "normal",
        "multiply",
        "screen",
        "overlay",
        "darken",
        "lighten",
        "color-dodge",
        "color-burn",
        "hard-light",
        "soft-light",
        "difference",
        "exclusion",
        "hue",
        "saturation",
        "color",
        "luminosity",
      ],
      Qe = () => [
        "start",
        "end",
        "center",
        "between",
        "around",
        "evenly",
        "stretch",
      ],
      tt = () => ["", "0", isArbitraryValue],
      ht = () => [
        "auto",
        "avoid",
        "all",
        "avoid-page",
        "page",
        "left",
        "right",
        "column",
      ],
      Fe = () => [isNumber, isArbitraryValue];
    return {
      cacheSize: 500,
      separator: ":",
      theme: {
        colors: [isAny],
        spacing: [isLength, isArbitraryLength],
        blur: ["none", "", isTshirtSize, isArbitraryValue],
        brightness: Fe(),
        borderColor: [a],
        borderRadius: ["none", "", "full", isTshirtSize, isArbitraryValue],
        borderSpacing: dt(),
        borderWidth: _t(),
        contrast: Fe(),
        grayscale: tt(),
        hueRotate: Fe(),
        invert: tt(),
        gap: dt(),
        gradientColorStops: [a],
        gradientColorStopPositions: [isPercent, isArbitraryLength],
        inset: mt(),
        margin: mt(),
        opacity: Fe(),
        padding: dt(),
        saturate: Fe(),
        scale: Fe(),
        sepia: tt(),
        skew: Fe(),
        space: dt(),
        translate: dt(),
      },
      classGroups: {
        aspect: [{ aspect: ["auto", "square", "video", isArbitraryValue] }],
        container: ["container"],
        columns: [{ columns: [isTshirtSize] }],
        "break-after": [{ "break-after": ht() }],
        "break-before": [{ "break-before": ht() }],
        "break-inside": [
          { "break-inside": ["auto", "avoid", "avoid-page", "avoid-column"] },
        ],
        "box-decoration": [{ "box-decoration": ["slice", "clone"] }],
        box: [{ box: ["border", "content"] }],
        display: [
          "block",
          "inline-block",
          "inline",
          "flex",
          "inline-flex",
          "table",
          "inline-table",
          "table-caption",
          "table-cell",
          "table-column",
          "table-column-group",
          "table-footer-group",
          "table-header-group",
          "table-row-group",
          "table-row",
          "flow-root",
          "grid",
          "inline-grid",
          "contents",
          "list-item",
          "hidden",
        ],
        float: [{ float: ["right", "left", "none", "start", "end"] }],
        clear: [{ clear: ["left", "right", "both", "none", "start", "end"] }],
        isolation: ["isolate", "isolation-auto"],
        "object-fit": [
          { object: ["contain", "cover", "fill", "none", "scale-down"] },
        ],
        "object-position": [{ object: [...at(), isArbitraryValue] }],
        overflow: [{ overflow: gt() }],
        "overflow-x": [{ "overflow-x": gt() }],
        "overflow-y": [{ "overflow-y": gt() }],
        overscroll: [{ overscroll: pt() }],
        "overscroll-x": [{ "overscroll-x": pt() }],
        "overscroll-y": [{ "overscroll-y": pt() }],
        position: ["static", "fixed", "absolute", "relative", "sticky"],
        inset: [{ inset: [re] }],
        "inset-x": [{ "inset-x": [re] }],
        "inset-y": [{ "inset-y": [re] }],
        start: [{ start: [re] }],
        end: [{ end: [re] }],
        top: [{ top: [re] }],
        right: [{ right: [re] }],
        bottom: [{ bottom: [re] }],
        left: [{ left: [re] }],
        visibility: ["visible", "invisible", "collapse"],
        z: [{ z: ["auto", isInteger, isArbitraryValue] }],
        basis: [{ basis: mt() }],
        "flex-direction": [
          { flex: ["row", "row-reverse", "col", "col-reverse"] },
        ],
        "flex-wrap": [{ flex: ["wrap", "wrap-reverse", "nowrap"] }],
        flex: [{ flex: ["1", "auto", "initial", "none", isArbitraryValue] }],
        grow: [{ grow: tt() }],
        shrink: [{ shrink: tt() }],
        order: [
          { order: ["first", "last", "none", isInteger, isArbitraryValue] },
        ],
        "grid-cols": [{ "grid-cols": [isAny] }],
        "col-start-end": [
          {
            col: [
              "auto",
              { span: ["full", isInteger, isArbitraryValue] },
              isArbitraryValue,
            ],
          },
        ],
        "col-start": [{ "col-start": bt() }],
        "col-end": [{ "col-end": bt() }],
        "grid-rows": [{ "grid-rows": [isAny] }],
        "row-start-end": [
          {
            row: [
              "auto",
              { span: [isInteger, isArbitraryValue] },
              isArbitraryValue,
            ],
          },
        ],
        "row-start": [{ "row-start": bt() }],
        "row-end": [{ "row-end": bt() }],
        "grid-flow": [
          { "grid-flow": ["row", "col", "dense", "row-dense", "col-dense"] },
        ],
        "auto-cols": [
          { "auto-cols": ["auto", "min", "max", "fr", isArbitraryValue] },
        ],
        "auto-rows": [
          { "auto-rows": ["auto", "min", "max", "fr", isArbitraryValue] },
        ],
        gap: [{ gap: [Q] }],
        "gap-x": [{ "gap-x": [Q] }],
        "gap-y": [{ "gap-y": [Q] }],
        "justify-content": [{ justify: ["normal", ...Qe()] }],
        "justify-items": [
          { "justify-items": ["start", "end", "center", "stretch"] },
        ],
        "justify-self": [
          { "justify-self": ["auto", "start", "end", "center", "stretch"] },
        ],
        "align-content": [{ content: ["normal", ...Qe(), "baseline"] }],
        "align-items": [
          { items: ["start", "end", "center", "baseline", "stretch"] },
        ],
        "align-self": [
          { self: ["auto", "start", "end", "center", "stretch", "baseline"] },
        ],
        "place-content": [{ "place-content": [...Qe(), "baseline"] }],
        "place-items": [
          { "place-items": ["start", "end", "center", "baseline", "stretch"] },
        ],
        "place-self": [
          { "place-self": ["auto", "start", "end", "center", "stretch"] },
        ],
        p: [{ p: [Be] }],
        px: [{ px: [Be] }],
        py: [{ py: [Be] }],
        ps: [{ ps: [Be] }],
        pe: [{ pe: [Be] }],
        pt: [{ pt: [Be] }],
        pr: [{ pr: [Be] }],
        pb: [{ pb: [Be] }],
        pl: [{ pl: [Be] }],
        m: [{ m: [Oe] }],
        mx: [{ mx: [Oe] }],
        my: [{ my: [Oe] }],
        ms: [{ ms: [Oe] }],
        me: [{ me: [Oe] }],
        mt: [{ mt: [Oe] }],
        mr: [{ mr: [Oe] }],
        mb: [{ mb: [Oe] }],
        ml: [{ ml: [Oe] }],
        "space-x": [{ "space-x": [qe] }],
        "space-x-reverse": ["space-x-reverse"],
        "space-y": [{ "space-y": [qe] }],
        "space-y-reverse": ["space-y-reverse"],
        w: [
          {
            w: [
              "auto",
              "min",
              "max",
              "fit",
              "svw",
              "lvw",
              "dvw",
              isArbitraryValue,
              e,
            ],
          },
        ],
        "min-w": [{ "min-w": [isArbitraryValue, e, "min", "max", "fit"] }],
        "max-w": [
          {
            "max-w": [
              isArbitraryValue,
              e,
              "none",
              "full",
              "min",
              "max",
              "fit",
              "prose",
              { screen: [isTshirtSize] },
              isTshirtSize,
            ],
          },
        ],
        h: [
          {
            h: [
              isArbitraryValue,
              e,
              "auto",
              "min",
              "max",
              "fit",
              "svh",
              "lvh",
              "dvh",
            ],
          },
        ],
        "min-h": [
          {
            "min-h": [
              isArbitraryValue,
              e,
              "min",
              "max",
              "fit",
              "svh",
              "lvh",
              "dvh",
            ],
          },
        ],
        "max-h": [
          {
            "max-h": [
              isArbitraryValue,
              e,
              "min",
              "max",
              "fit",
              "svh",
              "lvh",
              "dvh",
            ],
          },
        ],
        size: [{ size: [isArbitraryValue, e, "auto", "min", "max", "fit"] }],
        "font-size": [{ text: ["base", isTshirtSize, isArbitraryLength] }],
        "font-smoothing": ["antialiased", "subpixel-antialiased"],
        "font-style": ["italic", "not-italic"],
        "font-weight": [
          {
            font: [
              "thin",
              "extralight",
              "light",
              "normal",
              "medium",
              "semibold",
              "bold",
              "extrabold",
              "black",
              isArbitraryNumber,
            ],
          },
        ],
        "font-family": [{ font: [isAny] }],
        "fvn-normal": ["normal-nums"],
        "fvn-ordinal": ["ordinal"],
        "fvn-slashed-zero": ["slashed-zero"],
        "fvn-figure": ["lining-nums", "oldstyle-nums"],
        "fvn-spacing": ["proportional-nums", "tabular-nums"],
        "fvn-fraction": ["diagonal-fractions", "stacked-fractions"],
        tracking: [
          {
            tracking: [
              "tighter",
              "tight",
              "normal",
              "wide",
              "wider",
              "widest",
              isArbitraryValue,
            ],
          },
        ],
        "line-clamp": [{ "line-clamp": ["none", isNumber, isArbitraryNumber] }],
        leading: [
          {
            leading: [
              "none",
              "tight",
              "snug",
              "normal",
              "relaxed",
              "loose",
              isLength,
              isArbitraryValue,
            ],
          },
        ],
        "list-image": [{ "list-image": ["none", isArbitraryValue] }],
        "list-style-type": [
          { list: ["none", "disc", "decimal", isArbitraryValue] },
        ],
        "list-style-position": [{ list: ["inside", "outside"] }],
        "placeholder-color": [{ placeholder: [a] }],
        "placeholder-opacity": [{ "placeholder-opacity": [Le] }],
        "text-alignment": [
          { text: ["left", "center", "right", "justify", "start", "end"] },
        ],
        "text-color": [{ text: [a] }],
        "text-opacity": [{ "text-opacity": [Le] }],
        "text-decoration": [
          "underline",
          "overline",
          "line-through",
          "no-underline",
        ],
        "text-decoration-style": [{ decoration: [...$e(), "wavy"] }],
        "text-decoration-thickness": [
          { decoration: ["auto", "from-font", isLength, isArbitraryLength] },
        ],
        "underline-offset": [
          { "underline-offset": ["auto", isLength, isArbitraryValue] },
        ],
        "text-decoration-color": [{ decoration: [a] }],
        "text-transform": [
          "uppercase",
          "lowercase",
          "capitalize",
          "normal-case",
        ],
        "text-overflow": ["truncate", "text-ellipsis", "text-clip"],
        "text-wrap": [{ text: ["wrap", "nowrap", "balance", "pretty"] }],
        indent: [{ indent: dt() }],
        "vertical-align": [
          {
            align: [
              "baseline",
              "top",
              "middle",
              "bottom",
              "text-top",
              "text-bottom",
              "sub",
              "super",
              isArbitraryValue,
            ],
          },
        ],
        whitespace: [
          {
            whitespace: [
              "normal",
              "nowrap",
              "pre",
              "pre-line",
              "pre-wrap",
              "break-spaces",
            ],
          },
        ],
        break: [{ break: ["normal", "words", "all", "keep"] }],
        hyphens: [{ hyphens: ["none", "manual", "auto"] }],
        content: [{ content: ["none", isArbitraryValue] }],
        "bg-attachment": [{ bg: ["fixed", "local", "scroll"] }],
        "bg-clip": [{ "bg-clip": ["border", "padding", "content", "text"] }],
        "bg-opacity": [{ "bg-opacity": [Le] }],
        "bg-origin": [{ "bg-origin": ["border", "padding", "content"] }],
        "bg-position": [{ bg: [...at(), isArbitraryPosition] }],
        "bg-repeat": [
          { bg: ["no-repeat", { repeat: ["", "x", "y", "round", "space"] }] },
        ],
        "bg-size": [{ bg: ["auto", "cover", "contain", isArbitrarySize] }],
        "bg-image": [
          {
            bg: [
              "none",
              { "gradient-to": ["t", "tr", "r", "br", "b", "bl", "l", "tl"] },
              isArbitraryImage,
            ],
          },
        ],
        "bg-color": [{ bg: [a] }],
        "gradient-from-pos": [{ from: [se] }],
        "gradient-via-pos": [{ via: [se] }],
        "gradient-to-pos": [{ to: [se] }],
        "gradient-from": [{ from: [te] }],
        "gradient-via": [{ via: [te] }],
        "gradient-to": [{ to: [te] }],
        rounded: [{ rounded: [v] }],
        "rounded-s": [{ "rounded-s": [v] }],
        "rounded-e": [{ "rounded-e": [v] }],
        "rounded-t": [{ "rounded-t": [v] }],
        "rounded-r": [{ "rounded-r": [v] }],
        "rounded-b": [{ "rounded-b": [v] }],
        "rounded-l": [{ "rounded-l": [v] }],
        "rounded-ss": [{ "rounded-ss": [v] }],
        "rounded-se": [{ "rounded-se": [v] }],
        "rounded-ee": [{ "rounded-ee": [v] }],
        "rounded-es": [{ "rounded-es": [v] }],
        "rounded-tl": [{ "rounded-tl": [v] }],
        "rounded-tr": [{ "rounded-tr": [v] }],
        "rounded-br": [{ "rounded-br": [v] }],
        "rounded-bl": [{ "rounded-bl": [v] }],
        "border-w": [{ border: [R] }],
        "border-w-x": [{ "border-x": [R] }],
        "border-w-y": [{ "border-y": [R] }],
        "border-w-s": [{ "border-s": [R] }],
        "border-w-e": [{ "border-e": [R] }],
        "border-w-t": [{ "border-t": [R] }],
        "border-w-r": [{ "border-r": [R] }],
        "border-w-b": [{ "border-b": [R] }],
        "border-w-l": [{ "border-l": [R] }],
        "border-opacity": [{ "border-opacity": [Le] }],
        "border-style": [{ border: [...$e(), "hidden"] }],
        "divide-x": [{ "divide-x": [R] }],
        "divide-x-reverse": ["divide-x-reverse"],
        "divide-y": [{ "divide-y": [R] }],
        "divide-y-reverse": ["divide-y-reverse"],
        "divide-opacity": [{ "divide-opacity": [Le] }],
        "divide-style": [{ divide: $e() }],
        "border-color": [{ border: [w] }],
        "border-color-x": [{ "border-x": [w] }],
        "border-color-y": [{ "border-y": [w] }],
        "border-color-s": [{ "border-s": [w] }],
        "border-color-e": [{ "border-e": [w] }],
        "border-color-t": [{ "border-t": [w] }],
        "border-color-r": [{ "border-r": [w] }],
        "border-color-b": [{ "border-b": [w] }],
        "border-color-l": [{ "border-l": [w] }],
        "divide-color": [{ divide: [w] }],
        "outline-style": [{ outline: ["", ...$e()] }],
        "outline-offset": [{ "outline-offset": [isLength, isArbitraryValue] }],
        "outline-w": [{ outline: [isLength, isArbitraryLength] }],
        "outline-color": [{ outline: [a] }],
        "ring-w": [{ ring: _t() }],
        "ring-w-inset": ["ring-inset"],
        "ring-color": [{ ring: [a] }],
        "ring-opacity": [{ "ring-opacity": [Le] }],
        "ring-offset-w": [{ "ring-offset": [isLength, isArbitraryLength] }],
        "ring-offset-color": [{ "ring-offset": [a] }],
        shadow: [
          { shadow: ["", "inner", "none", isTshirtSize, isArbitraryShadow] },
        ],
        "shadow-color": [{ shadow: [isAny] }],
        opacity: [{ opacity: [Le] }],
        "mix-blend": [
          { "mix-blend": [...Ye(), "plus-lighter", "plus-darker"] },
        ],
        "bg-blend": [{ "bg-blend": Ye() }],
        filter: [{ filter: ["", "none"] }],
        blur: [{ blur: [f] }],
        brightness: [{ brightness: [_] }],
        contrast: [{ contrast: [O] }],
        "drop-shadow": [
          { "drop-shadow": ["", "none", isTshirtSize, isArbitraryValue] },
        ],
        grayscale: [{ grayscale: [j] }],
        "hue-rotate": [{ "hue-rotate": [F] }],
        invert: [{ invert: [q] }],
        saturate: [{ saturate: [Ve] }],
        sepia: [{ sepia: [Ge] }],
        "backdrop-filter": [{ "backdrop-filter": ["", "none"] }],
        "backdrop-blur": [{ "backdrop-blur": [f] }],
        "backdrop-brightness": [{ "backdrop-brightness": [_] }],
        "backdrop-contrast": [{ "backdrop-contrast": [O] }],
        "backdrop-grayscale": [{ "backdrop-grayscale": [j] }],
        "backdrop-hue-rotate": [{ "backdrop-hue-rotate": [F] }],
        "backdrop-invert": [{ "backdrop-invert": [q] }],
        "backdrop-opacity": [{ "backdrop-opacity": [Le] }],
        "backdrop-saturate": [{ "backdrop-saturate": [Ve] }],
        "backdrop-sepia": [{ "backdrop-sepia": [Ge] }],
        "border-collapse": [{ border: ["collapse", "separate"] }],
        "border-spacing": [{ "border-spacing": [S] }],
        "border-spacing-x": [{ "border-spacing-x": [S] }],
        "border-spacing-y": [{ "border-spacing-y": [S] }],
        "table-layout": [{ table: ["auto", "fixed"] }],
        caption: [{ caption: ["top", "bottom"] }],
        transition: [
          {
            transition: [
              "none",
              "all",
              "",
              "colors",
              "opacity",
              "shadow",
              "transform",
              isArbitraryValue,
            ],
          },
        ],
        duration: [{ duration: Fe() }],
        ease: [{ ease: ["linear", "in", "out", "in-out", isArbitraryValue] }],
        delay: [{ delay: Fe() }],
        animate: [
          {
            animate: [
              "none",
              "spin",
              "ping",
              "pulse",
              "bounce",
              isArbitraryValue,
            ],
          },
        ],
        transform: [{ transform: ["", "gpu", "none"] }],
        scale: [{ scale: [ze] }],
        "scale-x": [{ "scale-x": [ze] }],
        "scale-y": [{ "scale-y": [ze] }],
        rotate: [{ rotate: [isInteger, isArbitraryValue] }],
        "translate-x": [{ "translate-x": [nt] }],
        "translate-y": [{ "translate-y": [nt] }],
        "skew-x": [{ "skew-x": [Ke] }],
        "skew-y": [{ "skew-y": [Ke] }],
        "transform-origin": [
          {
            origin: [
              "center",
              "top",
              "top-right",
              "right",
              "bottom-right",
              "bottom",
              "bottom-left",
              "left",
              "top-left",
              isArbitraryValue,
            ],
          },
        ],
        accent: [{ accent: ["auto", a] }],
        appearance: [{ appearance: ["none", "auto"] }],
        cursor: [
          {
            cursor: [
              "auto",
              "default",
              "pointer",
              "wait",
              "text",
              "move",
              "help",
              "not-allowed",
              "none",
              "context-menu",
              "progress",
              "cell",
              "crosshair",
              "vertical-text",
              "alias",
              "copy",
              "no-drop",
              "grab",
              "grabbing",
              "all-scroll",
              "col-resize",
              "row-resize",
              "n-resize",
              "e-resize",
              "s-resize",
              "w-resize",
              "ne-resize",
              "nw-resize",
              "se-resize",
              "sw-resize",
              "ew-resize",
              "ns-resize",
              "nesw-resize",
              "nwse-resize",
              "zoom-in",
              "zoom-out",
              isArbitraryValue,
            ],
          },
        ],
        "caret-color": [{ caret: [a] }],
        "pointer-events": [{ "pointer-events": ["none", "auto"] }],
        resize: [{ resize: ["none", "y", "x", ""] }],
        "scroll-behavior": [{ scroll: ["auto", "smooth"] }],
        "scroll-m": [{ "scroll-m": dt() }],
        "scroll-mx": [{ "scroll-mx": dt() }],
        "scroll-my": [{ "scroll-my": dt() }],
        "scroll-ms": [{ "scroll-ms": dt() }],
        "scroll-me": [{ "scroll-me": dt() }],
        "scroll-mt": [{ "scroll-mt": dt() }],
        "scroll-mr": [{ "scroll-mr": dt() }],
        "scroll-mb": [{ "scroll-mb": dt() }],
        "scroll-ml": [{ "scroll-ml": dt() }],
        "scroll-p": [{ "scroll-p": dt() }],
        "scroll-px": [{ "scroll-px": dt() }],
        "scroll-py": [{ "scroll-py": dt() }],
        "scroll-ps": [{ "scroll-ps": dt() }],
        "scroll-pe": [{ "scroll-pe": dt() }],
        "scroll-pt": [{ "scroll-pt": dt() }],
        "scroll-pr": [{ "scroll-pr": dt() }],
        "scroll-pb": [{ "scroll-pb": dt() }],
        "scroll-pl": [{ "scroll-pl": dt() }],
        "snap-align": [{ snap: ["start", "end", "center", "align-none"] }],
        "snap-stop": [{ snap: ["normal", "always"] }],
        "snap-type": [{ snap: ["none", "x", "y", "both"] }],
        "snap-strictness": [{ snap: ["mandatory", "proximity"] }],
        touch: [{ touch: ["auto", "none", "manipulation"] }],
        "touch-x": [{ "touch-pan": ["x", "left", "right"] }],
        "touch-y": [{ "touch-pan": ["y", "up", "down"] }],
        "touch-pz": ["touch-pinch-zoom"],
        select: [{ select: ["none", "text", "all", "auto"] }],
        "will-change": [
          {
            "will-change": [
              "auto",
              "scroll",
              "contents",
              "transform",
              isArbitraryValue,
            ],
          },
        ],
        fill: [{ fill: [a, "none"] }],
        "stroke-w": [
          { stroke: [isLength, isArbitraryLength, isArbitraryNumber] },
        ],
        stroke: [{ stroke: [a, "none"] }],
        sr: ["sr-only", "not-sr-only"],
        "forced-color-adjust": [{ "forced-color-adjust": ["auto", "none"] }],
      },
      conflictingClassGroups: {
        overflow: ["overflow-x", "overflow-y"],
        overscroll: ["overscroll-x", "overscroll-y"],
        inset: [
          "inset-x",
          "inset-y",
          "start",
          "end",
          "top",
          "right",
          "bottom",
          "left",
        ],
        "inset-x": ["right", "left"],
        "inset-y": ["top", "bottom"],
        flex: ["basis", "grow", "shrink"],
        gap: ["gap-x", "gap-y"],
        p: ["px", "py", "ps", "pe", "pt", "pr", "pb", "pl"],
        px: ["pr", "pl"],
        py: ["pt", "pb"],
        m: ["mx", "my", "ms", "me", "mt", "mr", "mb", "ml"],
        mx: ["mr", "ml"],
        my: ["mt", "mb"],
        size: ["w", "h"],
        "font-size": ["leading"],
        "fvn-normal": [
          "fvn-ordinal",
          "fvn-slashed-zero",
          "fvn-figure",
          "fvn-spacing",
          "fvn-fraction",
        ],
        "fvn-ordinal": ["fvn-normal"],
        "fvn-slashed-zero": ["fvn-normal"],
        "fvn-figure": ["fvn-normal"],
        "fvn-spacing": ["fvn-normal"],
        "fvn-fraction": ["fvn-normal"],
        "line-clamp": ["display", "overflow"],
        rounded: [
          "rounded-s",
          "rounded-e",
          "rounded-t",
          "rounded-r",
          "rounded-b",
          "rounded-l",
          "rounded-ss",
          "rounded-se",
          "rounded-ee",
          "rounded-es",
          "rounded-tl",
          "rounded-tr",
          "rounded-br",
          "rounded-bl",
        ],
        "rounded-s": ["rounded-ss", "rounded-es"],
        "rounded-e": ["rounded-se", "rounded-ee"],
        "rounded-t": ["rounded-tl", "rounded-tr"],
        "rounded-r": ["rounded-tr", "rounded-br"],
        "rounded-b": ["rounded-br", "rounded-bl"],
        "rounded-l": ["rounded-tl", "rounded-bl"],
        "border-spacing": ["border-spacing-x", "border-spacing-y"],
        "border-w": [
          "border-w-s",
          "border-w-e",
          "border-w-t",
          "border-w-r",
          "border-w-b",
          "border-w-l",
        ],
        "border-w-x": ["border-w-r", "border-w-l"],
        "border-w-y": ["border-w-t", "border-w-b"],
        "border-color": [
          "border-color-s",
          "border-color-e",
          "border-color-t",
          "border-color-r",
          "border-color-b",
          "border-color-l",
        ],
        "border-color-x": ["border-color-r", "border-color-l"],
        "border-color-y": ["border-color-t", "border-color-b"],
        "scroll-m": [
          "scroll-mx",
          "scroll-my",
          "scroll-ms",
          "scroll-me",
          "scroll-mt",
          "scroll-mr",
          "scroll-mb",
          "scroll-ml",
        ],
        "scroll-mx": ["scroll-mr", "scroll-ml"],
        "scroll-my": ["scroll-mt", "scroll-mb"],
        "scroll-p": [
          "scroll-px",
          "scroll-py",
          "scroll-ps",
          "scroll-pe",
          "scroll-pt",
          "scroll-pr",
          "scroll-pb",
          "scroll-pl",
        ],
        "scroll-px": ["scroll-pr", "scroll-pl"],
        "scroll-py": ["scroll-pt", "scroll-pb"],
        touch: ["touch-x", "touch-y", "touch-pz"],
        "touch-x": ["touch"],
        "touch-y": ["touch"],
        "touch-pz": ["touch"],
      },
      conflictingClassGroupModifiers: { "font-size": ["leading"] },
    };
  },
  twMerge = createTailwindMerge(getDefaultConfig);
function cn(...a) {
  return twMerge(clsx(a));
}
const buttonVariants = cva(
    "inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-full font-medium text-sm transition-all duration-150 focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-0 disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0",
    {
      variants: {
        variant: {
          default:
            "bg-primary text-primary-foreground hover:bg-[#3d8aff] active:bg-primary",
          destructive:
            "bg-destructive text-destructive-foreground hover:bg-[#f06666] active:bg-destructive",
          outline:
            "border border-border bg-transparent text-foreground hover:bg-secondary hover:border-accent",
          secondary:
            "bg-secondary text-secondary-foreground hover:bg-[#2a2e33] active:bg-secondary",
          ghost: "text-foreground hover:bg-secondary active:bg-muted",
          link: "text-primary underline-offset-4 hover:underline hover:text-[#3d8aff]",
        },
        size: {
          default: "h-10 px-6 py-2",
          sm: "h-9 rounded-full px-4 text-sm",
          lg: "h-12 rounded-full px-8 text-base",
          icon: "h-10 w-10 rounded-full",
          "icon-sm": "h-8 w-8 rounded-full",
        },
      },
      defaultVariants: { variant: "default", size: "default" },
    },
  ),
  Button = reactExports.forwardRef(
    ({ className: a, variant: e, size: f, asChild: _ = !1, ...w }, v) => {
      const S = _ ? Slot$3 : "button";
      return jsxRuntimeExports.jsx(S, {
        className: cn(buttonVariants({ variant: e, size: f, className: a })),
        ref: v,
        ...w,
      });
    },
  );
Button.displayName = "Button";
const Input = reactExports.forwardRef(({ className: a, type: e, ...f }, _) =>
  jsxRuntimeExports.jsx("input", {
    type: e,
    className: cn(
      "flex h-10 w-full rounded-md border border-border bg-input px-3 py-2 text-base text-foreground ring-offset-0 file:border-0 file:bg-transparent file:text-sm file:font-medium file:text-foreground placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-0 disabled:cursor-not-allowed disabled:opacity-50 md:text-sm transition-colors duration-150",
      a,
    ),
    ref: _,
    ...f,
  }),
);
Input.displayName = "Input";
var reactDomExports = requireReactDom();
const ReactDOM = getDefaultExportFromCjs(reactDomExports);
var NODES$2 = [
    "a",
    "button",
    "div",
    "form",
    "h2",
    "h3",
    "img",
    "input",
    "label",
    "li",
    "nav",
    "ol",
    "p",
    "select",
    "span",
    "svg",
    "ul",
  ],
  Primitive$2 = NODES$2.reduce((a, e) => {
    const f = createSlot$5(`Primitive.${e}`),
      _ = reactExports.forwardRef((w, v) => {
        const { asChild: S, ...R } = w,
          O = S ? f : e;
        return (
          typeof window < "u" && (window[Symbol.for("radix-ui")] = !0),
          jsxRuntimeExports.jsx(O, { ...R, ref: v })
        );
      });
    return ((_.displayName = `Primitive.${e}`), { ...a, [e]: _ });
  }, {}),
  NAME$2 = "Separator",
  DEFAULT_ORIENTATION = "horizontal",
  ORIENTATIONS = ["horizontal", "vertical"],
  Separator$3 = reactExports.forwardRef((a, e) => {
    const { decorative: f, orientation: _ = DEFAULT_ORIENTATION, ...w } = a,
      v = isValidOrientation(_) ? _ : DEFAULT_ORIENTATION,
      R = f
        ? { role: "none" }
        : {
            "aria-orientation": v === "vertical" ? v : void 0,
            role: "separator",
          };
    return jsxRuntimeExports.jsx(Primitive$2.div, {
      "data-orientation": v,
      ...R,
      ...w,
      ref: e,
    });
  });
Separator$3.displayName = NAME$2;
function isValidOrientation(a) {
  return ORIENTATIONS.includes(a);
}
var Root$5 = Separator$3;
const Separator$2 = reactExports.forwardRef(
  (
    { className: a, orientation: e = "horizontal", decorative: f = !0, ..._ },
    w,
  ) =>
    jsxRuntimeExports.jsx(Root$5, {
      ref: w,
      decorative: f,
      orientation: e,
      className: cn(
        "shrink-0 bg-border",
        e === "horizontal" ? "h-[1px] w-full" : "h-full w-[1px]",
        a,
      ),
      ..._,
    }),
);
Separator$2.displayName = Root$5.displayName;
function composeEventHandlers(a, e, { checkForDefaultPrevented: f = !0 } = {}) {
  return function (w) {
    if ((a?.(w), f === !1 || !w.defaultPrevented)) return e?.(w);
  };
}
function createContext2(a, e) {
  const f = reactExports.createContext(e),
    _ = (v) => {
      const { children: S, ...R } = v,
        O = reactExports.useMemo(() => R, Object.values(R));
      return jsxRuntimeExports.jsx(f.Provider, { value: O, children: S });
    };
  _.displayName = a + "Provider";
  function w(v) {
    const S = reactExports.useContext(f);
    if (S) return S;
    if (e !== void 0) return e;
    throw new Error(`\`${v}\` must be used within \`${a}\``);
  }
  return [_, w];
}
function createContextScope(a, e = []) {
  let f = [];
  function _(v, S) {
    const R = reactExports.createContext(S),
      O = f.length;
    f = [...f, S];
    const j = (q) => {
      const { scope: Q, children: te, ...se } = q,
        re = Q?.[a]?.[O] || R,
        Oe = reactExports.useMemo(() => se, Object.values(se));
      return jsxRuntimeExports.jsx(re.Provider, { value: Oe, children: te });
    };
    j.displayName = v + "Provider";
    function F(q, Q) {
      const te = Q?.[a]?.[O] || R,
        se = reactExports.useContext(te);
      if (se) return se;
      if (S !== void 0) return S;
      throw new Error(`\`${q}\` must be used within \`${v}\``);
    }
    return [j, F];
  }
  const w = () => {
    const v = f.map((S) => reactExports.createContext(S));
    return function (R) {
      const O = R?.[a] || v;
      return reactExports.useMemo(
        () => ({ [`__scope${a}`]: { ...R, [a]: O } }),
        [R, O],
      );
    };
  };
  return ((w.scopeName = a), [_, composeContextScopes(w, ...e)]);
}
function composeContextScopes(...a) {
  const e = a[0];
  if (a.length === 1) return e;
  const f = () => {
    const _ = a.map((w) => ({ useScope: w(), scopeName: w.scopeName }));
    return function (v) {
      const S = _.reduce((R, { useScope: O, scopeName: j }) => {
        const q = O(v)[`__scope${j}`];
        return { ...R, ...q };
      }, {});
      return reactExports.useMemo(
        () => ({ [`__scope${e.scopeName}`]: S }),
        [S],
      );
    };
  };
  return ((f.scopeName = e.scopeName), f);
}
var useLayoutEffect2 = globalThis?.document
    ? reactExports.useLayoutEffect
    : () => {},
  useReactId = React[" useId ".trim().toString()] || (() => {}),
  count$1 = 0;
function useId(a) {
  const [e, f] = reactExports.useState(useReactId());
  return (
    useLayoutEffect2(() => {
      f((_) => _ ?? String(count$1++));
    }, [a]),
    a || (e ? `radix-${e}` : "")
  );
}
var useInsertionEffect =
  React[" useInsertionEffect ".trim().toString()] || useLayoutEffect2;
function useControllableState({
  prop: a,
  defaultProp: e,
  onChange: f = () => {},
  caller: _,
}) {
  const [w, v, S] = useUncontrolledState({ defaultProp: e, onChange: f }),
    R = a !== void 0,
    O = R ? a : w;
  {
    const F = reactExports.useRef(a !== void 0);
    reactExports.useEffect(() => {
      const q = F.current;
      (q !== R &&
        console.warn(
          `${_} is changing from ${q ? "controlled" : "uncontrolled"} to ${R ? "controlled" : "uncontrolled"}. Components should not switch from controlled to uncontrolled (or vice versa). Decide between using a controlled or uncontrolled value for the lifetime of the component.`,
        ),
        (F.current = R));
    }, [R, _]);
  }
  const j = reactExports.useCallback(
    (F) => {
      if (R) {
        const q = isFunction(F) ? F(a) : F;
        q !== a && S.current?.(q);
      } else v(F);
    },
    [R, a, v, S],
  );
  return [O, j];
}
function useUncontrolledState({ defaultProp: a, onChange: e }) {
  const [f, _] = reactExports.useState(a),
    w = reactExports.useRef(f),
    v = reactExports.useRef(e);
  return (
    useInsertionEffect(() => {
      v.current = e;
    }, [e]),
    reactExports.useEffect(() => {
      w.current !== f && (v.current?.(f), (w.current = f));
    }, [f, w]),
    [f, _, v]
  );
}
function isFunction(a) {
  return typeof a == "function";
}
function createSlot$4(a) {
  const e = createSlotClone$4(a),
    f = reactExports.forwardRef((_, w) => {
      const { children: v, ...S } = _,
        R = reactExports.Children.toArray(v),
        O = R.find(isSlottable$4);
      if (O) {
        const j = O.props.children,
          F = R.map((q) =>
            q === O
              ? reactExports.Children.count(j) > 1
                ? reactExports.Children.only(null)
                : reactExports.isValidElement(j)
                  ? j.props.children
                  : null
              : q,
          );
        return jsxRuntimeExports.jsx(e, {
          ...S,
          ref: w,
          children: reactExports.isValidElement(j)
            ? reactExports.cloneElement(j, void 0, F)
            : null,
        });
      }
      return jsxRuntimeExports.jsx(e, { ...S, ref: w, children: v });
    });
  return ((f.displayName = `${a}.Slot`), f);
}
function createSlotClone$4(a) {
  const e = reactExports.forwardRef((f, _) => {
    const { children: w, ...v } = f;
    if (reactExports.isValidElement(w)) {
      const S = getElementRef$5(w),
        R = mergeProps$4(v, w.props);
      return (
        w.type !== reactExports.Fragment && (R.ref = _ ? composeRefs(_, S) : S),
        reactExports.cloneElement(w, R)
      );
    }
    return reactExports.Children.count(w) > 1
      ? reactExports.Children.only(null)
      : null;
  });
  return ((e.displayName = `${a}.SlotClone`), e);
}
var SLOTTABLE_IDENTIFIER$5 = Symbol("radix.slottable");
function isSlottable$4(a) {
  return (
    reactExports.isValidElement(a) &&
    typeof a.type == "function" &&
    "__radixId" in a.type &&
    a.type.__radixId === SLOTTABLE_IDENTIFIER$5
  );
}
function mergeProps$4(a, e) {
  const f = { ...e };
  for (const _ in e) {
    const w = a[_],
      v = e[_];
    /^on[A-Z]/.test(_)
      ? w && v
        ? (f[_] = (...R) => {
            const O = v(...R);
            return (w(...R), O);
          })
        : w && (f[_] = w)
      : _ === "style"
        ? (f[_] = { ...w, ...v })
        : _ === "className" && (f[_] = [w, v].filter(Boolean).join(" "));
  }
  return { ...a, ...f };
}
function getElementRef$5(a) {
  let e = Object.getOwnPropertyDescriptor(a.props, "ref")?.get,
    f = e && "isReactWarning" in e && e.isReactWarning;
  return f
    ? a.ref
    : ((e = Object.getOwnPropertyDescriptor(a, "ref")?.get),
      (f = e && "isReactWarning" in e && e.isReactWarning),
      f ? a.props.ref : a.props.ref || a.ref);
}
var NODES$1 = [
    "a",
    "button",
    "div",
    "form",
    "h2",
    "h3",
    "img",
    "input",
    "label",
    "li",
    "nav",
    "ol",
    "p",
    "select",
    "span",
    "svg",
    "ul",
  ],
  Primitive$1 = NODES$1.reduce((a, e) => {
    const f = createSlot$4(`Primitive.${e}`),
      _ = reactExports.forwardRef((w, v) => {
        const { asChild: S, ...R } = w,
          O = S ? f : e;
        return (
          typeof window < "u" && (window[Symbol.for("radix-ui")] = !0),
          jsxRuntimeExports.jsx(O, { ...R, ref: v })
        );
      });
    return ((_.displayName = `Primitive.${e}`), { ...a, [e]: _ });
  }, {});
function dispatchDiscreteCustomEvent(a, e) {
  a && reactDomExports.flushSync(() => a.dispatchEvent(e));
}
function useCallbackRef$1(a) {
  const e = reactExports.useRef(a);
  return (
    reactExports.useEffect(() => {
      e.current = a;
    }),
    reactExports.useMemo(
      () =>
        (...f) =>
          e.current?.(...f),
      [],
    )
  );
}
function useEscapeKeydown(a, e = globalThis?.document) {
  const f = useCallbackRef$1(a);
  reactExports.useEffect(() => {
    const _ = (w) => {
      w.key === "Escape" && f(w);
    };
    return (
      e.addEventListener("keydown", _, { capture: !0 }),
      () => e.removeEventListener("keydown", _, { capture: !0 })
    );
  }, [f, e]);
}
var DISMISSABLE_LAYER_NAME = "DismissableLayer",
  CONTEXT_UPDATE = "dismissableLayer.update",
  POINTER_DOWN_OUTSIDE = "dismissableLayer.pointerDownOutside",
  FOCUS_OUTSIDE = "dismissableLayer.focusOutside",
  originalBodyPointerEvents,
  DismissableLayerContext = reactExports.createContext({
    layers: new Set(),
    layersWithOutsidePointerEventsDisabled: new Set(),
    branches: new Set(),
  }),
  DismissableLayer = reactExports.forwardRef((a, e) => {
    const {
        disableOutsidePointerEvents: f = !1,
        onEscapeKeyDown: _,
        onPointerDownOutside: w,
        onFocusOutside: v,
        onInteractOutside: S,
        onDismiss: R,
        ...O
      } = a,
      j = reactExports.useContext(DismissableLayerContext),
      [F, q] = reactExports.useState(null),
      Q = F?.ownerDocument ?? globalThis?.document,
      [, te] = reactExports.useState({}),
      se = useComposedRefs(e, (qe) => q(qe)),
      re = Array.from(j.layers),
      [Oe] = [...j.layersWithOutsidePointerEventsDisabled].slice(-1),
      Le = re.indexOf(Oe),
      Be = F ? re.indexOf(F) : -1,
      Ve = j.layersWithOutsidePointerEventsDisabled.size > 0,
      ze = Be >= Le,
      Ge = usePointerDownOutside((qe) => {
        const nt = qe.target,
          pt = [...j.branches].some((gt) => gt.contains(nt));
        !ze || pt || (w?.(qe), S?.(qe), qe.defaultPrevented || R?.());
      }, Q),
      Ke = useFocusOutside((qe) => {
        const nt = qe.target;
        [...j.branches].some((gt) => gt.contains(nt)) ||
          (v?.(qe), S?.(qe), qe.defaultPrevented || R?.());
      }, Q);
    return (
      useEscapeKeydown((qe) => {
        Be === j.layers.size - 1 &&
          (_?.(qe), !qe.defaultPrevented && R && (qe.preventDefault(), R()));
      }, Q),
      reactExports.useEffect(() => {
        if (F)
          return (
            f &&
              (j.layersWithOutsidePointerEventsDisabled.size === 0 &&
                ((originalBodyPointerEvents = Q.body.style.pointerEvents),
                (Q.body.style.pointerEvents = "none")),
              j.layersWithOutsidePointerEventsDisabled.add(F)),
            j.layers.add(F),
            dispatchUpdate(),
            () => {
              f &&
                j.layersWithOutsidePointerEventsDisabled.size === 1 &&
                (Q.body.style.pointerEvents = originalBodyPointerEvents);
            }
          );
      }, [F, Q, f, j]),
      reactExports.useEffect(
        () => () => {
          F &&
            (j.layers.delete(F),
            j.layersWithOutsidePointerEventsDisabled.delete(F),
            dispatchUpdate());
        },
        [F, j],
      ),
      reactExports.useEffect(() => {
        const qe = () => te({});
        return (
          document.addEventListener(CONTEXT_UPDATE, qe),
          () => document.removeEventListener(CONTEXT_UPDATE, qe)
        );
      }, []),
      jsxRuntimeExports.jsx(Primitive$1.div, {
        ...O,
        ref: se,
        style: {
          pointerEvents: Ve ? (ze ? "auto" : "none") : void 0,
          ...a.style,
        },
        onFocusCapture: composeEventHandlers(
          a.onFocusCapture,
          Ke.onFocusCapture,
        ),
        onBlurCapture: composeEventHandlers(a.onBlurCapture, Ke.onBlurCapture),
        onPointerDownCapture: composeEventHandlers(
          a.onPointerDownCapture,
          Ge.onPointerDownCapture,
        ),
      })
    );
  });
DismissableLayer.displayName = DISMISSABLE_LAYER_NAME;
var BRANCH_NAME = "DismissableLayerBranch",
  DismissableLayerBranch = reactExports.forwardRef((a, e) => {
    const f = reactExports.useContext(DismissableLayerContext),
      _ = reactExports.useRef(null),
      w = useComposedRefs(e, _);
    return (
      reactExports.useEffect(() => {
        const v = _.current;
        if (v)
          return (
            f.branches.add(v),
            () => {
              f.branches.delete(v);
            }
          );
      }, [f.branches]),
      jsxRuntimeExports.jsx(Primitive$1.div, { ...a, ref: w })
    );
  });
DismissableLayerBranch.displayName = BRANCH_NAME;
function usePointerDownOutside(a, e = globalThis?.document) {
  const f = useCallbackRef$1(a),
    _ = reactExports.useRef(!1),
    w = reactExports.useRef(() => {});
  return (
    reactExports.useEffect(() => {
      const v = (R) => {
          if (R.target && !_.current) {
            let O = function () {
              handleAndDispatchCustomEvent(POINTER_DOWN_OUTSIDE, f, j, {
                discrete: !0,
              });
            };
            const j = { originalEvent: R };
            R.pointerType === "touch"
              ? (e.removeEventListener("click", w.current),
                (w.current = O),
                e.addEventListener("click", w.current, { once: !0 }))
              : O();
          } else e.removeEventListener("click", w.current);
          _.current = !1;
        },
        S = window.setTimeout(() => {
          e.addEventListener("pointerdown", v);
        }, 0);
      return () => {
        (window.clearTimeout(S),
          e.removeEventListener("pointerdown", v),
          e.removeEventListener("click", w.current));
      };
    }, [e, f]),
    { onPointerDownCapture: () => (_.current = !0) }
  );
}
function useFocusOutside(a, e = globalThis?.document) {
  const f = useCallbackRef$1(a),
    _ = reactExports.useRef(!1);
  return (
    reactExports.useEffect(() => {
      const w = (v) => {
        v.target &&
          !_.current &&
          handleAndDispatchCustomEvent(
            FOCUS_OUTSIDE,
            f,
            { originalEvent: v },
            { discrete: !1 },
          );
      };
      return (
        e.addEventListener("focusin", w),
        () => e.removeEventListener("focusin", w)
      );
    }, [e, f]),
    {
      onFocusCapture: () => (_.current = !0),
      onBlurCapture: () => (_.current = !1),
    }
  );
}
function dispatchUpdate() {
  const a = new CustomEvent(CONTEXT_UPDATE);
  document.dispatchEvent(a);
}
function handleAndDispatchCustomEvent(a, e, f, { discrete: _ }) {
  const w = f.originalEvent.target,
    v = new CustomEvent(a, { bubbles: !1, cancelable: !0, detail: f });
  (e && w.addEventListener(a, e, { once: !0 }),
    _ ? dispatchDiscreteCustomEvent(w, v) : w.dispatchEvent(v));
}
var AUTOFOCUS_ON_MOUNT = "focusScope.autoFocusOnMount",
  AUTOFOCUS_ON_UNMOUNT = "focusScope.autoFocusOnUnmount",
  EVENT_OPTIONS$1 = { bubbles: !1, cancelable: !0 },
  FOCUS_SCOPE_NAME = "FocusScope",
  FocusScope = reactExports.forwardRef((a, e) => {
    const {
        loop: f = !1,
        trapped: _ = !1,
        onMountAutoFocus: w,
        onUnmountAutoFocus: v,
        ...S
      } = a,
      [R, O] = reactExports.useState(null),
      j = useCallbackRef$1(w),
      F = useCallbackRef$1(v),
      q = reactExports.useRef(null),
      Q = useComposedRefs(e, (re) => O(re)),
      te = reactExports.useRef({
        paused: !1,
        pause() {
          this.paused = !0;
        },
        resume() {
          this.paused = !1;
        },
      }).current;
    (reactExports.useEffect(() => {
      if (_) {
        let re = function (Ve) {
            if (te.paused || !R) return;
            const ze = Ve.target;
            R.contains(ze)
              ? (q.current = ze)
              : focus(q.current, { select: !0 });
          },
          Oe = function (Ve) {
            if (te.paused || !R) return;
            const ze = Ve.relatedTarget;
            ze !== null && (R.contains(ze) || focus(q.current, { select: !0 }));
          },
          Le = function (Ve) {
            if (document.activeElement === document.body)
              for (const Ge of Ve) Ge.removedNodes.length > 0 && focus(R);
          };
        (document.addEventListener("focusin", re),
          document.addEventListener("focusout", Oe));
        const Be = new MutationObserver(Le);
        return (
          R && Be.observe(R, { childList: !0, subtree: !0 }),
          () => {
            (document.removeEventListener("focusin", re),
              document.removeEventListener("focusout", Oe),
              Be.disconnect());
          }
        );
      }
    }, [_, R, te.paused]),
      reactExports.useEffect(() => {
        if (R) {
          focusScopesStack.add(te);
          const re = document.activeElement;
          if (!R.contains(re)) {
            const Le = new CustomEvent(AUTOFOCUS_ON_MOUNT, EVENT_OPTIONS$1);
            (R.addEventListener(AUTOFOCUS_ON_MOUNT, j),
              R.dispatchEvent(Le),
              Le.defaultPrevented ||
                (focusFirst$2(removeLinks(getTabbableCandidates(R)), {
                  select: !0,
                }),
                document.activeElement === re && focus(R)));
          }
          return () => {
            (R.removeEventListener(AUTOFOCUS_ON_MOUNT, j),
              setTimeout(() => {
                const Le = new CustomEvent(
                  AUTOFOCUS_ON_UNMOUNT,
                  EVENT_OPTIONS$1,
                );
                (R.addEventListener(AUTOFOCUS_ON_UNMOUNT, F),
                  R.dispatchEvent(Le),
                  Le.defaultPrevented ||
                    focus(re ?? document.body, { select: !0 }),
                  R.removeEventListener(AUTOFOCUS_ON_UNMOUNT, F),
                  focusScopesStack.remove(te));
              }, 0));
          };
        }
      }, [R, j, F, te]));
    const se = reactExports.useCallback(
      (re) => {
        if ((!f && !_) || te.paused) return;
        const Oe = re.key === "Tab" && !re.altKey && !re.ctrlKey && !re.metaKey,
          Le = document.activeElement;
        if (Oe && Le) {
          const Be = re.currentTarget,
            [Ve, ze] = getTabbableEdges(Be);
          Ve && ze
            ? !re.shiftKey && Le === ze
              ? (re.preventDefault(), f && focus(Ve, { select: !0 }))
              : re.shiftKey &&
                Le === Ve &&
                (re.preventDefault(), f && focus(ze, { select: !0 }))
            : Le === Be && re.preventDefault();
        }
      },
      [f, _, te.paused],
    );
    return jsxRuntimeExports.jsx(Primitive$1.div, {
      tabIndex: -1,
      ...S,
      ref: Q,
      onKeyDown: se,
    });
  });
FocusScope.displayName = FOCUS_SCOPE_NAME;
function focusFirst$2(a, { select: e = !1 } = {}) {
  const f = document.activeElement;
  for (const _ of a)
    if ((focus(_, { select: e }), document.activeElement !== f)) return;
}
function getTabbableEdges(a) {
  const e = getTabbableCandidates(a),
    f = findVisible(e, a),
    _ = findVisible(e.reverse(), a);
  return [f, _];
}
function getTabbableCandidates(a) {
  const e = [],
    f = document.createTreeWalker(a, NodeFilter.SHOW_ELEMENT, {
      acceptNode: (_) => {
        const w = _.tagName === "INPUT" && _.type === "hidden";
        return _.disabled || _.hidden || w
          ? NodeFilter.FILTER_SKIP
          : _.tabIndex >= 0
            ? NodeFilter.FILTER_ACCEPT
            : NodeFilter.FILTER_SKIP;
      },
    });
  for (; f.nextNode(); ) e.push(f.currentNode);
  return e;
}
function findVisible(a, e) {
  for (const f of a) if (!isHidden(f, { upTo: e })) return f;
}
function isHidden(a, { upTo: e }) {
  if (getComputedStyle(a).visibility === "hidden") return !0;
  for (; a; ) {
    if (e !== void 0 && a === e) return !1;
    if (getComputedStyle(a).display === "none") return !0;
    a = a.parentElement;
  }
  return !1;
}
function isSelectableInput(a) {
  return a instanceof HTMLInputElement && "select" in a;
}
function focus(a, { select: e = !1 } = {}) {
  if (a && a.focus) {
    const f = document.activeElement;
    (a.focus({ preventScroll: !0 }),
      a !== f && isSelectableInput(a) && e && a.select());
  }
}
var focusScopesStack = createFocusScopesStack();
function createFocusScopesStack() {
  let a = [];
  return {
    add(e) {
      const f = a[0];
      (e !== f && f?.pause(), (a = arrayRemove(a, e)), a.unshift(e));
    },
    remove(e) {
      ((a = arrayRemove(a, e)), a[0]?.resume());
    },
  };
}
function arrayRemove(a, e) {
  const f = [...a],
    _ = f.indexOf(e);
  return (_ !== -1 && f.splice(_, 1), f);
}
function removeLinks(a) {
  return a.filter((e) => e.tagName !== "A");
}
var PORTAL_NAME$5 = "Portal",
  Portal$3 = reactExports.forwardRef((a, e) => {
    const { container: f, ..._ } = a,
      [w, v] = reactExports.useState(!1);
    useLayoutEffect2(() => v(!0), []);
    const S = f || (w && globalThis?.document?.body);
    return S
      ? ReactDOM.createPortal(
          jsxRuntimeExports.jsx(Primitive$1.div, { ..._, ref: e }),
          S,
        )
      : null;
  });
Portal$3.displayName = PORTAL_NAME$5;
function useStateMachine$1(a, e) {
  return reactExports.useReducer((f, _) => e[f][_] ?? f, a);
}
var Presence = (a) => {
  const { present: e, children: f } = a,
    _ = usePresence$1(e),
    w =
      typeof f == "function"
        ? f({ present: _.isPresent })
        : reactExports.Children.only(f),
    v = useComposedRefs(_.ref, getElementRef$4(w));
  return typeof f == "function" || _.isPresent
    ? reactExports.cloneElement(w, { ref: v })
    : null;
};
Presence.displayName = "Presence";
function usePresence$1(a) {
  const [e, f] = reactExports.useState(),
    _ = reactExports.useRef(null),
    w = reactExports.useRef(a),
    v = reactExports.useRef("none"),
    S = a ? "mounted" : "unmounted",
    [R, O] = useStateMachine$1(S, {
      mounted: { UNMOUNT: "unmounted", ANIMATION_OUT: "unmountSuspended" },
      unmountSuspended: { MOUNT: "mounted", ANIMATION_END: "unmounted" },
      unmounted: { MOUNT: "mounted" },
    });
  return (
    reactExports.useEffect(() => {
      const j = getAnimationName(_.current);
      v.current = R === "mounted" ? j : "none";
    }, [R]),
    useLayoutEffect2(() => {
      const j = _.current,
        F = w.current;
      if (F !== a) {
        const Q = v.current,
          te = getAnimationName(j);
        (a
          ? O("MOUNT")
          : te === "none" || j?.display === "none"
            ? O("UNMOUNT")
            : O(F && Q !== te ? "ANIMATION_OUT" : "UNMOUNT"),
          (w.current = a));
      }
    }, [a, O]),
    useLayoutEffect2(() => {
      if (e) {
        let j;
        const F = e.ownerDocument.defaultView ?? window,
          q = (te) => {
            const re = getAnimationName(_.current).includes(
              CSS.escape(te.animationName),
            );
            if (te.target === e && re && (O("ANIMATION_END"), !w.current)) {
              const Oe = e.style.animationFillMode;
              ((e.style.animationFillMode = "forwards"),
                (j = F.setTimeout(() => {
                  e.style.animationFillMode === "forwards" &&
                    (e.style.animationFillMode = Oe);
                })));
            }
          },
          Q = (te) => {
            te.target === e && (v.current = getAnimationName(_.current));
          };
        return (
          e.addEventListener("animationstart", Q),
          e.addEventListener("animationcancel", q),
          e.addEventListener("animationend", q),
          () => {
            (F.clearTimeout(j),
              e.removeEventListener("animationstart", Q),
              e.removeEventListener("animationcancel", q),
              e.removeEventListener("animationend", q));
          }
        );
      } else O("ANIMATION_END");
    }, [e, O]),
    {
      isPresent: ["mounted", "unmountSuspended"].includes(R),
      ref: reactExports.useCallback((j) => {
        ((_.current = j ? getComputedStyle(j) : null), f(j));
      }, []),
    }
  );
}
function getAnimationName(a) {
  return a?.animationName || "none";
}
function getElementRef$4(a) {
  let e = Object.getOwnPropertyDescriptor(a.props, "ref")?.get,
    f = e && "isReactWarning" in e && e.isReactWarning;
  return f
    ? a.ref
    : ((e = Object.getOwnPropertyDescriptor(a, "ref")?.get),
      (f = e && "isReactWarning" in e && e.isReactWarning),
      f ? a.props.ref : a.props.ref || a.ref);
}
var count = 0;
function useFocusGuards() {
  reactExports.useEffect(() => {
    const a = document.querySelectorAll("[data-radix-focus-guard]");
    return (
      document.body.insertAdjacentElement(
        "afterbegin",
        a[0] ?? createFocusGuard(),
      ),
      document.body.insertAdjacentElement(
        "beforeend",
        a[1] ?? createFocusGuard(),
      ),
      count++,
      () => {
        (count === 1 &&
          document
            .querySelectorAll("[data-radix-focus-guard]")
            .forEach((e) => e.remove()),
          count--);
      }
    );
  }, []);
}
function createFocusGuard() {
  const a = document.createElement("span");
  return (
    a.setAttribute("data-radix-focus-guard", ""),
    (a.tabIndex = 0),
    (a.style.outline = "none"),
    (a.style.opacity = "0"),
    (a.style.position = "fixed"),
    (a.style.pointerEvents = "none"),
    a
  );
}
var __assign$1 = function () {
  return (
    (__assign$1 =
      Object.assign ||
      function (e) {
        for (var f, _ = 1, w = arguments.length; _ < w; _++) {
          f = arguments[_];
          for (var v in f)
            Object.prototype.hasOwnProperty.call(f, v) && (e[v] = f[v]);
        }
        return e;
      }),
    __assign$1.apply(this, arguments)
  );
};
function __rest$1(a, e) {
  var f = {};
  for (var _ in a)
    Object.prototype.hasOwnProperty.call(a, _) &&
      e.indexOf(_) < 0 &&
      (f[_] = a[_]);
  if (a != null && typeof Object.getOwnPropertySymbols == "function")
    for (var w = 0, _ = Object.getOwnPropertySymbols(a); w < _.length; w++)
      e.indexOf(_[w]) < 0 &&
        Object.prototype.propertyIsEnumerable.call(a, _[w]) &&
        (f[_[w]] = a[_[w]]);
  return f;
}
function __spreadArray(a, e, f) {
  if (f || arguments.length === 2)
    for (var _ = 0, w = e.length, v; _ < w; _++)
      (v || !(_ in e)) &&
        (v || (v = Array.prototype.slice.call(e, 0, _)), (v[_] = e[_]));
  return a.concat(v || Array.prototype.slice.call(e));
}
typeof SuppressedError == "function" && SuppressedError;
var zeroRightClassName = "right-scroll-bar-position",
  fullWidthClassName = "width-before-scroll-bar",
  noScrollbarsClassName = "with-scroll-bars-hidden",
  removedBarSizeVariable = "--removed-body-scroll-bar-size";
function assignRef(a, e) {
  return (typeof a == "function" ? a(e) : a && (a.current = e), a);
}
function useCallbackRef(a, e) {
  var f = reactExports.useState(function () {
    return {
      value: a,
      callback: e,
      facade: {
        get current() {
          return f.value;
        },
        set current(_) {
          var w = f.value;
          w !== _ && ((f.value = _), f.callback(_, w));
        },
      },
    };
  })[0];
  return ((f.callback = e), f.facade);
}
var useIsomorphicLayoutEffect$1 =
    typeof window < "u" ? reactExports.useLayoutEffect : reactExports.useEffect,
  currentValues = new WeakMap();
function useMergeRefs(a, e) {
  var f = useCallbackRef(null, function (_) {
    return a.forEach(function (w) {
      return assignRef(w, _);
    });
  });
  return (
    useIsomorphicLayoutEffect$1(
      function () {
        var _ = currentValues.get(f);
        if (_) {
          var w = new Set(_),
            v = new Set(a),
            S = f.current;
          (w.forEach(function (R) {
            v.has(R) || assignRef(R, null);
          }),
            v.forEach(function (R) {
              w.has(R) || assignRef(R, S);
            }));
        }
        currentValues.set(f, a);
      },
      [a],
    ),
    f
  );
}
var __assign = function () {
  return (
    (__assign =
      Object.assign ||
      function (e) {
        for (var f, _ = 1, w = arguments.length; _ < w; _++) {
          f = arguments[_];
          for (var v in f)
            Object.prototype.hasOwnProperty.call(f, v) && (e[v] = f[v]);
        }
        return e;
      }),
    __assign.apply(this, arguments)
  );
};
function __rest(a, e) {
  var f = {};
  for (var _ in a)
    Object.prototype.hasOwnProperty.call(a, _) &&
      e.indexOf(_) < 0 &&
      (f[_] = a[_]);
  if (a != null && typeof Object.getOwnPropertySymbols == "function")
    for (var w = 0, _ = Object.getOwnPropertySymbols(a); w < _.length; w++)
      e.indexOf(_[w]) < 0 &&
        Object.prototype.propertyIsEnumerable.call(a, _[w]) &&
        (f[_[w]] = a[_[w]]);
  return f;
}
typeof SuppressedError == "function" && SuppressedError;
function ItoI(a) {
  return a;
}
function innerCreateMedium(a, e) {
  e === void 0 && (e = ItoI);
  var f = [],
    _ = !1,
    w = {
      read: function () {
        if (_)
          throw new Error(
            "Sidecar: could not `read` from an `assigned` medium. `read` could be used only with `useMedium`.",
          );
        return f.length ? f[f.length - 1] : a;
      },
      useMedium: function (v) {
        var S = e(v, _);
        return (
          f.push(S),
          function () {
            f = f.filter(function (R) {
              return R !== S;
            });
          }
        );
      },
      assignSyncMedium: function (v) {
        for (_ = !0; f.length; ) {
          var S = f;
          ((f = []), S.forEach(v));
        }
        f = {
          push: function (R) {
            return v(R);
          },
          filter: function () {
            return f;
          },
        };
      },
      assignMedium: function (v) {
        _ = !0;
        var S = [];
        if (f.length) {
          var R = f;
          ((f = []), R.forEach(v), (S = f));
        }
        var O = function () {
            var F = S;
            ((S = []), F.forEach(v));
          },
          j = function () {
            return Promise.resolve().then(O);
          };
        (j(),
          (f = {
            push: function (F) {
              (S.push(F), j());
            },
            filter: function (F) {
              return ((S = S.filter(F)), f);
            },
          }));
      },
    };
  return w;
}
function createSidecarMedium(a) {
  a === void 0 && (a = {});
  var e = innerCreateMedium(null);
  return ((e.options = __assign({ async: !0, ssr: !1 }, a)), e);
}
var SideCar$1 = function (a) {
  var e = a.sideCar,
    f = __rest(a, ["sideCar"]);
  if (!e)
    throw new Error(
      "Sidecar: please provide `sideCar` property to import the right car",
    );
  var _ = e.read();
  if (!_) throw new Error("Sidecar medium not found");
  return reactExports.createElement(_, __assign({}, f));
};
SideCar$1.isSideCarExport = !0;
function exportSidecar(a, e) {
  return (a.useMedium(e), SideCar$1);
}
var effectCar = createSidecarMedium(),
  nothing = function () {},
  RemoveScroll = reactExports.forwardRef(function (a, e) {
    var f = reactExports.useRef(null),
      _ = reactExports.useState({
        onScrollCapture: nothing,
        onWheelCapture: nothing,
        onTouchMoveCapture: nothing,
      }),
      w = _[0],
      v = _[1],
      S = a.forwardProps,
      R = a.children,
      O = a.className,
      j = a.removeScrollBar,
      F = a.enabled,
      q = a.shards,
      Q = a.sideCar,
      te = a.noRelative,
      se = a.noIsolation,
      re = a.inert,
      Oe = a.allowPinchZoom,
      Le = a.as,
      Be = Le === void 0 ? "div" : Le,
      Ve = a.gapMode,
      ze = __rest$1(a, [
        "forwardProps",
        "children",
        "className",
        "removeScrollBar",
        "enabled",
        "shards",
        "sideCar",
        "noRelative",
        "noIsolation",
        "inert",
        "allowPinchZoom",
        "as",
        "gapMode",
      ]),
      Ge = Q,
      Ke = useMergeRefs([f, e]),
      qe = __assign$1(__assign$1({}, ze), w);
    return reactExports.createElement(
      reactExports.Fragment,
      null,
      F &&
        reactExports.createElement(Ge, {
          sideCar: effectCar,
          removeScrollBar: j,
          shards: q,
          noRelative: te,
          noIsolation: se,
          inert: re,
          setCallbacks: v,
          allowPinchZoom: !!Oe,
          lockRef: f,
          gapMode: Ve,
        }),
      S
        ? reactExports.cloneElement(
            reactExports.Children.only(R),
            __assign$1(__assign$1({}, qe), { ref: Ke }),
          )
        : reactExports.createElement(
            Be,
            __assign$1({}, qe, { className: O, ref: Ke }),
            R,
          ),
    );
  });
RemoveScroll.defaultProps = { enabled: !0, removeScrollBar: !0, inert: !1 };
RemoveScroll.classNames = {
  fullWidth: fullWidthClassName,
  zeroRight: zeroRightClassName,
};
var getNonce = function () {
  if (typeof __webpack_nonce__ < "u") return __webpack_nonce__;
};
function makeStyleTag() {
  if (!document) return null;
  var a = document.createElement("style");
  a.type = "text/css";
  var e = getNonce();
  return (e && a.setAttribute("nonce", e), a);
}
function injectStyles(a, e) {
  a.styleSheet
    ? (a.styleSheet.cssText = e)
    : a.appendChild(document.createTextNode(e));
}
function insertStyleTag(a) {
  var e = document.head || document.getElementsByTagName("head")[0];
  e.appendChild(a);
}
var stylesheetSingleton = function () {
    var a = 0,
      e = null;
    return {
      add: function (f) {
        (a == 0 &&
          (e = makeStyleTag()) &&
          (injectStyles(e, f), insertStyleTag(e)),
          a++);
      },
      remove: function () {
        (a--,
          !a && e && (e.parentNode && e.parentNode.removeChild(e), (e = null)));
      },
    };
  },
  styleHookSingleton = function () {
    var a = stylesheetSingleton();
    return function (e, f) {
      reactExports.useEffect(
        function () {
          return (
            a.add(e),
            function () {
              a.remove();
            }
          );
        },
        [e && f],
      );
    };
  },
  styleSingleton = function () {
    var a = styleHookSingleton(),
      e = function (f) {
        var _ = f.styles,
          w = f.dynamic;
        return (a(_, w), null);
      };
    return e;
  },
  zeroGap = { left: 0, top: 0, right: 0, gap: 0 },
  parse = function (a) {
    return parseInt(a || "", 10) || 0;
  },
  getOffset = function (a) {
    var e = window.getComputedStyle(document.body),
      f = e[a === "padding" ? "paddingLeft" : "marginLeft"],
      _ = e[a === "padding" ? "paddingTop" : "marginTop"],
      w = e[a === "padding" ? "paddingRight" : "marginRight"];
    return [parse(f), parse(_), parse(w)];
  },
  getGapWidth = function (a) {
    if ((a === void 0 && (a = "margin"), typeof window > "u")) return zeroGap;
    var e = getOffset(a),
      f = document.documentElement.clientWidth,
      _ = window.innerWidth;
    return {
      left: e[0],
      top: e[1],
      right: e[2],
      gap: Math.max(0, _ - f + e[2] - e[0]),
    };
  },
  Style = styleSingleton(),
  lockAttribute = "data-scroll-locked",
  getStyles = function (a, e, f, _) {
    var w = a.left,
      v = a.top,
      S = a.right,
      R = a.gap;
    return (
      f === void 0 && (f = "margin"),
      `
  .`
        .concat(
          noScrollbarsClassName,
          ` {
   overflow: hidden `,
        )
        .concat(
          _,
          `;
   padding-right: `,
        )
        .concat(R, "px ")
        .concat(
          _,
          `;
  }
  body[`,
        )
        .concat(
          lockAttribute,
          `] {
    overflow: hidden `,
        )
        .concat(
          _,
          `;
    overscroll-behavior: contain;
    `,
        )
        .concat(
          [
            e && "position: relative ".concat(_, ";"),
            f === "margin" &&
              `
    padding-left: `
                .concat(
                  w,
                  `px;
    padding-top: `,
                )
                .concat(
                  v,
                  `px;
    padding-right: `,
                )
                .concat(
                  S,
                  `px;
    margin-left:0;
    margin-top:0;
    margin-right: `,
                )
                .concat(R, "px ")
                .concat(
                  _,
                  `;
    `,
                ),
            f === "padding" &&
              "padding-right: ".concat(R, "px ").concat(_, ";"),
          ]
            .filter(Boolean)
            .join(""),
          `
  }
  
  .`,
        )
        .concat(
          zeroRightClassName,
          ` {
    right: `,
        )
        .concat(R, "px ")
        .concat(
          _,
          `;
  }
  
  .`,
        )
        .concat(
          fullWidthClassName,
          ` {
    margin-right: `,
        )
        .concat(R, "px ")
        .concat(
          _,
          `;
  }
  
  .`,
        )
        .concat(zeroRightClassName, " .")
        .concat(
          zeroRightClassName,
          ` {
    right: 0 `,
        )
        .concat(
          _,
          `;
  }
  
  .`,
        )
        .concat(fullWidthClassName, " .")
        .concat(
          fullWidthClassName,
          ` {
    margin-right: 0 `,
        )
        .concat(
          _,
          `;
  }
  
  body[`,
        )
        .concat(
          lockAttribute,
          `] {
    `,
        )
        .concat(removedBarSizeVariable, ": ")
        .concat(
          R,
          `px;
  }
`,
        )
    );
  },
  getCurrentUseCounter = function () {
    var a = parseInt(document.body.getAttribute(lockAttribute) || "0", 10);
    return isFinite(a) ? a : 0;
  },
  useLockAttribute = function () {
    reactExports.useEffect(function () {
      return (
        document.body.setAttribute(
          lockAttribute,
          (getCurrentUseCounter() + 1).toString(),
        ),
        function () {
          var a = getCurrentUseCounter() - 1;
          a <= 0
            ? document.body.removeAttribute(lockAttribute)
            : document.body.setAttribute(lockAttribute, a.toString());
        }
      );
    }, []);
  },
  RemoveScrollBar = function (a) {
    var e = a.noRelative,
      f = a.noImportant,
      _ = a.gapMode,
      w = _ === void 0 ? "margin" : _;
    useLockAttribute();
    var v = reactExports.useMemo(
      function () {
        return getGapWidth(w);
      },
      [w],
    );
    return reactExports.createElement(Style, {
      styles: getStyles(v, !e, w, f ? "" : "!important"),
    });
  },
  passiveSupported = !1;
if (typeof window < "u")
  try {
    var options = Object.defineProperty({}, "passive", {
      get: function () {
        return ((passiveSupported = !0), !0);
      },
    });
    (window.addEventListener("test", options, options),
      window.removeEventListener("test", options, options));
  } catch {
    passiveSupported = !1;
  }
var nonPassive = passiveSupported ? { passive: !1 } : !1,
  alwaysContainsScroll = function (a) {
    return a.tagName === "TEXTAREA";
  },
  elementCanBeScrolled = function (a, e) {
    if (!(a instanceof Element)) return !1;
    var f = window.getComputedStyle(a);
    return (
      f[e] !== "hidden" &&
      !(
        f.overflowY === f.overflowX &&
        !alwaysContainsScroll(a) &&
        f[e] === "visible"
      )
    );
  },
  elementCouldBeVScrolled = function (a) {
    return elementCanBeScrolled(a, "overflowY");
  },
  elementCouldBeHScrolled = function (a) {
    return elementCanBeScrolled(a, "overflowX");
  },
  locationCouldBeScrolled = function (a, e) {
    var f = e.ownerDocument,
      _ = e;
    do {
      typeof ShadowRoot < "u" && _ instanceof ShadowRoot && (_ = _.host);
      var w = elementCouldBeScrolled(a, _);
      if (w) {
        var v = getScrollVariables(a, _),
          S = v[1],
          R = v[2];
        if (S > R) return !0;
      }
      _ = _.parentNode;
    } while (_ && _ !== f.body);
    return !1;
  },
  getVScrollVariables = function (a) {
    var e = a.scrollTop,
      f = a.scrollHeight,
      _ = a.clientHeight;
    return [e, f, _];
  },
  getHScrollVariables = function (a) {
    var e = a.scrollLeft,
      f = a.scrollWidth,
      _ = a.clientWidth;
    return [e, f, _];
  },
  elementCouldBeScrolled = function (a, e) {
    return a === "v" ? elementCouldBeVScrolled(e) : elementCouldBeHScrolled(e);
  },
  getScrollVariables = function (a, e) {
    return a === "v" ? getVScrollVariables(e) : getHScrollVariables(e);
  },
  getDirectionFactor = function (a, e) {
    return a === "h" && e === "rtl" ? -1 : 1;
  },
  handleScroll = function (a, e, f, _, w) {
    var v = getDirectionFactor(a, window.getComputedStyle(e).direction),
      S = v * _,
      R = f.target,
      O = e.contains(R),
      j = !1,
      F = S > 0,
      q = 0,
      Q = 0;
    do {
      if (!R) break;
      var te = getScrollVariables(a, R),
        se = te[0],
        re = te[1],
        Oe = te[2],
        Le = re - Oe - v * se;
      (se || Le) && elementCouldBeScrolled(a, R) && ((q += Le), (Q += se));
      var Be = R.parentNode;
      R = Be && Be.nodeType === Node.DOCUMENT_FRAGMENT_NODE ? Be.host : Be;
    } while ((!O && R !== document.body) || (O && (e.contains(R) || e === R)));
    return (((F && Math.abs(q) < 1) || (!F && Math.abs(Q) < 1)) && (j = !0), j);
  },
  getTouchXY = function (a) {
    return "changedTouches" in a
      ? [a.changedTouches[0].clientX, a.changedTouches[0].clientY]
      : [0, 0];
  },
  getDeltaXY = function (a) {
    return [a.deltaX, a.deltaY];
  },
  extractRef = function (a) {
    return a && "current" in a ? a.current : a;
  },
  deltaCompare = function (a, e) {
    return a[0] === e[0] && a[1] === e[1];
  },
  generateStyle = function (a) {
    return `
  .block-interactivity-`
      .concat(
        a,
        ` {pointer-events: none;}
  .allow-interactivity-`,
      )
      .concat(
        a,
        ` {pointer-events: all;}
`,
      );
  },
  idCounter = 0,
  lockStack = [];
function RemoveScrollSideCar(a) {
  var e = reactExports.useRef([]),
    f = reactExports.useRef([0, 0]),
    _ = reactExports.useRef(),
    w = reactExports.useState(idCounter++)[0],
    v = reactExports.useState(styleSingleton)[0],
    S = reactExports.useRef(a);
  (reactExports.useEffect(
    function () {
      S.current = a;
    },
    [a],
  ),
    reactExports.useEffect(
      function () {
        if (a.inert) {
          document.body.classList.add("block-interactivity-".concat(w));
          var re = __spreadArray(
            [a.lockRef.current],
            (a.shards || []).map(extractRef),
            !0,
          ).filter(Boolean);
          return (
            re.forEach(function (Oe) {
              return Oe.classList.add("allow-interactivity-".concat(w));
            }),
            function () {
              (document.body.classList.remove("block-interactivity-".concat(w)),
                re.forEach(function (Oe) {
                  return Oe.classList.remove("allow-interactivity-".concat(w));
                }));
            }
          );
        }
      },
      [a.inert, a.lockRef.current, a.shards],
    ));
  var R = reactExports.useCallback(function (re, Oe) {
      if (
        ("touches" in re && re.touches.length === 2) ||
        (re.type === "wheel" && re.ctrlKey)
      )
        return !S.current.allowPinchZoom;
      var Le = getTouchXY(re),
        Be = f.current,
        Ve = "deltaX" in re ? re.deltaX : Be[0] - Le[0],
        ze = "deltaY" in re ? re.deltaY : Be[1] - Le[1],
        Ge,
        Ke = re.target,
        qe = Math.abs(Ve) > Math.abs(ze) ? "h" : "v";
      if ("touches" in re && qe === "h" && Ke.type === "range") return !1;
      var nt = window.getSelection(),
        pt = nt && nt.anchorNode,
        gt = pt ? pt === Ke || pt.contains(Ke) : !1;
      if (gt) return !1;
      var mt = locationCouldBeScrolled(qe, Ke);
      if (!mt) return !0;
      if (
        (mt
          ? (Ge = qe)
          : ((Ge = qe === "v" ? "h" : "v"),
            (mt = locationCouldBeScrolled(qe, Ke))),
        !mt)
      )
        return !1;
      if (
        (!_.current && "changedTouches" in re && (Ve || ze) && (_.current = Ge),
        !Ge)
      )
        return !0;
      var dt = _.current || Ge;
      return handleScroll(dt, Oe, re, dt === "h" ? Ve : ze);
    }, []),
    O = reactExports.useCallback(function (re) {
      var Oe = re;
      if (!(!lockStack.length || lockStack[lockStack.length - 1] !== v)) {
        var Le = "deltaY" in Oe ? getDeltaXY(Oe) : getTouchXY(Oe),
          Be = e.current.filter(function (Ge) {
            return (
              Ge.name === Oe.type &&
              (Ge.target === Oe.target || Oe.target === Ge.shadowParent) &&
              deltaCompare(Ge.delta, Le)
            );
          })[0];
        if (Be && Be.should) {
          Oe.cancelable && Oe.preventDefault();
          return;
        }
        if (!Be) {
          var Ve = (S.current.shards || [])
              .map(extractRef)
              .filter(Boolean)
              .filter(function (Ge) {
                return Ge.contains(Oe.target);
              }),
            ze = Ve.length > 0 ? R(Oe, Ve[0]) : !S.current.noIsolation;
          ze && Oe.cancelable && Oe.preventDefault();
        }
      }
    }, []),
    j = reactExports.useCallback(function (re, Oe, Le, Be) {
      var Ve = {
        name: re,
        delta: Oe,
        target: Le,
        should: Be,
        shadowParent: getOutermostShadowParent(Le),
      };
      (e.current.push(Ve),
        setTimeout(function () {
          e.current = e.current.filter(function (ze) {
            return ze !== Ve;
          });
        }, 1));
    }, []),
    F = reactExports.useCallback(function (re) {
      ((f.current = getTouchXY(re)), (_.current = void 0));
    }, []),
    q = reactExports.useCallback(function (re) {
      j(re.type, getDeltaXY(re), re.target, R(re, a.lockRef.current));
    }, []),
    Q = reactExports.useCallback(function (re) {
      j(re.type, getTouchXY(re), re.target, R(re, a.lockRef.current));
    }, []);
  reactExports.useEffect(function () {
    return (
      lockStack.push(v),
      a.setCallbacks({
        onScrollCapture: q,
        onWheelCapture: q,
        onTouchMoveCapture: Q,
      }),
      document.addEventListener("wheel", O, nonPassive),
      document.addEventListener("touchmove", O, nonPassive),
      document.addEventListener("touchstart", F, nonPassive),
      function () {
        ((lockStack = lockStack.filter(function (re) {
          return re !== v;
        })),
          document.removeEventListener("wheel", O, nonPassive),
          document.removeEventListener("touchmove", O, nonPassive),
          document.removeEventListener("touchstart", F, nonPassive));
      }
    );
  }, []);
  var te = a.removeScrollBar,
    se = a.inert;
  return reactExports.createElement(
    reactExports.Fragment,
    null,
    se ? reactExports.createElement(v, { styles: generateStyle(w) }) : null,
    te
      ? reactExports.createElement(RemoveScrollBar, {
          noRelative: a.noRelative,
          gapMode: a.gapMode,
        })
      : null,
  );
}
function getOutermostShadowParent(a) {
  for (var e = null; a !== null; )
    (a instanceof ShadowRoot && ((e = a.host), (a = a.host)),
      (a = a.parentNode));
  return e;
}
const SideCar = exportSidecar(effectCar, RemoveScrollSideCar);
var ReactRemoveScroll = reactExports.forwardRef(function (a, e) {
  return reactExports.createElement(
    RemoveScroll,
    __assign$1({}, a, { ref: e, sideCar: SideCar }),
  );
});
ReactRemoveScroll.classNames = RemoveScroll.classNames;
var getDefaultParent = function (a) {
    if (typeof document > "u") return null;
    var e = Array.isArray(a) ? a[0] : a;
    return e.ownerDocument.body;
  },
  counterMap = new WeakMap(),
  uncontrolledNodes = new WeakMap(),
  markerMap = {},
  lockCount = 0,
  unwrapHost = function (a) {
    return a && (a.host || unwrapHost(a.parentNode));
  },
  correctTargets = function (a, e) {
    return e
      .map(function (f) {
        if (a.contains(f)) return f;
        var _ = unwrapHost(f);
        return _ && a.contains(_)
          ? _
          : (console.error(
              "aria-hidden",
              f,
              "in not contained inside",
              a,
              ". Doing nothing",
            ),
            null);
      })
      .filter(function (f) {
        return !!f;
      });
  },
  applyAttributeToOthers = function (a, e, f, _) {
    var w = correctTargets(e, Array.isArray(a) ? a : [a]);
    markerMap[f] || (markerMap[f] = new WeakMap());
    var v = markerMap[f],
      S = [],
      R = new Set(),
      O = new Set(w),
      j = function (q) {
        !q || R.has(q) || (R.add(q), j(q.parentNode));
      };
    w.forEach(j);
    var F = function (q) {
      !q ||
        O.has(q) ||
        Array.prototype.forEach.call(q.children, function (Q) {
          if (R.has(Q)) F(Q);
          else
            try {
              var te = Q.getAttribute(_),
                se = te !== null && te !== "false",
                re = (counterMap.get(Q) || 0) + 1,
                Oe = (v.get(Q) || 0) + 1;
              (counterMap.set(Q, re),
                v.set(Q, Oe),
                S.push(Q),
                re === 1 && se && uncontrolledNodes.set(Q, !0),
                Oe === 1 && Q.setAttribute(f, "true"),
                se || Q.setAttribute(_, "true"));
            } catch (Le) {
              console.error("aria-hidden: cannot operate on ", Q, Le);
            }
        });
    };
    return (
      F(e),
      R.clear(),
      lockCount++,
      function () {
        (S.forEach(function (q) {
          var Q = counterMap.get(q) - 1,
            te = v.get(q) - 1;
          (counterMap.set(q, Q),
            v.set(q, te),
            Q ||
              (uncontrolledNodes.has(q) || q.removeAttribute(_),
              uncontrolledNodes.delete(q)),
            te || q.removeAttribute(f));
        }),
          lockCount--,
          lockCount ||
            ((counterMap = new WeakMap()),
            (counterMap = new WeakMap()),
            (uncontrolledNodes = new WeakMap()),
            (markerMap = {})));
      }
    );
  },
  hideOthers = function (a, e, f) {
    f === void 0 && (f = "data-aria-hidden");
    var _ = Array.from(Array.isArray(a) ? a : [a]),
      w = getDefaultParent(a);
    return w
      ? (_.push.apply(_, Array.from(w.querySelectorAll("[aria-live], script"))),
        applyAttributeToOthers(_, w, f, "aria-hidden"))
      : function () {
          return null;
        };
  };
function createSlot$3(a) {
  const e = createSlotClone$3(a),
    f = reactExports.forwardRef((_, w) => {
      const { children: v, ...S } = _,
        R = reactExports.Children.toArray(v),
        O = R.find(isSlottable$3);
      if (O) {
        const j = O.props.children,
          F = R.map((q) =>
            q === O
              ? reactExports.Children.count(j) > 1
                ? reactExports.Children.only(null)
                : reactExports.isValidElement(j)
                  ? j.props.children
                  : null
              : q,
          );
        return jsxRuntimeExports.jsx(e, {
          ...S,
          ref: w,
          children: reactExports.isValidElement(j)
            ? reactExports.cloneElement(j, void 0, F)
            : null,
        });
      }
      return jsxRuntimeExports.jsx(e, { ...S, ref: w, children: v });
    });
  return ((f.displayName = `${a}.Slot`), f);
}
function createSlotClone$3(a) {
  const e = reactExports.forwardRef((f, _) => {
    const { children: w, ...v } = f;
    if (reactExports.isValidElement(w)) {
      const S = getElementRef$3(w),
        R = mergeProps$3(v, w.props);
      return (
        w.type !== reactExports.Fragment && (R.ref = _ ? composeRefs(_, S) : S),
        reactExports.cloneElement(w, R)
      );
    }
    return reactExports.Children.count(w) > 1
      ? reactExports.Children.only(null)
      : null;
  });
  return ((e.displayName = `${a}.SlotClone`), e);
}
var SLOTTABLE_IDENTIFIER$4 = Symbol("radix.slottable");
function isSlottable$3(a) {
  return (
    reactExports.isValidElement(a) &&
    typeof a.type == "function" &&
    "__radixId" in a.type &&
    a.type.__radixId === SLOTTABLE_IDENTIFIER$4
  );
}
function mergeProps$3(a, e) {
  const f = { ...e };
  for (const _ in e) {
    const w = a[_],
      v = e[_];
    /^on[A-Z]/.test(_)
      ? w && v
        ? (f[_] = (...R) => {
            const O = v(...R);
            return (w(...R), O);
          })
        : w && (f[_] = w)
      : _ === "style"
        ? (f[_] = { ...w, ...v })
        : _ === "className" && (f[_] = [w, v].filter(Boolean).join(" "));
  }
  return { ...a, ...f };
}
function getElementRef$3(a) {
  let e = Object.getOwnPropertyDescriptor(a.props, "ref")?.get,
    f = e && "isReactWarning" in e && e.isReactWarning;
  return f
    ? a.ref
    : ((e = Object.getOwnPropertyDescriptor(a, "ref")?.get),
      (f = e && "isReactWarning" in e && e.isReactWarning),
      f ? a.props.ref : a.props.ref || a.ref);
}
var DIALOG_NAME = "Dialog",
  [createDialogContext] = createContextScope(DIALOG_NAME),
  [DialogProvider, useDialogContext] = createDialogContext(DIALOG_NAME),
  Dialog$1 = (a) => {
    const {
        __scopeDialog: e,
        children: f,
        open: _,
        defaultOpen: w,
        onOpenChange: v,
        modal: S = !0,
      } = a,
      R = reactExports.useRef(null),
      O = reactExports.useRef(null),
      [j, F] = useControllableState({
        prop: _,
        defaultProp: w ?? !1,
        onChange: v,
        caller: DIALOG_NAME,
      });
    return jsxRuntimeExports.jsx(DialogProvider, {
      scope: e,
      triggerRef: R,
      contentRef: O,
      contentId: useId(),
      titleId: useId(),
      descriptionId: useId(),
      open: j,
      onOpenChange: F,
      onOpenToggle: reactExports.useCallback(() => F((q) => !q), [F]),
      modal: S,
      children: f,
    });
  };
Dialog$1.displayName = DIALOG_NAME;
var TRIGGER_NAME$3 = "DialogTrigger",
  DialogTrigger$1 = reactExports.forwardRef((a, e) => {
    const { __scopeDialog: f, ..._ } = a,
      w = useDialogContext(TRIGGER_NAME$3, f),
      v = useComposedRefs(e, w.triggerRef);
    return jsxRuntimeExports.jsx(Primitive$1.button, {
      type: "button",
      "aria-haspopup": "dialog",
      "aria-expanded": w.open,
      "aria-controls": w.contentId,
      "data-state": getState(w.open),
      ..._,
      ref: v,
      onClick: composeEventHandlers(a.onClick, w.onOpenToggle),
    });
  });
DialogTrigger$1.displayName = TRIGGER_NAME$3;
var PORTAL_NAME$4 = "DialogPortal",
  [PortalProvider$2, usePortalContext$2] = createDialogContext(PORTAL_NAME$4, {
    forceMount: void 0,
  }),
  DialogPortal$1 = (a) => {
    const { __scopeDialog: e, forceMount: f, children: _, container: w } = a,
      v = useDialogContext(PORTAL_NAME$4, e);
    return jsxRuntimeExports.jsx(PortalProvider$2, {
      scope: e,
      forceMount: f,
      children: reactExports.Children.map(_, (S) =>
        jsxRuntimeExports.jsx(Presence, {
          present: f || v.open,
          children: jsxRuntimeExports.jsx(Portal$3, {
            asChild: !0,
            container: w,
            children: S,
          }),
        }),
      ),
    });
  };
DialogPortal$1.displayName = PORTAL_NAME$4;
var OVERLAY_NAME = "DialogOverlay",
  DialogOverlay$1 = reactExports.forwardRef((a, e) => {
    const f = usePortalContext$2(OVERLAY_NAME, a.__scopeDialog),
      { forceMount: _ = f.forceMount, ...w } = a,
      v = useDialogContext(OVERLAY_NAME, a.__scopeDialog);
    return v.modal
      ? jsxRuntimeExports.jsx(Presence, {
          present: _ || v.open,
          children: jsxRuntimeExports.jsx(DialogOverlayImpl, { ...w, ref: e }),
        })
      : null;
  });
DialogOverlay$1.displayName = OVERLAY_NAME;
var Slot$2 = createSlot$3("DialogOverlay.RemoveScroll"),
  DialogOverlayImpl = reactExports.forwardRef((a, e) => {
    const { __scopeDialog: f, ..._ } = a,
      w = useDialogContext(OVERLAY_NAME, f);
    return jsxRuntimeExports.jsx(ReactRemoveScroll, {
      as: Slot$2,
      allowPinchZoom: !0,
      shards: [w.contentRef],
      children: jsxRuntimeExports.jsx(Primitive$1.div, {
        "data-state": getState(w.open),
        ..._,
        ref: e,
        style: { pointerEvents: "auto", ..._.style },
      }),
    });
  }),
  CONTENT_NAME$5 = "DialogContent",
  DialogContent$1 = reactExports.forwardRef((a, e) => {
    const f = usePortalContext$2(CONTENT_NAME$5, a.__scopeDialog),
      { forceMount: _ = f.forceMount, ...w } = a,
      v = useDialogContext(CONTENT_NAME$5, a.__scopeDialog);
    return jsxRuntimeExports.jsx(Presence, {
      present: _ || v.open,
      children: v.modal
        ? jsxRuntimeExports.jsx(DialogContentModal, { ...w, ref: e })
        : jsxRuntimeExports.jsx(DialogContentNonModal, { ...w, ref: e }),
    });
  });
DialogContent$1.displayName = CONTENT_NAME$5;
var DialogContentModal = reactExports.forwardRef((a, e) => {
    const f = useDialogContext(CONTENT_NAME$5, a.__scopeDialog),
      _ = reactExports.useRef(null),
      w = useComposedRefs(e, f.contentRef, _);
    return (
      reactExports.useEffect(() => {
        const v = _.current;
        if (v) return hideOthers(v);
      }, []),
      jsxRuntimeExports.jsx(DialogContentImpl, {
        ...a,
        ref: w,
        trapFocus: f.open,
        disableOutsidePointerEvents: !0,
        onCloseAutoFocus: composeEventHandlers(a.onCloseAutoFocus, (v) => {
          (v.preventDefault(), f.triggerRef.current?.focus());
        }),
        onPointerDownOutside: composeEventHandlers(
          a.onPointerDownOutside,
          (v) => {
            const S = v.detail.originalEvent,
              R = S.button === 0 && S.ctrlKey === !0;
            (S.button === 2 || R) && v.preventDefault();
          },
        ),
        onFocusOutside: composeEventHandlers(a.onFocusOutside, (v) =>
          v.preventDefault(),
        ),
      })
    );
  }),
  DialogContentNonModal = reactExports.forwardRef((a, e) => {
    const f = useDialogContext(CONTENT_NAME$5, a.__scopeDialog),
      _ = reactExports.useRef(!1),
      w = reactExports.useRef(!1);
    return jsxRuntimeExports.jsx(DialogContentImpl, {
      ...a,
      ref: e,
      trapFocus: !1,
      disableOutsidePointerEvents: !1,
      onCloseAutoFocus: (v) => {
        (a.onCloseAutoFocus?.(v),
          v.defaultPrevented ||
            (_.current || f.triggerRef.current?.focus(), v.preventDefault()),
          (_.current = !1),
          (w.current = !1));
      },
      onInteractOutside: (v) => {
        (a.onInteractOutside?.(v),
          v.defaultPrevented ||
            ((_.current = !0),
            v.detail.originalEvent.type === "pointerdown" && (w.current = !0)));
        const S = v.target;
        (f.triggerRef.current?.contains(S) && v.preventDefault(),
          v.detail.originalEvent.type === "focusin" &&
            w.current &&
            v.preventDefault());
      },
    });
  }),
  DialogContentImpl = reactExports.forwardRef((a, e) => {
    const {
        __scopeDialog: f,
        trapFocus: _,
        onOpenAutoFocus: w,
        onCloseAutoFocus: v,
        ...S
      } = a,
      R = useDialogContext(CONTENT_NAME$5, f),
      O = reactExports.useRef(null),
      j = useComposedRefs(e, O);
    return (
      useFocusGuards(),
      jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
        children: [
          jsxRuntimeExports.jsx(FocusScope, {
            asChild: !0,
            loop: !0,
            trapped: _,
            onMountAutoFocus: w,
            onUnmountAutoFocus: v,
            children: jsxRuntimeExports.jsx(DismissableLayer, {
              role: "dialog",
              id: R.contentId,
              "aria-describedby": R.descriptionId,
              "aria-labelledby": R.titleId,
              "data-state": getState(R.open),
              ...S,
              ref: j,
              onDismiss: () => R.onOpenChange(!1),
            }),
          }),
          jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
            children: [
              jsxRuntimeExports.jsx(TitleWarning, { titleId: R.titleId }),
              jsxRuntimeExports.jsx(DescriptionWarning, {
                contentRef: O,
                descriptionId: R.descriptionId,
              }),
            ],
          }),
        ],
      })
    );
  }),
  TITLE_NAME = "DialogTitle",
  DialogTitle$1 = reactExports.forwardRef((a, e) => {
    const { __scopeDialog: f, ..._ } = a,
      w = useDialogContext(TITLE_NAME, f);
    return jsxRuntimeExports.jsx(Primitive$1.h2, {
      id: w.titleId,
      ..._,
      ref: e,
    });
  });
DialogTitle$1.displayName = TITLE_NAME;
var DESCRIPTION_NAME = "DialogDescription",
  DialogDescription$1 = reactExports.forwardRef((a, e) => {
    const { __scopeDialog: f, ..._ } = a,
      w = useDialogContext(DESCRIPTION_NAME, f);
    return jsxRuntimeExports.jsx(Primitive$1.p, {
      id: w.descriptionId,
      ..._,
      ref: e,
    });
  });
DialogDescription$1.displayName = DESCRIPTION_NAME;
var CLOSE_NAME = "DialogClose",
  DialogClose = reactExports.forwardRef((a, e) => {
    const { __scopeDialog: f, ..._ } = a,
      w = useDialogContext(CLOSE_NAME, f);
    return jsxRuntimeExports.jsx(Primitive$1.button, {
      type: "button",
      ..._,
      ref: e,
      onClick: composeEventHandlers(a.onClick, () => w.onOpenChange(!1)),
    });
  });
DialogClose.displayName = CLOSE_NAME;
function getState(a) {
  return a ? "open" : "closed";
}
var TITLE_WARNING_NAME = "DialogTitleWarning",
  [WarningProvider, useWarningContext] = createContext2(TITLE_WARNING_NAME, {
    contentName: CONTENT_NAME$5,
    titleName: TITLE_NAME,
    docsSlug: "dialog",
  }),
  TitleWarning = ({ titleId: a }) => {
    const e = useWarningContext(TITLE_WARNING_NAME),
      f = `\`${e.contentName}\` requires a \`${e.titleName}\` for the component to be accessible for screen reader users.

If you want to hide the \`${e.titleName}\`, you can wrap it with our VisuallyHidden component.

For more information, see https://radix-ui.com/primitives/docs/components/${e.docsSlug}`;
    return (
      reactExports.useEffect(() => {
        a && (document.getElementById(a) || console.error(f));
      }, [f, a]),
      null
    );
  },
  DESCRIPTION_WARNING_NAME = "DialogDescriptionWarning",
  DescriptionWarning = ({ contentRef: a, descriptionId: e }) => {
    const _ = `Warning: Missing \`Description\` or \`aria-describedby={undefined}\` for {${useWarningContext(DESCRIPTION_WARNING_NAME).contentName}}.`;
    return (
      reactExports.useEffect(() => {
        const w = a.current?.getAttribute("aria-describedby");
        e && w && (document.getElementById(e) || console.warn(_));
      }, [_, a, e]),
      null
    );
  },
  Root$4 = Dialog$1,
  Trigger$3 = DialogTrigger$1,
  Portal$2 = DialogPortal$1,
  Overlay = DialogOverlay$1,
  Content$1 = DialogContent$1,
  Title = DialogTitle$1,
  Description = DialogDescription$1,
  Close = DialogClose;
const Sheet = Root$4,
  SheetPortal = Portal$2,
  SheetOverlay = reactExports.forwardRef(({ className: a, ...e }, f) =>
    jsxRuntimeExports.jsx(Overlay, {
      className: cn(
        "fixed inset-0 z-50 bg-black/80  data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
        a,
      ),
      ...e,
      ref: f,
    }),
  );
SheetOverlay.displayName = Overlay.displayName;
const sheetVariants = cva(
    "fixed z-50 gap-4 bg-background p-6 transition ease-in-out data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:duration-150 data-[state=open]:duration-150",
    {
      variants: {
        side: {
          top: "inset-x-0 top-0 border-b data-[state=closed]:slide-out-to-top data-[state=open]:slide-in-from-top",
          bottom:
            "inset-x-0 bottom-0 border-t data-[state=closed]:slide-out-to-bottom data-[state=open]:slide-in-from-bottom",
          left: "inset-y-0 left-0 h-full w-3/4 border-r data-[state=closed]:slide-out-to-left data-[state=open]:slide-in-from-left sm:max-w-sm",
          right:
            "inset-y-0 right-0 h-full w-3/4  border-l data-[state=closed]:slide-out-to-right data-[state=open]:slide-in-from-right sm:max-w-sm",
        },
      },
      defaultVariants: { side: "right" },
    },
  ),
  SheetContent = reactExports.forwardRef(
    ({ side: a = "right", className: e, children: f, ..._ }, w) =>
      jsxRuntimeExports.jsxs(SheetPortal, {
        children: [
          jsxRuntimeExports.jsx(SheetOverlay, {}),
          jsxRuntimeExports.jsxs(Content$1, {
            ref: w,
            className: cn(sheetVariants({ side: a }), e),
            ..._,
            children: [
              f,
              jsxRuntimeExports.jsxs(Close, {
                className:
                  "absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-secondary",
                children: [
                  jsxRuntimeExports.jsx(X$1, { className: "h-4 w-4" }),
                  jsxRuntimeExports.jsx("span", {
                    className: "sr-only",
                    children: "Close",
                  }),
                ],
              }),
            ],
          }),
        ],
      }),
  );
SheetContent.displayName = Content$1.displayName;
const SheetHeader = ({ className: a, ...e }) =>
  jsxRuntimeExports.jsx("div", {
    className: cn("flex flex-col space-y-2 text-center sm:text-left", a),
    ...e,
  });
SheetHeader.displayName = "SheetHeader";
const SheetTitle = reactExports.forwardRef(({ className: a, ...e }, f) =>
  jsxRuntimeExports.jsx(Title, {
    ref: f,
    className: cn("text-lg font-semibold text-foreground", a),
    ...e,
  }),
);
SheetTitle.displayName = Title.displayName;
const SheetDescription = reactExports.forwardRef(({ className: a, ...e }, f) =>
  jsxRuntimeExports.jsx(Description, {
    ref: f,
    className: cn("text-sm text-muted-foreground", a),
    ...e,
  }),
);
SheetDescription.displayName = Description.displayName;
function Skeleton({ className: a, ...e }) {
  return jsxRuntimeExports.jsx("div", {
    className: cn("animate-pulse rounded-md bg-muted", a),
    ...e,
  });
}
const sides = ["top", "right", "bottom", "left"],
  min = Math.min,
  max = Math.max,
  round = Math.round,
  floor = Math.floor,
  createCoords = (a) => ({ x: a, y: a }),
  oppositeSideMap = {
    left: "right",
    right: "left",
    bottom: "top",
    top: "bottom",
  },
  oppositeAlignmentMap = { start: "end", end: "start" };
function clamp$2(a, e, f) {
  return max(a, min(e, f));
}
function evaluate(a, e) {
  return typeof a == "function" ? a(e) : a;
}
function getSide(a) {
  return a.split("-")[0];
}
function getAlignment(a) {
  return a.split("-")[1];
}
function getOppositeAxis(a) {
  return a === "x" ? "y" : "x";
}
function getAxisLength(a) {
  return a === "y" ? "height" : "width";
}
const yAxisSides = new Set(["top", "bottom"]);
function getSideAxis(a) {
  return yAxisSides.has(getSide(a)) ? "y" : "x";
}
function getAlignmentAxis(a) {
  return getOppositeAxis(getSideAxis(a));
}
function getAlignmentSides(a, e, f) {
  f === void 0 && (f = !1);
  const _ = getAlignment(a),
    w = getAlignmentAxis(a),
    v = getAxisLength(w);
  let S =
    w === "x"
      ? _ === (f ? "end" : "start")
        ? "right"
        : "left"
      : _ === "start"
        ? "bottom"
        : "top";
  return (
    e.reference[v] > e.floating[v] && (S = getOppositePlacement(S)),
    [S, getOppositePlacement(S)]
  );
}
function getExpandedPlacements(a) {
  const e = getOppositePlacement(a);
  return [
    getOppositeAlignmentPlacement(a),
    e,
    getOppositeAlignmentPlacement(e),
  ];
}
function getOppositeAlignmentPlacement(a) {
  return a.replace(/start|end/g, (e) => oppositeAlignmentMap[e]);
}
const lrPlacement = ["left", "right"],
  rlPlacement = ["right", "left"],
  tbPlacement = ["top", "bottom"],
  btPlacement = ["bottom", "top"];
function getSideList(a, e, f) {
  switch (a) {
    case "top":
    case "bottom":
      return f
        ? e
          ? rlPlacement
          : lrPlacement
        : e
          ? lrPlacement
          : rlPlacement;
    case "left":
    case "right":
      return e ? tbPlacement : btPlacement;
    default:
      return [];
  }
}
function getOppositeAxisPlacements(a, e, f, _) {
  const w = getAlignment(a);
  let v = getSideList(getSide(a), f === "start", _);
  return (
    w &&
      ((v = v.map((S) => S + "-" + w)),
      e && (v = v.concat(v.map(getOppositeAlignmentPlacement)))),
    v
  );
}
function getOppositePlacement(a) {
  return a.replace(/left|right|bottom|top/g, (e) => oppositeSideMap[e]);
}
function expandPaddingObject(a) {
  return { top: 0, right: 0, bottom: 0, left: 0, ...a };
}
function getPaddingObject(a) {
  return typeof a != "number"
    ? expandPaddingObject(a)
    : { top: a, right: a, bottom: a, left: a };
}
function rectToClientRect(a) {
  const { x: e, y: f, width: _, height: w } = a;
  return {
    width: _,
    height: w,
    top: f,
    left: e,
    right: e + _,
    bottom: f + w,
    x: e,
    y: f,
  };
}
function computeCoordsFromPlacement(a, e, f) {
  let { reference: _, floating: w } = a;
  const v = getSideAxis(e),
    S = getAlignmentAxis(e),
    R = getAxisLength(S),
    O = getSide(e),
    j = v === "y",
    F = _.x + _.width / 2 - w.width / 2,
    q = _.y + _.height / 2 - w.height / 2,
    Q = _[R] / 2 - w[R] / 2;
  let te;
  switch (O) {
    case "top":
      te = { x: F, y: _.y - w.height };
      break;
    case "bottom":
      te = { x: F, y: _.y + _.height };
      break;
    case "right":
      te = { x: _.x + _.width, y: q };
      break;
    case "left":
      te = { x: _.x - w.width, y: q };
      break;
    default:
      te = { x: _.x, y: _.y };
  }
  switch (getAlignment(e)) {
    case "start":
      te[S] -= Q * (f && j ? -1 : 1);
      break;
    case "end":
      te[S] += Q * (f && j ? -1 : 1);
      break;
  }
  return te;
}
const computePosition$1 = async (a, e, f) => {
  const {
      placement: _ = "bottom",
      strategy: w = "absolute",
      middleware: v = [],
      platform: S,
    } = f,
    R = v.filter(Boolean),
    O = await (S.isRTL == null ? void 0 : S.isRTL(e));
  let j = await S.getElementRects({ reference: a, floating: e, strategy: w }),
    { x: F, y: q } = computeCoordsFromPlacement(j, _, O),
    Q = _,
    te = {},
    se = 0;
  for (let re = 0; re < R.length; re++) {
    const { name: Oe, fn: Le } = R[re],
      {
        x: Be,
        y: Ve,
        data: ze,
        reset: Ge,
      } = await Le({
        x: F,
        y: q,
        initialPlacement: _,
        placement: Q,
        strategy: w,
        middlewareData: te,
        rects: j,
        platform: S,
        elements: { reference: a, floating: e },
      });
    ((F = Be ?? F),
      (q = Ve ?? q),
      (te = { ...te, [Oe]: { ...te[Oe], ...ze } }),
      Ge &&
        se <= 50 &&
        (se++,
        typeof Ge == "object" &&
          (Ge.placement && (Q = Ge.placement),
          Ge.rects &&
            (j =
              Ge.rects === !0
                ? await S.getElementRects({
                    reference: a,
                    floating: e,
                    strategy: w,
                  })
                : Ge.rects),
          ({ x: F, y: q } = computeCoordsFromPlacement(j, Q, O))),
        (re = -1)));
  }
  return { x: F, y: q, placement: Q, strategy: w, middlewareData: te };
};
async function detectOverflow(a, e) {
  var f;
  e === void 0 && (e = {});
  const { x: _, y: w, platform: v, rects: S, elements: R, strategy: O } = a,
    {
      boundary: j = "clippingAncestors",
      rootBoundary: F = "viewport",
      elementContext: q = "floating",
      altBoundary: Q = !1,
      padding: te = 0,
    } = evaluate(e, a),
    se = getPaddingObject(te),
    Oe = R[Q ? (q === "floating" ? "reference" : "floating") : q],
    Le = rectToClientRect(
      await v.getClippingRect({
        element:
          (f = await (v.isElement == null ? void 0 : v.isElement(Oe))) ==
            null || f
            ? Oe
            : Oe.contextElement ||
              (await (v.getDocumentElement == null
                ? void 0
                : v.getDocumentElement(R.floating))),
        boundary: j,
        rootBoundary: F,
        strategy: O,
      }),
    ),
    Be =
      q === "floating"
        ? { x: _, y: w, width: S.floating.width, height: S.floating.height }
        : S.reference,
    Ve = await (v.getOffsetParent == null
      ? void 0
      : v.getOffsetParent(R.floating)),
    ze = (await (v.isElement == null ? void 0 : v.isElement(Ve)))
      ? (await (v.getScale == null ? void 0 : v.getScale(Ve))) || { x: 1, y: 1 }
      : { x: 1, y: 1 },
    Ge = rectToClientRect(
      v.convertOffsetParentRelativeRectToViewportRelativeRect
        ? await v.convertOffsetParentRelativeRectToViewportRelativeRect({
            elements: R,
            rect: Be,
            offsetParent: Ve,
            strategy: O,
          })
        : Be,
    );
  return {
    top: (Le.top - Ge.top + se.top) / ze.y,
    bottom: (Ge.bottom - Le.bottom + se.bottom) / ze.y,
    left: (Le.left - Ge.left + se.left) / ze.x,
    right: (Ge.right - Le.right + se.right) / ze.x,
  };
}
const arrow$3 = (a) => ({
    name: "arrow",
    options: a,
    async fn(e) {
      const {
          x: f,
          y: _,
          placement: w,
          rects: v,
          platform: S,
          elements: R,
          middlewareData: O,
        } = e,
        { element: j, padding: F = 0 } = evaluate(a, e) || {};
      if (j == null) return {};
      const q = getPaddingObject(F),
        Q = { x: f, y: _ },
        te = getAlignmentAxis(w),
        se = getAxisLength(te),
        re = await S.getDimensions(j),
        Oe = te === "y",
        Le = Oe ? "top" : "left",
        Be = Oe ? "bottom" : "right",
        Ve = Oe ? "clientHeight" : "clientWidth",
        ze = v.reference[se] + v.reference[te] - Q[te] - v.floating[se],
        Ge = Q[te] - v.reference[te],
        Ke = await (S.getOffsetParent == null ? void 0 : S.getOffsetParent(j));
      let qe = Ke ? Ke[Ve] : 0;
      (!qe || !(await (S.isElement == null ? void 0 : S.isElement(Ke)))) &&
        (qe = R.floating[Ve] || v.floating[se]);
      const nt = ze / 2 - Ge / 2,
        pt = qe / 2 - re[se] / 2 - 1,
        gt = min(q[Le], pt),
        mt = min(q[Be], pt),
        dt = gt,
        _t = qe - re[se] - mt,
        bt = qe / 2 - re[se] / 2 + nt,
        at = clamp$2(dt, bt, _t),
        $e =
          !O.arrow &&
          getAlignment(w) != null &&
          bt !== at &&
          v.reference[se] / 2 - (bt < dt ? gt : mt) - re[se] / 2 < 0,
        Ye = $e ? (bt < dt ? bt - dt : bt - _t) : 0;
      return {
        [te]: Q[te] + Ye,
        data: {
          [te]: at,
          centerOffset: bt - at - Ye,
          ...($e && { alignmentOffset: Ye }),
        },
        reset: $e,
      };
    },
  }),
  flip$2 = function (a) {
    return (
      a === void 0 && (a = {}),
      {
        name: "flip",
        options: a,
        async fn(e) {
          var f, _;
          const {
              placement: w,
              middlewareData: v,
              rects: S,
              initialPlacement: R,
              platform: O,
              elements: j,
            } = e,
            {
              mainAxis: F = !0,
              crossAxis: q = !0,
              fallbackPlacements: Q,
              fallbackStrategy: te = "bestFit",
              fallbackAxisSideDirection: se = "none",
              flipAlignment: re = !0,
              ...Oe
            } = evaluate(a, e);
          if ((f = v.arrow) != null && f.alignmentOffset) return {};
          const Le = getSide(w),
            Be = getSideAxis(R),
            Ve = getSide(R) === R,
            ze = await (O.isRTL == null ? void 0 : O.isRTL(j.floating)),
            Ge =
              Q ||
              (Ve || !re
                ? [getOppositePlacement(R)]
                : getExpandedPlacements(R)),
            Ke = se !== "none";
          !Q && Ke && Ge.push(...getOppositeAxisPlacements(R, re, se, ze));
          const qe = [R, ...Ge],
            nt = await detectOverflow(e, Oe),
            pt = [];
          let gt = ((_ = v.flip) == null ? void 0 : _.overflows) || [];
          if ((F && pt.push(nt[Le]), q)) {
            const bt = getAlignmentSides(w, S, ze);
            pt.push(nt[bt[0]], nt[bt[1]]);
          }
          if (
            ((gt = [...gt, { placement: w, overflows: pt }]),
            !pt.every((bt) => bt <= 0))
          ) {
            var mt, dt;
            const bt = (((mt = v.flip) == null ? void 0 : mt.index) || 0) + 1,
              at = qe[bt];
            if (
              at &&
              (!(q === "alignment" ? Be !== getSideAxis(at) : !1) ||
                gt.every((Qe) =>
                  getSideAxis(Qe.placement) === Be ? Qe.overflows[0] > 0 : !0,
                ))
            )
              return {
                data: { index: bt, overflows: gt },
                reset: { placement: at },
              };
            let $e =
              (dt = gt
                .filter((Ye) => Ye.overflows[0] <= 0)
                .sort((Ye, Qe) => Ye.overflows[1] - Qe.overflows[1])[0]) == null
                ? void 0
                : dt.placement;
            if (!$e)
              switch (te) {
                case "bestFit": {
                  var _t;
                  const Ye =
                    (_t = gt
                      .filter((Qe) => {
                        if (Ke) {
                          const tt = getSideAxis(Qe.placement);
                          return tt === Be || tt === "y";
                        }
                        return !0;
                      })
                      .map((Qe) => [
                        Qe.placement,
                        Qe.overflows
                          .filter((tt) => tt > 0)
                          .reduce((tt, ht) => tt + ht, 0),
                      ])
                      .sort((Qe, tt) => Qe[1] - tt[1])[0]) == null
                      ? void 0
                      : _t[0];
                  Ye && ($e = Ye);
                  break;
                }
                case "initialPlacement":
                  $e = R;
                  break;
              }
            if (w !== $e) return { reset: { placement: $e } };
          }
          return {};
        },
      }
    );
  };
function getSideOffsets(a, e) {
  return {
    top: a.top - e.height,
    right: a.right - e.width,
    bottom: a.bottom - e.height,
    left: a.left - e.width,
  };
}
function isAnySideFullyClipped(a) {
  return sides.some((e) => a[e] >= 0);
}
const hide$2 = function (a) {
    return (
      a === void 0 && (a = {}),
      {
        name: "hide",
        options: a,
        async fn(e) {
          const { rects: f } = e,
            { strategy: _ = "referenceHidden", ...w } = evaluate(a, e);
          switch (_) {
            case "referenceHidden": {
              const v = await detectOverflow(e, {
                  ...w,
                  elementContext: "reference",
                }),
                S = getSideOffsets(v, f.reference);
              return {
                data: {
                  referenceHiddenOffsets: S,
                  referenceHidden: isAnySideFullyClipped(S),
                },
              };
            }
            case "escaped": {
              const v = await detectOverflow(e, { ...w, altBoundary: !0 }),
                S = getSideOffsets(v, f.floating);
              return {
                data: { escapedOffsets: S, escaped: isAnySideFullyClipped(S) },
              };
            }
            default:
              return {};
          }
        },
      }
    );
  },
  originSides = new Set(["left", "top"]);
async function convertValueToCoords(a, e) {
  const { placement: f, platform: _, elements: w } = a,
    v = await (_.isRTL == null ? void 0 : _.isRTL(w.floating)),
    S = getSide(f),
    R = getAlignment(f),
    O = getSideAxis(f) === "y",
    j = originSides.has(S) ? -1 : 1,
    F = v && O ? -1 : 1,
    q = evaluate(e, a);
  let {
    mainAxis: Q,
    crossAxis: te,
    alignmentAxis: se,
  } = typeof q == "number"
    ? { mainAxis: q, crossAxis: 0, alignmentAxis: null }
    : {
        mainAxis: q.mainAxis || 0,
        crossAxis: q.crossAxis || 0,
        alignmentAxis: q.alignmentAxis,
      };
  return (
    R && typeof se == "number" && (te = R === "end" ? se * -1 : se),
    O ? { x: te * F, y: Q * j } : { x: Q * j, y: te * F }
  );
}
const offset$2 = function (a) {
    return (
      a === void 0 && (a = 0),
      {
        name: "offset",
        options: a,
        async fn(e) {
          var f, _;
          const { x: w, y: v, placement: S, middlewareData: R } = e,
            O = await convertValueToCoords(e, a);
          return S === ((f = R.offset) == null ? void 0 : f.placement) &&
            (_ = R.arrow) != null &&
            _.alignmentOffset
            ? {}
            : { x: w + O.x, y: v + O.y, data: { ...O, placement: S } };
        },
      }
    );
  },
  shift$2 = function (a) {
    return (
      a === void 0 && (a = {}),
      {
        name: "shift",
        options: a,
        async fn(e) {
          const { x: f, y: _, placement: w } = e,
            {
              mainAxis: v = !0,
              crossAxis: S = !1,
              limiter: R = {
                fn: (Oe) => {
                  let { x: Le, y: Be } = Oe;
                  return { x: Le, y: Be };
                },
              },
              ...O
            } = evaluate(a, e),
            j = { x: f, y: _ },
            F = await detectOverflow(e, O),
            q = getSideAxis(getSide(w)),
            Q = getOppositeAxis(q);
          let te = j[Q],
            se = j[q];
          if (v) {
            const Oe = Q === "y" ? "top" : "left",
              Le = Q === "y" ? "bottom" : "right",
              Be = te + F[Oe],
              Ve = te - F[Le];
            te = clamp$2(Be, te, Ve);
          }
          if (S) {
            const Oe = q === "y" ? "top" : "left",
              Le = q === "y" ? "bottom" : "right",
              Be = se + F[Oe],
              Ve = se - F[Le];
            se = clamp$2(Be, se, Ve);
          }
          const re = R.fn({ ...e, [Q]: te, [q]: se });
          return {
            ...re,
            data: { x: re.x - f, y: re.y - _, enabled: { [Q]: v, [q]: S } },
          };
        },
      }
    );
  },
  limitShift$2 = function (a) {
    return (
      a === void 0 && (a = {}),
      {
        options: a,
        fn(e) {
          const { x: f, y: _, placement: w, rects: v, middlewareData: S } = e,
            {
              offset: R = 0,
              mainAxis: O = !0,
              crossAxis: j = !0,
            } = evaluate(a, e),
            F = { x: f, y: _ },
            q = getSideAxis(w),
            Q = getOppositeAxis(q);
          let te = F[Q],
            se = F[q];
          const re = evaluate(R, e),
            Oe =
              typeof re == "number"
                ? { mainAxis: re, crossAxis: 0 }
                : { mainAxis: 0, crossAxis: 0, ...re };
          if (O) {
            const Ve = Q === "y" ? "height" : "width",
              ze = v.reference[Q] - v.floating[Ve] + Oe.mainAxis,
              Ge = v.reference[Q] + v.reference[Ve] - Oe.mainAxis;
            te < ze ? (te = ze) : te > Ge && (te = Ge);
          }
          if (j) {
            var Le, Be;
            const Ve = Q === "y" ? "width" : "height",
              ze = originSides.has(getSide(w)),
              Ge =
                v.reference[q] -
                v.floating[Ve] +
                ((ze && ((Le = S.offset) == null ? void 0 : Le[q])) || 0) +
                (ze ? 0 : Oe.crossAxis),
              Ke =
                v.reference[q] +
                v.reference[Ve] +
                (ze ? 0 : ((Be = S.offset) == null ? void 0 : Be[q]) || 0) -
                (ze ? Oe.crossAxis : 0);
            se < Ge ? (se = Ge) : se > Ke && (se = Ke);
          }
          return { [Q]: te, [q]: se };
        },
      }
    );
  },
  size$3 = function (a) {
    return (
      a === void 0 && (a = {}),
      {
        name: "size",
        options: a,
        async fn(e) {
          var f, _;
          const { placement: w, rects: v, platform: S, elements: R } = e,
            { apply: O = () => {}, ...j } = evaluate(a, e),
            F = await detectOverflow(e, j),
            q = getSide(w),
            Q = getAlignment(w),
            te = getSideAxis(w) === "y",
            { width: se, height: re } = v.floating;
          let Oe, Le;
          q === "top" || q === "bottom"
            ? ((Oe = q),
              (Le =
                Q ===
                ((await (S.isRTL == null ? void 0 : S.isRTL(R.floating)))
                  ? "start"
                  : "end")
                  ? "left"
                  : "right"))
            : ((Le = q), (Oe = Q === "end" ? "top" : "bottom"));
          const Be = re - F.top - F.bottom,
            Ve = se - F.left - F.right,
            ze = min(re - F[Oe], Be),
            Ge = min(se - F[Le], Ve),
            Ke = !e.middlewareData.shift;
          let qe = ze,
            nt = Ge;
          if (
            ((f = e.middlewareData.shift) != null && f.enabled.x && (nt = Ve),
            (_ = e.middlewareData.shift) != null && _.enabled.y && (qe = Be),
            Ke && !Q)
          ) {
            const gt = max(F.left, 0),
              mt = max(F.right, 0),
              dt = max(F.top, 0),
              _t = max(F.bottom, 0);
            te
              ? (nt =
                  se -
                  2 * (gt !== 0 || mt !== 0 ? gt + mt : max(F.left, F.right)))
              : (qe =
                  re -
                  2 * (dt !== 0 || _t !== 0 ? dt + _t : max(F.top, F.bottom)));
          }
          await O({ ...e, availableWidth: nt, availableHeight: qe });
          const pt = await S.getDimensions(R.floating);
          return se !== pt.width || re !== pt.height
            ? { reset: { rects: !0 } }
            : {};
        },
      }
    );
  };
function hasWindow() {
  return typeof window < "u";
}
function getNodeName(a) {
  return isNode(a) ? (a.nodeName || "").toLowerCase() : "#document";
}
function getWindow(a) {
  var e;
  return (
    (a == null || (e = a.ownerDocument) == null ? void 0 : e.defaultView) ||
    window
  );
}
function getDocumentElement(a) {
  var e;
  return (e = (isNode(a) ? a.ownerDocument : a.document) || window.document) ==
    null
    ? void 0
    : e.documentElement;
}
function isNode(a) {
  return hasWindow() ? a instanceof Node || a instanceof getWindow(a).Node : !1;
}
function isElement(a) {
  return hasWindow()
    ? a instanceof Element || a instanceof getWindow(a).Element
    : !1;
}
function isHTMLElement(a) {
  return hasWindow()
    ? a instanceof HTMLElement || a instanceof getWindow(a).HTMLElement
    : !1;
}
function isShadowRoot(a) {
  return !hasWindow() || typeof ShadowRoot > "u"
    ? !1
    : a instanceof ShadowRoot || a instanceof getWindow(a).ShadowRoot;
}
const invalidOverflowDisplayValues = new Set(["inline", "contents"]);
function isOverflowElement(a) {
  const {
    overflow: e,
    overflowX: f,
    overflowY: _,
    display: w,
  } = getComputedStyle$2(a);
  return (
    /auto|scroll|overlay|hidden|clip/.test(e + _ + f) &&
    !invalidOverflowDisplayValues.has(w)
  );
}
const tableElements = new Set(["table", "td", "th"]);
function isTableElement(a) {
  return tableElements.has(getNodeName(a));
}
const topLayerSelectors = [":popover-open", ":modal"];
function isTopLayer(a) {
  return topLayerSelectors.some((e) => {
    try {
      return a.matches(e);
    } catch {
      return !1;
    }
  });
}
const transformProperties = [
    "transform",
    "translate",
    "scale",
    "rotate",
    "perspective",
  ],
  willChangeValues = [
    "transform",
    "translate",
    "scale",
    "rotate",
    "perspective",
    "filter",
  ],
  containValues = ["paint", "layout", "strict", "content"];
function isContainingBlock(a) {
  const e = isWebKit(),
    f = isElement(a) ? getComputedStyle$2(a) : a;
  return (
    transformProperties.some((_) => (f[_] ? f[_] !== "none" : !1)) ||
    (f.containerType ? f.containerType !== "normal" : !1) ||
    (!e && (f.backdropFilter ? f.backdropFilter !== "none" : !1)) ||
    (!e && (f.filter ? f.filter !== "none" : !1)) ||
    willChangeValues.some((_) => (f.willChange || "").includes(_)) ||
    containValues.some((_) => (f.contain || "").includes(_))
  );
}
function getContainingBlock(a) {
  let e = getParentNode(a);
  for (; isHTMLElement(e) && !isLastTraversableNode(e); ) {
    if (isContainingBlock(e)) return e;
    if (isTopLayer(e)) return null;
    e = getParentNode(e);
  }
  return null;
}
function isWebKit() {
  return typeof CSS > "u" || !CSS.supports
    ? !1
    : CSS.supports("-webkit-backdrop-filter", "none");
}
const lastTraversableNodeNames = new Set(["html", "body", "#document"]);
function isLastTraversableNode(a) {
  return lastTraversableNodeNames.has(getNodeName(a));
}
function getComputedStyle$2(a) {
  return getWindow(a).getComputedStyle(a);
}
function getNodeScroll(a) {
  return isElement(a)
    ? { scrollLeft: a.scrollLeft, scrollTop: a.scrollTop }
    : { scrollLeft: a.scrollX, scrollTop: a.scrollY };
}
function getParentNode(a) {
  if (getNodeName(a) === "html") return a;
  const e =
    a.assignedSlot ||
    a.parentNode ||
    (isShadowRoot(a) && a.host) ||
    getDocumentElement(a);
  return isShadowRoot(e) ? e.host : e;
}
function getNearestOverflowAncestor(a) {
  const e = getParentNode(a);
  return isLastTraversableNode(e)
    ? a.ownerDocument
      ? a.ownerDocument.body
      : a.body
    : isHTMLElement(e) && isOverflowElement(e)
      ? e
      : getNearestOverflowAncestor(e);
}
function getOverflowAncestors(a, e, f) {
  var _;
  (e === void 0 && (e = []), f === void 0 && (f = !0));
  const w = getNearestOverflowAncestor(a),
    v = w === ((_ = a.ownerDocument) == null ? void 0 : _.body),
    S = getWindow(w);
  if (v) {
    const R = getFrameElement(S);
    return e.concat(
      S,
      S.visualViewport || [],
      isOverflowElement(w) ? w : [],
      R && f ? getOverflowAncestors(R) : [],
    );
  }
  return e.concat(w, getOverflowAncestors(w, [], f));
}
function getFrameElement(a) {
  return a.parent && Object.getPrototypeOf(a.parent) ? a.frameElement : null;
}
function getCssDimensions(a) {
  const e = getComputedStyle$2(a);
  let f = parseFloat(e.width) || 0,
    _ = parseFloat(e.height) || 0;
  const w = isHTMLElement(a),
    v = w ? a.offsetWidth : f,
    S = w ? a.offsetHeight : _,
    R = round(f) !== v || round(_) !== S;
  return (R && ((f = v), (_ = S)), { width: f, height: _, $: R });
}
function unwrapElement(a) {
  return isElement(a) ? a : a.contextElement;
}
function getScale(a) {
  const e = unwrapElement(a);
  if (!isHTMLElement(e)) return createCoords(1);
  const f = e.getBoundingClientRect(),
    { width: _, height: w, $: v } = getCssDimensions(e);
  let S = (v ? round(f.width) : f.width) / _,
    R = (v ? round(f.height) : f.height) / w;
  return (
    (!S || !Number.isFinite(S)) && (S = 1),
    (!R || !Number.isFinite(R)) && (R = 1),
    { x: S, y: R }
  );
}
const noOffsets = createCoords(0);
function getVisualOffsets(a) {
  const e = getWindow(a);
  return !isWebKit() || !e.visualViewport
    ? noOffsets
    : { x: e.visualViewport.offsetLeft, y: e.visualViewport.offsetTop };
}
function shouldAddVisualOffsets(a, e, f) {
  return (e === void 0 && (e = !1), !f || (e && f !== getWindow(a)) ? !1 : e);
}
function getBoundingClientRect(a, e, f, _) {
  (e === void 0 && (e = !1), f === void 0 && (f = !1));
  const w = a.getBoundingClientRect(),
    v = unwrapElement(a);
  let S = createCoords(1);
  e && (_ ? isElement(_) && (S = getScale(_)) : (S = getScale(a)));
  const R = shouldAddVisualOffsets(v, f, _)
    ? getVisualOffsets(v)
    : createCoords(0);
  let O = (w.left + R.x) / S.x,
    j = (w.top + R.y) / S.y,
    F = w.width / S.x,
    q = w.height / S.y;
  if (v) {
    const Q = getWindow(v),
      te = _ && isElement(_) ? getWindow(_) : _;
    let se = Q,
      re = getFrameElement(se);
    for (; re && _ && te !== se; ) {
      const Oe = getScale(re),
        Le = re.getBoundingClientRect(),
        Be = getComputedStyle$2(re),
        Ve = Le.left + (re.clientLeft + parseFloat(Be.paddingLeft)) * Oe.x,
        ze = Le.top + (re.clientTop + parseFloat(Be.paddingTop)) * Oe.y;
      ((O *= Oe.x),
        (j *= Oe.y),
        (F *= Oe.x),
        (q *= Oe.y),
        (O += Ve),
        (j += ze),
        (se = getWindow(re)),
        (re = getFrameElement(se)));
    }
  }
  return rectToClientRect({ width: F, height: q, x: O, y: j });
}
function getWindowScrollBarX(a, e) {
  const f = getNodeScroll(a).scrollLeft;
  return e ? e.left + f : getBoundingClientRect(getDocumentElement(a)).left + f;
}
function getHTMLOffset(a, e) {
  const f = a.getBoundingClientRect(),
    _ = f.left + e.scrollLeft - getWindowScrollBarX(a, f),
    w = f.top + e.scrollTop;
  return { x: _, y: w };
}
function convertOffsetParentRelativeRectToViewportRelativeRect(a) {
  let { elements: e, rect: f, offsetParent: _, strategy: w } = a;
  const v = w === "fixed",
    S = getDocumentElement(_),
    R = e ? isTopLayer(e.floating) : !1;
  if (_ === S || (R && v)) return f;
  let O = { scrollLeft: 0, scrollTop: 0 },
    j = createCoords(1);
  const F = createCoords(0),
    q = isHTMLElement(_);
  if (
    (q || (!q && !v)) &&
    ((getNodeName(_) !== "body" || isOverflowElement(S)) &&
      (O = getNodeScroll(_)),
    isHTMLElement(_))
  ) {
    const te = getBoundingClientRect(_);
    ((j = getScale(_)),
      (F.x = te.x + _.clientLeft),
      (F.y = te.y + _.clientTop));
  }
  const Q = S && !q && !v ? getHTMLOffset(S, O) : createCoords(0);
  return {
    width: f.width * j.x,
    height: f.height * j.y,
    x: f.x * j.x - O.scrollLeft * j.x + F.x + Q.x,
    y: f.y * j.y - O.scrollTop * j.y + F.y + Q.y,
  };
}
function getClientRects(a) {
  return Array.from(a.getClientRects());
}
function getDocumentRect(a) {
  const e = getDocumentElement(a),
    f = getNodeScroll(a),
    _ = a.ownerDocument.body,
    w = max(e.scrollWidth, e.clientWidth, _.scrollWidth, _.clientWidth),
    v = max(e.scrollHeight, e.clientHeight, _.scrollHeight, _.clientHeight);
  let S = -f.scrollLeft + getWindowScrollBarX(a);
  const R = -f.scrollTop;
  return (
    getComputedStyle$2(_).direction === "rtl" &&
      (S += max(e.clientWidth, _.clientWidth) - w),
    { width: w, height: v, x: S, y: R }
  );
}
const SCROLLBAR_MAX = 25;
function getViewportRect(a, e) {
  const f = getWindow(a),
    _ = getDocumentElement(a),
    w = f.visualViewport;
  let v = _.clientWidth,
    S = _.clientHeight,
    R = 0,
    O = 0;
  if (w) {
    ((v = w.width), (S = w.height));
    const F = isWebKit();
    (!F || (F && e === "fixed")) && ((R = w.offsetLeft), (O = w.offsetTop));
  }
  const j = getWindowScrollBarX(_);
  if (j <= 0) {
    const F = _.ownerDocument,
      q = F.body,
      Q = getComputedStyle(q),
      te =
        (F.compatMode === "CSS1Compat" &&
          parseFloat(Q.marginLeft) + parseFloat(Q.marginRight)) ||
        0,
      se = Math.abs(_.clientWidth - q.clientWidth - te);
    se <= SCROLLBAR_MAX && (v -= se);
  } else j <= SCROLLBAR_MAX && (v += j);
  return { width: v, height: S, x: R, y: O };
}
const absoluteOrFixed = new Set(["absolute", "fixed"]);
function getInnerBoundingClientRect(a, e) {
  const f = getBoundingClientRect(a, !0, e === "fixed"),
    _ = f.top + a.clientTop,
    w = f.left + a.clientLeft,
    v = isHTMLElement(a) ? getScale(a) : createCoords(1),
    S = a.clientWidth * v.x,
    R = a.clientHeight * v.y,
    O = w * v.x,
    j = _ * v.y;
  return { width: S, height: R, x: O, y: j };
}
function getClientRectFromClippingAncestor(a, e, f) {
  let _;
  if (e === "viewport") _ = getViewportRect(a, f);
  else if (e === "document") _ = getDocumentRect(getDocumentElement(a));
  else if (isElement(e)) _ = getInnerBoundingClientRect(e, f);
  else {
    const w = getVisualOffsets(a);
    _ = { x: e.x - w.x, y: e.y - w.y, width: e.width, height: e.height };
  }
  return rectToClientRect(_);
}
function hasFixedPositionAncestor(a, e) {
  const f = getParentNode(a);
  return f === e || !isElement(f) || isLastTraversableNode(f)
    ? !1
    : getComputedStyle$2(f).position === "fixed" ||
        hasFixedPositionAncestor(f, e);
}
function getClippingElementAncestors(a, e) {
  const f = e.get(a);
  if (f) return f;
  let _ = getOverflowAncestors(a, [], !1).filter(
      (R) => isElement(R) && getNodeName(R) !== "body",
    ),
    w = null;
  const v = getComputedStyle$2(a).position === "fixed";
  let S = v ? getParentNode(a) : a;
  for (; isElement(S) && !isLastTraversableNode(S); ) {
    const R = getComputedStyle$2(S),
      O = isContainingBlock(S);
    (!O && R.position === "fixed" && (w = null),
      (
        v
          ? !O && !w
          : (!O &&
              R.position === "static" &&
              !!w &&
              absoluteOrFixed.has(w.position)) ||
            (isOverflowElement(S) && !O && hasFixedPositionAncestor(a, S))
      )
        ? (_ = _.filter((F) => F !== S))
        : (w = R),
      (S = getParentNode(S)));
  }
  return (e.set(a, _), _);
}
function getClippingRect(a) {
  let { element: e, boundary: f, rootBoundary: _, strategy: w } = a;
  const S = [
      ...(f === "clippingAncestors"
        ? isTopLayer(e)
          ? []
          : getClippingElementAncestors(e, this._c)
        : [].concat(f)),
      _,
    ],
    R = S[0],
    O = S.reduce(
      (j, F) => {
        const q = getClientRectFromClippingAncestor(e, F, w);
        return (
          (j.top = max(q.top, j.top)),
          (j.right = min(q.right, j.right)),
          (j.bottom = min(q.bottom, j.bottom)),
          (j.left = max(q.left, j.left)),
          j
        );
      },
      getClientRectFromClippingAncestor(e, R, w),
    );
  return {
    width: O.right - O.left,
    height: O.bottom - O.top,
    x: O.left,
    y: O.top,
  };
}
function getDimensions(a) {
  const { width: e, height: f } = getCssDimensions(a);
  return { width: e, height: f };
}
function getRectRelativeToOffsetParent(a, e, f) {
  const _ = isHTMLElement(e),
    w = getDocumentElement(e),
    v = f === "fixed",
    S = getBoundingClientRect(a, !0, v, e);
  let R = { scrollLeft: 0, scrollTop: 0 };
  const O = createCoords(0);
  function j() {
    O.x = getWindowScrollBarX(w);
  }
  if (_ || (!_ && !v))
    if (
      ((getNodeName(e) !== "body" || isOverflowElement(w)) &&
        (R = getNodeScroll(e)),
      _)
    ) {
      const te = getBoundingClientRect(e, !0, v, e);
      ((O.x = te.x + e.clientLeft), (O.y = te.y + e.clientTop));
    } else w && j();
  v && !_ && w && j();
  const F = w && !_ && !v ? getHTMLOffset(w, R) : createCoords(0),
    q = S.left + R.scrollLeft - O.x - F.x,
    Q = S.top + R.scrollTop - O.y - F.y;
  return { x: q, y: Q, width: S.width, height: S.height };
}
function isStaticPositioned(a) {
  return getComputedStyle$2(a).position === "static";
}
function getTrueOffsetParent(a, e) {
  if (!isHTMLElement(a) || getComputedStyle$2(a).position === "fixed")
    return null;
  if (e) return e(a);
  let f = a.offsetParent;
  return (getDocumentElement(a) === f && (f = f.ownerDocument.body), f);
}
function getOffsetParent(a, e) {
  const f = getWindow(a);
  if (isTopLayer(a)) return f;
  if (!isHTMLElement(a)) {
    let w = getParentNode(a);
    for (; w && !isLastTraversableNode(w); ) {
      if (isElement(w) && !isStaticPositioned(w)) return w;
      w = getParentNode(w);
    }
    return f;
  }
  let _ = getTrueOffsetParent(a, e);
  for (; _ && isTableElement(_) && isStaticPositioned(_); )
    _ = getTrueOffsetParent(_, e);
  return _ &&
    isLastTraversableNode(_) &&
    isStaticPositioned(_) &&
    !isContainingBlock(_)
    ? f
    : _ || getContainingBlock(a) || f;
}
const getElementRects = async function (a) {
  const e = this.getOffsetParent || getOffsetParent,
    f = this.getDimensions,
    _ = await f(a.floating);
  return {
    reference: getRectRelativeToOffsetParent(
      a.reference,
      await e(a.floating),
      a.strategy,
    ),
    floating: { x: 0, y: 0, width: _.width, height: _.height },
  };
};
function isRTL(a) {
  return getComputedStyle$2(a).direction === "rtl";
}
const platform = {
  convertOffsetParentRelativeRectToViewportRelativeRect,
  getDocumentElement,
  getClippingRect,
  getOffsetParent,
  getElementRects,
  getClientRects,
  getDimensions,
  getScale,
  isElement,
  isRTL,
};
function rectsAreEqual(a, e) {
  return (
    a.x === e.x && a.y === e.y && a.width === e.width && a.height === e.height
  );
}
function observeMove(a, e) {
  let f = null,
    _;
  const w = getDocumentElement(a);
  function v() {
    var R;
    (clearTimeout(_), (R = f) == null || R.disconnect(), (f = null));
  }
  function S(R, O) {
    (R === void 0 && (R = !1), O === void 0 && (O = 1), v());
    const j = a.getBoundingClientRect(),
      { left: F, top: q, width: Q, height: te } = j;
    if ((R || e(), !Q || !te)) return;
    const se = floor(q),
      re = floor(w.clientWidth - (F + Q)),
      Oe = floor(w.clientHeight - (q + te)),
      Le = floor(F),
      Ve = {
        rootMargin: -se + "px " + -re + "px " + -Oe + "px " + -Le + "px",
        threshold: max(0, min(1, O)) || 1,
      };
    let ze = !0;
    function Ge(Ke) {
      const qe = Ke[0].intersectionRatio;
      if (qe !== O) {
        if (!ze) return S();
        qe
          ? S(!1, qe)
          : (_ = setTimeout(() => {
              S(!1, 1e-7);
            }, 1e3));
      }
      (qe === 1 && !rectsAreEqual(j, a.getBoundingClientRect()) && S(),
        (ze = !1));
    }
    try {
      f = new IntersectionObserver(Ge, { ...Ve, root: w.ownerDocument });
    } catch {
      f = new IntersectionObserver(Ge, Ve);
    }
    f.observe(a);
  }
  return (S(!0), v);
}
function autoUpdate(a, e, f, _) {
  _ === void 0 && (_ = {});
  const {
      ancestorScroll: w = !0,
      ancestorResize: v = !0,
      elementResize: S = typeof ResizeObserver == "function",
      layoutShift: R = typeof IntersectionObserver == "function",
      animationFrame: O = !1,
    } = _,
    j = unwrapElement(a),
    F =
      w || v
        ? [...(j ? getOverflowAncestors(j) : []), ...getOverflowAncestors(e)]
        : [];
  F.forEach((Le) => {
    (w && Le.addEventListener("scroll", f, { passive: !0 }),
      v && Le.addEventListener("resize", f));
  });
  const q = j && R ? observeMove(j, f) : null;
  let Q = -1,
    te = null;
  S &&
    ((te = new ResizeObserver((Le) => {
      let [Be] = Le;
      (Be &&
        Be.target === j &&
        te &&
        (te.unobserve(e),
        cancelAnimationFrame(Q),
        (Q = requestAnimationFrame(() => {
          var Ve;
          (Ve = te) == null || Ve.observe(e);
        }))),
        f());
    })),
    j && !O && te.observe(j),
    te.observe(e));
  let se,
    re = O ? getBoundingClientRect(a) : null;
  O && Oe();
  function Oe() {
    const Le = getBoundingClientRect(a);
    (re && !rectsAreEqual(re, Le) && f(),
      (re = Le),
      (se = requestAnimationFrame(Oe)));
  }
  return (
    f(),
    () => {
      var Le;
      (F.forEach((Be) => {
        (w && Be.removeEventListener("scroll", f),
          v && Be.removeEventListener("resize", f));
      }),
        q?.(),
        (Le = te) == null || Le.disconnect(),
        (te = null),
        O && cancelAnimationFrame(se));
    }
  );
}
const offset$1 = offset$2,
  shift$1 = shift$2,
  flip$1 = flip$2,
  size$2 = size$3,
  hide$1 = hide$2,
  arrow$2 = arrow$3,
  limitShift$1 = limitShift$2,
  computePosition = (a, e, f) => {
    const _ = new Map(),
      w = { platform, ...f },
      v = { ...w.platform, _c: _ };
    return computePosition$1(a, e, { ...w, platform: v });
  };
var isClient = typeof document < "u",
  noop$1 = function () {},
  index = isClient ? reactExports.useLayoutEffect : noop$1;
function deepEqual(a, e) {
  if (a === e) return !0;
  if (typeof a != typeof e) return !1;
  if (typeof a == "function" && a.toString() === e.toString()) return !0;
  let f, _, w;
  if (a && e && typeof a == "object") {
    if (Array.isArray(a)) {
      if (((f = a.length), f !== e.length)) return !1;
      for (_ = f; _-- !== 0; ) if (!deepEqual(a[_], e[_])) return !1;
      return !0;
    }
    if (((w = Object.keys(a)), (f = w.length), f !== Object.keys(e).length))
      return !1;
    for (_ = f; _-- !== 0; ) if (!{}.hasOwnProperty.call(e, w[_])) return !1;
    for (_ = f; _-- !== 0; ) {
      const v = w[_];
      if (!(v === "_owner" && a.$$typeof) && !deepEqual(a[v], e[v])) return !1;
    }
    return !0;
  }
  return a !== a && e !== e;
}
function getDPR(a) {
  return typeof window > "u"
    ? 1
    : (a.ownerDocument.defaultView || window).devicePixelRatio || 1;
}
function roundByDPR(a, e) {
  const f = getDPR(a);
  return Math.round(e * f) / f;
}
function useLatestRef(a) {
  const e = reactExports.useRef(a);
  return (
    index(() => {
      e.current = a;
    }),
    e
  );
}
function useFloating(a) {
  a === void 0 && (a = {});
  const {
      placement: e = "bottom",
      strategy: f = "absolute",
      middleware: _ = [],
      platform: w,
      elements: { reference: v, floating: S } = {},
      transform: R = !0,
      whileElementsMounted: O,
      open: j,
    } = a,
    [F, q] = reactExports.useState({
      x: 0,
      y: 0,
      strategy: f,
      placement: e,
      middlewareData: {},
      isPositioned: !1,
    }),
    [Q, te] = reactExports.useState(_);
  deepEqual(Q, _) || te(_);
  const [se, re] = reactExports.useState(null),
    [Oe, Le] = reactExports.useState(null),
    Be = reactExports.useCallback((Qe) => {
      Qe !== Ke.current && ((Ke.current = Qe), re(Qe));
    }, []),
    Ve = reactExports.useCallback((Qe) => {
      Qe !== qe.current && ((qe.current = Qe), Le(Qe));
    }, []),
    ze = v || se,
    Ge = S || Oe,
    Ke = reactExports.useRef(null),
    qe = reactExports.useRef(null),
    nt = reactExports.useRef(F),
    pt = O != null,
    gt = useLatestRef(O),
    mt = useLatestRef(w),
    dt = useLatestRef(j),
    _t = reactExports.useCallback(() => {
      if (!Ke.current || !qe.current) return;
      const Qe = { placement: e, strategy: f, middleware: Q };
      (mt.current && (Qe.platform = mt.current),
        computePosition(Ke.current, qe.current, Qe).then((tt) => {
          const ht = { ...tt, isPositioned: dt.current !== !1 };
          bt.current &&
            !deepEqual(nt.current, ht) &&
            ((nt.current = ht),
            reactDomExports.flushSync(() => {
              q(ht);
            }));
        }));
    }, [Q, e, f, mt, dt]);
  index(() => {
    j === !1 &&
      nt.current.isPositioned &&
      ((nt.current.isPositioned = !1),
      q((Qe) => ({ ...Qe, isPositioned: !1 })));
  }, [j]);
  const bt = reactExports.useRef(!1);
  (index(
    () => (
      (bt.current = !0),
      () => {
        bt.current = !1;
      }
    ),
    [],
  ),
    index(() => {
      if ((ze && (Ke.current = ze), Ge && (qe.current = Ge), ze && Ge)) {
        if (gt.current) return gt.current(ze, Ge, _t);
        _t();
      }
    }, [ze, Ge, _t, gt, pt]));
  const at = reactExports.useMemo(
      () => ({
        reference: Ke,
        floating: qe,
        setReference: Be,
        setFloating: Ve,
      }),
      [Be, Ve],
    ),
    $e = reactExports.useMemo(
      () => ({ reference: ze, floating: Ge }),
      [ze, Ge],
    ),
    Ye = reactExports.useMemo(() => {
      const Qe = { position: f, left: 0, top: 0 };
      if (!$e.floating) return Qe;
      const tt = roundByDPR($e.floating, F.x),
        ht = roundByDPR($e.floating, F.y);
      return R
        ? {
            ...Qe,
            transform: "translate(" + tt + "px, " + ht + "px)",
            ...(getDPR($e.floating) >= 1.5 && { willChange: "transform" }),
          }
        : { position: f, left: tt, top: ht };
    }, [f, R, $e.floating, F.x, F.y]);
  return reactExports.useMemo(
    () => ({ ...F, update: _t, refs: at, elements: $e, floatingStyles: Ye }),
    [F, _t, at, $e, Ye],
  );
}
const arrow$1 = (a) => {
    function e(f) {
      return {}.hasOwnProperty.call(f, "current");
    }
    return {
      name: "arrow",
      options: a,
      fn(f) {
        const { element: _, padding: w } = typeof a == "function" ? a(f) : a;
        return _ && e(_)
          ? _.current != null
            ? arrow$2({ element: _.current, padding: w }).fn(f)
            : {}
          : _
            ? arrow$2({ element: _, padding: w }).fn(f)
            : {};
      },
    };
  },
  offset = (a, e) => ({ ...offset$1(a), options: [a, e] }),
  shift = (a, e) => ({ ...shift$1(a), options: [a, e] }),
  limitShift = (a, e) => ({ ...limitShift$1(a), options: [a, e] }),
  flip = (a, e) => ({ ...flip$1(a), options: [a, e] }),
  size$1 = (a, e) => ({ ...size$2(a), options: [a, e] }),
  hide = (a, e) => ({ ...hide$1(a), options: [a, e] }),
  arrow = (a, e) => ({ ...arrow$1(a), options: [a, e] });
var NAME$1 = "Arrow",
  Arrow$1 = reactExports.forwardRef((a, e) => {
    const { children: f, width: _ = 10, height: w = 5, ...v } = a;
    return jsxRuntimeExports.jsx(Primitive$1.svg, {
      ...v,
      ref: e,
      width: _,
      height: w,
      viewBox: "0 0 30 10",
      preserveAspectRatio: "none",
      children: a.asChild
        ? f
        : jsxRuntimeExports.jsx("polygon", { points: "0,0 30,0 15,10" }),
    });
  });
Arrow$1.displayName = NAME$1;
var Root$3 = Arrow$1;
function useSize(a) {
  const [e, f] = reactExports.useState(void 0);
  return (
    useLayoutEffect2(() => {
      if (a) {
        f({ width: a.offsetWidth, height: a.offsetHeight });
        const _ = new ResizeObserver((w) => {
          if (!Array.isArray(w) || !w.length) return;
          const v = w[0];
          let S, R;
          if ("borderBoxSize" in v) {
            const O = v.borderBoxSize,
              j = Array.isArray(O) ? O[0] : O;
            ((S = j.inlineSize), (R = j.blockSize));
          } else ((S = a.offsetWidth), (R = a.offsetHeight));
          f({ width: S, height: R });
        });
        return (_.observe(a, { box: "border-box" }), () => _.unobserve(a));
      } else f(void 0);
    }, [a]),
    e
  );
}
var POPPER_NAME = "Popper",
  [createPopperContext, createPopperScope] = createContextScope(POPPER_NAME),
  [PopperProvider, usePopperContext] = createPopperContext(POPPER_NAME),
  Popper = (a) => {
    const { __scopePopper: e, children: f } = a,
      [_, w] = reactExports.useState(null);
    return jsxRuntimeExports.jsx(PopperProvider, {
      scope: e,
      anchor: _,
      onAnchorChange: w,
      children: f,
    });
  };
Popper.displayName = POPPER_NAME;
var ANCHOR_NAME$1 = "PopperAnchor",
  PopperAnchor = reactExports.forwardRef((a, e) => {
    const { __scopePopper: f, virtualRef: _, ...w } = a,
      v = usePopperContext(ANCHOR_NAME$1, f),
      S = reactExports.useRef(null),
      R = useComposedRefs(e, S),
      O = reactExports.useRef(null);
    return (
      reactExports.useEffect(() => {
        const j = O.current;
        ((O.current = _?.current || S.current),
          j !== O.current && v.onAnchorChange(O.current));
      }),
      _ ? null : jsxRuntimeExports.jsx(Primitive$1.div, { ...w, ref: R })
    );
  });
PopperAnchor.displayName = ANCHOR_NAME$1;
var CONTENT_NAME$4 = "PopperContent",
  [PopperContentProvider, useContentContext] =
    createPopperContext(CONTENT_NAME$4),
  PopperContent = reactExports.forwardRef((a, e) => {
    const {
        __scopePopper: f,
        side: _ = "bottom",
        sideOffset: w = 0,
        align: v = "center",
        alignOffset: S = 0,
        arrowPadding: R = 0,
        avoidCollisions: O = !0,
        collisionBoundary: j = [],
        collisionPadding: F = 0,
        sticky: q = "partial",
        hideWhenDetached: Q = !1,
        updatePositionStrategy: te = "optimized",
        onPlaced: se,
        ...re
      } = a,
      Oe = usePopperContext(CONTENT_NAME$4, f),
      [Le, Be] = reactExports.useState(null),
      Ve = useComposedRefs(e, (it) => Be(it)),
      [ze, Ge] = reactExports.useState(null),
      Ke = useSize(ze),
      qe = Ke?.width ?? 0,
      nt = Ke?.height ?? 0,
      pt = _ + (v !== "center" ? "-" + v : ""),
      gt =
        typeof F == "number"
          ? F
          : { top: 0, right: 0, bottom: 0, left: 0, ...F },
      mt = Array.isArray(j) ? j : [j],
      dt = mt.length > 0,
      _t = { padding: gt, boundary: mt.filter(isNotNull$1), altBoundary: dt },
      {
        refs: bt,
        floatingStyles: at,
        placement: $e,
        isPositioned: Ye,
        middlewareData: Qe,
      } = useFloating({
        strategy: "fixed",
        placement: pt,
        whileElementsMounted: (...it) =>
          autoUpdate(...it, { animationFrame: te === "always" }),
        elements: { reference: Oe.anchor },
        middleware: [
          offset({ mainAxis: w + nt, alignmentAxis: S }),
          O &&
            shift({
              mainAxis: !0,
              crossAxis: !1,
              limiter: q === "partial" ? limitShift() : void 0,
              ..._t,
            }),
          O && flip({ ..._t }),
          size$1({
            ..._t,
            apply: ({
              elements: it,
              rects: Et,
              availableWidth: xt,
              availableHeight: At,
            }) => {
              const { width: Lt, height: Vt } = Et.reference,
                Yt = it.floating.style;
              (Yt.setProperty("--radix-popper-available-width", `${xt}px`),
                Yt.setProperty("--radix-popper-available-height", `${At}px`),
                Yt.setProperty("--radix-popper-anchor-width", `${Lt}px`),
                Yt.setProperty("--radix-popper-anchor-height", `${Vt}px`));
            },
          }),
          ze && arrow({ element: ze, padding: R }),
          transformOrigin({ arrowWidth: qe, arrowHeight: nt }),
          Q && hide({ strategy: "referenceHidden", ..._t }),
        ],
      }),
      [tt, ht] = getSideAndAlignFromPlacement($e),
      Fe = useCallbackRef$1(se);
    useLayoutEffect2(() => {
      Ye && Fe?.();
    }, [Ye, Fe]);
    const Ue = Qe.arrow?.x,
      ot = Qe.arrow?.y,
      lt = Qe.arrow?.centerOffset !== 0,
      [ut, yt] = reactExports.useState();
    return (
      useLayoutEffect2(() => {
        Le && yt(window.getComputedStyle(Le).zIndex);
      }, [Le]),
      jsxRuntimeExports.jsx("div", {
        ref: bt.setFloating,
        "data-radix-popper-content-wrapper": "",
        style: {
          ...at,
          transform: Ye ? at.transform : "translate(0, -200%)",
          minWidth: "max-content",
          zIndex: ut,
          "--radix-popper-transform-origin": [
            Qe.transformOrigin?.x,
            Qe.transformOrigin?.y,
          ].join(" "),
          ...(Qe.hide?.referenceHidden && {
            visibility: "hidden",
            pointerEvents: "none",
          }),
        },
        dir: a.dir,
        children: jsxRuntimeExports.jsx(PopperContentProvider, {
          scope: f,
          placedSide: tt,
          onArrowChange: Ge,
          arrowX: Ue,
          arrowY: ot,
          shouldHideArrow: lt,
          children: jsxRuntimeExports.jsx(Primitive$1.div, {
            "data-side": tt,
            "data-align": ht,
            ...re,
            ref: Ve,
            style: { ...re.style, animation: Ye ? void 0 : "none" },
          }),
        }),
      })
    );
  });
PopperContent.displayName = CONTENT_NAME$4;
var ARROW_NAME$4 = "PopperArrow",
  OPPOSITE_SIDE = {
    top: "bottom",
    right: "left",
    bottom: "top",
    left: "right",
  },
  PopperArrow = reactExports.forwardRef(function (e, f) {
    const { __scopePopper: _, ...w } = e,
      v = useContentContext(ARROW_NAME$4, _),
      S = OPPOSITE_SIDE[v.placedSide];
    return jsxRuntimeExports.jsx("span", {
      ref: v.onArrowChange,
      style: {
        position: "absolute",
        left: v.arrowX,
        top: v.arrowY,
        [S]: 0,
        transformOrigin: {
          top: "",
          right: "0 0",
          bottom: "center 0",
          left: "100% 0",
        }[v.placedSide],
        transform: {
          top: "translateY(100%)",
          right: "translateY(50%) rotate(90deg) translateX(-50%)",
          bottom: "rotate(180deg)",
          left: "translateY(50%) rotate(-90deg) translateX(50%)",
        }[v.placedSide],
        visibility: v.shouldHideArrow ? "hidden" : void 0,
      },
      children: jsxRuntimeExports.jsx(Root$3, {
        ...w,
        ref: f,
        style: { ...w.style, display: "block" },
      }),
    });
  });
PopperArrow.displayName = ARROW_NAME$4;
function isNotNull$1(a) {
  return a !== null;
}
var transformOrigin = (a) => ({
  name: "transformOrigin",
  options: a,
  fn(e) {
    const { placement: f, rects: _, middlewareData: w } = e,
      S = w.arrow?.centerOffset !== 0,
      R = S ? 0 : a.arrowWidth,
      O = S ? 0 : a.arrowHeight,
      [j, F] = getSideAndAlignFromPlacement(f),
      q = { start: "0%", center: "50%", end: "100%" }[F],
      Q = (w.arrow?.x ?? 0) + R / 2,
      te = (w.arrow?.y ?? 0) + O / 2;
    let se = "",
      re = "";
    return (
      j === "bottom"
        ? ((se = S ? q : `${Q}px`), (re = `${-O}px`))
        : j === "top"
          ? ((se = S ? q : `${Q}px`), (re = `${_.floating.height + O}px`))
          : j === "right"
            ? ((se = `${-O}px`), (re = S ? q : `${te}px`))
            : j === "left" &&
              ((se = `${_.floating.width + O}px`), (re = S ? q : `${te}px`)),
      { data: { x: se, y: re } }
    );
  },
});
function getSideAndAlignFromPlacement(a) {
  const [e, f = "center"] = a.split("-");
  return [e, f];
}
var Root2$1 = Popper,
  Anchor = PopperAnchor,
  Content = PopperContent,
  Arrow = PopperArrow,
  SLOTTABLE_IDENTIFIER$3 = Symbol("radix.slottable");
function createSlottable(a) {
  const e = ({ children: f }) =>
    jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: f });
  return (
    (e.displayName = `${a}.Slottable`),
    (e.__radixId = SLOTTABLE_IDENTIFIER$3),
    e
  );
}
var VISUALLY_HIDDEN_STYLES = Object.freeze({
    position: "absolute",
    border: 0,
    width: 1,
    height: 1,
    padding: 0,
    margin: -1,
    overflow: "hidden",
    clip: "rect(0, 0, 0, 0)",
    whiteSpace: "nowrap",
    wordWrap: "normal",
  }),
  NAME = "VisuallyHidden",
  VisuallyHidden = reactExports.forwardRef((a, e) =>
    jsxRuntimeExports.jsx(Primitive$1.span, {
      ...a,
      ref: e,
      style: { ...VISUALLY_HIDDEN_STYLES, ...a.style },
    }),
  );
VisuallyHidden.displayName = NAME;
var Root$2 = VisuallyHidden,
  [createTooltipContext] = createContextScope("Tooltip", [createPopperScope]),
  usePopperScope$2 = createPopperScope(),
  PROVIDER_NAME = "TooltipProvider",
  DEFAULT_DELAY_DURATION = 700,
  TOOLTIP_OPEN = "tooltip.open",
  [TooltipProviderContextProvider, useTooltipProviderContext] =
    createTooltipContext(PROVIDER_NAME),
  TooltipProvider$1 = (a) => {
    const {
        __scopeTooltip: e,
        delayDuration: f = DEFAULT_DELAY_DURATION,
        skipDelayDuration: _ = 300,
        disableHoverableContent: w = !1,
        children: v,
      } = a,
      S = reactExports.useRef(!0),
      R = reactExports.useRef(!1),
      O = reactExports.useRef(0);
    return (
      reactExports.useEffect(() => {
        const j = O.current;
        return () => window.clearTimeout(j);
      }, []),
      jsxRuntimeExports.jsx(TooltipProviderContextProvider, {
        scope: e,
        isOpenDelayedRef: S,
        delayDuration: f,
        onOpen: reactExports.useCallback(() => {
          (window.clearTimeout(O.current), (S.current = !1));
        }, []),
        onClose: reactExports.useCallback(() => {
          (window.clearTimeout(O.current),
            (O.current = window.setTimeout(() => (S.current = !0), _)));
        }, [_]),
        isPointerInTransitRef: R,
        onPointerInTransitChange: reactExports.useCallback((j) => {
          R.current = j;
        }, []),
        disableHoverableContent: w,
        children: v,
      })
    );
  };
TooltipProvider$1.displayName = PROVIDER_NAME;
var TOOLTIP_NAME = "Tooltip",
  [TooltipContextProvider, useTooltipContext] =
    createTooltipContext(TOOLTIP_NAME),
  Tooltip$1 = (a) => {
    const {
        __scopeTooltip: e,
        children: f,
        open: _,
        defaultOpen: w,
        onOpenChange: v,
        disableHoverableContent: S,
        delayDuration: R,
      } = a,
      O = useTooltipProviderContext(TOOLTIP_NAME, a.__scopeTooltip),
      j = usePopperScope$2(e),
      [F, q] = reactExports.useState(null),
      Q = useId(),
      te = reactExports.useRef(0),
      se = S ?? O.disableHoverableContent,
      re = R ?? O.delayDuration,
      Oe = reactExports.useRef(!1),
      [Le, Be] = useControllableState({
        prop: _,
        defaultProp: w ?? !1,
        onChange: (qe) => {
          (qe
            ? (O.onOpen(),
              document.dispatchEvent(new CustomEvent(TOOLTIP_OPEN)))
            : O.onClose(),
            v?.(qe));
        },
        caller: TOOLTIP_NAME,
      }),
      Ve = reactExports.useMemo(
        () => (Le ? (Oe.current ? "delayed-open" : "instant-open") : "closed"),
        [Le],
      ),
      ze = reactExports.useCallback(() => {
        (window.clearTimeout(te.current),
          (te.current = 0),
          (Oe.current = !1),
          Be(!0));
      }, [Be]),
      Ge = reactExports.useCallback(() => {
        (window.clearTimeout(te.current), (te.current = 0), Be(!1));
      }, [Be]),
      Ke = reactExports.useCallback(() => {
        (window.clearTimeout(te.current),
          (te.current = window.setTimeout(() => {
            ((Oe.current = !0), Be(!0), (te.current = 0));
          }, re)));
      }, [re, Be]);
    return (
      reactExports.useEffect(
        () => () => {
          te.current && (window.clearTimeout(te.current), (te.current = 0));
        },
        [],
      ),
      jsxRuntimeExports.jsx(Root2$1, {
        ...j,
        children: jsxRuntimeExports.jsx(TooltipContextProvider, {
          scope: e,
          contentId: Q,
          open: Le,
          stateAttribute: Ve,
          trigger: F,
          onTriggerChange: q,
          onTriggerEnter: reactExports.useCallback(() => {
            O.isOpenDelayedRef.current ? Ke() : ze();
          }, [O.isOpenDelayedRef, Ke, ze]),
          onTriggerLeave: reactExports.useCallback(() => {
            se ? Ge() : (window.clearTimeout(te.current), (te.current = 0));
          }, [Ge, se]),
          onOpen: ze,
          onClose: Ge,
          disableHoverableContent: se,
          children: f,
        }),
      })
    );
  };
Tooltip$1.displayName = TOOLTIP_NAME;
var TRIGGER_NAME$2 = "TooltipTrigger",
  TooltipTrigger$1 = reactExports.forwardRef((a, e) => {
    const { __scopeTooltip: f, ..._ } = a,
      w = useTooltipContext(TRIGGER_NAME$2, f),
      v = useTooltipProviderContext(TRIGGER_NAME$2, f),
      S = usePopperScope$2(f),
      R = reactExports.useRef(null),
      O = useComposedRefs(e, R, w.onTriggerChange),
      j = reactExports.useRef(!1),
      F = reactExports.useRef(!1),
      q = reactExports.useCallback(() => (j.current = !1), []);
    return (
      reactExports.useEffect(
        () => () => document.removeEventListener("pointerup", q),
        [q],
      ),
      jsxRuntimeExports.jsx(Anchor, {
        asChild: !0,
        ...S,
        children: jsxRuntimeExports.jsx(Primitive$1.button, {
          "aria-describedby": w.open ? w.contentId : void 0,
          "data-state": w.stateAttribute,
          ..._,
          ref: O,
          onPointerMove: composeEventHandlers(a.onPointerMove, (Q) => {
            Q.pointerType !== "touch" &&
              !F.current &&
              !v.isPointerInTransitRef.current &&
              (w.onTriggerEnter(), (F.current = !0));
          }),
          onPointerLeave: composeEventHandlers(a.onPointerLeave, () => {
            (w.onTriggerLeave(), (F.current = !1));
          }),
          onPointerDown: composeEventHandlers(a.onPointerDown, () => {
            (w.open && w.onClose(),
              (j.current = !0),
              document.addEventListener("pointerup", q, { once: !0 }));
          }),
          onFocus: composeEventHandlers(a.onFocus, () => {
            j.current || w.onOpen();
          }),
          onBlur: composeEventHandlers(a.onBlur, w.onClose),
          onClick: composeEventHandlers(a.onClick, w.onClose),
        }),
      })
    );
  });
TooltipTrigger$1.displayName = TRIGGER_NAME$2;
var PORTAL_NAME$3 = "TooltipPortal",
  [PortalProvider$1, usePortalContext$1] = createTooltipContext(PORTAL_NAME$3, {
    forceMount: void 0,
  }),
  CONTENT_NAME$3 = "TooltipContent",
  TooltipContent$1 = reactExports.forwardRef((a, e) => {
    const f = usePortalContext$1(CONTENT_NAME$3, a.__scopeTooltip),
      { forceMount: _ = f.forceMount, side: w = "top", ...v } = a,
      S = useTooltipContext(CONTENT_NAME$3, a.__scopeTooltip);
    return jsxRuntimeExports.jsx(Presence, {
      present: _ || S.open,
      children: S.disableHoverableContent
        ? jsxRuntimeExports.jsx(TooltipContentImpl, { side: w, ...v, ref: e })
        : jsxRuntimeExports.jsx(TooltipContentHoverable, {
            side: w,
            ...v,
            ref: e,
          }),
    });
  }),
  TooltipContentHoverable = reactExports.forwardRef((a, e) => {
    const f = useTooltipContext(CONTENT_NAME$3, a.__scopeTooltip),
      _ = useTooltipProviderContext(CONTENT_NAME$3, a.__scopeTooltip),
      w = reactExports.useRef(null),
      v = useComposedRefs(e, w),
      [S, R] = reactExports.useState(null),
      { trigger: O, onClose: j } = f,
      F = w.current,
      { onPointerInTransitChange: q } = _,
      Q = reactExports.useCallback(() => {
        (R(null), q(!1));
      }, [q]),
      te = reactExports.useCallback(
        (se, re) => {
          const Oe = se.currentTarget,
            Le = { x: se.clientX, y: se.clientY },
            Be = getExitSideFromRect(Le, Oe.getBoundingClientRect()),
            Ve = getPaddedExitPoints(Le, Be),
            ze = getPointsFromRect(re.getBoundingClientRect()),
            Ge = getHull([...Ve, ...ze]);
          (R(Ge), q(!0));
        },
        [q],
      );
    return (
      reactExports.useEffect(() => () => Q(), [Q]),
      reactExports.useEffect(() => {
        if (O && F) {
          const se = (Oe) => te(Oe, F),
            re = (Oe) => te(Oe, O);
          return (
            O.addEventListener("pointerleave", se),
            F.addEventListener("pointerleave", re),
            () => {
              (O.removeEventListener("pointerleave", se),
                F.removeEventListener("pointerleave", re));
            }
          );
        }
      }, [O, F, te, Q]),
      reactExports.useEffect(() => {
        if (S) {
          const se = (re) => {
            const Oe = re.target,
              Le = { x: re.clientX, y: re.clientY },
              Be = O?.contains(Oe) || F?.contains(Oe),
              Ve = !isPointInPolygon$1(Le, S);
            Be ? Q() : Ve && (Q(), j());
          };
          return (
            document.addEventListener("pointermove", se),
            () => document.removeEventListener("pointermove", se)
          );
        }
      }, [O, F, S, j, Q]),
      jsxRuntimeExports.jsx(TooltipContentImpl, { ...a, ref: v })
    );
  }),
  [VisuallyHiddenContentContextProvider, useVisuallyHiddenContentContext] =
    createTooltipContext(TOOLTIP_NAME, { isInside: !1 }),
  Slottable = createSlottable("TooltipContent"),
  TooltipContentImpl = reactExports.forwardRef((a, e) => {
    const {
        __scopeTooltip: f,
        children: _,
        "aria-label": w,
        onEscapeKeyDown: v,
        onPointerDownOutside: S,
        ...R
      } = a,
      O = useTooltipContext(CONTENT_NAME$3, f),
      j = usePopperScope$2(f),
      { onClose: F } = O;
    return (
      reactExports.useEffect(
        () => (
          document.addEventListener(TOOLTIP_OPEN, F),
          () => document.removeEventListener(TOOLTIP_OPEN, F)
        ),
        [F],
      ),
      reactExports.useEffect(() => {
        if (O.trigger) {
          const q = (Q) => {
            Q.target?.contains(O.trigger) && F();
          };
          return (
            window.addEventListener("scroll", q, { capture: !0 }),
            () => window.removeEventListener("scroll", q, { capture: !0 })
          );
        }
      }, [O.trigger, F]),
      jsxRuntimeExports.jsx(DismissableLayer, {
        asChild: !0,
        disableOutsidePointerEvents: !1,
        onEscapeKeyDown: v,
        onPointerDownOutside: S,
        onFocusOutside: (q) => q.preventDefault(),
        onDismiss: F,
        children: jsxRuntimeExports.jsxs(Content, {
          "data-state": O.stateAttribute,
          ...j,
          ...R,
          ref: e,
          style: {
            ...R.style,
            "--radix-tooltip-content-transform-origin":
              "var(--radix-popper-transform-origin)",
            "--radix-tooltip-content-available-width":
              "var(--radix-popper-available-width)",
            "--radix-tooltip-content-available-height":
              "var(--radix-popper-available-height)",
            "--radix-tooltip-trigger-width": "var(--radix-popper-anchor-width)",
            "--radix-tooltip-trigger-height":
              "var(--radix-popper-anchor-height)",
          },
          children: [
            jsxRuntimeExports.jsx(Slottable, { children: _ }),
            jsxRuntimeExports.jsx(VisuallyHiddenContentContextProvider, {
              scope: f,
              isInside: !0,
              children: jsxRuntimeExports.jsx(Root$2, {
                id: O.contentId,
                role: "tooltip",
                children: w || _,
              }),
            }),
          ],
        }),
      })
    );
  });
TooltipContent$1.displayName = CONTENT_NAME$3;
var ARROW_NAME$3 = "TooltipArrow",
  TooltipArrow = reactExports.forwardRef((a, e) => {
    const { __scopeTooltip: f, ..._ } = a,
      w = usePopperScope$2(f);
    return useVisuallyHiddenContentContext(ARROW_NAME$3, f).isInside
      ? null
      : jsxRuntimeExports.jsx(Arrow, { ...w, ..._, ref: e });
  });
TooltipArrow.displayName = ARROW_NAME$3;
function getExitSideFromRect(a, e) {
  const f = Math.abs(e.top - a.y),
    _ = Math.abs(e.bottom - a.y),
    w = Math.abs(e.right - a.x),
    v = Math.abs(e.left - a.x);
  switch (Math.min(f, _, w, v)) {
    case v:
      return "left";
    case w:
      return "right";
    case f:
      return "top";
    case _:
      return "bottom";
    default:
      throw new Error("unreachable");
  }
}
function getPaddedExitPoints(a, e, f = 5) {
  const _ = [];
  switch (e) {
    case "top":
      _.push({ x: a.x - f, y: a.y + f }, { x: a.x + f, y: a.y + f });
      break;
    case "bottom":
      _.push({ x: a.x - f, y: a.y - f }, { x: a.x + f, y: a.y - f });
      break;
    case "left":
      _.push({ x: a.x + f, y: a.y - f }, { x: a.x + f, y: a.y + f });
      break;
    case "right":
      _.push({ x: a.x - f, y: a.y - f }, { x: a.x - f, y: a.y + f });
      break;
  }
  return _;
}
function getPointsFromRect(a) {
  const { top: e, right: f, bottom: _, left: w } = a;
  return [
    { x: w, y: e },
    { x: f, y: e },
    { x: f, y: _ },
    { x: w, y: _ },
  ];
}
function isPointInPolygon$1(a, e) {
  const { x: f, y: _ } = a;
  let w = !1;
  for (let v = 0, S = e.length - 1; v < e.length; S = v++) {
    const R = e[v],
      O = e[S],
      j = R.x,
      F = R.y,
      q = O.x,
      Q = O.y;
    F > _ != Q > _ && f < ((q - j) * (_ - F)) / (Q - F) + j && (w = !w);
  }
  return w;
}
function getHull(a) {
  const e = a.slice();
  return (
    e.sort((f, _) =>
      f.x < _.x ? -1 : f.x > _.x ? 1 : f.y < _.y ? -1 : f.y > _.y ? 1 : 0,
    ),
    getHullPresorted(e)
  );
}
function getHullPresorted(a) {
  if (a.length <= 1) return a.slice();
  const e = [];
  for (let _ = 0; _ < a.length; _++) {
    const w = a[_];
    for (; e.length >= 2; ) {
      const v = e[e.length - 1],
        S = e[e.length - 2];
      if ((v.x - S.x) * (w.y - S.y) >= (v.y - S.y) * (w.x - S.x)) e.pop();
      else break;
    }
    e.push(w);
  }
  e.pop();
  const f = [];
  for (let _ = a.length - 1; _ >= 0; _--) {
    const w = a[_];
    for (; f.length >= 2; ) {
      const v = f[f.length - 1],
        S = f[f.length - 2];
      if ((v.x - S.x) * (w.y - S.y) >= (v.y - S.y) * (w.x - S.x)) f.pop();
      else break;
    }
    f.push(w);
  }
  return (
    f.pop(),
    e.length === 1 && f.length === 1 && e[0].x === f[0].x && e[0].y === f[0].y
      ? e
      : e.concat(f)
  );
}
var Provider = TooltipProvider$1,
  Root3$1 = Tooltip$1,
  Trigger$2 = TooltipTrigger$1,
  Content2$3 = TooltipContent$1;
const TooltipProvider = Provider,
  Tooltip = Root3$1,
  TooltipTrigger = Trigger$2,
  TooltipContent = reactExports.forwardRef(
    ({ className: a, sideOffset: e = 4, ...f }, _) =>
      jsxRuntimeExports.jsx(Content2$3, {
        ref: _,
        sideOffset: e,
        className: cn(
          "z-50 overflow-hidden rounded-md border bg-popover px-3 py-1.5 text-sm text-popover-foreground animate-in fade-in-0 zoom-in-95 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 origin-[--radix-tooltip-content-transform-origin]",
          a,
        ),
        ...f,
      }),
  );
TooltipContent.displayName = Content2$3.displayName;
const MOBILE_BREAKPOINT = 768;
function useIsMobile() {
  const [a, e] = reactExports.useState(void 0);
  return (
    reactExports.useEffect(() => {
      const f = window.matchMedia(`(max-width: ${MOBILE_BREAKPOINT - 1}px)`),
        _ = () => {
          e(window.innerWidth < MOBILE_BREAKPOINT);
        };
      return (
        f.addEventListener("change", _),
        e(window.innerWidth < MOBILE_BREAKPOINT),
        () => f.removeEventListener("change", _)
      );
    }, []),
    !!a
  );
}
const SIDEBAR_COOKIE_NAME = "sidebar_state",
  SIDEBAR_COOKIE_MAX_AGE = 60 * 60 * 24 * 7,
  SIDEBAR_WIDTH = "16rem",
  SIDEBAR_WIDTH_MOBILE = "18rem",
  SIDEBAR_WIDTH_ICON = "3rem",
  SIDEBAR_KEYBOARD_SHORTCUT = "b",
  SidebarContext = reactExports.createContext(null);
function useSidebar() {
  const a = reactExports.useContext(SidebarContext);
  if (!a) throw new Error("useSidebar must be used within a SidebarProvider.");
  return a;
}
const SidebarProvider = reactExports.forwardRef(
  (
    {
      defaultOpen: a = !0,
      open: e,
      onOpenChange: f,
      className: _,
      style: w,
      children: v,
      ...S
    },
    R,
  ) => {
    const O = useIsMobile(),
      [j, F] = reactExports.useState(!1),
      [q, Q] = reactExports.useState(a),
      te = e ?? q,
      se = reactExports.useCallback(
        (Be) => {
          const Ve = typeof Be == "function" ? Be(te) : Be;
          (f ? f(Ve) : Q(Ve),
            (document.cookie = `${SIDEBAR_COOKIE_NAME}=${Ve}; path=/; max-age=${SIDEBAR_COOKIE_MAX_AGE}`));
        },
        [f, te],
      ),
      re = reactExports.useCallback(
        () => (O ? F((Be) => !Be) : se((Be) => !Be)),
        [O, se, F],
      );
    reactExports.useEffect(() => {
      const Be = (Ve) => {
        Ve.key === SIDEBAR_KEYBOARD_SHORTCUT &&
          (Ve.metaKey || Ve.ctrlKey) &&
          (Ve.preventDefault(), re());
      };
      return (
        window.addEventListener("keydown", Be),
        () => window.removeEventListener("keydown", Be)
      );
    }, [re]);
    const Oe = te ? "expanded" : "collapsed",
      Le = reactExports.useMemo(
        () => ({
          state: Oe,
          open: te,
          setOpen: se,
          isMobile: O,
          openMobile: j,
          setOpenMobile: F,
          toggleSidebar: re,
        }),
        [Oe, te, se, O, j, F, re],
      );
    return jsxRuntimeExports.jsx(SidebarContext.Provider, {
      value: Le,
      children: jsxRuntimeExports.jsx(TooltipProvider, {
        delayDuration: 0,
        children: jsxRuntimeExports.jsx("div", {
          className: cn(
            "group/sidebar-wrapper flex min-h-svh w-full has-[[data-variant=inset]]:bg-sidebar",
            _,
          ),
          ref: R,
          style: {
            "--sidebar-width": SIDEBAR_WIDTH,
            "--sidebar-width-icon": SIDEBAR_WIDTH_ICON,
            ...w,
          },
          ...S,
          children: v,
        }),
      }),
    });
  },
);
SidebarProvider.displayName = "SidebarProvider";
const Sidebar$1 = reactExports.forwardRef(
  (
    {
      side: a = "left",
      variant: e = "sidebar",
      collapsible: f = "offcanvas",
      className: _,
      children: w,
      ...v
    },
    S,
  ) => {
    const {
      isMobile: R,
      state: O,
      openMobile: j,
      setOpenMobile: F,
    } = useSidebar();
    return f === "none"
      ? jsxRuntimeExports.jsx("div", {
          className: cn(
            "flex h-full w-[var(--sidebar-width)] flex-col bg-sidebar text-sidebar-foreground",
            _,
          ),
          ref: S,
          ...v,
          children: w,
        })
      : R
        ? jsxRuntimeExports.jsx(Sheet, {
            onOpenChange: F,
            open: j,
            ...v,
            children: jsxRuntimeExports.jsxs(SheetContent, {
              className:
                "w-[var(--sidebar-width)] bg-sidebar p-0 text-sidebar-foreground [&>button]:hidden",
              "data-mobile": "true",
              "data-sidebar": "sidebar",
              side: a,
              style: { "--sidebar-width": SIDEBAR_WIDTH_MOBILE },
              children: [
                jsxRuntimeExports.jsxs(SheetHeader, {
                  className: "sr-only",
                  children: [
                    jsxRuntimeExports.jsx(SheetTitle, { children: "Sidebar" }),
                    jsxRuntimeExports.jsx(SheetDescription, {
                      children: "Displays the mobile sidebar.",
                    }),
                  ],
                }),
                jsxRuntimeExports.jsx("div", {
                  className: "flex h-full w-full flex-col",
                  children: w,
                }),
              ],
            }),
          })
        : jsxRuntimeExports.jsxs("div", {
            className: "group peer hidden text-sidebar-foreground md:block",
            "data-collapsible": O === "collapsed" ? f : "",
            "data-side": a,
            "data-state": O,
            "data-variant": e,
            ref: S,
            children: [
              jsxRuntimeExports.jsx("div", {
                className: cn(
                  "relative w-[var(--sidebar-width)] bg-transparent transition-[width] duration-150 ease-linear",
                  "group-data-[collapsible=offcanvas]:w-0",
                  "group-data-[side=right]:rotate-180",
                  e === "floating" || e === "inset"
                    ? "group-data-[collapsible=icon]:w-[calc(var(--sidebar-width-icon)_+_theme(spacing.4))]"
                    : "group-data-[collapsible=icon]:w-[var(--sidebar-width-icon)]",
                ),
              }),
              jsxRuntimeExports.jsx("div", {
                className: cn(
                  "fixed inset-y-0 z-10 hidden h-svh w-[var(--sidebar-width)] transition-[left,right,width] duration-150 ease-linear md:flex",
                  a === "left"
                    ? "left-0 group-data-[collapsible=offcanvas]:left-[calc(var(--sidebar-width)*-1)]"
                    : "right-0 group-data-[collapsible=offcanvas]:right-[calc(var(--sidebar-width)*-1)]",
                  e === "floating" || e === "inset"
                    ? "p-2 group-data-[collapsible=icon]:w-[calc(var(--sidebar-width-icon)_+_theme(spacing.4)_+2px)]"
                    : "group-data-[collapsible=icon]:w-[var(--sidebar-width-icon)] group-data-[side=left]:border-r group-data-[side=right]:border-l",
                  _,
                ),
                ...v,
                children: jsxRuntimeExports.jsx("div", {
                  className:
                    "flex h-full w-full flex-col bg-sidebar group-data-[variant=floating]:rounded-md group-data-[variant=floating]:border group-data-[variant=floating]:border-sidebar-border",
                  "data-sidebar": "sidebar",
                  children: w,
                }),
              }),
            ],
          });
  },
);
Sidebar$1.displayName = "Sidebar";
const SidebarTrigger = reactExports.forwardRef(
  ({ className: a, onClick: e, ...f }, _) => {
    const { toggleSidebar: w } = useSidebar();
    return jsxRuntimeExports.jsxs(Button, {
      className: cn("h-7 w-7", a),
      "data-sidebar": "trigger",
      onClick: (v) => {
        (e?.(v), w());
      },
      ref: _,
      size: "icon",
      variant: "ghost",
      ...f,
      children: [
        jsxRuntimeExports.jsx(PanelLeft, {}),
        jsxRuntimeExports.jsx("span", {
          className: "sr-only",
          children: "Toggle Sidebar",
        }),
      ],
    });
  },
);
SidebarTrigger.displayName = "SidebarTrigger";
const SidebarRail = reactExports.forwardRef(({ className: a, ...e }, f) => {
  const { toggleSidebar: _ } = useSidebar();
  return jsxRuntimeExports.jsx("button", {
    "aria-label": "Toggle Sidebar",
    className: cn(
      "-translate-x-1/2 group-data-[side=left]:-right-4 absolute inset-y-0 z-20 hidden w-4 transition-all ease-linear after:absolute after:inset-y-0 after:left-1/2 after:w-[2px] hover:after:bg-sidebar-border group-data-[side=right]:left-0 sm:flex",
      "[[data-side=left]_&]:cursor-w-resize [[data-side=right]_&]:cursor-e-resize",
      "[[data-side=left][data-state=collapsed]_&]:cursor-e-resize [[data-side=right][data-state=collapsed]_&]:cursor-w-resize",
      "group-data-[collapsible=offcanvas]:translate-x-0 group-data-[collapsible=offcanvas]:hover:bg-sidebar group-data-[collapsible=offcanvas]:after:left-full",
      "[[data-side=left][data-collapsible=offcanvas]_&]:-right-2",
      "[[data-side=right][data-collapsible=offcanvas]_&]:-left-2",
      a,
    ),
    "data-sidebar": "rail",
    onClick: _,
    ref: f,
    tabIndex: -1,
    title: "Toggle Sidebar",
    ...e,
  });
});
SidebarRail.displayName = "SidebarRail";
const SidebarInset = reactExports.forwardRef(({ className: a, ...e }, f) =>
  jsxRuntimeExports.jsx("main", {
    className: cn(
      "relative flex w-full flex-1 flex-col bg-background",
      "md:peer-data-[state=collapsed]:peer-data-[variant=inset]:ml-2 md:peer-data-[variant=inset]:m-2 md:peer-data-[variant=inset]:ml-0 md:peer-data-[variant=inset]:rounded-md",
      a,
    ),
    ref: f,
    ...e,
  }),
);
SidebarInset.displayName = "SidebarInset";
const SidebarInput = reactExports.forwardRef(({ className: a, ...e }, f) =>
  jsxRuntimeExports.jsx(Input, {
    className: cn(
      "h-8 w-full bg-background shadow-none focus-visible:ring-2 focus-visible:ring-sidebar-ring",
      a,
    ),
    "data-sidebar": "input",
    ref: f,
    ...e,
  }),
);
SidebarInput.displayName = "SidebarInput";
const SidebarHeader = reactExports.forwardRef(({ className: a, ...e }, f) =>
  jsxRuntimeExports.jsx("div", {
    className: cn("flex flex-col gap-2 p-2", a),
    "data-sidebar": "header",
    ref: f,
    ...e,
  }),
);
SidebarHeader.displayName = "SidebarHeader";
const SidebarFooter = reactExports.forwardRef(({ className: a, ...e }, f) =>
  jsxRuntimeExports.jsx("div", {
    className: cn("flex flex-col gap-2 p-2", a),
    "data-sidebar": "footer",
    ref: f,
    ...e,
  }),
);
SidebarFooter.displayName = "SidebarFooter";
const SidebarSeparator = reactExports.forwardRef(({ className: a, ...e }, f) =>
  jsxRuntimeExports.jsx(Separator$2, {
    className: cn("mx-2 w-auto bg-sidebar-border", a),
    "data-sidebar": "separator",
    ref: f,
    ...e,
  }),
);
SidebarSeparator.displayName = "SidebarSeparator";
const SidebarContent = reactExports.forwardRef(({ className: a, ...e }, f) =>
  jsxRuntimeExports.jsx("div", {
    className: cn(
      "flex min-h-0 flex-1 flex-col gap-2 overflow-auto group-data-[collapsible=icon]:overflow-hidden",
      a,
    ),
    "data-sidebar": "content",
    ref: f,
    ...e,
  }),
);
SidebarContent.displayName = "SidebarContent";
const SidebarGroup = reactExports.forwardRef(({ className: a, ...e }, f) =>
  jsxRuntimeExports.jsx("div", {
    className: cn("relative flex w-full min-w-0 flex-col p-2", a),
    "data-sidebar": "group",
    ref: f,
    ...e,
  }),
);
SidebarGroup.displayName = "SidebarGroup";
const SidebarGroupLabel = reactExports.forwardRef(
  ({ className: a, asChild: e = !1, ...f }, _) => {
    const w = e ? Slot$3 : "div";
    return jsxRuntimeExports.jsx(w, {
      className: cn(
        "flex h-8 shrink-0 items-center rounded-md px-2 font-medium text-sidebar-foreground/70 text-xs outline-none ring-sidebar-ring transition-[margin,opacity] duration-150 ease-linear focus-visible:ring-2 [&>svg]:size-4 [&>svg]:shrink-0",
        "group-data-[collapsible=icon]:-mt-8 group-data-[collapsible=icon]:opacity-0",
        a,
      ),
      "data-sidebar": "group-label",
      ref: _,
      ...f,
    });
  },
);
SidebarGroupLabel.displayName = "SidebarGroupLabel";
const SidebarGroupAction = reactExports.forwardRef(
  ({ className: a, asChild: e = !1, ...f }, _) => {
    const w = e ? Slot$3 : "button";
    return jsxRuntimeExports.jsx(w, {
      className: cn(
        "absolute top-3.5 right-3 flex aspect-square w-5 items-center justify-center rounded-md p-0 text-sidebar-foreground outline-none ring-sidebar-ring transition-transform hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 [&>svg]:size-4 [&>svg]:shrink-0",
        "after:-inset-2 after:absolute after:md:hidden",
        "group-data-[collapsible=icon]:hidden",
        a,
      ),
      "data-sidebar": "group-action",
      ref: _,
      ...f,
    });
  },
);
SidebarGroupAction.displayName = "SidebarGroupAction";
const SidebarGroupContent = reactExports.forwardRef(
  ({ className: a, ...e }, f) =>
    jsxRuntimeExports.jsx("div", {
      className: cn("w-full text-sm", a),
      "data-sidebar": "group-content",
      ref: f,
      ...e,
    }),
);
SidebarGroupContent.displayName = "SidebarGroupContent";
const SidebarMenu = reactExports.forwardRef(({ className: a, ...e }, f) =>
  jsxRuntimeExports.jsx("ul", {
    className: cn("flex w-full min-w-0 flex-col gap-1", a),
    "data-sidebar": "menu",
    ref: f,
    ...e,
  }),
);
SidebarMenu.displayName = "SidebarMenu";
const SidebarMenuItem = reactExports.forwardRef(({ className: a, ...e }, f) =>
  jsxRuntimeExports.jsx("li", {
    className: cn("group/menu-item relative", a),
    "data-sidebar": "menu-item",
    ref: f,
    ...e,
  }),
);
SidebarMenuItem.displayName = "SidebarMenuItem";
const sidebarMenuButtonVariants = cva(
    "peer/menu-button group-data-[collapsible=icon]:!size-8 group-data-[collapsible=icon]:!p-2 flex w-full items-center gap-2 overflow-hidden rounded-md p-2 text-left text-sm outline-none ring-sidebar-ring transition-[width,height,padding] hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 active:bg-sidebar-accent active:text-sidebar-accent-foreground disabled:pointer-events-none disabled:opacity-50 group-has-[[data-sidebar=menu-action]]/menu-item:pr-8 aria-disabled:pointer-events-none aria-disabled:opacity-50 data-[active=true]:bg-sidebar-accent data-[active=true]:font-medium data-[active=true]:text-sidebar-accent-foreground data-[state=open]:hover:bg-sidebar-accent data-[state=open]:hover:text-sidebar-accent-foreground [&>span:last-child]:truncate [&>svg]:size-4 [&>svg]:shrink-0",
    {
      variants: {
        variant: {
          default:
            "hover:bg-sidebar-accent hover:text-sidebar-accent-foreground",
          outline:
            "bg-background shadow-[0_0_0_1px_hsl(var(--sidebar-border))] hover:bg-sidebar-accent hover:text-sidebar-accent-foreground hover:shadow-[0_0_0_1px_hsl(var(--sidebar-accent))]",
        },
        size: {
          default: "h-8 text-sm",
          sm: "h-7 text-xs",
          lg: "group-data-[collapsible=icon]:!p-0 h-12 text-sm",
        },
      },
      defaultVariants: { variant: "default", size: "default" },
    },
  ),
  SidebarMenuButton = reactExports.forwardRef(
    (
      {
        asChild: a = !1,
        isActive: e = !1,
        variant: f = "default",
        size: _ = "default",
        tooltip: w,
        className: v,
        ...S
      },
      R,
    ) => {
      const O = a ? Slot$3 : "button",
        { isMobile: j, state: F } = useSidebar(),
        q = jsxRuntimeExports.jsx(O, {
          className: cn(sidebarMenuButtonVariants({ variant: f, size: _ }), v),
          "data-active": e,
          "data-sidebar": "menu-button",
          "data-size": _,
          ref: R,
          ...S,
        });
      return w
        ? (typeof w == "string" && (w = { children: w }),
          jsxRuntimeExports.jsxs(Tooltip, {
            children: [
              jsxRuntimeExports.jsx(TooltipTrigger, {
                asChild: !0,
                children: q,
              }),
              jsxRuntimeExports.jsx(TooltipContent, {
                align: "center",
                hidden: F !== "collapsed" || j,
                side: "right",
                ...w,
              }),
            ],
          }))
        : q;
    },
  );
SidebarMenuButton.displayName = "SidebarMenuButton";
const SidebarMenuAction = reactExports.forwardRef(
  ({ className: a, asChild: e = !1, showOnHover: f = !1, ..._ }, w) => {
    const v = e ? Slot$3 : "button";
    return jsxRuntimeExports.jsx(v, {
      className: cn(
        "absolute top-1.5 right-1 flex aspect-square w-5 items-center justify-center rounded-md p-0 text-sidebar-foreground outline-none ring-sidebar-ring transition-transform hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 peer-hover/menu-button:text-sidebar-accent-foreground [&>svg]:size-4 [&>svg]:shrink-0",
        "after:-inset-2 after:absolute after:md:hidden",
        "peer-data-[size=sm]/menu-button:top-1",
        "peer-data-[size=default]/menu-button:top-1.5",
        "peer-data-[size=lg]/menu-button:top-2.5",
        "group-data-[collapsible=icon]:hidden",
        f &&
          "group-focus-within/menu-item:opacity-100 group-hover/menu-item:opacity-100 data-[state=open]:opacity-100 peer-data-[active=true]/menu-button:text-sidebar-accent-foreground md:opacity-0",
        a,
      ),
      "data-sidebar": "menu-action",
      ref: w,
      ..._,
    });
  },
);
SidebarMenuAction.displayName = "SidebarMenuAction";
const SidebarMenuBadge = reactExports.forwardRef(({ className: a, ...e }, f) =>
  jsxRuntimeExports.jsx("div", {
    className: cn(
      "pointer-events-none absolute right-1 flex h-5 min-w-5 select-none items-center justify-center rounded-md px-1 font-medium text-sidebar-foreground text-xs tabular-nums",
      "peer-hover/menu-button:text-sidebar-accent-foreground peer-data-[active=true]/menu-button:text-sidebar-accent-foreground",
      "peer-data-[size=sm]/menu-button:top-1",
      "peer-data-[size=default]/menu-button:top-1.5",
      "peer-data-[size=lg]/menu-button:top-2.5",
      "group-data-[collapsible=icon]:hidden",
      a,
    ),
    "data-sidebar": "menu-badge",
    ref: f,
    ...e,
  }),
);
SidebarMenuBadge.displayName = "SidebarMenuBadge";
const SidebarMenuSkeleton = reactExports.forwardRef(
  ({ className: a, showIcon: e = !1, ...f }, _) => {
    const w = reactExports.useMemo(
      () => `${Math.floor(Math.random() * 40) + 50}%`,
      [],
    );
    return jsxRuntimeExports.jsxs("div", {
      className: cn("flex h-8 items-center gap-2 rounded-md px-2", a),
      "data-sidebar": "menu-skeleton",
      ref: _,
      ...f,
      children: [
        e &&
          jsxRuntimeExports.jsx(Skeleton, {
            className: "size-4 rounded-md",
            "data-sidebar": "menu-skeleton-icon",
          }),
        jsxRuntimeExports.jsx(Skeleton, {
          className: "h-4 max-w-[var(--skeleton-width)] flex-1",
          "data-sidebar": "menu-skeleton-text",
          style: { "--skeleton-width": w },
        }),
      ],
    });
  },
);
SidebarMenuSkeleton.displayName = "SidebarMenuSkeleton";
const SidebarMenuSub = reactExports.forwardRef(({ className: a, ...e }, f) =>
  jsxRuntimeExports.jsx("ul", {
    className: cn(
      "mx-3.5 flex min-w-0 translate-x-px flex-col gap-1 border-sidebar-border border-l px-2.5 py-0.5",
      "group-data-[collapsible=icon]:hidden",
      a,
    ),
    "data-sidebar": "menu-sub",
    ref: f,
    ...e,
  }),
);
SidebarMenuSub.displayName = "SidebarMenuSub";
const SidebarMenuSubItem = reactExports.forwardRef(({ ...a }, e) =>
  jsxRuntimeExports.jsx("li", { ref: e, ...a }),
);
SidebarMenuSubItem.displayName = "SidebarMenuSubItem";
const SidebarMenuSubButton = reactExports.forwardRef(
  ({ asChild: a = !1, size: e = "md", isActive: f, className: _, ...w }, v) => {
    const S = a ? Slot$3 : "a";
    return jsxRuntimeExports.jsx(S, {
      className: cn(
        "-translate-x-px flex h-7 min-w-0 items-center gap-2 overflow-hidden rounded-md px-2 text-sidebar-foreground outline-none ring-sidebar-ring hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 active:bg-sidebar-accent active:text-sidebar-accent-foreground disabled:pointer-events-none disabled:opacity-50 aria-disabled:pointer-events-none aria-disabled:opacity-50 [&>span:last-child]:truncate [&>svg]:size-4 [&>svg]:shrink-0 [&>svg]:text-sidebar-accent-foreground",
        "data-[active=true]:bg-sidebar-accent data-[active=true]:text-sidebar-accent-foreground",
        e === "sm" && "text-xs",
        e === "md" && "text-sm",
        "group-data-[collapsible=icon]:hidden",
        _,
      ),
      "data-active": f,
      "data-sidebar": "menu-sub-button",
      "data-size": e,
      ref: v,
      ...w,
    });
  },
);
SidebarMenuSubButton.displayName = "SidebarMenuSubButton";
const LayoutGroupContext = reactExports.createContext({});
function useConstant(a) {
  const e = reactExports.useRef(null);
  return (e.current === null && (e.current = a()), e.current);
}
const PresenceContext = reactExports.createContext(null),
  MotionConfigContext = reactExports.createContext({
    transformPagePoint: (a) => a,
    isStatic: !1,
    reducedMotion: "never",
  });
function usePresence(a = !0) {
  const e = reactExports.useContext(PresenceContext);
  if (e === null) return [!0, null];
  const { isPresent: f, onExitComplete: _, register: w } = e,
    v = reactExports.useId();
  reactExports.useEffect(() => {
    a && w(v);
  }, [a]);
  const S = reactExports.useCallback(() => a && _ && _(v), [v, _, a]);
  return !f && _ ? [!1, S] : [!0];
}
const isBrowser = typeof window < "u",
  useIsomorphicLayoutEffect = isBrowser
    ? reactExports.useLayoutEffect
    : reactExports.useEffect,
  noop = (a) => a;
let invariant = noop;
function memo(a) {
  let e;
  return () => (e === void 0 && (e = a()), e);
}
const progress = (a, e, f) => {
    const _ = e - a;
    return _ === 0 ? 1 : (f - a) / _;
  },
  secondsToMilliseconds = (a) => a * 1e3,
  millisecondsToSeconds = (a) => a / 1e3,
  MotionGlobalConfig = { useManualTiming: !1 };
function createRenderStep(a) {
  let e = new Set(),
    f = new Set(),
    _ = !1,
    w = !1;
  const v = new WeakSet();
  let S = { delta: 0, timestamp: 0, isProcessing: !1 };
  function R(j) {
    (v.has(j) && (O.schedule(j), a()), j(S));
  }
  const O = {
    schedule: (j, F = !1, q = !1) => {
      const te = q && _ ? e : f;
      return (F && v.add(j), te.has(j) || te.add(j), j);
    },
    cancel: (j) => {
      (f.delete(j), v.delete(j));
    },
    process: (j) => {
      if (((S = j), _)) {
        w = !0;
        return;
      }
      ((_ = !0),
        ([e, f] = [f, e]),
        e.forEach(R),
        e.clear(),
        (_ = !1),
        w && ((w = !1), O.process(j)));
    },
  };
  return O;
}
const stepsOrder = [
    "read",
    "resolveKeyframes",
    "update",
    "preRender",
    "render",
    "postRender",
  ],
  maxElapsed = 40;
function createRenderBatcher(a, e) {
  let f = !1,
    _ = !0;
  const w = { delta: 0, timestamp: 0, isProcessing: !1 },
    v = () => (f = !0),
    S = stepsOrder.reduce((Le, Be) => ((Le[Be] = createRenderStep(v)), Le), {}),
    {
      read: R,
      resolveKeyframes: O,
      update: j,
      preRender: F,
      render: q,
      postRender: Q,
    } = S,
    te = () => {
      const Le = performance.now();
      ((f = !1),
        (w.delta = _
          ? 1e3 / 60
          : Math.max(Math.min(Le - w.timestamp, maxElapsed), 1)),
        (w.timestamp = Le),
        (w.isProcessing = !0),
        R.process(w),
        O.process(w),
        j.process(w),
        F.process(w),
        q.process(w),
        Q.process(w),
        (w.isProcessing = !1),
        f && e && ((_ = !1), a(te)));
    },
    se = () => {
      ((f = !0), (_ = !0), w.isProcessing || a(te));
    };
  return {
    schedule: stepsOrder.reduce((Le, Be) => {
      const Ve = S[Be];
      return (
        (Le[Be] = (ze, Ge = !1, Ke = !1) => (
          f || se(),
          Ve.schedule(ze, Ge, Ke)
        )),
        Le
      );
    }, {}),
    cancel: (Le) => {
      for (let Be = 0; Be < stepsOrder.length; Be++)
        S[stepsOrder[Be]].cancel(Le);
    },
    state: w,
    steps: S,
  };
}
const {
    schedule: frame,
    cancel: cancelFrame,
    state: frameData,
    steps: frameSteps,
  } = createRenderBatcher(
    typeof requestAnimationFrame < "u" ? requestAnimationFrame : noop,
    !0,
  ),
  LazyContext = reactExports.createContext({ strict: !1 }),
  featureProps = {
    animation: [
      "animate",
      "variants",
      "whileHover",
      "whileTap",
      "exit",
      "whileInView",
      "whileFocus",
      "whileDrag",
    ],
    exit: ["exit"],
    drag: ["drag", "dragControls"],
    focus: ["whileFocus"],
    hover: ["whileHover", "onHoverStart", "onHoverEnd"],
    tap: ["whileTap", "onTap", "onTapStart", "onTapCancel"],
    pan: ["onPan", "onPanStart", "onPanSessionStart", "onPanEnd"],
    inView: ["whileInView", "onViewportEnter", "onViewportLeave"],
    layout: ["layout", "layoutId"],
  },
  featureDefinitions = {};
for (const a in featureProps)
  featureDefinitions[a] = {
    isEnabled: (e) => featureProps[a].some((f) => !!e[f]),
  };
function loadFeatures(a) {
  for (const e in a)
    featureDefinitions[e] = { ...featureDefinitions[e], ...a[e] };
}
const validMotionProps = new Set([
  "animate",
  "exit",
  "variants",
  "initial",
  "style",
  "values",
  "variants",
  "transition",
  "transformTemplate",
  "custom",
  "inherit",
  "onBeforeLayoutMeasure",
  "onAnimationStart",
  "onAnimationComplete",
  "onUpdate",
  "onDragStart",
  "onDrag",
  "onDragEnd",
  "onMeasureDragConstraints",
  "onDirectionLock",
  "onDragTransitionEnd",
  "_dragX",
  "_dragY",
  "onHoverStart",
  "onHoverEnd",
  "onViewportEnter",
  "onViewportLeave",
  "globalTapTarget",
  "ignoreStrict",
  "viewport",
]);
function isValidMotionProp(a) {
  return (
    a.startsWith("while") ||
    (a.startsWith("drag") && a !== "draggable") ||
    a.startsWith("layout") ||
    a.startsWith("onTap") ||
    a.startsWith("onPan") ||
    a.startsWith("onLayout") ||
    validMotionProps.has(a)
  );
}
let shouldForward = (a) => !isValidMotionProp(a);
function loadExternalIsValidProp(a) {
  a &&
    (shouldForward = (e) =>
      e.startsWith("on") ? !isValidMotionProp(e) : a(e));
}
try {
  loadExternalIsValidProp(require("@emotion/is-prop-valid").default);
} catch {}
function filterProps(a, e, f) {
  const _ = {};
  for (const w in a)
    (w === "values" && typeof a.values == "object") ||
      ((shouldForward(w) ||
        (f === !0 && isValidMotionProp(w)) ||
        (!e && !isValidMotionProp(w)) ||
        (a.draggable && w.startsWith("onDrag"))) &&
        (_[w] = a[w]));
  return _;
}
function createDOMMotionComponentProxy(a) {
  if (typeof Proxy > "u") return a;
  const e = new Map(),
    f = (..._) => a(..._);
  return new Proxy(f, {
    get: (_, w) =>
      w === "create" ? a : (e.has(w) || e.set(w, a(w)), e.get(w)),
  });
}
const MotionContext = reactExports.createContext({});
function isVariantLabel(a) {
  return typeof a == "string" || Array.isArray(a);
}
function isAnimationControls(a) {
  return a !== null && typeof a == "object" && typeof a.start == "function";
}
const variantPriorityOrder = [
    "animate",
    "whileInView",
    "whileFocus",
    "whileHover",
    "whileTap",
    "whileDrag",
    "exit",
  ],
  variantProps = ["initial", ...variantPriorityOrder];
function isControllingVariants(a) {
  return (
    isAnimationControls(a.animate) ||
    variantProps.some((e) => isVariantLabel(a[e]))
  );
}
function isVariantNode(a) {
  return !!(isControllingVariants(a) || a.variants);
}
function getCurrentTreeVariants(a, e) {
  if (isControllingVariants(a)) {
    const { initial: f, animate: _ } = a;
    return {
      initial: f === !1 || isVariantLabel(f) ? f : void 0,
      animate: isVariantLabel(_) ? _ : void 0,
    };
  }
  return a.inherit !== !1 ? e : {};
}
function useCreateMotionContext(a) {
  const { initial: e, animate: f } = getCurrentTreeVariants(
    a,
    reactExports.useContext(MotionContext),
  );
  return reactExports.useMemo(
    () => ({ initial: e, animate: f }),
    [variantLabelsAsDependency(e), variantLabelsAsDependency(f)],
  );
}
function variantLabelsAsDependency(a) {
  return Array.isArray(a) ? a.join(" ") : a;
}
const motionComponentSymbol = Symbol.for("motionComponentSymbol");
function isRefObject(a) {
  return (
    a &&
    typeof a == "object" &&
    Object.prototype.hasOwnProperty.call(a, "current")
  );
}
function useMotionRef(a, e, f) {
  return reactExports.useCallback(
    (_) => {
      (_ && a.onMount && a.onMount(_),
        e && (_ ? e.mount(_) : e.unmount()),
        f &&
          (typeof f == "function" ? f(_) : isRefObject(f) && (f.current = _)));
    },
    [e],
  );
}
const camelToDash = (a) => a.replace(/([a-z])([A-Z])/gu, "$1-$2").toLowerCase(),
  optimizedAppearDataId = "framerAppearId",
  optimizedAppearDataAttribute = "data-" + camelToDash(optimizedAppearDataId),
  { schedule: microtask } = createRenderBatcher(queueMicrotask, !1),
  SwitchLayoutGroupContext = reactExports.createContext({});
function useVisualElement(a, e, f, _, w) {
  var v, S;
  const { visualElement: R } = reactExports.useContext(MotionContext),
    O = reactExports.useContext(LazyContext),
    j = reactExports.useContext(PresenceContext),
    F = reactExports.useContext(MotionConfigContext).reducedMotion,
    q = reactExports.useRef(null);
  ((_ = _ || O.renderer),
    !q.current &&
      _ &&
      (q.current = _(a, {
        visualState: e,
        parent: R,
        props: f,
        presenceContext: j,
        blockInitialAnimation: j ? j.initial === !1 : !1,
        reducedMotionConfig: F,
      })));
  const Q = q.current,
    te = reactExports.useContext(SwitchLayoutGroupContext);
  Q &&
    !Q.projection &&
    w &&
    (Q.type === "html" || Q.type === "svg") &&
    createProjectionNode$1(q.current, f, w, te);
  const se = reactExports.useRef(!1);
  reactExports.useInsertionEffect(() => {
    Q && se.current && Q.update(f, j);
  });
  const re = f[optimizedAppearDataAttribute],
    Oe = reactExports.useRef(
      !!re &&
        !(
          !((v = window.MotionHandoffIsComplete) === null || v === void 0) &&
          v.call(window, re)
        ) &&
        ((S = window.MotionHasOptimisedAnimation) === null || S === void 0
          ? void 0
          : S.call(window, re)),
    );
  return (
    useIsomorphicLayoutEffect(() => {
      Q &&
        ((se.current = !0),
        (window.MotionIsMounted = !0),
        Q.updateFeatures(),
        microtask.render(Q.render),
        Oe.current && Q.animationState && Q.animationState.animateChanges());
    }),
    reactExports.useEffect(() => {
      Q &&
        (!Oe.current && Q.animationState && Q.animationState.animateChanges(),
        Oe.current &&
          (queueMicrotask(() => {
            var Le;
            (Le = window.MotionHandoffMarkAsComplete) === null ||
              Le === void 0 ||
              Le.call(window, re);
          }),
          (Oe.current = !1)));
    }),
    Q
  );
}
function createProjectionNode$1(a, e, f, _) {
  const {
    layoutId: w,
    layout: v,
    drag: S,
    dragConstraints: R,
    layoutScroll: O,
    layoutRoot: j,
  } = e;
  ((a.projection = new f(
    a.latestValues,
    e["data-framer-portal-id"] ? void 0 : getClosestProjectingNode(a.parent),
  )),
    a.projection.setOptions({
      layoutId: w,
      layout: v,
      alwaysMeasureLayout: !!S || (R && isRefObject(R)),
      visualElement: a,
      animationType: typeof v == "string" ? v : "both",
      initialPromotionConfig: _,
      layoutScroll: O,
      layoutRoot: j,
    }));
}
function getClosestProjectingNode(a) {
  if (a)
    return a.options.allowProjection !== !1
      ? a.projection
      : getClosestProjectingNode(a.parent);
}
function createRendererMotionComponent({
  preloadedFeatures: a,
  createVisualElement: e,
  useRender: f,
  useVisualState: _,
  Component: w,
}) {
  var v, S;
  a && loadFeatures(a);
  function R(j, F) {
    let q;
    const Q = {
        ...reactExports.useContext(MotionConfigContext),
        ...j,
        layoutId: useLayoutId(j),
      },
      { isStatic: te } = Q,
      se = useCreateMotionContext(j),
      re = _(j, te);
    if (!te && isBrowser) {
      useStrictMode();
      const Oe = getProjectionFunctionality(Q);
      ((q = Oe.MeasureLayout),
        (se.visualElement = useVisualElement(w, re, Q, e, Oe.ProjectionNode)));
    }
    return jsxRuntimeExports.jsxs(MotionContext.Provider, {
      value: se,
      children: [
        q && se.visualElement
          ? jsxRuntimeExports.jsx(q, { visualElement: se.visualElement, ...Q })
          : null,
        f(
          w,
          j,
          useMotionRef(re, se.visualElement, F),
          re,
          te,
          se.visualElement,
        ),
      ],
    });
  }
  R.displayName = `motion.${typeof w == "string" ? w : `create(${(S = (v = w.displayName) !== null && v !== void 0 ? v : w.name) !== null && S !== void 0 ? S : ""})`}`;
  const O = reactExports.forwardRef(R);
  return ((O[motionComponentSymbol] = w), O);
}
function useLayoutId({ layoutId: a }) {
  const e = reactExports.useContext(LayoutGroupContext).id;
  return e && a !== void 0 ? e + "-" + a : a;
}
function useStrictMode(a, e) {
  reactExports.useContext(LazyContext).strict;
}
function getProjectionFunctionality(a) {
  const { drag: e, layout: f } = featureDefinitions;
  if (!e && !f) return {};
  const _ = { ...e, ...f };
  return {
    MeasureLayout:
      e?.isEnabled(a) || f?.isEnabled(a) ? _.MeasureLayout : void 0,
    ProjectionNode: _.ProjectionNode,
  };
}
const lowercaseSVGElements = [
  "animate",
  "circle",
  "defs",
  "desc",
  "ellipse",
  "g",
  "image",
  "line",
  "filter",
  "marker",
  "mask",
  "metadata",
  "path",
  "pattern",
  "polygon",
  "polyline",
  "rect",
  "stop",
  "switch",
  "symbol",
  "svg",
  "text",
  "tspan",
  "use",
  "view",
];
function isSVGComponent(a) {
  return typeof a != "string" || a.includes("-")
    ? !1
    : !!(lowercaseSVGElements.indexOf(a) > -1 || /[A-Z]/u.test(a));
}
function getValueState(a) {
  const e = [{}, {}];
  return (
    a?.values.forEach((f, _) => {
      ((e[0][_] = f.get()), (e[1][_] = f.getVelocity()));
    }),
    e
  );
}
function resolveVariantFromProps(a, e, f, _) {
  if (typeof e == "function") {
    const [w, v] = getValueState(_);
    e = e(f !== void 0 ? f : a.custom, w, v);
  }
  if (
    (typeof e == "string" && (e = a.variants && a.variants[e]),
    typeof e == "function")
  ) {
    const [w, v] = getValueState(_);
    e = e(f !== void 0 ? f : a.custom, w, v);
  }
  return e;
}
const isKeyframesTarget = (a) => Array.isArray(a),
  isCustomValue = (a) => !!(a && typeof a == "object" && a.mix && a.toValue),
  resolveFinalValueInKeyframes = (a) =>
    isKeyframesTarget(a) ? a[a.length - 1] || 0 : a,
  isMotionValue = (a) => !!(a && a.getVelocity);
function resolveMotionValue(a) {
  const e = isMotionValue(a) ? a.get() : a;
  return isCustomValue(e) ? e.toValue() : e;
}
function makeState(
  { scrapeMotionValuesFromProps: a, createRenderState: e, onUpdate: f },
  _,
  w,
  v,
) {
  const S = { latestValues: makeLatestValues(_, w, v, a), renderState: e() };
  return (
    f &&
      ((S.onMount = (R) => f({ props: _, current: R, ...S })),
      (S.onUpdate = (R) => f(R))),
    S
  );
}
const makeUseVisualState = (a) => (e, f) => {
  const _ = reactExports.useContext(MotionContext),
    w = reactExports.useContext(PresenceContext),
    v = () => makeState(a, e, _, w);
  return f ? v() : useConstant(v);
};
function makeLatestValues(a, e, f, _) {
  const w = {},
    v = _(a, {});
  for (const Q in v) w[Q] = resolveMotionValue(v[Q]);
  let { initial: S, animate: R } = a;
  const O = isControllingVariants(a),
    j = isVariantNode(a);
  e &&
    j &&
    !O &&
    a.inherit !== !1 &&
    (S === void 0 && (S = e.initial), R === void 0 && (R = e.animate));
  let F = f ? f.initial === !1 : !1;
  F = F || S === !1;
  const q = F ? R : S;
  if (q && typeof q != "boolean" && !isAnimationControls(q)) {
    const Q = Array.isArray(q) ? q : [q];
    for (let te = 0; te < Q.length; te++) {
      const se = resolveVariantFromProps(a, Q[te]);
      if (se) {
        const { transitionEnd: re, transition: Oe, ...Le } = se;
        for (const Be in Le) {
          let Ve = Le[Be];
          if (Array.isArray(Ve)) {
            const ze = F ? Ve.length - 1 : 0;
            Ve = Ve[ze];
          }
          Ve !== null && (w[Be] = Ve);
        }
        for (const Be in re) w[Be] = re[Be];
      }
    }
  }
  return w;
}
const transformPropOrder = [
    "transformPerspective",
    "x",
    "y",
    "z",
    "translateX",
    "translateY",
    "translateZ",
    "scale",
    "scaleX",
    "scaleY",
    "rotate",
    "rotateX",
    "rotateY",
    "rotateZ",
    "skew",
    "skewX",
    "skewY",
  ],
  transformProps = new Set(transformPropOrder),
  checkStringStartsWith = (a) => (e) => typeof e == "string" && e.startsWith(a),
  isCSSVariableName = checkStringStartsWith("--"),
  startsAsVariableToken = checkStringStartsWith("var(--"),
  isCSSVariableToken = (a) =>
    startsAsVariableToken(a)
      ? singleCssVariableRegex.test(a.split("/*")[0].trim())
      : !1,
  singleCssVariableRegex =
    /var\(--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)$/iu,
  getValueAsType = (a, e) => (e && typeof a == "number" ? e.transform(a) : a),
  clamp$1 = (a, e, f) => (f > e ? e : f < a ? a : f),
  number = {
    test: (a) => typeof a == "number",
    parse: parseFloat,
    transform: (a) => a,
  },
  alpha = { ...number, transform: (a) => clamp$1(0, 1, a) },
  scale = { ...number, default: 1 },
  createUnitType = (a) => ({
    test: (e) =>
      typeof e == "string" && e.endsWith(a) && e.split(" ").length === 1,
    parse: parseFloat,
    transform: (e) => `${e}${a}`,
  }),
  degrees = createUnitType("deg"),
  percent = createUnitType("%"),
  px = createUnitType("px"),
  vh = createUnitType("vh"),
  vw = createUnitType("vw"),
  progressPercentage = {
    ...percent,
    parse: (a) => percent.parse(a) / 100,
    transform: (a) => percent.transform(a * 100),
  },
  browserNumberValueTypes = {
    borderWidth: px,
    borderTopWidth: px,
    borderRightWidth: px,
    borderBottomWidth: px,
    borderLeftWidth: px,
    borderRadius: px,
    radius: px,
    borderTopLeftRadius: px,
    borderTopRightRadius: px,
    borderBottomRightRadius: px,
    borderBottomLeftRadius: px,
    width: px,
    maxWidth: px,
    height: px,
    maxHeight: px,
    top: px,
    right: px,
    bottom: px,
    left: px,
    padding: px,
    paddingTop: px,
    paddingRight: px,
    paddingBottom: px,
    paddingLeft: px,
    margin: px,
    marginTop: px,
    marginRight: px,
    marginBottom: px,
    marginLeft: px,
    backgroundPositionX: px,
    backgroundPositionY: px,
  },
  transformValueTypes = {
    rotate: degrees,
    rotateX: degrees,
    rotateY: degrees,
    rotateZ: degrees,
    scale,
    scaleX: scale,
    scaleY: scale,
    scaleZ: scale,
    skew: degrees,
    skewX: degrees,
    skewY: degrees,
    distance: px,
    translateX: px,
    translateY: px,
    translateZ: px,
    x: px,
    y: px,
    z: px,
    perspective: px,
    transformPerspective: px,
    opacity: alpha,
    originX: progressPercentage,
    originY: progressPercentage,
    originZ: px,
  },
  int = { ...number, transform: Math.round },
  numberValueTypes = {
    ...browserNumberValueTypes,
    ...transformValueTypes,
    zIndex: int,
    size: px,
    fillOpacity: alpha,
    strokeOpacity: alpha,
    numOctaves: int,
  },
  translateAlias = {
    x: "translateX",
    y: "translateY",
    z: "translateZ",
    transformPerspective: "perspective",
  },
  numTransforms = transformPropOrder.length;
function buildTransform(a, e, f) {
  let _ = "",
    w = !0;
  for (let v = 0; v < numTransforms; v++) {
    const S = transformPropOrder[v],
      R = a[S];
    if (R === void 0) continue;
    let O = !0;
    if (
      (typeof R == "number"
        ? (O = R === (S.startsWith("scale") ? 1 : 0))
        : (O = parseFloat(R) === 0),
      !O || f)
    ) {
      const j = getValueAsType(R, numberValueTypes[S]);
      if (!O) {
        w = !1;
        const F = translateAlias[S] || S;
        _ += `${F}(${j}) `;
      }
      f && (e[S] = j);
    }
  }
  return ((_ = _.trim()), f ? (_ = f(e, w ? "" : _)) : w && (_ = "none"), _);
}
function buildHTMLStyles(a, e, f) {
  const { style: _, vars: w, transformOrigin: v } = a;
  let S = !1,
    R = !1;
  for (const O in e) {
    const j = e[O];
    if (transformProps.has(O)) {
      S = !0;
      continue;
    } else if (isCSSVariableName(O)) {
      w[O] = j;
      continue;
    } else {
      const F = getValueAsType(j, numberValueTypes[O]);
      O.startsWith("origin") ? ((R = !0), (v[O] = F)) : (_[O] = F);
    }
  }
  if (
    (e.transform ||
      (S || f
        ? (_.transform = buildTransform(e, a.transform, f))
        : _.transform && (_.transform = "none")),
    R)
  ) {
    const { originX: O = "50%", originY: j = "50%", originZ: F = 0 } = v;
    _.transformOrigin = `${O} ${j} ${F}`;
  }
}
const dashKeys = { offset: "stroke-dashoffset", array: "stroke-dasharray" },
  camelKeys = { offset: "strokeDashoffset", array: "strokeDasharray" };
function buildSVGPath(a, e, f = 1, _ = 0, w = !0) {
  a.pathLength = 1;
  const v = w ? dashKeys : camelKeys;
  a[v.offset] = px.transform(-_);
  const S = px.transform(e),
    R = px.transform(f);
  a[v.array] = `${S} ${R}`;
}
function calcOrigin$1(a, e, f) {
  return typeof a == "string" ? a : px.transform(e + f * a);
}
function calcSVGTransformOrigin(a, e, f) {
  const _ = calcOrigin$1(e, a.x, a.width),
    w = calcOrigin$1(f, a.y, a.height);
  return `${_} ${w}`;
}
function buildSVGAttrs(
  a,
  {
    attrX: e,
    attrY: f,
    attrScale: _,
    originX: w,
    originY: v,
    pathLength: S,
    pathSpacing: R = 1,
    pathOffset: O = 0,
    ...j
  },
  F,
  q,
) {
  if ((buildHTMLStyles(a, j, q), F)) {
    a.style.viewBox && (a.attrs.viewBox = a.style.viewBox);
    return;
  }
  ((a.attrs = a.style), (a.style = {}));
  const { attrs: Q, style: te, dimensions: se } = a;
  (Q.transform && (se && (te.transform = Q.transform), delete Q.transform),
    se &&
      (w !== void 0 || v !== void 0 || te.transform) &&
      (te.transformOrigin = calcSVGTransformOrigin(
        se,
        w !== void 0 ? w : 0.5,
        v !== void 0 ? v : 0.5,
      )),
    e !== void 0 && (Q.x = e),
    f !== void 0 && (Q.y = f),
    _ !== void 0 && (Q.scale = _),
    S !== void 0 && buildSVGPath(Q, S, R, O, !1));
}
const createHtmlRenderState = () => ({
    style: {},
    transform: {},
    transformOrigin: {},
    vars: {},
  }),
  createSvgRenderState = () => ({ ...createHtmlRenderState(), attrs: {} }),
  isSVGTag = (a) => typeof a == "string" && a.toLowerCase() === "svg";
function renderHTML(a, { style: e, vars: f }, _, w) {
  Object.assign(a.style, e, w && w.getProjectionStyles(_));
  for (const v in f) a.style.setProperty(v, f[v]);
}
const camelCaseAttributes = new Set([
  "baseFrequency",
  "diffuseConstant",
  "kernelMatrix",
  "kernelUnitLength",
  "keySplines",
  "keyTimes",
  "limitingConeAngle",
  "markerHeight",
  "markerWidth",
  "numOctaves",
  "targetX",
  "targetY",
  "surfaceScale",
  "specularConstant",
  "specularExponent",
  "stdDeviation",
  "tableValues",
  "viewBox",
  "gradientTransform",
  "pathLength",
  "startOffset",
  "textLength",
  "lengthAdjust",
]);
function renderSVG(a, e, f, _) {
  renderHTML(a, e, void 0, _);
  for (const w in e.attrs)
    a.setAttribute(camelCaseAttributes.has(w) ? w : camelToDash(w), e.attrs[w]);
}
const scaleCorrectors = {};
function addScaleCorrector(a) {
  Object.assign(scaleCorrectors, a);
}
function isForcedMotionValue(a, { layout: e, layoutId: f }) {
  return (
    transformProps.has(a) ||
    a.startsWith("origin") ||
    ((e || f !== void 0) && (!!scaleCorrectors[a] || a === "opacity"))
  );
}
function scrapeMotionValuesFromProps$1(a, e, f) {
  var _;
  const { style: w } = a,
    v = {};
  for (const S in w)
    (isMotionValue(w[S]) ||
      (e.style && isMotionValue(e.style[S])) ||
      isForcedMotionValue(S, a) ||
      ((_ = f?.getValue(S)) === null || _ === void 0 ? void 0 : _.liveStyle) !==
        void 0) &&
      (v[S] = w[S]);
  return v;
}
function scrapeMotionValuesFromProps(a, e, f) {
  const _ = scrapeMotionValuesFromProps$1(a, e, f);
  for (const w in a)
    if (isMotionValue(a[w]) || isMotionValue(e[w])) {
      const v =
        transformPropOrder.indexOf(w) !== -1
          ? "attr" + w.charAt(0).toUpperCase() + w.substring(1)
          : w;
      _[v] = a[w];
    }
  return _;
}
function updateSVGDimensions(a, e) {
  try {
    e.dimensions =
      typeof a.getBBox == "function" ? a.getBBox() : a.getBoundingClientRect();
  } catch {
    e.dimensions = { x: 0, y: 0, width: 0, height: 0 };
  }
}
const layoutProps = ["x", "y", "width", "height", "cx", "cy", "r"],
  svgMotionConfig = {
    useVisualState: makeUseVisualState({
      scrapeMotionValuesFromProps,
      createRenderState: createSvgRenderState,
      onUpdate: ({
        props: a,
        prevProps: e,
        current: f,
        renderState: _,
        latestValues: w,
      }) => {
        if (!f) return;
        let v = !!a.drag;
        if (!v) {
          for (const R in w)
            if (transformProps.has(R)) {
              v = !0;
              break;
            }
        }
        if (!v) return;
        let S = !e;
        if (e)
          for (let R = 0; R < layoutProps.length; R++) {
            const O = layoutProps[R];
            a[O] !== e[O] && (S = !0);
          }
        S &&
          frame.read(() => {
            (updateSVGDimensions(f, _),
              frame.render(() => {
                (buildSVGAttrs(_, w, isSVGTag(f.tagName), a.transformTemplate),
                  renderSVG(f, _));
              }));
          });
      },
    }),
  },
  htmlMotionConfig = {
    useVisualState: makeUseVisualState({
      scrapeMotionValuesFromProps: scrapeMotionValuesFromProps$1,
      createRenderState: createHtmlRenderState,
    }),
  };
function copyRawValuesOnly(a, e, f) {
  for (const _ in e)
    !isMotionValue(e[_]) && !isForcedMotionValue(_, f) && (a[_] = e[_]);
}
function useInitialMotionValues({ transformTemplate: a }, e) {
  return reactExports.useMemo(() => {
    const f = createHtmlRenderState();
    return (buildHTMLStyles(f, e, a), Object.assign({}, f.vars, f.style));
  }, [e]);
}
function useStyle(a, e) {
  const f = a.style || {},
    _ = {};
  return (
    copyRawValuesOnly(_, f, a),
    Object.assign(_, useInitialMotionValues(a, e)),
    _
  );
}
function useHTMLProps(a, e) {
  const f = {},
    _ = useStyle(a, e);
  return (
    a.drag &&
      a.dragListener !== !1 &&
      ((f.draggable = !1),
      (_.userSelect = _.WebkitUserSelect = _.WebkitTouchCallout = "none"),
      (_.touchAction =
        a.drag === !0 ? "none" : `pan-${a.drag === "x" ? "y" : "x"}`)),
    a.tabIndex === void 0 &&
      (a.onTap || a.onTapStart || a.whileTap) &&
      (f.tabIndex = 0),
    (f.style = _),
    f
  );
}
function useSVGProps(a, e, f, _) {
  const w = reactExports.useMemo(() => {
    const v = createSvgRenderState();
    return (
      buildSVGAttrs(v, e, isSVGTag(_), a.transformTemplate),
      { ...v.attrs, style: { ...v.style } }
    );
  }, [e]);
  if (a.style) {
    const v = {};
    (copyRawValuesOnly(v, a.style, a), (w.style = { ...v, ...w.style }));
  }
  return w;
}
function createUseRender(a = !1) {
  return (f, _, w, { latestValues: v }, S) => {
    const O = (isSVGComponent(f) ? useSVGProps : useHTMLProps)(_, v, S, f),
      j = filterProps(_, typeof f == "string", a),
      F = f !== reactExports.Fragment ? { ...j, ...O, ref: w } : {},
      { children: q } = _,
      Q = reactExports.useMemo(() => (isMotionValue(q) ? q.get() : q), [q]);
    return reactExports.createElement(f, { ...F, children: Q });
  };
}
function createMotionComponentFactory(a, e) {
  return function (_, { forwardMotionProps: w } = { forwardMotionProps: !1 }) {
    const S = {
      ...(isSVGComponent(_) ? svgMotionConfig : htmlMotionConfig),
      preloadedFeatures: a,
      useRender: createUseRender(w),
      createVisualElement: e,
      Component: _,
    };
    return createRendererMotionComponent(S);
  };
}
function shallowCompare(a, e) {
  if (!Array.isArray(e)) return !1;
  const f = e.length;
  if (f !== a.length) return !1;
  for (let _ = 0; _ < f; _++) if (e[_] !== a[_]) return !1;
  return !0;
}
function resolveVariant(a, e, f) {
  const _ = a.getProps();
  return resolveVariantFromProps(_, e, f !== void 0 ? f : _.custom, a);
}
const supportsScrollTimeline = memo(() => window.ScrollTimeline !== void 0);
class BaseGroupPlaybackControls {
  constructor(e) {
    ((this.stop = () => this.runAll("stop")),
      (this.animations = e.filter(Boolean)));
  }
  get finished() {
    return Promise.all(
      this.animations.map((e) => ("finished" in e ? e.finished : e)),
    );
  }
  getAll(e) {
    return this.animations[0][e];
  }
  setAll(e, f) {
    for (let _ = 0; _ < this.animations.length; _++) this.animations[_][e] = f;
  }
  attachTimeline(e, f) {
    const _ = this.animations.map((w) => {
      if (supportsScrollTimeline() && w.attachTimeline)
        return w.attachTimeline(e);
      if (typeof f == "function") return f(w);
    });
    return () => {
      _.forEach((w, v) => {
        (w && w(), this.animations[v].stop());
      });
    };
  }
  get time() {
    return this.getAll("time");
  }
  set time(e) {
    this.setAll("time", e);
  }
  get speed() {
    return this.getAll("speed");
  }
  set speed(e) {
    this.setAll("speed", e);
  }
  get startTime() {
    return this.getAll("startTime");
  }
  get duration() {
    let e = 0;
    for (let f = 0; f < this.animations.length; f++)
      e = Math.max(e, this.animations[f].duration);
    return e;
  }
  runAll(e) {
    this.animations.forEach((f) => f[e]());
  }
  flatten() {
    this.runAll("flatten");
  }
  play() {
    this.runAll("play");
  }
  pause() {
    this.runAll("pause");
  }
  cancel() {
    this.runAll("cancel");
  }
  complete() {
    this.runAll("complete");
  }
}
class GroupPlaybackControls extends BaseGroupPlaybackControls {
  then(e, f) {
    return Promise.all(this.animations).then(e).catch(f);
  }
}
function getValueTransition(a, e) {
  return a ? a[e] || a.default || a : void 0;
}
const maxGeneratorDuration = 2e4;
function calcGeneratorDuration(a) {
  let e = 0;
  const f = 50;
  let _ = a.next(e);
  for (; !_.done && e < maxGeneratorDuration; ) ((e += f), (_ = a.next(e)));
  return e >= maxGeneratorDuration ? 1 / 0 : e;
}
function isGenerator(a) {
  return typeof a == "function";
}
function attachTimeline(a, e) {
  ((a.timeline = e), (a.onfinish = null));
}
const isBezierDefinition = (a) => Array.isArray(a) && typeof a[0] == "number",
  supportsFlags = { linearEasing: void 0 };
function memoSupports(a, e) {
  const f = memo(a);
  return () => {
    var _;
    return (_ = supportsFlags[e]) !== null && _ !== void 0 ? _ : f();
  };
}
const supportsLinearEasing = memoSupports(() => {
    try {
      document
        .createElement("div")
        .animate({ opacity: 0 }, { easing: "linear(0, 1)" });
    } catch {
      return !1;
    }
    return !0;
  }, "linearEasing"),
  generateLinearEasing = (a, e, f = 10) => {
    let _ = "";
    const w = Math.max(Math.round(e / f), 2);
    for (let v = 0; v < w; v++) _ += a(progress(0, w - 1, v)) + ", ";
    return `linear(${_.substring(0, _.length - 2)})`;
  };
function isWaapiSupportedEasing(a) {
  return !!(
    (typeof a == "function" && supportsLinearEasing()) ||
    !a ||
    (typeof a == "string" &&
      (a in supportedWaapiEasing || supportsLinearEasing())) ||
    isBezierDefinition(a) ||
    (Array.isArray(a) && a.every(isWaapiSupportedEasing))
  );
}
const cubicBezierAsString = ([a, e, f, _]) =>
    `cubic-bezier(${a}, ${e}, ${f}, ${_})`,
  supportedWaapiEasing = {
    linear: "linear",
    ease: "ease",
    easeIn: "ease-in",
    easeOut: "ease-out",
    easeInOut: "ease-in-out",
    circIn: cubicBezierAsString([0, 0.65, 0.55, 1]),
    circOut: cubicBezierAsString([0.55, 0, 1, 0.45]),
    backIn: cubicBezierAsString([0.31, 0.01, 0.66, -0.59]),
    backOut: cubicBezierAsString([0.33, 1.53, 0.69, 0.99]),
  };
function mapEasingToNativeEasing(a, e) {
  if (a)
    return typeof a == "function" && supportsLinearEasing()
      ? generateLinearEasing(a, e)
      : isBezierDefinition(a)
        ? cubicBezierAsString(a)
        : Array.isArray(a)
          ? a.map(
              (f) =>
                mapEasingToNativeEasing(f, e) || supportedWaapiEasing.easeOut,
            )
          : supportedWaapiEasing[a];
}
const isDragging = { x: !1, y: !1 };
function isDragActive() {
  return isDragging.x || isDragging.y;
}
function resolveElements(a, e, f) {
  var _;
  if (a instanceof Element) return [a];
  if (typeof a == "string") {
    let w = document;
    const v = (_ = void 0) !== null && _ !== void 0 ? _ : w.querySelectorAll(a);
    return v ? Array.from(v) : [];
  }
  return Array.from(a);
}
function setupGesture(a, e) {
  const f = resolveElements(a),
    _ = new AbortController(),
    w = { passive: !0, ...e, signal: _.signal };
  return [f, w, () => _.abort()];
}
function filterEvents$1(a) {
  return (e) => {
    e.pointerType === "touch" || isDragActive() || a(e);
  };
}
function hover(a, e, f = {}) {
  const [_, w, v] = setupGesture(a, f),
    S = filterEvents$1((R) => {
      const { target: O } = R,
        j = e(R);
      if (typeof j != "function" || !O) return;
      const F = filterEvents$1((q) => {
        (j(q), O.removeEventListener("pointerleave", F));
      });
      O.addEventListener("pointerleave", F, w);
    });
  return (
    _.forEach((R) => {
      R.addEventListener("pointerenter", S, w);
    }),
    v
  );
}
const isNodeOrChild = (a, e) =>
    e ? (a === e ? !0 : isNodeOrChild(a, e.parentElement)) : !1,
  isPrimaryPointer = (a) =>
    a.pointerType === "mouse"
      ? typeof a.button != "number" || a.button <= 0
      : a.isPrimary !== !1,
  focusableElements = new Set(["BUTTON", "INPUT", "SELECT", "TEXTAREA", "A"]);
function isElementKeyboardAccessible(a) {
  return focusableElements.has(a.tagName) || a.tabIndex !== -1;
}
const isPressing = new WeakSet();
function filterEvents(a) {
  return (e) => {
    e.key === "Enter" && a(e);
  };
}
function firePointerEvent(a, e) {
  a.dispatchEvent(
    new PointerEvent("pointer" + e, { isPrimary: !0, bubbles: !0 }),
  );
}
const enableKeyboardPress = (a, e) => {
  const f = a.currentTarget;
  if (!f) return;
  const _ = filterEvents(() => {
    if (isPressing.has(f)) return;
    firePointerEvent(f, "down");
    const w = filterEvents(() => {
        firePointerEvent(f, "up");
      }),
      v = () => firePointerEvent(f, "cancel");
    (f.addEventListener("keyup", w, e), f.addEventListener("blur", v, e));
  });
  (f.addEventListener("keydown", _, e),
    f.addEventListener("blur", () => f.removeEventListener("keydown", _), e));
};
function isValidPressEvent(a) {
  return isPrimaryPointer(a) && !isDragActive();
}
function press(a, e, f = {}) {
  const [_, w, v] = setupGesture(a, f),
    S = (R) => {
      const O = R.currentTarget;
      if (!isValidPressEvent(R) || isPressing.has(O)) return;
      isPressing.add(O);
      const j = e(R),
        F = (te, se) => {
          (window.removeEventListener("pointerup", q),
            window.removeEventListener("pointercancel", Q),
            !(!isValidPressEvent(te) || !isPressing.has(O)) &&
              (isPressing.delete(O),
              typeof j == "function" && j(te, { success: se })));
        },
        q = (te) => {
          F(te, f.useGlobalTarget || isNodeOrChild(O, te.target));
        },
        Q = (te) => {
          F(te, !1);
        };
      (window.addEventListener("pointerup", q, w),
        window.addEventListener("pointercancel", Q, w));
    };
  return (
    _.forEach((R) => {
      (!isElementKeyboardAccessible(R) &&
        R.getAttribute("tabindex") === null &&
        (R.tabIndex = 0),
        (f.useGlobalTarget ? window : R).addEventListener("pointerdown", S, w),
        R.addEventListener("focus", (j) => enableKeyboardPress(j, w), w));
    }),
    v
  );
}
function setDragLock(a) {
  return a === "x" || a === "y"
    ? isDragging[a]
      ? null
      : ((isDragging[a] = !0),
        () => {
          isDragging[a] = !1;
        })
    : isDragging.x || isDragging.y
      ? null
      : ((isDragging.x = isDragging.y = !0),
        () => {
          isDragging.x = isDragging.y = !1;
        });
}
const positionalKeys = new Set([
  "width",
  "height",
  "top",
  "left",
  "right",
  "bottom",
  ...transformPropOrder,
]);
let now;
function clearTime() {
  now = void 0;
}
const time = {
  now: () => (
    now === void 0 &&
      time.set(
        frameData.isProcessing || MotionGlobalConfig.useManualTiming
          ? frameData.timestamp
          : performance.now(),
      ),
    now
  ),
  set: (a) => {
    ((now = a), queueMicrotask(clearTime));
  },
};
function addUniqueItem(a, e) {
  a.indexOf(e) === -1 && a.push(e);
}
function removeItem(a, e) {
  const f = a.indexOf(e);
  f > -1 && a.splice(f, 1);
}
class SubscriptionManager {
  constructor() {
    this.subscriptions = [];
  }
  add(e) {
    return (
      addUniqueItem(this.subscriptions, e),
      () => removeItem(this.subscriptions, e)
    );
  }
  notify(e, f, _) {
    const w = this.subscriptions.length;
    if (w)
      if (w === 1) this.subscriptions[0](e, f, _);
      else
        for (let v = 0; v < w; v++) {
          const S = this.subscriptions[v];
          S && S(e, f, _);
        }
  }
  getSize() {
    return this.subscriptions.length;
  }
  clear() {
    this.subscriptions.length = 0;
  }
}
function velocityPerSecond(a, e) {
  return e ? a * (1e3 / e) : 0;
}
const MAX_VELOCITY_DELTA = 30,
  isFloat = (a) => !isNaN(parseFloat(a));
class MotionValue {
  constructor(e, f = {}) {
    ((this.version = "11.18.2"),
      (this.canTrackVelocity = null),
      (this.events = {}),
      (this.updateAndNotify = (_, w = !0) => {
        const v = time.now();
        (this.updatedAt !== v && this.setPrevFrameValue(),
          (this.prev = this.current),
          this.setCurrent(_),
          this.current !== this.prev &&
            this.events.change &&
            this.events.change.notify(this.current),
          w &&
            this.events.renderRequest &&
            this.events.renderRequest.notify(this.current));
      }),
      (this.hasAnimated = !1),
      this.setCurrent(e),
      (this.owner = f.owner));
  }
  setCurrent(e) {
    ((this.current = e),
      (this.updatedAt = time.now()),
      this.canTrackVelocity === null &&
        e !== void 0 &&
        (this.canTrackVelocity = isFloat(this.current)));
  }
  setPrevFrameValue(e = this.current) {
    ((this.prevFrameValue = e), (this.prevUpdatedAt = this.updatedAt));
  }
  onChange(e) {
    return this.on("change", e);
  }
  on(e, f) {
    this.events[e] || (this.events[e] = new SubscriptionManager());
    const _ = this.events[e].add(f);
    return e === "change"
      ? () => {
          (_(),
            frame.read(() => {
              this.events.change.getSize() || this.stop();
            }));
        }
      : _;
  }
  clearListeners() {
    for (const e in this.events) this.events[e].clear();
  }
  attach(e, f) {
    ((this.passiveEffect = e), (this.stopPassiveEffect = f));
  }
  set(e, f = !0) {
    !f || !this.passiveEffect
      ? this.updateAndNotify(e, f)
      : this.passiveEffect(e, this.updateAndNotify);
  }
  setWithVelocity(e, f, _) {
    (this.set(f),
      (this.prev = void 0),
      (this.prevFrameValue = e),
      (this.prevUpdatedAt = this.updatedAt - _));
  }
  jump(e, f = !0) {
    (this.updateAndNotify(e),
      (this.prev = e),
      (this.prevUpdatedAt = this.prevFrameValue = void 0),
      f && this.stop(),
      this.stopPassiveEffect && this.stopPassiveEffect());
  }
  get() {
    return this.current;
  }
  getPrevious() {
    return this.prev;
  }
  getVelocity() {
    const e = time.now();
    if (
      !this.canTrackVelocity ||
      this.prevFrameValue === void 0 ||
      e - this.updatedAt > MAX_VELOCITY_DELTA
    )
      return 0;
    const f = Math.min(this.updatedAt - this.prevUpdatedAt, MAX_VELOCITY_DELTA);
    return velocityPerSecond(
      parseFloat(this.current) - parseFloat(this.prevFrameValue),
      f,
    );
  }
  start(e) {
    return (
      this.stop(),
      new Promise((f) => {
        ((this.hasAnimated = !0),
          (this.animation = e(f)),
          this.events.animationStart && this.events.animationStart.notify());
      }).then(() => {
        (this.events.animationComplete &&
          this.events.animationComplete.notify(),
          this.clearAnimation());
      })
    );
  }
  stop() {
    (this.animation &&
      (this.animation.stop(),
      this.events.animationCancel && this.events.animationCancel.notify()),
      this.clearAnimation());
  }
  isAnimating() {
    return !!this.animation;
  }
  clearAnimation() {
    delete this.animation;
  }
  destroy() {
    (this.clearListeners(),
      this.stop(),
      this.stopPassiveEffect && this.stopPassiveEffect());
  }
}
function motionValue(a, e) {
  return new MotionValue(a, e);
}
function setMotionValue(a, e, f) {
  a.hasValue(e) ? a.getValue(e).set(f) : a.addValue(e, motionValue(f));
}
function setTarget(a, e) {
  const f = resolveVariant(a, e);
  let { transitionEnd: _ = {}, transition: w = {}, ...v } = f || {};
  v = { ...v, ..._ };
  for (const S in v) {
    const R = resolveFinalValueInKeyframes(v[S]);
    setMotionValue(a, S, R);
  }
}
function isWillChangeMotionValue(a) {
  return !!(isMotionValue(a) && a.add);
}
function addValueToWillChange(a, e) {
  const f = a.getValue("willChange");
  if (isWillChangeMotionValue(f)) return f.add(e);
}
function getOptimisedAppearId(a) {
  return a.props[optimizedAppearDataAttribute];
}
const calcBezier = (a, e, f) =>
    (((1 - 3 * f + 3 * e) * a + (3 * f - 6 * e)) * a + 3 * e) * a,
  subdivisionPrecision = 1e-7,
  subdivisionMaxIterations = 12;
function binarySubdivide(a, e, f, _, w) {
  let v,
    S,
    R = 0;
  do
    ((S = e + (f - e) / 2),
      (v = calcBezier(S, _, w) - a),
      v > 0 ? (f = S) : (e = S));
  while (Math.abs(v) > subdivisionPrecision && ++R < subdivisionMaxIterations);
  return S;
}
function cubicBezier(a, e, f, _) {
  if (a === e && f === _) return noop;
  const w = (v) => binarySubdivide(v, 0, 1, a, f);
  return (v) => (v === 0 || v === 1 ? v : calcBezier(w(v), e, _));
}
const mirrorEasing = (a) => (e) =>
    e <= 0.5 ? a(2 * e) / 2 : (2 - a(2 * (1 - e))) / 2,
  reverseEasing = (a) => (e) => 1 - a(1 - e),
  backOut = cubicBezier(0.33, 1.53, 0.69, 0.99),
  backIn = reverseEasing(backOut),
  backInOut = mirrorEasing(backIn),
  anticipate = (a) =>
    (a *= 2) < 1 ? 0.5 * backIn(a) : 0.5 * (2 - Math.pow(2, -10 * (a - 1))),
  circIn = (a) => 1 - Math.sin(Math.acos(a)),
  circOut = reverseEasing(circIn),
  circInOut = mirrorEasing(circIn),
  isZeroValueString = (a) => /^0[^.\s]+$/u.test(a);
function isNone(a) {
  return typeof a == "number"
    ? a === 0
    : a !== null
      ? a === "none" || a === "0" || isZeroValueString(a)
      : !0;
}
const sanitize = (a) => Math.round(a * 1e5) / 1e5,
  floatRegex = /-?(?:\d+(?:\.\d+)?|\.\d+)/gu;
function isNullish(a) {
  return a == null;
}
const singleColorRegex =
    /^(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))$/iu,
  isColorString = (a, e) => (f) =>
    !!(
      (typeof f == "string" && singleColorRegex.test(f) && f.startsWith(a)) ||
      (e && !isNullish(f) && Object.prototype.hasOwnProperty.call(f, e))
    ),
  splitColor = (a, e, f) => (_) => {
    if (typeof _ != "string") return _;
    const [w, v, S, R] = _.match(floatRegex);
    return {
      [a]: parseFloat(w),
      [e]: parseFloat(v),
      [f]: parseFloat(S),
      alpha: R !== void 0 ? parseFloat(R) : 1,
    };
  },
  clampRgbUnit = (a) => clamp$1(0, 255, a),
  rgbUnit = { ...number, transform: (a) => Math.round(clampRgbUnit(a)) },
  rgba = {
    test: isColorString("rgb", "red"),
    parse: splitColor("red", "green", "blue"),
    transform: ({ red: a, green: e, blue: f, alpha: _ = 1 }) =>
      "rgba(" +
      rgbUnit.transform(a) +
      ", " +
      rgbUnit.transform(e) +
      ", " +
      rgbUnit.transform(f) +
      ", " +
      sanitize(alpha.transform(_)) +
      ")",
  };
function parseHex(a) {
  let e = "",
    f = "",
    _ = "",
    w = "";
  return (
    a.length > 5
      ? ((e = a.substring(1, 3)),
        (f = a.substring(3, 5)),
        (_ = a.substring(5, 7)),
        (w = a.substring(7, 9)))
      : ((e = a.substring(1, 2)),
        (f = a.substring(2, 3)),
        (_ = a.substring(3, 4)),
        (w = a.substring(4, 5)),
        (e += e),
        (f += f),
        (_ += _),
        (w += w)),
    {
      red: parseInt(e, 16),
      green: parseInt(f, 16),
      blue: parseInt(_, 16),
      alpha: w ? parseInt(w, 16) / 255 : 1,
    }
  );
}
const hex = {
    test: isColorString("#"),
    parse: parseHex,
    transform: rgba.transform,
  },
  hsla = {
    test: isColorString("hsl", "hue"),
    parse: splitColor("hue", "saturation", "lightness"),
    transform: ({ hue: a, saturation: e, lightness: f, alpha: _ = 1 }) =>
      "hsla(" +
      Math.round(a) +
      ", " +
      percent.transform(sanitize(e)) +
      ", " +
      percent.transform(sanitize(f)) +
      ", " +
      sanitize(alpha.transform(_)) +
      ")",
  },
  color = {
    test: (a) => rgba.test(a) || hex.test(a) || hsla.test(a),
    parse: (a) =>
      rgba.test(a)
        ? rgba.parse(a)
        : hsla.test(a)
          ? hsla.parse(a)
          : hex.parse(a),
    transform: (a) =>
      typeof a == "string"
        ? a
        : a.hasOwnProperty("red")
          ? rgba.transform(a)
          : hsla.transform(a),
  },
  colorRegex =
    /(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))/giu;
function test(a) {
  var e, f;
  return (
    isNaN(a) &&
    typeof a == "string" &&
    (((e = a.match(floatRegex)) === null || e === void 0 ? void 0 : e.length) ||
      0) +
      (((f = a.match(colorRegex)) === null || f === void 0
        ? void 0
        : f.length) || 0) >
      0
  );
}
const NUMBER_TOKEN = "number",
  COLOR_TOKEN = "color",
  VAR_TOKEN = "var",
  VAR_FUNCTION_TOKEN = "var(",
  SPLIT_TOKEN = "${}",
  complexRegex =
    /var\s*\(\s*--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)|#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\)|-?(?:\d+(?:\.\d+)?|\.\d+)/giu;
function analyseComplexValue(a) {
  const e = a.toString(),
    f = [],
    _ = { color: [], number: [], var: [] },
    w = [];
  let v = 0;
  const R = e
    .replace(
      complexRegex,
      (O) => (
        color.test(O)
          ? (_.color.push(v), w.push(COLOR_TOKEN), f.push(color.parse(O)))
          : O.startsWith(VAR_FUNCTION_TOKEN)
            ? (_.var.push(v), w.push(VAR_TOKEN), f.push(O))
            : (_.number.push(v), w.push(NUMBER_TOKEN), f.push(parseFloat(O))),
        ++v,
        SPLIT_TOKEN
      ),
    )
    .split(SPLIT_TOKEN);
  return { values: f, split: R, indexes: _, types: w };
}
function parseComplexValue(a) {
  return analyseComplexValue(a).values;
}
function createTransformer(a) {
  const { split: e, types: f } = analyseComplexValue(a),
    _ = e.length;
  return (w) => {
    let v = "";
    for (let S = 0; S < _; S++)
      if (((v += e[S]), w[S] !== void 0)) {
        const R = f[S];
        R === NUMBER_TOKEN
          ? (v += sanitize(w[S]))
          : R === COLOR_TOKEN
            ? (v += color.transform(w[S]))
            : (v += w[S]);
      }
    return v;
  };
}
const convertNumbersToZero = (a) => (typeof a == "number" ? 0 : a);
function getAnimatableNone$1(a) {
  const e = parseComplexValue(a);
  return createTransformer(a)(e.map(convertNumbersToZero));
}
const complex = {
    test,
    parse: parseComplexValue,
    createTransformer,
    getAnimatableNone: getAnimatableNone$1,
  },
  maxDefaults = new Set(["brightness", "contrast", "saturate", "opacity"]);
function applyDefaultFilter(a) {
  const [e, f] = a.slice(0, -1).split("(");
  if (e === "drop-shadow") return a;
  const [_] = f.match(floatRegex) || [];
  if (!_) return a;
  const w = f.replace(_, "");
  let v = maxDefaults.has(e) ? 1 : 0;
  return (_ !== f && (v *= 100), e + "(" + v + w + ")");
}
const functionRegex = /\b([a-z-]*)\(.*?\)/gu,
  filter = {
    ...complex,
    getAnimatableNone: (a) => {
      const e = a.match(functionRegex);
      return e ? e.map(applyDefaultFilter).join(" ") : a;
    },
  },
  defaultValueTypes = {
    ...numberValueTypes,
    color,
    backgroundColor: color,
    outlineColor: color,
    fill: color,
    stroke: color,
    borderColor: color,
    borderTopColor: color,
    borderRightColor: color,
    borderBottomColor: color,
    borderLeftColor: color,
    filter,
    WebkitFilter: filter,
  },
  getDefaultValueType = (a) => defaultValueTypes[a];
function getAnimatableNone(a, e) {
  let f = getDefaultValueType(a);
  return (
    f !== filter && (f = complex),
    f.getAnimatableNone ? f.getAnimatableNone(e) : void 0
  );
}
const invalidTemplates = new Set(["auto", "none", "0"]);
function makeNoneKeyframesAnimatable(a, e, f) {
  let _ = 0,
    w;
  for (; _ < a.length && !w; ) {
    const v = a[_];
    (typeof v == "string" &&
      !invalidTemplates.has(v) &&
      analyseComplexValue(v).values.length &&
      (w = a[_]),
      _++);
  }
  if (w && f) for (const v of e) a[v] = getAnimatableNone(f, w);
}
const isNumOrPxType = (a) => a === number || a === px,
  getPosFromMatrix = (a, e) => parseFloat(a.split(", ")[e]),
  getTranslateFromMatrix =
    (a, e) =>
    (f, { transform: _ }) => {
      if (_ === "none" || !_) return 0;
      const w = _.match(/^matrix3d\((.+)\)$/u);
      if (w) return getPosFromMatrix(w[1], e);
      {
        const v = _.match(/^matrix\((.+)\)$/u);
        return v ? getPosFromMatrix(v[1], a) : 0;
      }
    },
  transformKeys = new Set(["x", "y", "z"]),
  nonTranslationalTransformKeys = transformPropOrder.filter(
    (a) => !transformKeys.has(a),
  );
function removeNonTranslationalTransform(a) {
  const e = [];
  return (
    nonTranslationalTransformKeys.forEach((f) => {
      const _ = a.getValue(f);
      _ !== void 0 &&
        (e.push([f, _.get()]), _.set(f.startsWith("scale") ? 1 : 0));
    }),
    e
  );
}
const positionalValues = {
  width: ({ x: a }, { paddingLeft: e = "0", paddingRight: f = "0" }) =>
    a.max - a.min - parseFloat(e) - parseFloat(f),
  height: ({ y: a }, { paddingTop: e = "0", paddingBottom: f = "0" }) =>
    a.max - a.min - parseFloat(e) - parseFloat(f),
  top: (a, { top: e }) => parseFloat(e),
  left: (a, { left: e }) => parseFloat(e),
  bottom: ({ y: a }, { top: e }) => parseFloat(e) + (a.max - a.min),
  right: ({ x: a }, { left: e }) => parseFloat(e) + (a.max - a.min),
  x: getTranslateFromMatrix(4, 13),
  y: getTranslateFromMatrix(5, 14),
};
positionalValues.translateX = positionalValues.x;
positionalValues.translateY = positionalValues.y;
const toResolve = new Set();
let isScheduled = !1,
  anyNeedsMeasurement = !1;
function measureAllKeyframes() {
  if (anyNeedsMeasurement) {
    const a = Array.from(toResolve).filter((_) => _.needsMeasurement),
      e = new Set(a.map((_) => _.element)),
      f = new Map();
    (e.forEach((_) => {
      const w = removeNonTranslationalTransform(_);
      w.length && (f.set(_, w), _.render());
    }),
      a.forEach((_) => _.measureInitialState()),
      e.forEach((_) => {
        _.render();
        const w = f.get(_);
        w &&
          w.forEach(([v, S]) => {
            var R;
            (R = _.getValue(v)) === null || R === void 0 || R.set(S);
          });
      }),
      a.forEach((_) => _.measureEndState()),
      a.forEach((_) => {
        _.suspendedScrollY !== void 0 && window.scrollTo(0, _.suspendedScrollY);
      }));
  }
  ((anyNeedsMeasurement = !1),
    (isScheduled = !1),
    toResolve.forEach((a) => a.complete()),
    toResolve.clear());
}
function readAllKeyframes() {
  toResolve.forEach((a) => {
    (a.readKeyframes(), a.needsMeasurement && (anyNeedsMeasurement = !0));
  });
}
function flushKeyframeResolvers() {
  (readAllKeyframes(), measureAllKeyframes());
}
class KeyframeResolver {
  constructor(e, f, _, w, v, S = !1) {
    ((this.isComplete = !1),
      (this.isAsync = !1),
      (this.needsMeasurement = !1),
      (this.isScheduled = !1),
      (this.unresolvedKeyframes = [...e]),
      (this.onComplete = f),
      (this.name = _),
      (this.motionValue = w),
      (this.element = v),
      (this.isAsync = S));
  }
  scheduleResolve() {
    ((this.isScheduled = !0),
      this.isAsync
        ? (toResolve.add(this),
          isScheduled ||
            ((isScheduled = !0),
            frame.read(readAllKeyframes),
            frame.resolveKeyframes(measureAllKeyframes)))
        : (this.readKeyframes(), this.complete()));
  }
  readKeyframes() {
    const {
      unresolvedKeyframes: e,
      name: f,
      element: _,
      motionValue: w,
    } = this;
    for (let v = 0; v < e.length; v++)
      if (e[v] === null)
        if (v === 0) {
          const S = w?.get(),
            R = e[e.length - 1];
          if (S !== void 0) e[0] = S;
          else if (_ && f) {
            const O = _.readValue(f, R);
            O != null && (e[0] = O);
          }
          (e[0] === void 0 && (e[0] = R), w && S === void 0 && w.set(e[0]));
        } else e[v] = e[v - 1];
  }
  setFinalKeyframe() {}
  measureInitialState() {}
  renderEndStyles() {}
  measureEndState() {}
  complete() {
    ((this.isComplete = !0),
      this.onComplete(this.unresolvedKeyframes, this.finalKeyframe),
      toResolve.delete(this));
  }
  cancel() {
    this.isComplete || ((this.isScheduled = !1), toResolve.delete(this));
  }
  resume() {
    this.isComplete || this.scheduleResolve();
  }
}
const isNumericalString = (a) => /^-?(?:\d+(?:\.\d+)?|\.\d+)$/u.test(a),
  splitCSSVariableRegex =
    /^var\(--(?:([\w-]+)|([\w-]+), ?([a-zA-Z\d ()%#.,-]+))\)/u;
function parseCSSVariable(a) {
  const e = splitCSSVariableRegex.exec(a);
  if (!e) return [,];
  const [, f, _, w] = e;
  return [`--${f ?? _}`, w];
}
function getVariableValue(a, e, f = 1) {
  const [_, w] = parseCSSVariable(a);
  if (!_) return;
  const v = window.getComputedStyle(e).getPropertyValue(_);
  if (v) {
    const S = v.trim();
    return isNumericalString(S) ? parseFloat(S) : S;
  }
  return isCSSVariableToken(w) ? getVariableValue(w, e, f + 1) : w;
}
const testValueType = (a) => (e) => e.test(a),
  auto = { test: (a) => a === "auto", parse: (a) => a },
  dimensionValueTypes = [number, px, percent, degrees, vw, vh, auto],
  findDimensionValueType = (a) => dimensionValueTypes.find(testValueType(a));
class DOMKeyframesResolver extends KeyframeResolver {
  constructor(e, f, _, w, v) {
    super(e, f, _, w, v, !0);
  }
  readKeyframes() {
    const { unresolvedKeyframes: e, element: f, name: _ } = this;
    if (!f || !f.current) return;
    super.readKeyframes();
    for (let O = 0; O < e.length; O++) {
      let j = e[O];
      if (typeof j == "string" && ((j = j.trim()), isCSSVariableToken(j))) {
        const F = getVariableValue(j, f.current);
        (F !== void 0 && (e[O] = F),
          O === e.length - 1 && (this.finalKeyframe = j));
      }
    }
    if ((this.resolveNoneKeyframes(), !positionalKeys.has(_) || e.length !== 2))
      return;
    const [w, v] = e,
      S = findDimensionValueType(w),
      R = findDimensionValueType(v);
    if (S !== R)
      if (isNumOrPxType(S) && isNumOrPxType(R))
        for (let O = 0; O < e.length; O++) {
          const j = e[O];
          typeof j == "string" && (e[O] = parseFloat(j));
        }
      else this.needsMeasurement = !0;
  }
  resolveNoneKeyframes() {
    const { unresolvedKeyframes: e, name: f } = this,
      _ = [];
    for (let w = 0; w < e.length; w++) isNone(e[w]) && _.push(w);
    _.length && makeNoneKeyframesAnimatable(e, _, f);
  }
  measureInitialState() {
    const { element: e, unresolvedKeyframes: f, name: _ } = this;
    if (!e || !e.current) return;
    (_ === "height" && (this.suspendedScrollY = window.pageYOffset),
      (this.measuredOrigin = positionalValues[_](
        e.measureViewportBox(),
        window.getComputedStyle(e.current),
      )),
      (f[0] = this.measuredOrigin));
    const w = f[f.length - 1];
    w !== void 0 && e.getValue(_, w).jump(w, !1);
  }
  measureEndState() {
    var e;
    const { element: f, name: _, unresolvedKeyframes: w } = this;
    if (!f || !f.current) return;
    const v = f.getValue(_);
    v && v.jump(this.measuredOrigin, !1);
    const S = w.length - 1,
      R = w[S];
    ((w[S] = positionalValues[_](
      f.measureViewportBox(),
      window.getComputedStyle(f.current),
    )),
      R !== null && this.finalKeyframe === void 0 && (this.finalKeyframe = R),
      !((e = this.removedTransforms) === null || e === void 0) &&
        e.length &&
        this.removedTransforms.forEach(([O, j]) => {
          f.getValue(O).set(j);
        }),
      this.resolveNoneKeyframes());
  }
}
const isAnimatable = (a, e) =>
  e === "zIndex"
    ? !1
    : !!(
        typeof a == "number" ||
        Array.isArray(a) ||
        (typeof a == "string" &&
          (complex.test(a) || a === "0") &&
          !a.startsWith("url("))
      );
function hasKeyframesChanged(a) {
  const e = a[0];
  if (a.length === 1) return !0;
  for (let f = 0; f < a.length; f++) if (a[f] !== e) return !0;
}
function canAnimate(a, e, f, _) {
  const w = a[0];
  if (w === null) return !1;
  if (e === "display" || e === "visibility") return !0;
  const v = a[a.length - 1],
    S = isAnimatable(w, e),
    R = isAnimatable(v, e);
  return !S || !R
    ? !1
    : hasKeyframesChanged(a) || ((f === "spring" || isGenerator(f)) && _);
}
const isNotNull = (a) => a !== null;
function getFinalKeyframe(a, { repeat: e, repeatType: f = "loop" }, _) {
  const w = a.filter(isNotNull),
    v = e && f !== "loop" && e % 2 === 1 ? 0 : w.length - 1;
  return !v || _ === void 0 ? w[v] : _;
}
const MAX_RESOLVE_DELAY = 40;
class BaseAnimation {
  constructor({
    autoplay: e = !0,
    delay: f = 0,
    type: _ = "keyframes",
    repeat: w = 0,
    repeatDelay: v = 0,
    repeatType: S = "loop",
    ...R
  }) {
    ((this.isStopped = !1),
      (this.hasAttemptedResolve = !1),
      (this.createdAt = time.now()),
      (this.options = {
        autoplay: e,
        delay: f,
        type: _,
        repeat: w,
        repeatDelay: v,
        repeatType: S,
        ...R,
      }),
      this.updateFinishedPromise());
  }
  calcStartTime() {
    return this.resolvedAt
      ? this.resolvedAt - this.createdAt > MAX_RESOLVE_DELAY
        ? this.resolvedAt
        : this.createdAt
      : this.createdAt;
  }
  get resolved() {
    return (
      !this._resolved && !this.hasAttemptedResolve && flushKeyframeResolvers(),
      this._resolved
    );
  }
  onKeyframesResolved(e, f) {
    ((this.resolvedAt = time.now()), (this.hasAttemptedResolve = !0));
    const {
      name: _,
      type: w,
      velocity: v,
      delay: S,
      onComplete: R,
      onUpdate: O,
      isGenerator: j,
    } = this.options;
    if (!j && !canAnimate(e, _, w, v))
      if (S) this.options.duration = 0;
      else {
        (O && O(getFinalKeyframe(e, this.options, f)),
          R && R(),
          this.resolveFinishedPromise());
        return;
      }
    const F = this.initPlayback(e, f);
    F !== !1 &&
      ((this._resolved = { keyframes: e, finalKeyframe: f, ...F }),
      this.onPostResolved());
  }
  onPostResolved() {}
  then(e, f) {
    return this.currentFinishedPromise.then(e, f);
  }
  flatten() {
    ((this.options.type = "keyframes"), (this.options.ease = "linear"));
  }
  updateFinishedPromise() {
    this.currentFinishedPromise = new Promise((e) => {
      this.resolveFinishedPromise = e;
    });
  }
}
const mixNumber$1 = (a, e, f) => a + (e - a) * f;
function hueToRgb(a, e, f) {
  return (
    f < 0 && (f += 1),
    f > 1 && (f -= 1),
    f < 1 / 6
      ? a + (e - a) * 6 * f
      : f < 1 / 2
        ? e
        : f < 2 / 3
          ? a + (e - a) * (2 / 3 - f) * 6
          : a
  );
}
function hslaToRgba({ hue: a, saturation: e, lightness: f, alpha: _ }) {
  ((a /= 360), (e /= 100), (f /= 100));
  let w = 0,
    v = 0,
    S = 0;
  if (!e) w = v = S = f;
  else {
    const R = f < 0.5 ? f * (1 + e) : f + e - f * e,
      O = 2 * f - R;
    ((w = hueToRgb(O, R, a + 1 / 3)),
      (v = hueToRgb(O, R, a)),
      (S = hueToRgb(O, R, a - 1 / 3)));
  }
  return {
    red: Math.round(w * 255),
    green: Math.round(v * 255),
    blue: Math.round(S * 255),
    alpha: _,
  };
}
function mixImmediate(a, e) {
  return (f) => (f > 0 ? e : a);
}
const mixLinearColor = (a, e, f) => {
    const _ = a * a,
      w = f * (e * e - _) + _;
    return w < 0 ? 0 : Math.sqrt(w);
  },
  colorTypes = [hex, rgba, hsla],
  getColorType = (a) => colorTypes.find((e) => e.test(a));
function asRGBA(a) {
  const e = getColorType(a);
  if (!e) return !1;
  let f = e.parse(a);
  return (e === hsla && (f = hslaToRgba(f)), f);
}
const mixColor = (a, e) => {
    const f = asRGBA(a),
      _ = asRGBA(e);
    if (!f || !_) return mixImmediate(a, e);
    const w = { ...f };
    return (v) => (
      (w.red = mixLinearColor(f.red, _.red, v)),
      (w.green = mixLinearColor(f.green, _.green, v)),
      (w.blue = mixLinearColor(f.blue, _.blue, v)),
      (w.alpha = mixNumber$1(f.alpha, _.alpha, v)),
      rgba.transform(w)
    );
  },
  combineFunctions = (a, e) => (f) => e(a(f)),
  pipe = (...a) => a.reduce(combineFunctions),
  invisibleValues = new Set(["none", "hidden"]);
function mixVisibility(a, e) {
  return invisibleValues.has(a)
    ? (f) => (f <= 0 ? a : e)
    : (f) => (f >= 1 ? e : a);
}
function mixNumber(a, e) {
  return (f) => mixNumber$1(a, e, f);
}
function getMixer(a) {
  return typeof a == "number"
    ? mixNumber
    : typeof a == "string"
      ? isCSSVariableToken(a)
        ? mixImmediate
        : color.test(a)
          ? mixColor
          : mixComplex
      : Array.isArray(a)
        ? mixArray
        : typeof a == "object"
          ? color.test(a)
            ? mixColor
            : mixObject
          : mixImmediate;
}
function mixArray(a, e) {
  const f = [...a],
    _ = f.length,
    w = a.map((v, S) => getMixer(v)(v, e[S]));
  return (v) => {
    for (let S = 0; S < _; S++) f[S] = w[S](v);
    return f;
  };
}
function mixObject(a, e) {
  const f = { ...a, ...e },
    _ = {};
  for (const w in f)
    a[w] !== void 0 && e[w] !== void 0 && (_[w] = getMixer(a[w])(a[w], e[w]));
  return (w) => {
    for (const v in _) f[v] = _[v](w);
    return f;
  };
}
function matchOrder(a, e) {
  var f;
  const _ = [],
    w = { color: 0, var: 0, number: 0 };
  for (let v = 0; v < e.values.length; v++) {
    const S = e.types[v],
      R = a.indexes[S][w[S]],
      O = (f = a.values[R]) !== null && f !== void 0 ? f : 0;
    ((_[v] = O), w[S]++);
  }
  return _;
}
const mixComplex = (a, e) => {
  const f = complex.createTransformer(e),
    _ = analyseComplexValue(a),
    w = analyseComplexValue(e);
  return _.indexes.var.length === w.indexes.var.length &&
    _.indexes.color.length === w.indexes.color.length &&
    _.indexes.number.length >= w.indexes.number.length
    ? (invisibleValues.has(a) && !w.values.length) ||
      (invisibleValues.has(e) && !_.values.length)
      ? mixVisibility(a, e)
      : pipe(mixArray(matchOrder(_, w), w.values), f)
    : mixImmediate(a, e);
};
function mix(a, e, f) {
  return typeof a == "number" && typeof e == "number" && typeof f == "number"
    ? mixNumber$1(a, e, f)
    : getMixer(a)(a, e);
}
const velocitySampleDuration = 5;
function calcGeneratorVelocity(a, e, f) {
  const _ = Math.max(e - velocitySampleDuration, 0);
  return velocityPerSecond(f - a(_), e - _);
}
const springDefaults = {
    stiffness: 100,
    damping: 10,
    mass: 1,
    velocity: 0,
    duration: 800,
    bounce: 0.3,
    visualDuration: 0.3,
    restSpeed: { granular: 0.01, default: 2 },
    restDelta: { granular: 0.005, default: 0.5 },
    minDuration: 0.01,
    maxDuration: 10,
    minDamping: 0.05,
    maxDamping: 1,
  },
  safeMin = 0.001;
function findSpring({
  duration: a = springDefaults.duration,
  bounce: e = springDefaults.bounce,
  velocity: f = springDefaults.velocity,
  mass: _ = springDefaults.mass,
}) {
  let w,
    v,
    S = 1 - e;
  ((S = clamp$1(springDefaults.minDamping, springDefaults.maxDamping, S)),
    (a = clamp$1(
      springDefaults.minDuration,
      springDefaults.maxDuration,
      millisecondsToSeconds(a),
    )),
    S < 1
      ? ((w = (j) => {
          const F = j * S,
            q = F * a,
            Q = F - f,
            te = calcAngularFreq(j, S),
            se = Math.exp(-q);
          return safeMin - (Q / te) * se;
        }),
        (v = (j) => {
          const q = j * S * a,
            Q = q * f + f,
            te = Math.pow(S, 2) * Math.pow(j, 2) * a,
            se = Math.exp(-q),
            re = calcAngularFreq(Math.pow(j, 2), S);
          return ((-w(j) + safeMin > 0 ? -1 : 1) * ((Q - te) * se)) / re;
        }))
      : ((w = (j) => {
          const F = Math.exp(-j * a),
            q = (j - f) * a + 1;
          return -safeMin + F * q;
        }),
        (v = (j) => {
          const F = Math.exp(-j * a),
            q = (f - j) * (a * a);
          return F * q;
        })));
  const R = 5 / a,
    O = approximateRoot(w, v, R);
  if (((a = secondsToMilliseconds(a)), isNaN(O)))
    return {
      stiffness: springDefaults.stiffness,
      damping: springDefaults.damping,
      duration: a,
    };
  {
    const j = Math.pow(O, 2) * _;
    return { stiffness: j, damping: S * 2 * Math.sqrt(_ * j), duration: a };
  }
}
const rootIterations = 12;
function approximateRoot(a, e, f) {
  let _ = f;
  for (let w = 1; w < rootIterations; w++) _ = _ - a(_) / e(_);
  return _;
}
function calcAngularFreq(a, e) {
  return a * Math.sqrt(1 - e * e);
}
const durationKeys = ["duration", "bounce"],
  physicsKeys = ["stiffness", "damping", "mass"];
function isSpringType(a, e) {
  return e.some((f) => a[f] !== void 0);
}
function getSpringOptions(a) {
  let e = {
    velocity: springDefaults.velocity,
    stiffness: springDefaults.stiffness,
    damping: springDefaults.damping,
    mass: springDefaults.mass,
    isResolvedFromDuration: !1,
    ...a,
  };
  if (!isSpringType(a, physicsKeys) && isSpringType(a, durationKeys))
    if (a.visualDuration) {
      const f = a.visualDuration,
        _ = (2 * Math.PI) / (f * 1.2),
        w = _ * _,
        v = 2 * clamp$1(0.05, 1, 1 - (a.bounce || 0)) * Math.sqrt(w);
      e = { ...e, mass: springDefaults.mass, stiffness: w, damping: v };
    } else {
      const f = findSpring(a);
      ((e = { ...e, ...f, mass: springDefaults.mass }),
        (e.isResolvedFromDuration = !0));
    }
  return e;
}
function spring(a = springDefaults.visualDuration, e = springDefaults.bounce) {
  const f =
    typeof a != "object"
      ? { visualDuration: a, keyframes: [0, 1], bounce: e }
      : a;
  let { restSpeed: _, restDelta: w } = f;
  const v = f.keyframes[0],
    S = f.keyframes[f.keyframes.length - 1],
    R = { done: !1, value: v },
    {
      stiffness: O,
      damping: j,
      mass: F,
      duration: q,
      velocity: Q,
      isResolvedFromDuration: te,
    } = getSpringOptions({
      ...f,
      velocity: -millisecondsToSeconds(f.velocity || 0),
    }),
    se = Q || 0,
    re = j / (2 * Math.sqrt(O * F)),
    Oe = S - v,
    Le = millisecondsToSeconds(Math.sqrt(O / F)),
    Be = Math.abs(Oe) < 5;
  (_ ||
    (_ = Be
      ? springDefaults.restSpeed.granular
      : springDefaults.restSpeed.default),
    w ||
      (w = Be
        ? springDefaults.restDelta.granular
        : springDefaults.restDelta.default));
  let Ve;
  if (re < 1) {
    const Ge = calcAngularFreq(Le, re);
    Ve = (Ke) => {
      const qe = Math.exp(-re * Le * Ke);
      return (
        S -
        qe *
          (((se + re * Le * Oe) / Ge) * Math.sin(Ge * Ke) +
            Oe * Math.cos(Ge * Ke))
      );
    };
  } else if (re === 1)
    Ve = (Ge) => S - Math.exp(-Le * Ge) * (Oe + (se + Le * Oe) * Ge);
  else {
    const Ge = Le * Math.sqrt(re * re - 1);
    Ve = (Ke) => {
      const qe = Math.exp(-re * Le * Ke),
        nt = Math.min(Ge * Ke, 300);
      return (
        S -
        (qe * ((se + re * Le * Oe) * Math.sinh(nt) + Ge * Oe * Math.cosh(nt))) /
          Ge
      );
    };
  }
  const ze = {
    calculatedDuration: (te && q) || null,
    next: (Ge) => {
      const Ke = Ve(Ge);
      if (te) R.done = Ge >= q;
      else {
        let qe = 0;
        re < 1 &&
          (qe =
            Ge === 0
              ? secondsToMilliseconds(se)
              : calcGeneratorVelocity(Ve, Ge, Ke));
        const nt = Math.abs(qe) <= _,
          pt = Math.abs(S - Ke) <= w;
        R.done = nt && pt;
      }
      return ((R.value = R.done ? S : Ke), R);
    },
    toString: () => {
      const Ge = Math.min(calcGeneratorDuration(ze), maxGeneratorDuration),
        Ke = generateLinearEasing((qe) => ze.next(Ge * qe).value, Ge, 30);
      return Ge + "ms " + Ke;
    },
  };
  return ze;
}
function inertia({
  keyframes: a,
  velocity: e = 0,
  power: f = 0.8,
  timeConstant: _ = 325,
  bounceDamping: w = 10,
  bounceStiffness: v = 500,
  modifyTarget: S,
  min: R,
  max: O,
  restDelta: j = 0.5,
  restSpeed: F,
}) {
  const q = a[0],
    Q = { done: !1, value: q },
    te = (nt) => (R !== void 0 && nt < R) || (O !== void 0 && nt > O),
    se = (nt) =>
      R === void 0
        ? O
        : O === void 0 || Math.abs(R - nt) < Math.abs(O - nt)
          ? R
          : O;
  let re = f * e;
  const Oe = q + re,
    Le = S === void 0 ? Oe : S(Oe);
  Le !== Oe && (re = Le - q);
  const Be = (nt) => -re * Math.exp(-nt / _),
    Ve = (nt) => Le + Be(nt),
    ze = (nt) => {
      const pt = Be(nt),
        gt = Ve(nt);
      ((Q.done = Math.abs(pt) <= j), (Q.value = Q.done ? Le : gt));
    };
  let Ge, Ke;
  const qe = (nt) => {
    te(Q.value) &&
      ((Ge = nt),
      (Ke = spring({
        keyframes: [Q.value, se(Q.value)],
        velocity: calcGeneratorVelocity(Ve, nt, Q.value),
        damping: w,
        stiffness: v,
        restDelta: j,
        restSpeed: F,
      })));
  };
  return (
    qe(0),
    {
      calculatedDuration: null,
      next: (nt) => {
        let pt = !1;
        return (
          !Ke && Ge === void 0 && ((pt = !0), ze(nt), qe(nt)),
          Ge !== void 0 && nt >= Ge ? Ke.next(nt - Ge) : (!pt && ze(nt), Q)
        );
      },
    }
  );
}
const easeIn = cubicBezier(0.42, 0, 1, 1),
  easeOut = cubicBezier(0, 0, 0.58, 1),
  easeInOut = cubicBezier(0.42, 0, 0.58, 1),
  isEasingArray = (a) => Array.isArray(a) && typeof a[0] != "number",
  easingLookup = {
    linear: noop,
    easeIn,
    easeInOut,
    easeOut,
    circIn,
    circInOut,
    circOut,
    backIn,
    backInOut,
    backOut,
    anticipate,
  },
  easingDefinitionToFunction = (a) => {
    if (isBezierDefinition(a)) {
      invariant(a.length === 4);
      const [e, f, _, w] = a;
      return cubicBezier(e, f, _, w);
    } else if (typeof a == "string") return easingLookup[a];
    return a;
  };
function createMixers(a, e, f) {
  const _ = [],
    w = f || mix,
    v = a.length - 1;
  for (let S = 0; S < v; S++) {
    let R = w(a[S], a[S + 1]);
    if (e) {
      const O = Array.isArray(e) ? e[S] || noop : e;
      R = pipe(O, R);
    }
    _.push(R);
  }
  return _;
}
function interpolate(a, e, { clamp: f = !0, ease: _, mixer: w } = {}) {
  const v = a.length;
  if ((invariant(v === e.length), v === 1)) return () => e[0];
  if (v === 2 && e[0] === e[1]) return () => e[1];
  const S = a[0] === a[1];
  a[0] > a[v - 1] && ((a = [...a].reverse()), (e = [...e].reverse()));
  const R = createMixers(e, _, w),
    O = R.length,
    j = (F) => {
      if (S && F < a[0]) return e[0];
      let q = 0;
      if (O > 1) for (; q < a.length - 2 && !(F < a[q + 1]); q++);
      const Q = progress(a[q], a[q + 1], F);
      return R[q](Q);
    };
  return f ? (F) => j(clamp$1(a[0], a[v - 1], F)) : j;
}
function fillOffset(a, e) {
  const f = a[a.length - 1];
  for (let _ = 1; _ <= e; _++) {
    const w = progress(0, e, _);
    a.push(mixNumber$1(f, 1, w));
  }
}
function defaultOffset(a) {
  const e = [0];
  return (fillOffset(e, a.length - 1), e);
}
function convertOffsetToTimes(a, e) {
  return a.map((f) => f * e);
}
function defaultEasing(a, e) {
  return a.map(() => e || easeInOut).splice(0, a.length - 1);
}
function keyframes({
  duration: a = 300,
  keyframes: e,
  times: f,
  ease: _ = "easeInOut",
}) {
  const w = isEasingArray(_)
      ? _.map(easingDefinitionToFunction)
      : easingDefinitionToFunction(_),
    v = { done: !1, value: e[0] },
    S = convertOffsetToTimes(
      f && f.length === e.length ? f : defaultOffset(e),
      a,
    ),
    R = interpolate(S, e, { ease: Array.isArray(w) ? w : defaultEasing(e, w) });
  return {
    calculatedDuration: a,
    next: (O) => ((v.value = R(O)), (v.done = O >= a), v),
  };
}
const frameloopDriver = (a) => {
    const e = ({ timestamp: f }) => a(f);
    return {
      start: () => frame.update(e, !0),
      stop: () => cancelFrame(e),
      now: () => (frameData.isProcessing ? frameData.timestamp : time.now()),
    };
  },
  generators = { decay: inertia, inertia, tween: keyframes, keyframes, spring },
  percentToProgress = (a) => a / 100;
class MainThreadAnimation extends BaseAnimation {
  constructor(e) {
    (super(e),
      (this.holdTime = null),
      (this.cancelTime = null),
      (this.currentTime = 0),
      (this.playbackSpeed = 1),
      (this.pendingPlayState = "running"),
      (this.startTime = null),
      (this.state = "idle"),
      (this.stop = () => {
        if (
          (this.resolver.cancel(), (this.isStopped = !0), this.state === "idle")
        )
          return;
        this.teardown();
        const { onStop: O } = this.options;
        O && O();
      }));
    const { name: f, motionValue: _, element: w, keyframes: v } = this.options,
      S = w?.KeyframeResolver || KeyframeResolver,
      R = (O, j) => this.onKeyframesResolved(O, j);
    ((this.resolver = new S(v, R, f, _, w)), this.resolver.scheduleResolve());
  }
  flatten() {
    (super.flatten(),
      this._resolved &&
        Object.assign(
          this._resolved,
          this.initPlayback(this._resolved.keyframes),
        ));
  }
  initPlayback(e) {
    const {
        type: f = "keyframes",
        repeat: _ = 0,
        repeatDelay: w = 0,
        repeatType: v,
        velocity: S = 0,
      } = this.options,
      R = isGenerator(f) ? f : generators[f] || keyframes;
    let O, j;
    R !== keyframes &&
      typeof e[0] != "number" &&
      ((O = pipe(percentToProgress, mix(e[0], e[1]))), (e = [0, 100]));
    const F = R({ ...this.options, keyframes: e });
    (v === "mirror" &&
      (j = R({ ...this.options, keyframes: [...e].reverse(), velocity: -S })),
      F.calculatedDuration === null &&
        (F.calculatedDuration = calcGeneratorDuration(F)));
    const { calculatedDuration: q } = F,
      Q = q + w,
      te = Q * (_ + 1) - w;
    return {
      generator: F,
      mirroredGenerator: j,
      mapPercentToKeyframes: O,
      calculatedDuration: q,
      resolvedDuration: Q,
      totalDuration: te,
    };
  }
  onPostResolved() {
    const { autoplay: e = !0 } = this.options;
    (this.play(),
      this.pendingPlayState === "paused" || !e
        ? this.pause()
        : (this.state = this.pendingPlayState));
  }
  tick(e, f = !1) {
    const { resolved: _ } = this;
    if (!_) {
      const { keyframes: nt } = this.options;
      return { done: !0, value: nt[nt.length - 1] };
    }
    const {
      finalKeyframe: w,
      generator: v,
      mirroredGenerator: S,
      mapPercentToKeyframes: R,
      keyframes: O,
      calculatedDuration: j,
      totalDuration: F,
      resolvedDuration: q,
    } = _;
    if (this.startTime === null) return v.next(0);
    const {
      delay: Q,
      repeat: te,
      repeatType: se,
      repeatDelay: re,
      onUpdate: Oe,
    } = this.options;
    (this.speed > 0
      ? (this.startTime = Math.min(this.startTime, e))
      : this.speed < 0 &&
        (this.startTime = Math.min(e - F / this.speed, this.startTime)),
      f
        ? (this.currentTime = e)
        : this.holdTime !== null
          ? (this.currentTime = this.holdTime)
          : (this.currentTime = Math.round(e - this.startTime) * this.speed));
    const Le = this.currentTime - Q * (this.speed >= 0 ? 1 : -1),
      Be = this.speed >= 0 ? Le < 0 : Le > F;
    ((this.currentTime = Math.max(Le, 0)),
      this.state === "finished" &&
        this.holdTime === null &&
        (this.currentTime = F));
    let Ve = this.currentTime,
      ze = v;
    if (te) {
      const nt = Math.min(this.currentTime, F) / q;
      let pt = Math.floor(nt),
        gt = nt % 1;
      (!gt && nt >= 1 && (gt = 1),
        gt === 1 && pt--,
        (pt = Math.min(pt, te + 1)),
        !!(pt % 2) &&
          (se === "reverse"
            ? ((gt = 1 - gt), re && (gt -= re / q))
            : se === "mirror" && (ze = S)),
        (Ve = clamp$1(0, 1, gt) * q));
    }
    const Ge = Be ? { done: !1, value: O[0] } : ze.next(Ve);
    R && (Ge.value = R(Ge.value));
    let { done: Ke } = Ge;
    !Be &&
      j !== null &&
      (Ke = this.speed >= 0 ? this.currentTime >= F : this.currentTime <= 0);
    const qe =
      this.holdTime === null &&
      (this.state === "finished" || (this.state === "running" && Ke));
    return (
      qe && w !== void 0 && (Ge.value = getFinalKeyframe(O, this.options, w)),
      Oe && Oe(Ge.value),
      qe && this.finish(),
      Ge
    );
  }
  get duration() {
    const { resolved: e } = this;
    return e ? millisecondsToSeconds(e.calculatedDuration) : 0;
  }
  get time() {
    return millisecondsToSeconds(this.currentTime);
  }
  set time(e) {
    ((e = secondsToMilliseconds(e)),
      (this.currentTime = e),
      this.holdTime !== null || this.speed === 0
        ? (this.holdTime = e)
        : this.driver && (this.startTime = this.driver.now() - e / this.speed));
  }
  get speed() {
    return this.playbackSpeed;
  }
  set speed(e) {
    const f = this.playbackSpeed !== e;
    ((this.playbackSpeed = e),
      f && (this.time = millisecondsToSeconds(this.currentTime)));
  }
  play() {
    if (
      (this.resolver.isScheduled || this.resolver.resume(), !this._resolved)
    ) {
      this.pendingPlayState = "running";
      return;
    }
    if (this.isStopped) return;
    const {
      driver: e = frameloopDriver,
      onPlay: f,
      startTime: _,
    } = this.options;
    (this.driver || (this.driver = e((v) => this.tick(v))), f && f());
    const w = this.driver.now();
    (this.holdTime !== null
      ? (this.startTime = w - this.holdTime)
      : this.startTime
        ? this.state === "finished" && (this.startTime = w)
        : (this.startTime = _ ?? this.calcStartTime()),
      this.state === "finished" && this.updateFinishedPromise(),
      (this.cancelTime = this.startTime),
      (this.holdTime = null),
      (this.state = "running"),
      this.driver.start());
  }
  pause() {
    var e;
    if (!this._resolved) {
      this.pendingPlayState = "paused";
      return;
    }
    ((this.state = "paused"),
      (this.holdTime =
        (e = this.currentTime) !== null && e !== void 0 ? e : 0));
  }
  complete() {
    (this.state !== "running" && this.play(),
      (this.pendingPlayState = this.state = "finished"),
      (this.holdTime = null));
  }
  finish() {
    (this.teardown(), (this.state = "finished"));
    const { onComplete: e } = this.options;
    e && e();
  }
  cancel() {
    (this.cancelTime !== null && this.tick(this.cancelTime),
      this.teardown(),
      this.updateFinishedPromise());
  }
  teardown() {
    ((this.state = "idle"),
      this.stopDriver(),
      this.resolveFinishedPromise(),
      this.updateFinishedPromise(),
      (this.startTime = this.cancelTime = null),
      this.resolver.cancel());
  }
  stopDriver() {
    this.driver && (this.driver.stop(), (this.driver = void 0));
  }
  sample(e) {
    return ((this.startTime = 0), this.tick(e, !0));
  }
}
const acceleratedValues = new Set([
  "opacity",
  "clipPath",
  "filter",
  "transform",
]);
function startWaapiAnimation(
  a,
  e,
  f,
  {
    delay: _ = 0,
    duration: w = 300,
    repeat: v = 0,
    repeatType: S = "loop",
    ease: R = "easeInOut",
    times: O,
  } = {},
) {
  const j = { [e]: f };
  O && (j.offset = O);
  const F = mapEasingToNativeEasing(R, w);
  return (
    Array.isArray(F) && (j.easing = F),
    a.animate(j, {
      delay: _,
      duration: w,
      easing: Array.isArray(F) ? "linear" : F,
      fill: "both",
      iterations: v + 1,
      direction: S === "reverse" ? "alternate" : "normal",
    })
  );
}
const supportsWaapi = memo(() =>
    Object.hasOwnProperty.call(Element.prototype, "animate"),
  ),
  sampleDelta = 10,
  maxDuration = 2e4;
function requiresPregeneratedKeyframes(a) {
  return (
    isGenerator(a.type) ||
    a.type === "spring" ||
    !isWaapiSupportedEasing(a.ease)
  );
}
function pregenerateKeyframes(a, e) {
  const f = new MainThreadAnimation({
    ...e,
    keyframes: a,
    repeat: 0,
    delay: 0,
    isGenerator: !0,
  });
  let _ = { done: !1, value: a[0] };
  const w = [];
  let v = 0;
  for (; !_.done && v < maxDuration; )
    ((_ = f.sample(v)), w.push(_.value), (v += sampleDelta));
  return {
    times: void 0,
    keyframes: w,
    duration: v - sampleDelta,
    ease: "linear",
  };
}
const unsupportedEasingFunctions = { anticipate, backInOut, circInOut };
function isUnsupportedEase(a) {
  return a in unsupportedEasingFunctions;
}
class AcceleratedAnimation extends BaseAnimation {
  constructor(e) {
    super(e);
    const { name: f, motionValue: _, element: w, keyframes: v } = this.options;
    ((this.resolver = new DOMKeyframesResolver(
      v,
      (S, R) => this.onKeyframesResolved(S, R),
      f,
      _,
      w,
    )),
      this.resolver.scheduleResolve());
  }
  initPlayback(e, f) {
    let {
      duration: _ = 300,
      times: w,
      ease: v,
      type: S,
      motionValue: R,
      name: O,
      startTime: j,
    } = this.options;
    if (!R.owner || !R.owner.current) return !1;
    if (
      (typeof v == "string" &&
        supportsLinearEasing() &&
        isUnsupportedEase(v) &&
        (v = unsupportedEasingFunctions[v]),
      requiresPregeneratedKeyframes(this.options))
    ) {
      const {
          onComplete: q,
          onUpdate: Q,
          motionValue: te,
          element: se,
          ...re
        } = this.options,
        Oe = pregenerateKeyframes(e, re);
      ((e = Oe.keyframes),
        e.length === 1 && (e[1] = e[0]),
        (_ = Oe.duration),
        (w = Oe.times),
        (v = Oe.ease),
        (S = "keyframes"));
    }
    const F = startWaapiAnimation(R.owner.current, O, e, {
      ...this.options,
      duration: _,
      times: w,
      ease: v,
    });
    return (
      (F.startTime = j ?? this.calcStartTime()),
      this.pendingTimeline
        ? (attachTimeline(F, this.pendingTimeline),
          (this.pendingTimeline = void 0))
        : (F.onfinish = () => {
            const { onComplete: q } = this.options;
            (R.set(getFinalKeyframe(e, this.options, f)),
              q && q(),
              this.cancel(),
              this.resolveFinishedPromise());
          }),
      { animation: F, duration: _, times: w, type: S, ease: v, keyframes: e }
    );
  }
  get duration() {
    const { resolved: e } = this;
    if (!e) return 0;
    const { duration: f } = e;
    return millisecondsToSeconds(f);
  }
  get time() {
    const { resolved: e } = this;
    if (!e) return 0;
    const { animation: f } = e;
    return millisecondsToSeconds(f.currentTime || 0);
  }
  set time(e) {
    const { resolved: f } = this;
    if (!f) return;
    const { animation: _ } = f;
    _.currentTime = secondsToMilliseconds(e);
  }
  get speed() {
    const { resolved: e } = this;
    if (!e) return 1;
    const { animation: f } = e;
    return f.playbackRate;
  }
  set speed(e) {
    const { resolved: f } = this;
    if (!f) return;
    const { animation: _ } = f;
    _.playbackRate = e;
  }
  get state() {
    const { resolved: e } = this;
    if (!e) return "idle";
    const { animation: f } = e;
    return f.playState;
  }
  get startTime() {
    const { resolved: e } = this;
    if (!e) return null;
    const { animation: f } = e;
    return f.startTime;
  }
  attachTimeline(e) {
    if (!this._resolved) this.pendingTimeline = e;
    else {
      const { resolved: f } = this;
      if (!f) return noop;
      const { animation: _ } = f;
      attachTimeline(_, e);
    }
    return noop;
  }
  play() {
    if (this.isStopped) return;
    const { resolved: e } = this;
    if (!e) return;
    const { animation: f } = e;
    (f.playState === "finished" && this.updateFinishedPromise(), f.play());
  }
  pause() {
    const { resolved: e } = this;
    if (!e) return;
    const { animation: f } = e;
    f.pause();
  }
  stop() {
    if ((this.resolver.cancel(), (this.isStopped = !0), this.state === "idle"))
      return;
    (this.resolveFinishedPromise(), this.updateFinishedPromise());
    const { resolved: e } = this;
    if (!e) return;
    const {
      animation: f,
      keyframes: _,
      duration: w,
      type: v,
      ease: S,
      times: R,
    } = e;
    if (f.playState === "idle" || f.playState === "finished") return;
    if (this.time) {
      const {
          motionValue: j,
          onUpdate: F,
          onComplete: q,
          element: Q,
          ...te
        } = this.options,
        se = new MainThreadAnimation({
          ...te,
          keyframes: _,
          duration: w,
          type: v,
          ease: S,
          times: R,
          isGenerator: !0,
        }),
        re = secondsToMilliseconds(this.time);
      j.setWithVelocity(
        se.sample(re - sampleDelta).value,
        se.sample(re).value,
        sampleDelta,
      );
    }
    const { onStop: O } = this.options;
    (O && O(), this.cancel());
  }
  complete() {
    const { resolved: e } = this;
    e && e.animation.finish();
  }
  cancel() {
    const { resolved: e } = this;
    e && e.animation.cancel();
  }
  static supports(e) {
    const {
      motionValue: f,
      name: _,
      repeatDelay: w,
      repeatType: v,
      damping: S,
      type: R,
    } = e;
    if (!f || !f.owner || !(f.owner.current instanceof HTMLElement)) return !1;
    const { onUpdate: O, transformTemplate: j } = f.owner.getProps();
    return (
      supportsWaapi() &&
      _ &&
      acceleratedValues.has(_) &&
      !O &&
      !j &&
      !w &&
      v !== "mirror" &&
      S !== 0 &&
      R !== "inertia"
    );
  }
}
const underDampedSpring = {
    type: "spring",
    stiffness: 500,
    damping: 25,
    restSpeed: 10,
  },
  criticallyDampedSpring = (a) => ({
    type: "spring",
    stiffness: 550,
    damping: a === 0 ? 2 * Math.sqrt(550) : 30,
    restSpeed: 10,
  }),
  keyframesTransition = { type: "keyframes", duration: 0.8 },
  ease = { type: "keyframes", ease: [0.25, 0.1, 0.35, 1], duration: 0.3 },
  getDefaultTransition = (a, { keyframes: e }) =>
    e.length > 2
      ? keyframesTransition
      : transformProps.has(a)
        ? a.startsWith("scale")
          ? criticallyDampedSpring(e[1])
          : underDampedSpring
        : ease;
function isTransitionDefined({
  when: a,
  delay: e,
  delayChildren: f,
  staggerChildren: _,
  staggerDirection: w,
  repeat: v,
  repeatType: S,
  repeatDelay: R,
  from: O,
  elapsed: j,
  ...F
}) {
  return !!Object.keys(F).length;
}
const animateMotionValue =
  (a, e, f, _ = {}, w, v) =>
  (S) => {
    const R = getValueTransition(_, a) || {},
      O = R.delay || _.delay || 0;
    let { elapsed: j = 0 } = _;
    j = j - secondsToMilliseconds(O);
    let F = {
      keyframes: Array.isArray(f) ? f : [null, f],
      ease: "easeOut",
      velocity: e.getVelocity(),
      ...R,
      delay: -j,
      onUpdate: (Q) => {
        (e.set(Q), R.onUpdate && R.onUpdate(Q));
      },
      onComplete: () => {
        (S(), R.onComplete && R.onComplete());
      },
      name: a,
      motionValue: e,
      element: v ? void 0 : w,
    };
    (isTransitionDefined(R) || (F = { ...F, ...getDefaultTransition(a, F) }),
      F.duration && (F.duration = secondsToMilliseconds(F.duration)),
      F.repeatDelay && (F.repeatDelay = secondsToMilliseconds(F.repeatDelay)),
      F.from !== void 0 && (F.keyframes[0] = F.from));
    let q = !1;
    if (
      ((F.type === !1 || (F.duration === 0 && !F.repeatDelay)) &&
        ((F.duration = 0), F.delay === 0 && (q = !0)),
      q && !v && e.get() !== void 0)
    ) {
      const Q = getFinalKeyframe(F.keyframes, R);
      if (Q !== void 0)
        return (
          frame.update(() => {
            (F.onUpdate(Q), F.onComplete());
          }),
          new GroupPlaybackControls([])
        );
    }
    return !v && AcceleratedAnimation.supports(F)
      ? new AcceleratedAnimation(F)
      : new MainThreadAnimation(F);
  };
function shouldBlockAnimation({ protectedKeys: a, needsAnimating: e }, f) {
  const _ = a.hasOwnProperty(f) && e[f] !== !0;
  return ((e[f] = !1), _);
}
function animateTarget(
  a,
  e,
  { delay: f = 0, transitionOverride: _, type: w } = {},
) {
  var v;
  let { transition: S = a.getDefaultTransition(), transitionEnd: R, ...O } = e;
  _ && (S = _);
  const j = [],
    F = w && a.animationState && a.animationState.getState()[w];
  for (const q in O) {
    const Q = a.getValue(
        q,
        (v = a.latestValues[q]) !== null && v !== void 0 ? v : null,
      ),
      te = O[q];
    if (te === void 0 || (F && shouldBlockAnimation(F, q))) continue;
    const se = { delay: f, ...getValueTransition(S || {}, q) };
    let re = !1;
    if (window.MotionHandoffAnimation) {
      const Le = getOptimisedAppearId(a);
      if (Le) {
        const Be = window.MotionHandoffAnimation(Le, q, frame);
        Be !== null && ((se.startTime = Be), (re = !0));
      }
    }
    (addValueToWillChange(a, q),
      Q.start(
        animateMotionValue(
          q,
          Q,
          te,
          a.shouldReduceMotion && positionalKeys.has(q) ? { type: !1 } : se,
          a,
          re,
        ),
      ));
    const Oe = Q.animation;
    Oe && j.push(Oe);
  }
  return (
    R &&
      Promise.all(j).then(() => {
        frame.update(() => {
          R && setTarget(a, R);
        });
      }),
    j
  );
}
function animateVariant(a, e, f = {}) {
  var _;
  const w = resolveVariant(
    a,
    e,
    f.type === "exit"
      ? (_ = a.presenceContext) === null || _ === void 0
        ? void 0
        : _.custom
      : void 0,
  );
  let { transition: v = a.getDefaultTransition() || {} } = w || {};
  f.transitionOverride && (v = f.transitionOverride);
  const S = w
      ? () => Promise.all(animateTarget(a, w, f))
      : () => Promise.resolve(),
    R =
      a.variantChildren && a.variantChildren.size
        ? (j = 0) => {
            const {
              delayChildren: F = 0,
              staggerChildren: q,
              staggerDirection: Q,
            } = v;
            return animateChildren(a, e, F + j, q, Q, f);
          }
        : () => Promise.resolve(),
    { when: O } = v;
  if (O) {
    const [j, F] = O === "beforeChildren" ? [S, R] : [R, S];
    return j().then(() => F());
  } else return Promise.all([S(), R(f.delay)]);
}
function animateChildren(a, e, f = 0, _ = 0, w = 1, v) {
  const S = [],
    R = (a.variantChildren.size - 1) * _,
    O = w === 1 ? (j = 0) => j * _ : (j = 0) => R - j * _;
  return (
    Array.from(a.variantChildren)
      .sort(sortByTreeOrder)
      .forEach((j, F) => {
        (j.notify("AnimationStart", e),
          S.push(
            animateVariant(j, e, { ...v, delay: f + O(F) }).then(() =>
              j.notify("AnimationComplete", e),
            ),
          ));
      }),
    Promise.all(S)
  );
}
function sortByTreeOrder(a, e) {
  return a.sortNodePosition(e);
}
function animateVisualElement(a, e, f = {}) {
  a.notify("AnimationStart", e);
  let _;
  if (Array.isArray(e)) {
    const w = e.map((v) => animateVariant(a, v, f));
    _ = Promise.all(w);
  } else if (typeof e == "string") _ = animateVariant(a, e, f);
  else {
    const w = typeof e == "function" ? resolveVariant(a, e, f.custom) : e;
    _ = Promise.all(animateTarget(a, w, f));
  }
  return _.then(() => {
    a.notify("AnimationComplete", e);
  });
}
const numVariantProps = variantProps.length;
function getVariantContext(a) {
  if (!a) return;
  if (!a.isControllingVariants) {
    const f = a.parent ? getVariantContext(a.parent) || {} : {};
    return (a.props.initial !== void 0 && (f.initial = a.props.initial), f);
  }
  const e = {};
  for (let f = 0; f < numVariantProps; f++) {
    const _ = variantProps[f],
      w = a.props[_];
    (isVariantLabel(w) || w === !1) && (e[_] = w);
  }
  return e;
}
const reversePriorityOrder = [...variantPriorityOrder].reverse(),
  numAnimationTypes = variantPriorityOrder.length;
function animateList(a) {
  return (e) =>
    Promise.all(
      e.map(({ animation: f, options: _ }) => animateVisualElement(a, f, _)),
    );
}
function createAnimationState(a) {
  let e = animateList(a),
    f = createState(),
    _ = !0;
  const w = (O) => (j, F) => {
    var q;
    const Q = resolveVariant(
      a,
      F,
      O === "exit"
        ? (q = a.presenceContext) === null || q === void 0
          ? void 0
          : q.custom
        : void 0,
    );
    if (Q) {
      const { transition: te, transitionEnd: se, ...re } = Q;
      j = { ...j, ...re, ...se };
    }
    return j;
  };
  function v(O) {
    e = O(a);
  }
  function S(O) {
    const { props: j } = a,
      F = getVariantContext(a.parent) || {},
      q = [],
      Q = new Set();
    let te = {},
      se = 1 / 0;
    for (let Oe = 0; Oe < numAnimationTypes; Oe++) {
      const Le = reversePriorityOrder[Oe],
        Be = f[Le],
        Ve = j[Le] !== void 0 ? j[Le] : F[Le],
        ze = isVariantLabel(Ve),
        Ge = Le === O ? Be.isActive : null;
      Ge === !1 && (se = Oe);
      let Ke = Ve === F[Le] && Ve !== j[Le] && ze;
      if (
        (Ke && _ && a.manuallyAnimateOnMount && (Ke = !1),
        (Be.protectedKeys = { ...te }),
        (!Be.isActive && Ge === null) ||
          (!Ve && !Be.prevProp) ||
          isAnimationControls(Ve) ||
          typeof Ve == "boolean")
      )
        continue;
      const qe = checkVariantsDidChange(Be.prevProp, Ve);
      let nt = qe || (Le === O && Be.isActive && !Ke && ze) || (Oe > se && ze),
        pt = !1;
      const gt = Array.isArray(Ve) ? Ve : [Ve];
      let mt = gt.reduce(w(Le), {});
      Ge === !1 && (mt = {});
      const { prevResolvedValues: dt = {} } = Be,
        _t = { ...dt, ...mt },
        bt = (Ye) => {
          ((nt = !0),
            Q.has(Ye) && ((pt = !0), Q.delete(Ye)),
            (Be.needsAnimating[Ye] = !0));
          const Qe = a.getValue(Ye);
          Qe && (Qe.liveStyle = !1);
        };
      for (const Ye in _t) {
        const Qe = mt[Ye],
          tt = dt[Ye];
        if (te.hasOwnProperty(Ye)) continue;
        let ht = !1;
        (isKeyframesTarget(Qe) && isKeyframesTarget(tt)
          ? (ht = !shallowCompare(Qe, tt))
          : (ht = Qe !== tt),
          ht
            ? Qe != null
              ? bt(Ye)
              : Q.add(Ye)
            : Qe !== void 0 && Q.has(Ye)
              ? bt(Ye)
              : (Be.protectedKeys[Ye] = !0));
      }
      ((Be.prevProp = Ve),
        (Be.prevResolvedValues = mt),
        Be.isActive && (te = { ...te, ...mt }),
        _ && a.blockInitialAnimation && (nt = !1),
        nt &&
          (!(Ke && qe) || pt) &&
          q.push(
            ...gt.map((Ye) => ({ animation: Ye, options: { type: Le } })),
          ));
    }
    if (Q.size) {
      const Oe = {};
      (Q.forEach((Le) => {
        const Be = a.getBaseTarget(Le),
          Ve = a.getValue(Le);
        (Ve && (Ve.liveStyle = !0), (Oe[Le] = Be ?? null));
      }),
        q.push({ animation: Oe }));
    }
    let re = !!q.length;
    return (
      _ &&
        (j.initial === !1 || j.initial === j.animate) &&
        !a.manuallyAnimateOnMount &&
        (re = !1),
      (_ = !1),
      re ? e(q) : Promise.resolve()
    );
  }
  function R(O, j) {
    var F;
    if (f[O].isActive === j) return Promise.resolve();
    ((F = a.variantChildren) === null ||
      F === void 0 ||
      F.forEach((Q) => {
        var te;
        return (te = Q.animationState) === null || te === void 0
          ? void 0
          : te.setActive(O, j);
      }),
      (f[O].isActive = j));
    const q = S(O);
    for (const Q in f) f[Q].protectedKeys = {};
    return q;
  }
  return {
    animateChanges: S,
    setActive: R,
    setAnimateFunction: v,
    getState: () => f,
    reset: () => {
      ((f = createState()), (_ = !0));
    },
  };
}
function checkVariantsDidChange(a, e) {
  return typeof e == "string"
    ? e !== a
    : Array.isArray(e)
      ? !shallowCompare(e, a)
      : !1;
}
function createTypeState(a = !1) {
  return {
    isActive: a,
    protectedKeys: {},
    needsAnimating: {},
    prevResolvedValues: {},
  };
}
function createState() {
  return {
    animate: createTypeState(!0),
    whileInView: createTypeState(),
    whileHover: createTypeState(),
    whileTap: createTypeState(),
    whileDrag: createTypeState(),
    whileFocus: createTypeState(),
    exit: createTypeState(),
  };
}
class Feature {
  constructor(e) {
    ((this.isMounted = !1), (this.node = e));
  }
  update() {}
}
class AnimationFeature extends Feature {
  constructor(e) {
    (super(e),
      e.animationState || (e.animationState = createAnimationState(e)));
  }
  updateAnimationControlsSubscription() {
    const { animate: e } = this.node.getProps();
    isAnimationControls(e) && (this.unmountControls = e.subscribe(this.node));
  }
  mount() {
    this.updateAnimationControlsSubscription();
  }
  update() {
    const { animate: e } = this.node.getProps(),
      { animate: f } = this.node.prevProps || {};
    e !== f && this.updateAnimationControlsSubscription();
  }
  unmount() {
    var e;
    (this.node.animationState.reset(),
      (e = this.unmountControls) === null || e === void 0 || e.call(this));
  }
}
let id$1 = 0;
class ExitAnimationFeature extends Feature {
  constructor() {
    (super(...arguments), (this.id = id$1++));
  }
  update() {
    if (!this.node.presenceContext) return;
    const { isPresent: e, onExitComplete: f } = this.node.presenceContext,
      { isPresent: _ } = this.node.prevPresenceContext || {};
    if (!this.node.animationState || e === _) return;
    const w = this.node.animationState.setActive("exit", !e);
    f && !e && w.then(() => f(this.id));
  }
  mount() {
    const { register: e } = this.node.presenceContext || {};
    e && (this.unmount = e(this.id));
  }
  unmount() {}
}
const animations = {
  animation: { Feature: AnimationFeature },
  exit: { Feature: ExitAnimationFeature },
};
function addDomEvent(a, e, f, _ = { passive: !0 }) {
  return (a.addEventListener(e, f, _), () => a.removeEventListener(e, f));
}
function extractEventInfo(a) {
  return { point: { x: a.pageX, y: a.pageY } };
}
const addPointerInfo = (a) => (e) =>
  isPrimaryPointer(e) && a(e, extractEventInfo(e));
function addPointerEvent(a, e, f, _) {
  return addDomEvent(a, e, addPointerInfo(f), _);
}
const distance = (a, e) => Math.abs(a - e);
function distance2D(a, e) {
  const f = distance(a.x, e.x),
    _ = distance(a.y, e.y);
  return Math.sqrt(f ** 2 + _ ** 2);
}
class PanSession {
  constructor(
    e,
    f,
    { transformPagePoint: _, contextWindow: w, dragSnapToOrigin: v = !1 } = {},
  ) {
    if (
      ((this.startEvent = null),
      (this.lastMoveEvent = null),
      (this.lastMoveEventInfo = null),
      (this.handlers = {}),
      (this.contextWindow = window),
      (this.updatePoint = () => {
        if (!(this.lastMoveEvent && this.lastMoveEventInfo)) return;
        const q = getPanInfo(this.lastMoveEventInfo, this.history),
          Q = this.startEvent !== null,
          te = distance2D(q.offset, { x: 0, y: 0 }) >= 3;
        if (!Q && !te) return;
        const { point: se } = q,
          { timestamp: re } = frameData;
        this.history.push({ ...se, timestamp: re });
        const { onStart: Oe, onMove: Le } = this.handlers;
        (Q ||
          (Oe && Oe(this.lastMoveEvent, q),
          (this.startEvent = this.lastMoveEvent)),
          Le && Le(this.lastMoveEvent, q));
      }),
      (this.handlePointerMove = (q, Q) => {
        ((this.lastMoveEvent = q),
          (this.lastMoveEventInfo = transformPoint(Q, this.transformPagePoint)),
          frame.update(this.updatePoint, !0));
      }),
      (this.handlePointerUp = (q, Q) => {
        this.end();
        const {
          onEnd: te,
          onSessionEnd: se,
          resumeAnimation: re,
        } = this.handlers;
        if (
          (this.dragSnapToOrigin && re && re(),
          !(this.lastMoveEvent && this.lastMoveEventInfo))
        )
          return;
        const Oe = getPanInfo(
          q.type === "pointercancel"
            ? this.lastMoveEventInfo
            : transformPoint(Q, this.transformPagePoint),
          this.history,
        );
        (this.startEvent && te && te(q, Oe), se && se(q, Oe));
      }),
      !isPrimaryPointer(e))
    )
      return;
    ((this.dragSnapToOrigin = v),
      (this.handlers = f),
      (this.transformPagePoint = _),
      (this.contextWindow = w || window));
    const S = extractEventInfo(e),
      R = transformPoint(S, this.transformPagePoint),
      { point: O } = R,
      { timestamp: j } = frameData;
    this.history = [{ ...O, timestamp: j }];
    const { onSessionStart: F } = f;
    (F && F(e, getPanInfo(R, this.history)),
      (this.removeListeners = pipe(
        addPointerEvent(
          this.contextWindow,
          "pointermove",
          this.handlePointerMove,
        ),
        addPointerEvent(this.contextWindow, "pointerup", this.handlePointerUp),
        addPointerEvent(
          this.contextWindow,
          "pointercancel",
          this.handlePointerUp,
        ),
      )));
  }
  updateHandlers(e) {
    this.handlers = e;
  }
  end() {
    (this.removeListeners && this.removeListeners(),
      cancelFrame(this.updatePoint));
  }
}
function transformPoint(a, e) {
  return e ? { point: e(a.point) } : a;
}
function subtractPoint(a, e) {
  return { x: a.x - e.x, y: a.y - e.y };
}
function getPanInfo({ point: a }, e) {
  return {
    point: a,
    delta: subtractPoint(a, lastDevicePoint(e)),
    offset: subtractPoint(a, startDevicePoint(e)),
    velocity: getVelocity(e, 0.1),
  };
}
function startDevicePoint(a) {
  return a[0];
}
function lastDevicePoint(a) {
  return a[a.length - 1];
}
function getVelocity(a, e) {
  if (a.length < 2) return { x: 0, y: 0 };
  let f = a.length - 1,
    _ = null;
  const w = lastDevicePoint(a);
  for (
    ;
    f >= 0 &&
    ((_ = a[f]), !(w.timestamp - _.timestamp > secondsToMilliseconds(e)));

  )
    f--;
  if (!_) return { x: 0, y: 0 };
  const v = millisecondsToSeconds(w.timestamp - _.timestamp);
  if (v === 0) return { x: 0, y: 0 };
  const S = { x: (w.x - _.x) / v, y: (w.y - _.y) / v };
  return (S.x === 1 / 0 && (S.x = 0), S.y === 1 / 0 && (S.y = 0), S);
}
const SCALE_PRECISION = 1e-4,
  SCALE_MIN = 1 - SCALE_PRECISION,
  SCALE_MAX = 1 + SCALE_PRECISION,
  TRANSLATE_PRECISION = 0.01,
  TRANSLATE_MIN = 0 - TRANSLATE_PRECISION,
  TRANSLATE_MAX = 0 + TRANSLATE_PRECISION;
function calcLength(a) {
  return a.max - a.min;
}
function isNear(a, e, f) {
  return Math.abs(a - e) <= f;
}
function calcAxisDelta(a, e, f, _ = 0.5) {
  ((a.origin = _),
    (a.originPoint = mixNumber$1(e.min, e.max, a.origin)),
    (a.scale = calcLength(f) / calcLength(e)),
    (a.translate = mixNumber$1(f.min, f.max, a.origin) - a.originPoint),
    ((a.scale >= SCALE_MIN && a.scale <= SCALE_MAX) || isNaN(a.scale)) &&
      (a.scale = 1),
    ((a.translate >= TRANSLATE_MIN && a.translate <= TRANSLATE_MAX) ||
      isNaN(a.translate)) &&
      (a.translate = 0));
}
function calcBoxDelta(a, e, f, _) {
  (calcAxisDelta(a.x, e.x, f.x, _ ? _.originX : void 0),
    calcAxisDelta(a.y, e.y, f.y, _ ? _.originY : void 0));
}
function calcRelativeAxis(a, e, f) {
  ((a.min = f.min + e.min), (a.max = a.min + calcLength(e)));
}
function calcRelativeBox(a, e, f) {
  (calcRelativeAxis(a.x, e.x, f.x), calcRelativeAxis(a.y, e.y, f.y));
}
function calcRelativeAxisPosition(a, e, f) {
  ((a.min = e.min - f.min), (a.max = a.min + calcLength(e)));
}
function calcRelativePosition(a, e, f) {
  (calcRelativeAxisPosition(a.x, e.x, f.x),
    calcRelativeAxisPosition(a.y, e.y, f.y));
}
function applyConstraints(a, { min: e, max: f }, _) {
  return (
    e !== void 0 && a < e
      ? (a = _ ? mixNumber$1(e, a, _.min) : Math.max(a, e))
      : f !== void 0 &&
        a > f &&
        (a = _ ? mixNumber$1(f, a, _.max) : Math.min(a, f)),
    a
  );
}
function calcRelativeAxisConstraints(a, e, f) {
  return {
    min: e !== void 0 ? a.min + e : void 0,
    max: f !== void 0 ? a.max + f - (a.max - a.min) : void 0,
  };
}
function calcRelativeConstraints(a, { top: e, left: f, bottom: _, right: w }) {
  return {
    x: calcRelativeAxisConstraints(a.x, f, w),
    y: calcRelativeAxisConstraints(a.y, e, _),
  };
}
function calcViewportAxisConstraints(a, e) {
  let f = e.min - a.min,
    _ = e.max - a.max;
  return (
    e.max - e.min < a.max - a.min && ([f, _] = [_, f]),
    { min: f, max: _ }
  );
}
function calcViewportConstraints(a, e) {
  return {
    x: calcViewportAxisConstraints(a.x, e.x),
    y: calcViewportAxisConstraints(a.y, e.y),
  };
}
function calcOrigin(a, e) {
  let f = 0.5;
  const _ = calcLength(a),
    w = calcLength(e);
  return (
    w > _
      ? (f = progress(e.min, e.max - _, a.min))
      : _ > w && (f = progress(a.min, a.max - w, e.min)),
    clamp$1(0, 1, f)
  );
}
function rebaseAxisConstraints(a, e) {
  const f = {};
  return (
    e.min !== void 0 && (f.min = e.min - a.min),
    e.max !== void 0 && (f.max = e.max - a.min),
    f
  );
}
const defaultElastic = 0.35;
function resolveDragElastic(a = defaultElastic) {
  return (
    a === !1 ? (a = 0) : a === !0 && (a = defaultElastic),
    {
      x: resolveAxisElastic(a, "left", "right"),
      y: resolveAxisElastic(a, "top", "bottom"),
    }
  );
}
function resolveAxisElastic(a, e, f) {
  return { min: resolvePointElastic(a, e), max: resolvePointElastic(a, f) };
}
function resolvePointElastic(a, e) {
  return typeof a == "number" ? a : a[e] || 0;
}
const createAxisDelta = () => ({
    translate: 0,
    scale: 1,
    origin: 0,
    originPoint: 0,
  }),
  createDelta = () => ({ x: createAxisDelta(), y: createAxisDelta() }),
  createAxis = () => ({ min: 0, max: 0 }),
  createBox = () => ({ x: createAxis(), y: createAxis() });
function eachAxis(a) {
  return [a("x"), a("y")];
}
function convertBoundingBoxToBox({ top: a, left: e, right: f, bottom: _ }) {
  return { x: { min: e, max: f }, y: { min: a, max: _ } };
}
function convertBoxToBoundingBox({ x: a, y: e }) {
  return { top: e.min, right: a.max, bottom: e.max, left: a.min };
}
function transformBoxPoints(a, e) {
  if (!e) return a;
  const f = e({ x: a.left, y: a.top }),
    _ = e({ x: a.right, y: a.bottom });
  return { top: f.y, left: f.x, bottom: _.y, right: _.x };
}
function isIdentityScale(a) {
  return a === void 0 || a === 1;
}
function hasScale({ scale: a, scaleX: e, scaleY: f }) {
  return !isIdentityScale(a) || !isIdentityScale(e) || !isIdentityScale(f);
}
function hasTransform(a) {
  return (
    hasScale(a) ||
    has2DTranslate(a) ||
    a.z ||
    a.rotate ||
    a.rotateX ||
    a.rotateY ||
    a.skewX ||
    a.skewY
  );
}
function has2DTranslate(a) {
  return is2DTranslate(a.x) || is2DTranslate(a.y);
}
function is2DTranslate(a) {
  return a && a !== "0%";
}
function scalePoint(a, e, f) {
  const _ = a - f,
    w = e * _;
  return f + w;
}
function applyPointDelta(a, e, f, _, w) {
  return (w !== void 0 && (a = scalePoint(a, w, _)), scalePoint(a, f, _) + e);
}
function applyAxisDelta(a, e = 0, f = 1, _, w) {
  ((a.min = applyPointDelta(a.min, e, f, _, w)),
    (a.max = applyPointDelta(a.max, e, f, _, w)));
}
function applyBoxDelta(a, { x: e, y: f }) {
  (applyAxisDelta(a.x, e.translate, e.scale, e.originPoint),
    applyAxisDelta(a.y, f.translate, f.scale, f.originPoint));
}
const TREE_SCALE_SNAP_MIN = 0.999999999999,
  TREE_SCALE_SNAP_MAX = 1.0000000000001;
function applyTreeDeltas(a, e, f, _ = !1) {
  const w = f.length;
  if (!w) return;
  e.x = e.y = 1;
  let v, S;
  for (let R = 0; R < w; R++) {
    ((v = f[R]), (S = v.projectionDelta));
    const { visualElement: O } = v.options;
    (O && O.props.style && O.props.style.display === "contents") ||
      (_ &&
        v.options.layoutScroll &&
        v.scroll &&
        v !== v.root &&
        transformBox(a, { x: -v.scroll.offset.x, y: -v.scroll.offset.y }),
      S && ((e.x *= S.x.scale), (e.y *= S.y.scale), applyBoxDelta(a, S)),
      _ && hasTransform(v.latestValues) && transformBox(a, v.latestValues));
  }
  (e.x < TREE_SCALE_SNAP_MAX && e.x > TREE_SCALE_SNAP_MIN && (e.x = 1),
    e.y < TREE_SCALE_SNAP_MAX && e.y > TREE_SCALE_SNAP_MIN && (e.y = 1));
}
function translateAxis(a, e) {
  ((a.min = a.min + e), (a.max = a.max + e));
}
function transformAxis(a, e, f, _, w = 0.5) {
  const v = mixNumber$1(a.min, a.max, w);
  applyAxisDelta(a, e, f, v, _);
}
function transformBox(a, e) {
  (transformAxis(a.x, e.x, e.scaleX, e.scale, e.originX),
    transformAxis(a.y, e.y, e.scaleY, e.scale, e.originY));
}
function measureViewportBox(a, e) {
  return convertBoundingBoxToBox(
    transformBoxPoints(a.getBoundingClientRect(), e),
  );
}
function measurePageBox(a, e, f) {
  const _ = measureViewportBox(a, f),
    { scroll: w } = e;
  return (
    w && (translateAxis(_.x, w.offset.x), translateAxis(_.y, w.offset.y)),
    _
  );
}
const getContextWindow = ({ current: a }) =>
    a ? a.ownerDocument.defaultView : null,
  elementDragControls = new WeakMap();
class VisualElementDragControls {
  constructor(e) {
    ((this.openDragLock = null),
      (this.isDragging = !1),
      (this.currentDirection = null),
      (this.originPoint = { x: 0, y: 0 }),
      (this.constraints = !1),
      (this.hasMutatedConstraints = !1),
      (this.elastic = createBox()),
      (this.visualElement = e));
  }
  start(e, { snapToCursor: f = !1 } = {}) {
    const { presenceContext: _ } = this.visualElement;
    if (_ && _.isPresent === !1) return;
    const w = (F) => {
        const { dragSnapToOrigin: q } = this.getProps();
        (q ? this.pauseAnimation() : this.stopAnimation(),
          f && this.snapToCursor(extractEventInfo(F).point));
      },
      v = (F, q) => {
        const {
          drag: Q,
          dragPropagation: te,
          onDragStart: se,
        } = this.getProps();
        if (
          Q &&
          !te &&
          (this.openDragLock && this.openDragLock(),
          (this.openDragLock = setDragLock(Q)),
          !this.openDragLock)
        )
          return;
        ((this.isDragging = !0),
          (this.currentDirection = null),
          this.resolveConstraints(),
          this.visualElement.projection &&
            ((this.visualElement.projection.isAnimationBlocked = !0),
            (this.visualElement.projection.target = void 0)),
          eachAxis((Oe) => {
            let Le = this.getAxisMotionValue(Oe).get() || 0;
            if (percent.test(Le)) {
              const { projection: Be } = this.visualElement;
              if (Be && Be.layout) {
                const Ve = Be.layout.layoutBox[Oe];
                Ve && (Le = calcLength(Ve) * (parseFloat(Le) / 100));
              }
            }
            this.originPoint[Oe] = Le;
          }),
          se && frame.postRender(() => se(F, q)),
          addValueToWillChange(this.visualElement, "transform"));
        const { animationState: re } = this.visualElement;
        re && re.setActive("whileDrag", !0);
      },
      S = (F, q) => {
        const {
          dragPropagation: Q,
          dragDirectionLock: te,
          onDirectionLock: se,
          onDrag: re,
        } = this.getProps();
        if (!Q && !this.openDragLock) return;
        const { offset: Oe } = q;
        if (te && this.currentDirection === null) {
          ((this.currentDirection = getCurrentDirection(Oe)),
            this.currentDirection !== null && se && se(this.currentDirection));
          return;
        }
        (this.updateAxis("x", q.point, Oe),
          this.updateAxis("y", q.point, Oe),
          this.visualElement.render(),
          re && re(F, q));
      },
      R = (F, q) => this.stop(F, q),
      O = () =>
        eachAxis((F) => {
          var q;
          return (
            this.getAnimationState(F) === "paused" &&
            ((q = this.getAxisMotionValue(F).animation) === null || q === void 0
              ? void 0
              : q.play())
          );
        }),
      { dragSnapToOrigin: j } = this.getProps();
    this.panSession = new PanSession(
      e,
      {
        onSessionStart: w,
        onStart: v,
        onMove: S,
        onSessionEnd: R,
        resumeAnimation: O,
      },
      {
        transformPagePoint: this.visualElement.getTransformPagePoint(),
        dragSnapToOrigin: j,
        contextWindow: getContextWindow(this.visualElement),
      },
    );
  }
  stop(e, f) {
    const _ = this.isDragging;
    if ((this.cancel(), !_)) return;
    const { velocity: w } = f;
    this.startAnimation(w);
    const { onDragEnd: v } = this.getProps();
    v && frame.postRender(() => v(e, f));
  }
  cancel() {
    this.isDragging = !1;
    const { projection: e, animationState: f } = this.visualElement;
    (e && (e.isAnimationBlocked = !1),
      this.panSession && this.panSession.end(),
      (this.panSession = void 0));
    const { dragPropagation: _ } = this.getProps();
    (!_ &&
      this.openDragLock &&
      (this.openDragLock(), (this.openDragLock = null)),
      f && f.setActive("whileDrag", !1));
  }
  updateAxis(e, f, _) {
    const { drag: w } = this.getProps();
    if (!_ || !shouldDrag(e, w, this.currentDirection)) return;
    const v = this.getAxisMotionValue(e);
    let S = this.originPoint[e] + _[e];
    (this.constraints &&
      this.constraints[e] &&
      (S = applyConstraints(S, this.constraints[e], this.elastic[e])),
      v.set(S));
  }
  resolveConstraints() {
    var e;
    const { dragConstraints: f, dragElastic: _ } = this.getProps(),
      w =
        this.visualElement.projection && !this.visualElement.projection.layout
          ? this.visualElement.projection.measure(!1)
          : (e = this.visualElement.projection) === null || e === void 0
            ? void 0
            : e.layout,
      v = this.constraints;
    (f && isRefObject(f)
      ? this.constraints || (this.constraints = this.resolveRefConstraints())
      : f && w
        ? (this.constraints = calcRelativeConstraints(w.layoutBox, f))
        : (this.constraints = !1),
      (this.elastic = resolveDragElastic(_)),
      v !== this.constraints &&
        w &&
        this.constraints &&
        !this.hasMutatedConstraints &&
        eachAxis((S) => {
          this.constraints !== !1 &&
            this.getAxisMotionValue(S) &&
            (this.constraints[S] = rebaseAxisConstraints(
              w.layoutBox[S],
              this.constraints[S],
            ));
        }));
  }
  resolveRefConstraints() {
    const { dragConstraints: e, onMeasureDragConstraints: f } = this.getProps();
    if (!e || !isRefObject(e)) return !1;
    const _ = e.current,
      { projection: w } = this.visualElement;
    if (!w || !w.layout) return !1;
    const v = measurePageBox(
      _,
      w.root,
      this.visualElement.getTransformPagePoint(),
    );
    let S = calcViewportConstraints(w.layout.layoutBox, v);
    if (f) {
      const R = f(convertBoxToBoundingBox(S));
      ((this.hasMutatedConstraints = !!R),
        R && (S = convertBoundingBoxToBox(R)));
    }
    return S;
  }
  startAnimation(e) {
    const {
        drag: f,
        dragMomentum: _,
        dragElastic: w,
        dragTransition: v,
        dragSnapToOrigin: S,
        onDragTransitionEnd: R,
      } = this.getProps(),
      O = this.constraints || {},
      j = eachAxis((F) => {
        if (!shouldDrag(F, f, this.currentDirection)) return;
        let q = (O && O[F]) || {};
        S && (q = { min: 0, max: 0 });
        const Q = w ? 200 : 1e6,
          te = w ? 40 : 1e7,
          se = {
            type: "inertia",
            velocity: _ ? e[F] : 0,
            bounceStiffness: Q,
            bounceDamping: te,
            timeConstant: 750,
            restDelta: 1,
            restSpeed: 10,
            ...v,
            ...q,
          };
        return this.startAxisValueAnimation(F, se);
      });
    return Promise.all(j).then(R);
  }
  startAxisValueAnimation(e, f) {
    const _ = this.getAxisMotionValue(e);
    return (
      addValueToWillChange(this.visualElement, e),
      _.start(animateMotionValue(e, _, 0, f, this.visualElement, !1))
    );
  }
  stopAnimation() {
    eachAxis((e) => this.getAxisMotionValue(e).stop());
  }
  pauseAnimation() {
    eachAxis((e) => {
      var f;
      return (f = this.getAxisMotionValue(e).animation) === null || f === void 0
        ? void 0
        : f.pause();
    });
  }
  getAnimationState(e) {
    var f;
    return (f = this.getAxisMotionValue(e).animation) === null || f === void 0
      ? void 0
      : f.state;
  }
  getAxisMotionValue(e) {
    const f = `_drag${e.toUpperCase()}`,
      _ = this.visualElement.getProps(),
      w = _[f];
    return (
      w ||
      this.visualElement.getValue(e, (_.initial ? _.initial[e] : void 0) || 0)
    );
  }
  snapToCursor(e) {
    eachAxis((f) => {
      const { drag: _ } = this.getProps();
      if (!shouldDrag(f, _, this.currentDirection)) return;
      const { projection: w } = this.visualElement,
        v = this.getAxisMotionValue(f);
      if (w && w.layout) {
        const { min: S, max: R } = w.layout.layoutBox[f];
        v.set(e[f] - mixNumber$1(S, R, 0.5));
      }
    });
  }
  scalePositionWithinConstraints() {
    if (!this.visualElement.current) return;
    const { drag: e, dragConstraints: f } = this.getProps(),
      { projection: _ } = this.visualElement;
    if (!isRefObject(f) || !_ || !this.constraints) return;
    this.stopAnimation();
    const w = { x: 0, y: 0 };
    eachAxis((S) => {
      const R = this.getAxisMotionValue(S);
      if (R && this.constraints !== !1) {
        const O = R.get();
        w[S] = calcOrigin({ min: O, max: O }, this.constraints[S]);
      }
    });
    const { transformTemplate: v } = this.visualElement.getProps();
    ((this.visualElement.current.style.transform = v ? v({}, "") : "none"),
      _.root && _.root.updateScroll(),
      _.updateLayout(),
      this.resolveConstraints(),
      eachAxis((S) => {
        if (!shouldDrag(S, e, null)) return;
        const R = this.getAxisMotionValue(S),
          { min: O, max: j } = this.constraints[S];
        R.set(mixNumber$1(O, j, w[S]));
      }));
  }
  addListeners() {
    if (!this.visualElement.current) return;
    elementDragControls.set(this.visualElement, this);
    const e = this.visualElement.current,
      f = addPointerEvent(e, "pointerdown", (O) => {
        const { drag: j, dragListener: F = !0 } = this.getProps();
        j && F && this.start(O);
      }),
      _ = () => {
        const { dragConstraints: O } = this.getProps();
        isRefObject(O) &&
          O.current &&
          (this.constraints = this.resolveRefConstraints());
      },
      { projection: w } = this.visualElement,
      v = w.addEventListener("measure", _);
    (w && !w.layout && (w.root && w.root.updateScroll(), w.updateLayout()),
      frame.read(_));
    const S = addDomEvent(window, "resize", () =>
        this.scalePositionWithinConstraints(),
      ),
      R = w.addEventListener(
        "didUpdate",
        ({ delta: O, hasLayoutChanged: j }) => {
          this.isDragging &&
            j &&
            (eachAxis((F) => {
              const q = this.getAxisMotionValue(F);
              q &&
                ((this.originPoint[F] += O[F].translate),
                q.set(q.get() + O[F].translate));
            }),
            this.visualElement.render());
        },
      );
    return () => {
      (S(), f(), v(), R && R());
    };
  }
  getProps() {
    const e = this.visualElement.getProps(),
      {
        drag: f = !1,
        dragDirectionLock: _ = !1,
        dragPropagation: w = !1,
        dragConstraints: v = !1,
        dragElastic: S = defaultElastic,
        dragMomentum: R = !0,
      } = e;
    return {
      ...e,
      drag: f,
      dragDirectionLock: _,
      dragPropagation: w,
      dragConstraints: v,
      dragElastic: S,
      dragMomentum: R,
    };
  }
}
function shouldDrag(a, e, f) {
  return (e === !0 || e === a) && (f === null || f === a);
}
function getCurrentDirection(a, e = 10) {
  let f = null;
  return (Math.abs(a.y) > e ? (f = "y") : Math.abs(a.x) > e && (f = "x"), f);
}
class DragGesture extends Feature {
  constructor(e) {
    (super(e),
      (this.removeGroupControls = noop),
      (this.removeListeners = noop),
      (this.controls = new VisualElementDragControls(e)));
  }
  mount() {
    const { dragControls: e } = this.node.getProps();
    (e && (this.removeGroupControls = e.subscribe(this.controls)),
      (this.removeListeners = this.controls.addListeners() || noop));
  }
  unmount() {
    (this.removeGroupControls(), this.removeListeners());
  }
}
const asyncHandler = (a) => (e, f) => {
  a && frame.postRender(() => a(e, f));
};
class PanGesture extends Feature {
  constructor() {
    (super(...arguments), (this.removePointerDownListener = noop));
  }
  onPointerDown(e) {
    this.session = new PanSession(e, this.createPanHandlers(), {
      transformPagePoint: this.node.getTransformPagePoint(),
      contextWindow: getContextWindow(this.node),
    });
  }
  createPanHandlers() {
    const {
      onPanSessionStart: e,
      onPanStart: f,
      onPan: _,
      onPanEnd: w,
    } = this.node.getProps();
    return {
      onSessionStart: asyncHandler(e),
      onStart: asyncHandler(f),
      onMove: _,
      onEnd: (v, S) => {
        (delete this.session, w && frame.postRender(() => w(v, S)));
      },
    };
  }
  mount() {
    this.removePointerDownListener = addPointerEvent(
      this.node.current,
      "pointerdown",
      (e) => this.onPointerDown(e),
    );
  }
  update() {
    this.session && this.session.updateHandlers(this.createPanHandlers());
  }
  unmount() {
    (this.removePointerDownListener(), this.session && this.session.end());
  }
}
const globalProjectionState = {
  hasAnimatedSinceResize: !0,
  hasEverUpdated: !1,
};
function pixelsToPercent(a, e) {
  return e.max === e.min ? 0 : (a / (e.max - e.min)) * 100;
}
const correctBorderRadius = {
    correct: (a, e) => {
      if (!e.target) return a;
      if (typeof a == "string")
        if (px.test(a)) a = parseFloat(a);
        else return a;
      const f = pixelsToPercent(a, e.target.x),
        _ = pixelsToPercent(a, e.target.y);
      return `${f}% ${_}%`;
    },
  },
  correctBoxShadow = {
    correct: (a, { treeScale: e, projectionDelta: f }) => {
      const _ = a,
        w = complex.parse(a);
      if (w.length > 5) return _;
      const v = complex.createTransformer(a),
        S = typeof w[0] != "number" ? 1 : 0,
        R = f.x.scale * e.x,
        O = f.y.scale * e.y;
      ((w[0 + S] /= R), (w[1 + S] /= O));
      const j = mixNumber$1(R, O, 0.5);
      return (
        typeof w[2 + S] == "number" && (w[2 + S] /= j),
        typeof w[3 + S] == "number" && (w[3 + S] /= j),
        v(w)
      );
    },
  };
class MeasureLayoutWithContext extends reactExports.Component {
  componentDidMount() {
    const {
        visualElement: e,
        layoutGroup: f,
        switchLayoutGroup: _,
        layoutId: w,
      } = this.props,
      { projection: v } = e;
    (addScaleCorrector(defaultScaleCorrectors),
      v &&
        (f.group && f.group.add(v),
        _ && _.register && w && _.register(v),
        v.root.didUpdate(),
        v.addEventListener("animationComplete", () => {
          this.safeToRemove();
        }),
        v.setOptions({
          ...v.options,
          onExitComplete: () => this.safeToRemove(),
        })),
      (globalProjectionState.hasEverUpdated = !0));
  }
  getSnapshotBeforeUpdate(e) {
    const {
        layoutDependency: f,
        visualElement: _,
        drag: w,
        isPresent: v,
      } = this.props,
      S = _.projection;
    return (
      S &&
        ((S.isPresent = v),
        w || e.layoutDependency !== f || f === void 0
          ? S.willUpdate()
          : this.safeToRemove(),
        e.isPresent !== v &&
          (v
            ? S.promote()
            : S.relegate() ||
              frame.postRender(() => {
                const R = S.getStack();
                (!R || !R.members.length) && this.safeToRemove();
              }))),
      null
    );
  }
  componentDidUpdate() {
    const { projection: e } = this.props.visualElement;
    e &&
      (e.root.didUpdate(),
      microtask.postRender(() => {
        !e.currentAnimation && e.isLead() && this.safeToRemove();
      }));
  }
  componentWillUnmount() {
    const {
        visualElement: e,
        layoutGroup: f,
        switchLayoutGroup: _,
      } = this.props,
      { projection: w } = e;
    w &&
      (w.scheduleCheckAfterUnmount(),
      f && f.group && f.group.remove(w),
      _ && _.deregister && _.deregister(w));
  }
  safeToRemove() {
    const { safeToRemove: e } = this.props;
    e && e();
  }
  render() {
    return null;
  }
}
function MeasureLayout(a) {
  const [e, f] = usePresence(),
    _ = reactExports.useContext(LayoutGroupContext);
  return jsxRuntimeExports.jsx(MeasureLayoutWithContext, {
    ...a,
    layoutGroup: _,
    switchLayoutGroup: reactExports.useContext(SwitchLayoutGroupContext),
    isPresent: e,
    safeToRemove: f,
  });
}
const defaultScaleCorrectors = {
  borderRadius: {
    ...correctBorderRadius,
    applyTo: [
      "borderTopLeftRadius",
      "borderTopRightRadius",
      "borderBottomLeftRadius",
      "borderBottomRightRadius",
    ],
  },
  borderTopLeftRadius: correctBorderRadius,
  borderTopRightRadius: correctBorderRadius,
  borderBottomLeftRadius: correctBorderRadius,
  borderBottomRightRadius: correctBorderRadius,
  boxShadow: correctBoxShadow,
};
function animateSingleValue(a, e, f) {
  const _ = isMotionValue(a) ? a : motionValue(a);
  return (_.start(animateMotionValue("", _, e, f)), _.animation);
}
function isSVGElement(a) {
  return a instanceof SVGElement && a.tagName !== "svg";
}
const compareByDepth = (a, e) => a.depth - e.depth;
class FlatTree {
  constructor() {
    ((this.children = []), (this.isDirty = !1));
  }
  add(e) {
    (addUniqueItem(this.children, e), (this.isDirty = !0));
  }
  remove(e) {
    (removeItem(this.children, e), (this.isDirty = !0));
  }
  forEach(e) {
    (this.isDirty && this.children.sort(compareByDepth),
      (this.isDirty = !1),
      this.children.forEach(e));
  }
}
function delay(a, e) {
  const f = time.now(),
    _ = ({ timestamp: w }) => {
      const v = w - f;
      v >= e && (cancelFrame(_), a(v - e));
    };
  return (frame.read(_, !0), () => cancelFrame(_));
}
const borders = ["TopLeft", "TopRight", "BottomLeft", "BottomRight"],
  numBorders = borders.length,
  asNumber = (a) => (typeof a == "string" ? parseFloat(a) : a),
  isPx = (a) => typeof a == "number" || px.test(a);
function mixValues(a, e, f, _, w, v) {
  w
    ? ((a.opacity = mixNumber$1(
        0,
        f.opacity !== void 0 ? f.opacity : 1,
        easeCrossfadeIn(_),
      )),
      (a.opacityExit = mixNumber$1(
        e.opacity !== void 0 ? e.opacity : 1,
        0,
        easeCrossfadeOut(_),
      )))
    : v &&
      (a.opacity = mixNumber$1(
        e.opacity !== void 0 ? e.opacity : 1,
        f.opacity !== void 0 ? f.opacity : 1,
        _,
      ));
  for (let S = 0; S < numBorders; S++) {
    const R = `border${borders[S]}Radius`;
    let O = getRadius(e, R),
      j = getRadius(f, R);
    if (O === void 0 && j === void 0) continue;
    (O || (O = 0),
      j || (j = 0),
      O === 0 || j === 0 || isPx(O) === isPx(j)
        ? ((a[R] = Math.max(mixNumber$1(asNumber(O), asNumber(j), _), 0)),
          (percent.test(j) || percent.test(O)) && (a[R] += "%"))
        : (a[R] = j));
  }
  (e.rotate || f.rotate) &&
    (a.rotate = mixNumber$1(e.rotate || 0, f.rotate || 0, _));
}
function getRadius(a, e) {
  return a[e] !== void 0 ? a[e] : a.borderRadius;
}
const easeCrossfadeIn = compress(0, 0.5, circOut),
  easeCrossfadeOut = compress(0.5, 0.95, noop);
function compress(a, e, f) {
  return (_) => (_ < a ? 0 : _ > e ? 1 : f(progress(a, e, _)));
}
function copyAxisInto(a, e) {
  ((a.min = e.min), (a.max = e.max));
}
function copyBoxInto(a, e) {
  (copyAxisInto(a.x, e.x), copyAxisInto(a.y, e.y));
}
function copyAxisDeltaInto(a, e) {
  ((a.translate = e.translate),
    (a.scale = e.scale),
    (a.originPoint = e.originPoint),
    (a.origin = e.origin));
}
function removePointDelta(a, e, f, _, w) {
  return (
    (a -= e),
    (a = scalePoint(a, 1 / f, _)),
    w !== void 0 && (a = scalePoint(a, 1 / w, _)),
    a
  );
}
function removeAxisDelta(a, e = 0, f = 1, _ = 0.5, w, v = a, S = a) {
  if (
    (percent.test(e) &&
      ((e = parseFloat(e)), (e = mixNumber$1(S.min, S.max, e / 100) - S.min)),
    typeof e != "number")
  )
    return;
  let R = mixNumber$1(v.min, v.max, _);
  (a === v && (R -= e),
    (a.min = removePointDelta(a.min, e, f, R, w)),
    (a.max = removePointDelta(a.max, e, f, R, w)));
}
function removeAxisTransforms(a, e, [f, _, w], v, S) {
  removeAxisDelta(a, e[f], e[_], e[w], e.scale, v, S);
}
const xKeys = ["x", "scaleX", "originX"],
  yKeys = ["y", "scaleY", "originY"];
function removeBoxTransforms(a, e, f, _) {
  (removeAxisTransforms(a.x, e, xKeys, f ? f.x : void 0, _ ? _.x : void 0),
    removeAxisTransforms(a.y, e, yKeys, f ? f.y : void 0, _ ? _.y : void 0));
}
function isAxisDeltaZero(a) {
  return a.translate === 0 && a.scale === 1;
}
function isDeltaZero(a) {
  return isAxisDeltaZero(a.x) && isAxisDeltaZero(a.y);
}
function axisEquals(a, e) {
  return a.min === e.min && a.max === e.max;
}
function boxEquals(a, e) {
  return axisEquals(a.x, e.x) && axisEquals(a.y, e.y);
}
function axisEqualsRounded(a, e) {
  return (
    Math.round(a.min) === Math.round(e.min) &&
    Math.round(a.max) === Math.round(e.max)
  );
}
function boxEqualsRounded(a, e) {
  return axisEqualsRounded(a.x, e.x) && axisEqualsRounded(a.y, e.y);
}
function aspectRatio(a) {
  return calcLength(a.x) / calcLength(a.y);
}
function axisDeltaEquals(a, e) {
  return (
    a.translate === e.translate &&
    a.scale === e.scale &&
    a.originPoint === e.originPoint
  );
}
class NodeStack {
  constructor() {
    this.members = [];
  }
  add(e) {
    (addUniqueItem(this.members, e), e.scheduleRender());
  }
  remove(e) {
    if (
      (removeItem(this.members, e),
      e === this.prevLead && (this.prevLead = void 0),
      e === this.lead)
    ) {
      const f = this.members[this.members.length - 1];
      f && this.promote(f);
    }
  }
  relegate(e) {
    const f = this.members.findIndex((w) => e === w);
    if (f === 0) return !1;
    let _;
    for (let w = f; w >= 0; w--) {
      const v = this.members[w];
      if (v.isPresent !== !1) {
        _ = v;
        break;
      }
    }
    return _ ? (this.promote(_), !0) : !1;
  }
  promote(e, f) {
    const _ = this.lead;
    if (e !== _ && ((this.prevLead = _), (this.lead = e), e.show(), _)) {
      (_.instance && _.scheduleRender(),
        e.scheduleRender(),
        (e.resumeFrom = _),
        f && (e.resumeFrom.preserveOpacity = !0),
        _.snapshot &&
          ((e.snapshot = _.snapshot),
          (e.snapshot.latestValues = _.animationValues || _.latestValues)),
        e.root && e.root.isUpdating && (e.isLayoutDirty = !0));
      const { crossfade: w } = e.options;
      w === !1 && _.hide();
    }
  }
  exitAnimationComplete() {
    this.members.forEach((e) => {
      const { options: f, resumingFrom: _ } = e;
      (f.onExitComplete && f.onExitComplete(),
        _ && _.options.onExitComplete && _.options.onExitComplete());
    });
  }
  scheduleRender() {
    this.members.forEach((e) => {
      e.instance && e.scheduleRender(!1);
    });
  }
  removeLeadSnapshot() {
    this.lead && this.lead.snapshot && (this.lead.snapshot = void 0);
  }
}
function buildProjectionTransform(a, e, f) {
  let _ = "";
  const w = a.x.translate / e.x,
    v = a.y.translate / e.y,
    S = f?.z || 0;
  if (
    ((w || v || S) && (_ = `translate3d(${w}px, ${v}px, ${S}px) `),
    (e.x !== 1 || e.y !== 1) && (_ += `scale(${1 / e.x}, ${1 / e.y}) `),
    f)
  ) {
    const {
      transformPerspective: j,
      rotate: F,
      rotateX: q,
      rotateY: Q,
      skewX: te,
      skewY: se,
    } = f;
    (j && (_ = `perspective(${j}px) ${_}`),
      F && (_ += `rotate(${F}deg) `),
      q && (_ += `rotateX(${q}deg) `),
      Q && (_ += `rotateY(${Q}deg) `),
      te && (_ += `skewX(${te}deg) `),
      se && (_ += `skewY(${se}deg) `));
  }
  const R = a.x.scale * e.x,
    O = a.y.scale * e.y;
  return ((R !== 1 || O !== 1) && (_ += `scale(${R}, ${O})`), _ || "none");
}
const metrics = {
    type: "projectionFrame",
    totalNodes: 0,
    resolvedTargetDeltas: 0,
    recalculatedProjection: 0,
  },
  isDebug = typeof window < "u" && window.MotionDebug !== void 0,
  transformAxes = ["", "X", "Y", "Z"],
  hiddenVisibility = { visibility: "hidden" },
  animationTarget = 1e3;
let id = 0;
function resetDistortingTransform(a, e, f, _) {
  const { latestValues: w } = e;
  w[a] && ((f[a] = w[a]), e.setStaticValue(a, 0), _ && (_[a] = 0));
}
function cancelTreeOptimisedTransformAnimations(a) {
  if (((a.hasCheckedOptimisedAppear = !0), a.root === a)) return;
  const { visualElement: e } = a.options;
  if (!e) return;
  const f = getOptimisedAppearId(e);
  if (window.MotionHasOptimisedAnimation(f, "transform")) {
    const { layout: w, layoutId: v } = a.options;
    window.MotionCancelOptimisedAnimation(f, "transform", frame, !(w || v));
  }
  const { parent: _ } = a;
  _ &&
    !_.hasCheckedOptimisedAppear &&
    cancelTreeOptimisedTransformAnimations(_);
}
function createProjectionNode({
  attachResizeListener: a,
  defaultParent: e,
  measureScroll: f,
  checkIsScrollRoot: _,
  resetTransform: w,
}) {
  return class {
    constructor(S = {}, R = e?.()) {
      ((this.id = id++),
        (this.animationId = 0),
        (this.children = new Set()),
        (this.options = {}),
        (this.isTreeAnimating = !1),
        (this.isAnimationBlocked = !1),
        (this.isLayoutDirty = !1),
        (this.isProjectionDirty = !1),
        (this.isSharedProjectionDirty = !1),
        (this.isTransformDirty = !1),
        (this.updateManuallyBlocked = !1),
        (this.updateBlockedByResize = !1),
        (this.isUpdating = !1),
        (this.isSVG = !1),
        (this.needsReset = !1),
        (this.shouldResetTransform = !1),
        (this.hasCheckedOptimisedAppear = !1),
        (this.treeScale = { x: 1, y: 1 }),
        (this.eventHandlers = new Map()),
        (this.hasTreeAnimated = !1),
        (this.updateScheduled = !1),
        (this.scheduleUpdate = () => this.update()),
        (this.projectionUpdateScheduled = !1),
        (this.checkUpdateFailed = () => {
          this.isUpdating && ((this.isUpdating = !1), this.clearAllSnapshots());
        }),
        (this.updateProjection = () => {
          ((this.projectionUpdateScheduled = !1),
            isDebug &&
              (metrics.totalNodes =
                metrics.resolvedTargetDeltas =
                metrics.recalculatedProjection =
                  0),
            this.nodes.forEach(propagateDirtyNodes),
            this.nodes.forEach(resolveTargetDelta),
            this.nodes.forEach(calcProjection),
            this.nodes.forEach(cleanDirtyNodes),
            isDebug && window.MotionDebug.record(metrics));
        }),
        (this.resolvedRelativeTargetAt = 0),
        (this.hasProjected = !1),
        (this.isVisible = !0),
        (this.animationProgress = 0),
        (this.sharedNodes = new Map()),
        (this.latestValues = S),
        (this.root = R ? R.root || R : this),
        (this.path = R ? [...R.path, R] : []),
        (this.parent = R),
        (this.depth = R ? R.depth + 1 : 0));
      for (let O = 0; O < this.path.length; O++)
        this.path[O].shouldResetTransform = !0;
      this.root === this && (this.nodes = new FlatTree());
    }
    addEventListener(S, R) {
      return (
        this.eventHandlers.has(S) ||
          this.eventHandlers.set(S, new SubscriptionManager()),
        this.eventHandlers.get(S).add(R)
      );
    }
    notifyListeners(S, ...R) {
      const O = this.eventHandlers.get(S);
      O && O.notify(...R);
    }
    hasListeners(S) {
      return this.eventHandlers.has(S);
    }
    mount(S, R = this.root.hasTreeAnimated) {
      if (this.instance) return;
      ((this.isSVG = isSVGElement(S)), (this.instance = S));
      const { layoutId: O, layout: j, visualElement: F } = this.options;
      if (
        (F && !F.current && F.mount(S),
        this.root.nodes.add(this),
        this.parent && this.parent.children.add(this),
        R && (j || O) && (this.isLayoutDirty = !0),
        a)
      ) {
        let q;
        const Q = () => (this.root.updateBlockedByResize = !1);
        a(S, () => {
          ((this.root.updateBlockedByResize = !0),
            q && q(),
            (q = delay(Q, 250)),
            globalProjectionState.hasAnimatedSinceResize &&
              ((globalProjectionState.hasAnimatedSinceResize = !1),
              this.nodes.forEach(finishAnimation)));
        });
      }
      (O && this.root.registerSharedNode(O, this),
        this.options.animate !== !1 &&
          F &&
          (O || j) &&
          this.addEventListener(
            "didUpdate",
            ({
              delta: q,
              hasLayoutChanged: Q,
              hasRelativeTargetChanged: te,
              layout: se,
            }) => {
              if (this.isTreeAnimationBlocked()) {
                ((this.target = void 0), (this.relativeTarget = void 0));
                return;
              }
              const re =
                  this.options.transition ||
                  F.getDefaultTransition() ||
                  defaultLayoutTransition,
                { onLayoutAnimationStart: Oe, onLayoutAnimationComplete: Le } =
                  F.getProps(),
                Be =
                  !this.targetLayout ||
                  !boxEqualsRounded(this.targetLayout, se) ||
                  te,
                Ve = !Q && te;
              if (
                this.options.layoutRoot ||
                (this.resumeFrom && this.resumeFrom.instance) ||
                Ve ||
                (Q && (Be || !this.currentAnimation))
              ) {
                (this.resumeFrom &&
                  ((this.resumingFrom = this.resumeFrom),
                  (this.resumingFrom.resumingFrom = void 0)),
                  this.setAnimationOrigin(q, Ve));
                const ze = {
                  ...getValueTransition(re, "layout"),
                  onPlay: Oe,
                  onComplete: Le,
                };
                ((F.shouldReduceMotion || this.options.layoutRoot) &&
                  ((ze.delay = 0), (ze.type = !1)),
                  this.startAnimation(ze));
              } else
                (Q || finishAnimation(this),
                  this.isLead() &&
                    this.options.onExitComplete &&
                    this.options.onExitComplete());
              this.targetLayout = se;
            },
          ));
    }
    unmount() {
      (this.options.layoutId && this.willUpdate(),
        this.root.nodes.remove(this));
      const S = this.getStack();
      (S && S.remove(this),
        this.parent && this.parent.children.delete(this),
        (this.instance = void 0),
        cancelFrame(this.updateProjection));
    }
    blockUpdate() {
      this.updateManuallyBlocked = !0;
    }
    unblockUpdate() {
      this.updateManuallyBlocked = !1;
    }
    isUpdateBlocked() {
      return this.updateManuallyBlocked || this.updateBlockedByResize;
    }
    isTreeAnimationBlocked() {
      return (
        this.isAnimationBlocked ||
        (this.parent && this.parent.isTreeAnimationBlocked()) ||
        !1
      );
    }
    startUpdate() {
      this.isUpdateBlocked() ||
        ((this.isUpdating = !0),
        this.nodes && this.nodes.forEach(resetSkewAndRotation),
        this.animationId++);
    }
    getTransformTemplate() {
      const { visualElement: S } = this.options;
      return S && S.getProps().transformTemplate;
    }
    willUpdate(S = !0) {
      if (((this.root.hasTreeAnimated = !0), this.root.isUpdateBlocked())) {
        this.options.onExitComplete && this.options.onExitComplete();
        return;
      }
      if (
        (window.MotionCancelOptimisedAnimation &&
          !this.hasCheckedOptimisedAppear &&
          cancelTreeOptimisedTransformAnimations(this),
        !this.root.isUpdating && this.root.startUpdate(),
        this.isLayoutDirty)
      )
        return;
      this.isLayoutDirty = !0;
      for (let F = 0; F < this.path.length; F++) {
        const q = this.path[F];
        ((q.shouldResetTransform = !0),
          q.updateScroll("snapshot"),
          q.options.layoutRoot && q.willUpdate(!1));
      }
      const { layoutId: R, layout: O } = this.options;
      if (R === void 0 && !O) return;
      const j = this.getTransformTemplate();
      ((this.prevTransformTemplateValue = j
        ? j(this.latestValues, "")
        : void 0),
        this.updateSnapshot(),
        S && this.notifyListeners("willUpdate"));
    }
    update() {
      if (((this.updateScheduled = !1), this.isUpdateBlocked())) {
        (this.unblockUpdate(),
          this.clearAllSnapshots(),
          this.nodes.forEach(clearMeasurements));
        return;
      }
      (this.isUpdating || this.nodes.forEach(clearIsLayoutDirty),
        (this.isUpdating = !1),
        this.nodes.forEach(resetTransformStyle),
        this.nodes.forEach(updateLayout),
        this.nodes.forEach(notifyLayoutUpdate),
        this.clearAllSnapshots());
      const R = time.now();
      ((frameData.delta = clamp$1(0, 1e3 / 60, R - frameData.timestamp)),
        (frameData.timestamp = R),
        (frameData.isProcessing = !0),
        frameSteps.update.process(frameData),
        frameSteps.preRender.process(frameData),
        frameSteps.render.process(frameData),
        (frameData.isProcessing = !1));
    }
    didUpdate() {
      this.updateScheduled ||
        ((this.updateScheduled = !0), microtask.read(this.scheduleUpdate));
    }
    clearAllSnapshots() {
      (this.nodes.forEach(clearSnapshot),
        this.sharedNodes.forEach(removeLeadSnapshots));
    }
    scheduleUpdateProjection() {
      this.projectionUpdateScheduled ||
        ((this.projectionUpdateScheduled = !0),
        frame.preRender(this.updateProjection, !1, !0));
    }
    scheduleCheckAfterUnmount() {
      frame.postRender(() => {
        this.isLayoutDirty
          ? this.root.didUpdate()
          : this.root.checkUpdateFailed();
      });
    }
    updateSnapshot() {
      this.snapshot || !this.instance || (this.snapshot = this.measure());
    }
    updateLayout() {
      if (
        !this.instance ||
        (this.updateScroll(),
        !(this.options.alwaysMeasureLayout && this.isLead()) &&
          !this.isLayoutDirty)
      )
        return;
      if (this.resumeFrom && !this.resumeFrom.instance)
        for (let O = 0; O < this.path.length; O++) this.path[O].updateScroll();
      const S = this.layout;
      ((this.layout = this.measure(!1)),
        (this.layoutCorrected = createBox()),
        (this.isLayoutDirty = !1),
        (this.projectionDelta = void 0),
        this.notifyListeners("measure", this.layout.layoutBox));
      const { visualElement: R } = this.options;
      R &&
        R.notify(
          "LayoutMeasure",
          this.layout.layoutBox,
          S ? S.layoutBox : void 0,
        );
    }
    updateScroll(S = "measure") {
      let R = !!(this.options.layoutScroll && this.instance);
      if (
        (this.scroll &&
          this.scroll.animationId === this.root.animationId &&
          this.scroll.phase === S &&
          (R = !1),
        R)
      ) {
        const O = _(this.instance);
        this.scroll = {
          animationId: this.root.animationId,
          phase: S,
          isRoot: O,
          offset: f(this.instance),
          wasRoot: this.scroll ? this.scroll.isRoot : O,
        };
      }
    }
    resetTransform() {
      if (!w) return;
      const S =
          this.isLayoutDirty ||
          this.shouldResetTransform ||
          this.options.alwaysMeasureLayout,
        R = this.projectionDelta && !isDeltaZero(this.projectionDelta),
        O = this.getTransformTemplate(),
        j = O ? O(this.latestValues, "") : void 0,
        F = j !== this.prevTransformTemplateValue;
      S &&
        (R || hasTransform(this.latestValues) || F) &&
        (w(this.instance, j),
        (this.shouldResetTransform = !1),
        this.scheduleRender());
    }
    measure(S = !0) {
      const R = this.measurePageBox();
      let O = this.removeElementScroll(R);
      return (
        S && (O = this.removeTransform(O)),
        roundBox(O),
        {
          animationId: this.root.animationId,
          measuredBox: R,
          layoutBox: O,
          latestValues: {},
          source: this.id,
        }
      );
    }
    measurePageBox() {
      var S;
      const { visualElement: R } = this.options;
      if (!R) return createBox();
      const O = R.measureViewportBox();
      if (
        !(
          ((S = this.scroll) === null || S === void 0 ? void 0 : S.wasRoot) ||
          this.path.some(checkNodeWasScrollRoot)
        )
      ) {
        const { scroll: F } = this.root;
        F && (translateAxis(O.x, F.offset.x), translateAxis(O.y, F.offset.y));
      }
      return O;
    }
    removeElementScroll(S) {
      var R;
      const O = createBox();
      if (
        (copyBoxInto(O, S),
        !((R = this.scroll) === null || R === void 0) && R.wasRoot)
      )
        return O;
      for (let j = 0; j < this.path.length; j++) {
        const F = this.path[j],
          { scroll: q, options: Q } = F;
        F !== this.root &&
          q &&
          Q.layoutScroll &&
          (q.wasRoot && copyBoxInto(O, S),
          translateAxis(O.x, q.offset.x),
          translateAxis(O.y, q.offset.y));
      }
      return O;
    }
    applyTransform(S, R = !1) {
      const O = createBox();
      copyBoxInto(O, S);
      for (let j = 0; j < this.path.length; j++) {
        const F = this.path[j];
        (!R &&
          F.options.layoutScroll &&
          F.scroll &&
          F !== F.root &&
          transformBox(O, { x: -F.scroll.offset.x, y: -F.scroll.offset.y }),
          hasTransform(F.latestValues) && transformBox(O, F.latestValues));
      }
      return (
        hasTransform(this.latestValues) && transformBox(O, this.latestValues),
        O
      );
    }
    removeTransform(S) {
      const R = createBox();
      copyBoxInto(R, S);
      for (let O = 0; O < this.path.length; O++) {
        const j = this.path[O];
        if (!j.instance || !hasTransform(j.latestValues)) continue;
        hasScale(j.latestValues) && j.updateSnapshot();
        const F = createBox(),
          q = j.measurePageBox();
        (copyBoxInto(F, q),
          removeBoxTransforms(
            R,
            j.latestValues,
            j.snapshot ? j.snapshot.layoutBox : void 0,
            F,
          ));
      }
      return (
        hasTransform(this.latestValues) &&
          removeBoxTransforms(R, this.latestValues),
        R
      );
    }
    setTargetDelta(S) {
      ((this.targetDelta = S),
        this.root.scheduleUpdateProjection(),
        (this.isProjectionDirty = !0));
    }
    setOptions(S) {
      this.options = {
        ...this.options,
        ...S,
        crossfade: S.crossfade !== void 0 ? S.crossfade : !0,
      };
    }
    clearMeasurements() {
      ((this.scroll = void 0),
        (this.layout = void 0),
        (this.snapshot = void 0),
        (this.prevTransformTemplateValue = void 0),
        (this.targetDelta = void 0),
        (this.target = void 0),
        (this.isLayoutDirty = !1));
    }
    forceRelativeParentToResolveTarget() {
      this.relativeParent &&
        this.relativeParent.resolvedRelativeTargetAt !== frameData.timestamp &&
        this.relativeParent.resolveTargetDelta(!0);
    }
    resolveTargetDelta(S = !1) {
      var R;
      const O = this.getLead();
      (this.isProjectionDirty || (this.isProjectionDirty = O.isProjectionDirty),
        this.isTransformDirty || (this.isTransformDirty = O.isTransformDirty),
        this.isSharedProjectionDirty ||
          (this.isSharedProjectionDirty = O.isSharedProjectionDirty));
      const j = !!this.resumingFrom || this !== O;
      if (
        !(
          S ||
          (j && this.isSharedProjectionDirty) ||
          this.isProjectionDirty ||
          (!((R = this.parent) === null || R === void 0) &&
            R.isProjectionDirty) ||
          this.attemptToResolveRelativeTarget ||
          this.root.updateBlockedByResize
        )
      )
        return;
      const { layout: q, layoutId: Q } = this.options;
      if (!(!this.layout || !(q || Q))) {
        if (
          ((this.resolvedRelativeTargetAt = frameData.timestamp),
          !this.targetDelta && !this.relativeTarget)
        ) {
          const te = this.getClosestProjectingParent();
          te && te.layout && this.animationProgress !== 1
            ? ((this.relativeParent = te),
              this.forceRelativeParentToResolveTarget(),
              (this.relativeTarget = createBox()),
              (this.relativeTargetOrigin = createBox()),
              calcRelativePosition(
                this.relativeTargetOrigin,
                this.layout.layoutBox,
                te.layout.layoutBox,
              ),
              copyBoxInto(this.relativeTarget, this.relativeTargetOrigin))
            : (this.relativeParent = this.relativeTarget = void 0);
        }
        if (!(!this.relativeTarget && !this.targetDelta)) {
          if (
            (this.target ||
              ((this.target = createBox()),
              (this.targetWithTransforms = createBox())),
            this.relativeTarget &&
            this.relativeTargetOrigin &&
            this.relativeParent &&
            this.relativeParent.target
              ? (this.forceRelativeParentToResolveTarget(),
                calcRelativeBox(
                  this.target,
                  this.relativeTarget,
                  this.relativeParent.target,
                ))
              : this.targetDelta
                ? (this.resumingFrom
                    ? (this.target = this.applyTransform(this.layout.layoutBox))
                    : copyBoxInto(this.target, this.layout.layoutBox),
                  applyBoxDelta(this.target, this.targetDelta))
                : copyBoxInto(this.target, this.layout.layoutBox),
            this.attemptToResolveRelativeTarget)
          ) {
            this.attemptToResolveRelativeTarget = !1;
            const te = this.getClosestProjectingParent();
            te &&
            !!te.resumingFrom == !!this.resumingFrom &&
            !te.options.layoutScroll &&
            te.target &&
            this.animationProgress !== 1
              ? ((this.relativeParent = te),
                this.forceRelativeParentToResolveTarget(),
                (this.relativeTarget = createBox()),
                (this.relativeTargetOrigin = createBox()),
                calcRelativePosition(
                  this.relativeTargetOrigin,
                  this.target,
                  te.target,
                ),
                copyBoxInto(this.relativeTarget, this.relativeTargetOrigin))
              : (this.relativeParent = this.relativeTarget = void 0);
          }
          isDebug && metrics.resolvedTargetDeltas++;
        }
      }
    }
    getClosestProjectingParent() {
      if (
        !(
          !this.parent ||
          hasScale(this.parent.latestValues) ||
          has2DTranslate(this.parent.latestValues)
        )
      )
        return this.parent.isProjecting()
          ? this.parent
          : this.parent.getClosestProjectingParent();
    }
    isProjecting() {
      return !!(
        (this.relativeTarget || this.targetDelta || this.options.layoutRoot) &&
        this.layout
      );
    }
    calcProjection() {
      var S;
      const R = this.getLead(),
        O = !!this.resumingFrom || this !== R;
      let j = !0;
      if (
        ((this.isProjectionDirty ||
          (!((S = this.parent) === null || S === void 0) &&
            S.isProjectionDirty)) &&
          (j = !1),
        O &&
          (this.isSharedProjectionDirty || this.isTransformDirty) &&
          (j = !1),
        this.resolvedRelativeTargetAt === frameData.timestamp && (j = !1),
        j)
      )
        return;
      const { layout: F, layoutId: q } = this.options;
      if (
        ((this.isTreeAnimating = !!(
          (this.parent && this.parent.isTreeAnimating) ||
          this.currentAnimation ||
          this.pendingAnimation
        )),
        this.isTreeAnimating ||
          (this.targetDelta = this.relativeTarget = void 0),
        !this.layout || !(F || q))
      )
        return;
      copyBoxInto(this.layoutCorrected, this.layout.layoutBox);
      const Q = this.treeScale.x,
        te = this.treeScale.y;
      (applyTreeDeltas(this.layoutCorrected, this.treeScale, this.path, O),
        R.layout &&
          !R.target &&
          (this.treeScale.x !== 1 || this.treeScale.y !== 1) &&
          ((R.target = R.layout.layoutBox),
          (R.targetWithTransforms = createBox())));
      const { target: se } = R;
      if (!se) {
        this.prevProjectionDelta &&
          (this.createProjectionDeltas(), this.scheduleRender());
        return;
      }
      (!this.projectionDelta || !this.prevProjectionDelta
        ? this.createProjectionDeltas()
        : (copyAxisDeltaInto(
            this.prevProjectionDelta.x,
            this.projectionDelta.x,
          ),
          copyAxisDeltaInto(
            this.prevProjectionDelta.y,
            this.projectionDelta.y,
          )),
        calcBoxDelta(
          this.projectionDelta,
          this.layoutCorrected,
          se,
          this.latestValues,
        ),
        (this.treeScale.x !== Q ||
          this.treeScale.y !== te ||
          !axisDeltaEquals(
            this.projectionDelta.x,
            this.prevProjectionDelta.x,
          ) ||
          !axisDeltaEquals(
            this.projectionDelta.y,
            this.prevProjectionDelta.y,
          )) &&
          ((this.hasProjected = !0),
          this.scheduleRender(),
          this.notifyListeners("projectionUpdate", se)),
        isDebug && metrics.recalculatedProjection++);
    }
    hide() {
      this.isVisible = !1;
    }
    show() {
      this.isVisible = !0;
    }
    scheduleRender(S = !0) {
      var R;
      if (
        ((R = this.options.visualElement) === null ||
          R === void 0 ||
          R.scheduleRender(),
        S)
      ) {
        const O = this.getStack();
        O && O.scheduleRender();
      }
      this.resumingFrom &&
        !this.resumingFrom.instance &&
        (this.resumingFrom = void 0);
    }
    createProjectionDeltas() {
      ((this.prevProjectionDelta = createDelta()),
        (this.projectionDelta = createDelta()),
        (this.projectionDeltaWithTransform = createDelta()));
    }
    setAnimationOrigin(S, R = !1) {
      const O = this.snapshot,
        j = O ? O.latestValues : {},
        F = { ...this.latestValues },
        q = createDelta();
      ((!this.relativeParent || !this.relativeParent.options.layoutRoot) &&
        (this.relativeTarget = this.relativeTargetOrigin = void 0),
        (this.attemptToResolveRelativeTarget = !R));
      const Q = createBox(),
        te = O ? O.source : void 0,
        se = this.layout ? this.layout.source : void 0,
        re = te !== se,
        Oe = this.getStack(),
        Le = !Oe || Oe.members.length <= 1,
        Be = !!(
          re &&
          !Le &&
          this.options.crossfade === !0 &&
          !this.path.some(hasOpacityCrossfade)
        );
      this.animationProgress = 0;
      let Ve;
      ((this.mixTargetDelta = (ze) => {
        const Ge = ze / 1e3;
        (mixAxisDelta(q.x, S.x, Ge),
          mixAxisDelta(q.y, S.y, Ge),
          this.setTargetDelta(q),
          this.relativeTarget &&
            this.relativeTargetOrigin &&
            this.layout &&
            this.relativeParent &&
            this.relativeParent.layout &&
            (calcRelativePosition(
              Q,
              this.layout.layoutBox,
              this.relativeParent.layout.layoutBox,
            ),
            mixBox(this.relativeTarget, this.relativeTargetOrigin, Q, Ge),
            Ve &&
              boxEquals(this.relativeTarget, Ve) &&
              (this.isProjectionDirty = !1),
            Ve || (Ve = createBox()),
            copyBoxInto(Ve, this.relativeTarget)),
          re &&
            ((this.animationValues = F),
            mixValues(F, j, this.latestValues, Ge, Be, Le)),
          this.root.scheduleUpdateProjection(),
          this.scheduleRender(),
          (this.animationProgress = Ge));
      }),
        this.mixTargetDelta(this.options.layoutRoot ? 1e3 : 0));
    }
    startAnimation(S) {
      (this.notifyListeners("animationStart"),
        this.currentAnimation && this.currentAnimation.stop(),
        this.resumingFrom &&
          this.resumingFrom.currentAnimation &&
          this.resumingFrom.currentAnimation.stop(),
        this.pendingAnimation &&
          (cancelFrame(this.pendingAnimation),
          (this.pendingAnimation = void 0)),
        (this.pendingAnimation = frame.update(() => {
          ((globalProjectionState.hasAnimatedSinceResize = !0),
            (this.currentAnimation = animateSingleValue(0, animationTarget, {
              ...S,
              onUpdate: (R) => {
                (this.mixTargetDelta(R), S.onUpdate && S.onUpdate(R));
              },
              onComplete: () => {
                (S.onComplete && S.onComplete(), this.completeAnimation());
              },
            })),
            this.resumingFrom &&
              (this.resumingFrom.currentAnimation = this.currentAnimation),
            (this.pendingAnimation = void 0));
        })));
    }
    completeAnimation() {
      this.resumingFrom &&
        ((this.resumingFrom.currentAnimation = void 0),
        (this.resumingFrom.preserveOpacity = void 0));
      const S = this.getStack();
      (S && S.exitAnimationComplete(),
        (this.resumingFrom =
          this.currentAnimation =
          this.animationValues =
            void 0),
        this.notifyListeners("animationComplete"));
    }
    finishAnimation() {
      (this.currentAnimation &&
        (this.mixTargetDelta && this.mixTargetDelta(animationTarget),
        this.currentAnimation.stop()),
        this.completeAnimation());
    }
    applyTransformsToTarget() {
      const S = this.getLead();
      let {
        targetWithTransforms: R,
        target: O,
        layout: j,
        latestValues: F,
      } = S;
      if (!(!R || !O || !j)) {
        if (
          this !== S &&
          this.layout &&
          j &&
          shouldAnimatePositionOnly(
            this.options.animationType,
            this.layout.layoutBox,
            j.layoutBox,
          )
        ) {
          O = this.target || createBox();
          const q = calcLength(this.layout.layoutBox.x);
          ((O.x.min = S.target.x.min), (O.x.max = O.x.min + q));
          const Q = calcLength(this.layout.layoutBox.y);
          ((O.y.min = S.target.y.min), (O.y.max = O.y.min + Q));
        }
        (copyBoxInto(R, O),
          transformBox(R, F),
          calcBoxDelta(
            this.projectionDeltaWithTransform,
            this.layoutCorrected,
            R,
            F,
          ));
      }
    }
    registerSharedNode(S, R) {
      (this.sharedNodes.has(S) || this.sharedNodes.set(S, new NodeStack()),
        this.sharedNodes.get(S).add(R));
      const j = R.options.initialPromotionConfig;
      R.promote({
        transition: j ? j.transition : void 0,
        preserveFollowOpacity:
          j && j.shouldPreserveFollowOpacity
            ? j.shouldPreserveFollowOpacity(R)
            : void 0,
      });
    }
    isLead() {
      const S = this.getStack();
      return S ? S.lead === this : !0;
    }
    getLead() {
      var S;
      const { layoutId: R } = this.options;
      return R
        ? ((S = this.getStack()) === null || S === void 0 ? void 0 : S.lead) ||
            this
        : this;
    }
    getPrevLead() {
      var S;
      const { layoutId: R } = this.options;
      return R
        ? (S = this.getStack()) === null || S === void 0
          ? void 0
          : S.prevLead
        : void 0;
    }
    getStack() {
      const { layoutId: S } = this.options;
      if (S) return this.root.sharedNodes.get(S);
    }
    promote({ needsReset: S, transition: R, preserveFollowOpacity: O } = {}) {
      const j = this.getStack();
      (j && j.promote(this, O),
        S && ((this.projectionDelta = void 0), (this.needsReset = !0)),
        R && this.setOptions({ transition: R }));
    }
    relegate() {
      const S = this.getStack();
      return S ? S.relegate(this) : !1;
    }
    resetSkewAndRotation() {
      const { visualElement: S } = this.options;
      if (!S) return;
      let R = !1;
      const { latestValues: O } = S;
      if (
        ((O.z ||
          O.rotate ||
          O.rotateX ||
          O.rotateY ||
          O.rotateZ ||
          O.skewX ||
          O.skewY) &&
          (R = !0),
        !R)
      )
        return;
      const j = {};
      O.z && resetDistortingTransform("z", S, j, this.animationValues);
      for (let F = 0; F < transformAxes.length; F++)
        (resetDistortingTransform(
          `rotate${transformAxes[F]}`,
          S,
          j,
          this.animationValues,
        ),
          resetDistortingTransform(
            `skew${transformAxes[F]}`,
            S,
            j,
            this.animationValues,
          ));
      S.render();
      for (const F in j)
        (S.setStaticValue(F, j[F]),
          this.animationValues && (this.animationValues[F] = j[F]));
      S.scheduleRender();
    }
    getProjectionStyles(S) {
      var R, O;
      if (!this.instance || this.isSVG) return;
      if (!this.isVisible) return hiddenVisibility;
      const j = { visibility: "" },
        F = this.getTransformTemplate();
      if (this.needsReset)
        return (
          (this.needsReset = !1),
          (j.opacity = ""),
          (j.pointerEvents = resolveMotionValue(S?.pointerEvents) || ""),
          (j.transform = F ? F(this.latestValues, "") : "none"),
          j
        );
      const q = this.getLead();
      if (!this.projectionDelta || !this.layout || !q.target) {
        const re = {};
        return (
          this.options.layoutId &&
            ((re.opacity =
              this.latestValues.opacity !== void 0
                ? this.latestValues.opacity
                : 1),
            (re.pointerEvents = resolveMotionValue(S?.pointerEvents) || "")),
          this.hasProjected &&
            !hasTransform(this.latestValues) &&
            ((re.transform = F ? F({}, "") : "none"), (this.hasProjected = !1)),
          re
        );
      }
      const Q = q.animationValues || q.latestValues;
      (this.applyTransformsToTarget(),
        (j.transform = buildProjectionTransform(
          this.projectionDeltaWithTransform,
          this.treeScale,
          Q,
        )),
        F && (j.transform = F(Q, j.transform)));
      const { x: te, y: se } = this.projectionDelta;
      ((j.transformOrigin = `${te.origin * 100}% ${se.origin * 100}% 0`),
        q.animationValues
          ? (j.opacity =
              q === this
                ? (O =
                    (R = Q.opacity) !== null && R !== void 0
                      ? R
                      : this.latestValues.opacity) !== null && O !== void 0
                  ? O
                  : 1
                : this.preserveOpacity
                  ? this.latestValues.opacity
                  : Q.opacityExit)
          : (j.opacity =
              q === this
                ? Q.opacity !== void 0
                  ? Q.opacity
                  : ""
                : Q.opacityExit !== void 0
                  ? Q.opacityExit
                  : 0));
      for (const re in scaleCorrectors) {
        if (Q[re] === void 0) continue;
        const { correct: Oe, applyTo: Le } = scaleCorrectors[re],
          Be = j.transform === "none" ? Q[re] : Oe(Q[re], q);
        if (Le) {
          const Ve = Le.length;
          for (let ze = 0; ze < Ve; ze++) j[Le[ze]] = Be;
        } else j[re] = Be;
      }
      return (
        this.options.layoutId &&
          (j.pointerEvents =
            q === this ? resolveMotionValue(S?.pointerEvents) || "" : "none"),
        j
      );
    }
    clearSnapshot() {
      this.resumeFrom = this.snapshot = void 0;
    }
    resetTree() {
      (this.root.nodes.forEach((S) => {
        var R;
        return (R = S.currentAnimation) === null || R === void 0
          ? void 0
          : R.stop();
      }),
        this.root.nodes.forEach(clearMeasurements),
        this.root.sharedNodes.clear());
    }
  };
}
function updateLayout(a) {
  a.updateLayout();
}
function notifyLayoutUpdate(a) {
  var e;
  const f =
    ((e = a.resumeFrom) === null || e === void 0 ? void 0 : e.snapshot) ||
    a.snapshot;
  if (a.isLead() && a.layout && f && a.hasListeners("didUpdate")) {
    const { layoutBox: _, measuredBox: w } = a.layout,
      { animationType: v } = a.options,
      S = f.source !== a.layout.source;
    v === "size"
      ? eachAxis((q) => {
          const Q = S ? f.measuredBox[q] : f.layoutBox[q],
            te = calcLength(Q);
          ((Q.min = _[q].min), (Q.max = Q.min + te));
        })
      : shouldAnimatePositionOnly(v, f.layoutBox, _) &&
        eachAxis((q) => {
          const Q = S ? f.measuredBox[q] : f.layoutBox[q],
            te = calcLength(_[q]);
          ((Q.max = Q.min + te),
            a.relativeTarget &&
              !a.currentAnimation &&
              ((a.isProjectionDirty = !0),
              (a.relativeTarget[q].max = a.relativeTarget[q].min + te)));
        });
    const R = createDelta();
    calcBoxDelta(R, _, f.layoutBox);
    const O = createDelta();
    S
      ? calcBoxDelta(O, a.applyTransform(w, !0), f.measuredBox)
      : calcBoxDelta(O, _, f.layoutBox);
    const j = !isDeltaZero(R);
    let F = !1;
    if (!a.resumeFrom) {
      const q = a.getClosestProjectingParent();
      if (q && !q.resumeFrom) {
        const { snapshot: Q, layout: te } = q;
        if (Q && te) {
          const se = createBox();
          calcRelativePosition(se, f.layoutBox, Q.layoutBox);
          const re = createBox();
          (calcRelativePosition(re, _, te.layoutBox),
            boxEqualsRounded(se, re) || (F = !0),
            q.options.layoutRoot &&
              ((a.relativeTarget = re),
              (a.relativeTargetOrigin = se),
              (a.relativeParent = q)));
        }
      }
    }
    a.notifyListeners("didUpdate", {
      layout: _,
      snapshot: f,
      delta: O,
      layoutDelta: R,
      hasLayoutChanged: j,
      hasRelativeTargetChanged: F,
    });
  } else if (a.isLead()) {
    const { onExitComplete: _ } = a.options;
    _ && _();
  }
  a.options.transition = void 0;
}
function propagateDirtyNodes(a) {
  (isDebug && metrics.totalNodes++,
    a.parent &&
      (a.isProjecting() || (a.isProjectionDirty = a.parent.isProjectionDirty),
      a.isSharedProjectionDirty ||
        (a.isSharedProjectionDirty = !!(
          a.isProjectionDirty ||
          a.parent.isProjectionDirty ||
          a.parent.isSharedProjectionDirty
        )),
      a.isTransformDirty || (a.isTransformDirty = a.parent.isTransformDirty)));
}
function cleanDirtyNodes(a) {
  a.isProjectionDirty = a.isSharedProjectionDirty = a.isTransformDirty = !1;
}
function clearSnapshot(a) {
  a.clearSnapshot();
}
function clearMeasurements(a) {
  a.clearMeasurements();
}
function clearIsLayoutDirty(a) {
  a.isLayoutDirty = !1;
}
function resetTransformStyle(a) {
  const { visualElement: e } = a.options;
  (e && e.getProps().onBeforeLayoutMeasure && e.notify("BeforeLayoutMeasure"),
    a.resetTransform());
}
function finishAnimation(a) {
  (a.finishAnimation(),
    (a.targetDelta = a.relativeTarget = a.target = void 0),
    (a.isProjectionDirty = !0));
}
function resolveTargetDelta(a) {
  a.resolveTargetDelta();
}
function calcProjection(a) {
  a.calcProjection();
}
function resetSkewAndRotation(a) {
  a.resetSkewAndRotation();
}
function removeLeadSnapshots(a) {
  a.removeLeadSnapshot();
}
function mixAxisDelta(a, e, f) {
  ((a.translate = mixNumber$1(e.translate, 0, f)),
    (a.scale = mixNumber$1(e.scale, 1, f)),
    (a.origin = e.origin),
    (a.originPoint = e.originPoint));
}
function mixAxis(a, e, f, _) {
  ((a.min = mixNumber$1(e.min, f.min, _)),
    (a.max = mixNumber$1(e.max, f.max, _)));
}
function mixBox(a, e, f, _) {
  (mixAxis(a.x, e.x, f.x, _), mixAxis(a.y, e.y, f.y, _));
}
function hasOpacityCrossfade(a) {
  return a.animationValues && a.animationValues.opacityExit !== void 0;
}
const defaultLayoutTransition = { duration: 0.45, ease: [0.4, 0, 0.1, 1] },
  userAgentContains = (a) =>
    typeof navigator < "u" &&
    navigator.userAgent &&
    navigator.userAgent.toLowerCase().includes(a),
  roundPoint =
    userAgentContains("applewebkit/") && !userAgentContains("chrome/")
      ? Math.round
      : noop;
function roundAxis(a) {
  ((a.min = roundPoint(a.min)), (a.max = roundPoint(a.max)));
}
function roundBox(a) {
  (roundAxis(a.x), roundAxis(a.y));
}
function shouldAnimatePositionOnly(a, e, f) {
  return (
    a === "position" ||
    (a === "preserve-aspect" && !isNear(aspectRatio(e), aspectRatio(f), 0.2))
  );
}
function checkNodeWasScrollRoot(a) {
  var e;
  return (
    a !== a.root &&
    ((e = a.scroll) === null || e === void 0 ? void 0 : e.wasRoot)
  );
}
const DocumentProjectionNode = createProjectionNode({
    attachResizeListener: (a, e) => addDomEvent(a, "resize", e),
    measureScroll: () => ({
      x: document.documentElement.scrollLeft || document.body.scrollLeft,
      y: document.documentElement.scrollTop || document.body.scrollTop,
    }),
    checkIsScrollRoot: () => !0,
  }),
  rootProjectionNode = { current: void 0 },
  HTMLProjectionNode = createProjectionNode({
    measureScroll: (a) => ({ x: a.scrollLeft, y: a.scrollTop }),
    defaultParent: () => {
      if (!rootProjectionNode.current) {
        const a = new DocumentProjectionNode({});
        (a.mount(window),
          a.setOptions({ layoutScroll: !0 }),
          (rootProjectionNode.current = a));
      }
      return rootProjectionNode.current;
    },
    resetTransform: (a, e) => {
      a.style.transform = e !== void 0 ? e : "none";
    },
    checkIsScrollRoot: (a) => window.getComputedStyle(a).position === "fixed",
  }),
  drag = {
    pan: { Feature: PanGesture },
    drag: {
      Feature: DragGesture,
      ProjectionNode: HTMLProjectionNode,
      MeasureLayout,
    },
  };
function handleHoverEvent(a, e, f) {
  const { props: _ } = a;
  a.animationState &&
    _.whileHover &&
    a.animationState.setActive("whileHover", f === "Start");
  const w = "onHover" + f,
    v = _[w];
  v && frame.postRender(() => v(e, extractEventInfo(e)));
}
class HoverGesture extends Feature {
  mount() {
    const { current: e } = this.node;
    e &&
      (this.unmount = hover(
        e,
        (f) => (
          handleHoverEvent(this.node, f, "Start"),
          (_) => handleHoverEvent(this.node, _, "End")
        ),
      ));
  }
  unmount() {}
}
class FocusGesture extends Feature {
  constructor() {
    (super(...arguments), (this.isActive = !1));
  }
  onFocus() {
    let e = !1;
    try {
      e = this.node.current.matches(":focus-visible");
    } catch {
      e = !0;
    }
    !e ||
      !this.node.animationState ||
      (this.node.animationState.setActive("whileFocus", !0),
      (this.isActive = !0));
  }
  onBlur() {
    !this.isActive ||
      !this.node.animationState ||
      (this.node.animationState.setActive("whileFocus", !1),
      (this.isActive = !1));
  }
  mount() {
    this.unmount = pipe(
      addDomEvent(this.node.current, "focus", () => this.onFocus()),
      addDomEvent(this.node.current, "blur", () => this.onBlur()),
    );
  }
  unmount() {}
}
function handlePressEvent(a, e, f) {
  const { props: _ } = a;
  a.animationState &&
    _.whileTap &&
    a.animationState.setActive("whileTap", f === "Start");
  const w = "onTap" + (f === "End" ? "" : f),
    v = _[w];
  v && frame.postRender(() => v(e, extractEventInfo(e)));
}
class PressGesture extends Feature {
  mount() {
    const { current: e } = this.node;
    e &&
      (this.unmount = press(
        e,
        (f) => (
          handlePressEvent(this.node, f, "Start"),
          (_, { success: w }) =>
            handlePressEvent(this.node, _, w ? "End" : "Cancel")
        ),
        { useGlobalTarget: this.node.props.globalTapTarget },
      ));
  }
  unmount() {}
}
const observerCallbacks = new WeakMap(),
  observers = new WeakMap(),
  fireObserverCallback = (a) => {
    const e = observerCallbacks.get(a.target);
    e && e(a);
  },
  fireAllObserverCallbacks = (a) => {
    a.forEach(fireObserverCallback);
  };
function initIntersectionObserver({ root: a, ...e }) {
  const f = a || document;
  observers.has(f) || observers.set(f, {});
  const _ = observers.get(f),
    w = JSON.stringify(e);
  return (
    _[w] ||
      (_[w] = new IntersectionObserver(fireAllObserverCallbacks, {
        root: a,
        ...e,
      })),
    _[w]
  );
}
function observeIntersection(a, e, f) {
  const _ = initIntersectionObserver(e);
  return (
    observerCallbacks.set(a, f),
    _.observe(a),
    () => {
      (observerCallbacks.delete(a), _.unobserve(a));
    }
  );
}
const thresholdNames = { some: 0, all: 1 };
class InViewFeature extends Feature {
  constructor() {
    (super(...arguments), (this.hasEnteredView = !1), (this.isInView = !1));
  }
  startObserver() {
    this.unmount();
    const { viewport: e = {} } = this.node.getProps(),
      { root: f, margin: _, amount: w = "some", once: v } = e,
      S = {
        root: f ? f.current : void 0,
        rootMargin: _,
        threshold: typeof w == "number" ? w : thresholdNames[w],
      },
      R = (O) => {
        const { isIntersecting: j } = O;
        if (
          this.isInView === j ||
          ((this.isInView = j), v && !j && this.hasEnteredView)
        )
          return;
        (j && (this.hasEnteredView = !0),
          this.node.animationState &&
            this.node.animationState.setActive("whileInView", j));
        const { onViewportEnter: F, onViewportLeave: q } = this.node.getProps(),
          Q = j ? F : q;
        Q && Q(O);
      };
    return observeIntersection(this.node.current, S, R);
  }
  mount() {
    this.startObserver();
  }
  update() {
    if (typeof IntersectionObserver > "u") return;
    const { props: e, prevProps: f } = this.node;
    ["amount", "margin", "root"].some(hasViewportOptionChanged(e, f)) &&
      this.startObserver();
  }
  unmount() {}
}
function hasViewportOptionChanged(
  { viewport: a = {} },
  { viewport: e = {} } = {},
) {
  return (f) => a[f] !== e[f];
}
const gestureAnimations = {
    inView: { Feature: InViewFeature },
    tap: { Feature: PressGesture },
    focus: { Feature: FocusGesture },
    hover: { Feature: HoverGesture },
  },
  layout = { layout: { ProjectionNode: HTMLProjectionNode, MeasureLayout } },
  prefersReducedMotion = { current: null },
  hasReducedMotionListener = { current: !1 };
function initPrefersReducedMotion() {
  if (((hasReducedMotionListener.current = !0), !!isBrowser))
    if (window.matchMedia) {
      const a = window.matchMedia("(prefers-reduced-motion)"),
        e = () => (prefersReducedMotion.current = a.matches);
      (a.addListener(e), e());
    } else prefersReducedMotion.current = !1;
}
const valueTypes = [...dimensionValueTypes, color, complex],
  findValueType = (a) => valueTypes.find(testValueType(a)),
  visualElementStore = new WeakMap();
function updateMotionValuesFromProps(a, e, f) {
  for (const _ in e) {
    const w = e[_],
      v = f[_];
    if (isMotionValue(w)) a.addValue(_, w);
    else if (isMotionValue(v)) a.addValue(_, motionValue(w, { owner: a }));
    else if (v !== w)
      if (a.hasValue(_)) {
        const S = a.getValue(_);
        S.liveStyle === !0 ? S.jump(w) : S.hasAnimated || S.set(w);
      } else {
        const S = a.getStaticValue(_);
        a.addValue(_, motionValue(S !== void 0 ? S : w, { owner: a }));
      }
  }
  for (const _ in f) e[_] === void 0 && a.removeValue(_);
  return e;
}
const propEventHandlers = [
  "AnimationStart",
  "AnimationComplete",
  "Update",
  "BeforeLayoutMeasure",
  "LayoutMeasure",
  "LayoutAnimationStart",
  "LayoutAnimationComplete",
];
class VisualElement {
  scrapeMotionValuesFromProps(e, f, _) {
    return {};
  }
  constructor(
    {
      parent: e,
      props: f,
      presenceContext: _,
      reducedMotionConfig: w,
      blockInitialAnimation: v,
      visualState: S,
    },
    R = {},
  ) {
    ((this.current = null),
      (this.children = new Set()),
      (this.isVariantNode = !1),
      (this.isControllingVariants = !1),
      (this.shouldReduceMotion = null),
      (this.values = new Map()),
      (this.KeyframeResolver = KeyframeResolver),
      (this.features = {}),
      (this.valueSubscriptions = new Map()),
      (this.prevMotionValues = {}),
      (this.events = {}),
      (this.propEventSubscriptions = {}),
      (this.notifyUpdate = () => this.notify("Update", this.latestValues)),
      (this.render = () => {
        this.current &&
          (this.triggerBuild(),
          this.renderInstance(
            this.current,
            this.renderState,
            this.props.style,
            this.projection,
          ));
      }),
      (this.renderScheduledAt = 0),
      (this.scheduleRender = () => {
        const te = time.now();
        this.renderScheduledAt < te &&
          ((this.renderScheduledAt = te), frame.render(this.render, !1, !0));
      }));
    const { latestValues: O, renderState: j, onUpdate: F } = S;
    ((this.onUpdate = F),
      (this.latestValues = O),
      (this.baseTarget = { ...O }),
      (this.initialValues = f.initial ? { ...O } : {}),
      (this.renderState = j),
      (this.parent = e),
      (this.props = f),
      (this.presenceContext = _),
      (this.depth = e ? e.depth + 1 : 0),
      (this.reducedMotionConfig = w),
      (this.options = R),
      (this.blockInitialAnimation = !!v),
      (this.isControllingVariants = isControllingVariants(f)),
      (this.isVariantNode = isVariantNode(f)),
      this.isVariantNode && (this.variantChildren = new Set()),
      (this.manuallyAnimateOnMount = !!(e && e.current)));
    const { willChange: q, ...Q } = this.scrapeMotionValuesFromProps(
      f,
      {},
      this,
    );
    for (const te in Q) {
      const se = Q[te];
      O[te] !== void 0 && isMotionValue(se) && se.set(O[te], !1);
    }
  }
  mount(e) {
    ((this.current = e),
      visualElementStore.set(e, this),
      this.projection && !this.projection.instance && this.projection.mount(e),
      this.parent &&
        this.isVariantNode &&
        !this.isControllingVariants &&
        (this.removeFromVariantTree = this.parent.addVariantChild(this)),
      this.values.forEach((f, _) => this.bindToMotionValue(_, f)),
      hasReducedMotionListener.current || initPrefersReducedMotion(),
      (this.shouldReduceMotion =
        this.reducedMotionConfig === "never"
          ? !1
          : this.reducedMotionConfig === "always"
            ? !0
            : prefersReducedMotion.current),
      this.parent && this.parent.children.add(this),
      this.update(this.props, this.presenceContext));
  }
  unmount() {
    (visualElementStore.delete(this.current),
      this.projection && this.projection.unmount(),
      cancelFrame(this.notifyUpdate),
      cancelFrame(this.render),
      this.valueSubscriptions.forEach((e) => e()),
      this.valueSubscriptions.clear(),
      this.removeFromVariantTree && this.removeFromVariantTree(),
      this.parent && this.parent.children.delete(this));
    for (const e in this.events) this.events[e].clear();
    for (const e in this.features) {
      const f = this.features[e];
      f && (f.unmount(), (f.isMounted = !1));
    }
    this.current = null;
  }
  bindToMotionValue(e, f) {
    this.valueSubscriptions.has(e) && this.valueSubscriptions.get(e)();
    const _ = transformProps.has(e),
      w = f.on("change", (R) => {
        ((this.latestValues[e] = R),
          this.props.onUpdate && frame.preRender(this.notifyUpdate),
          _ && this.projection && (this.projection.isTransformDirty = !0));
      }),
      v = f.on("renderRequest", this.scheduleRender);
    let S;
    (window.MotionCheckAppearSync &&
      (S = window.MotionCheckAppearSync(this, e, f)),
      this.valueSubscriptions.set(e, () => {
        (w(), v(), S && S(), f.owner && f.stop());
      }));
  }
  sortNodePosition(e) {
    return !this.current ||
      !this.sortInstanceNodePosition ||
      this.type !== e.type
      ? 0
      : this.sortInstanceNodePosition(this.current, e.current);
  }
  updateFeatures() {
    let e = "animation";
    for (e in featureDefinitions) {
      const f = featureDefinitions[e];
      if (!f) continue;
      const { isEnabled: _, Feature: w } = f;
      if (
        (!this.features[e] &&
          w &&
          _(this.props) &&
          (this.features[e] = new w(this)),
        this.features[e])
      ) {
        const v = this.features[e];
        v.isMounted ? v.update() : (v.mount(), (v.isMounted = !0));
      }
    }
  }
  triggerBuild() {
    this.build(this.renderState, this.latestValues, this.props);
  }
  measureViewportBox() {
    return this.current
      ? this.measureInstanceViewportBox(this.current, this.props)
      : createBox();
  }
  getStaticValue(e) {
    return this.latestValues[e];
  }
  setStaticValue(e, f) {
    this.latestValues[e] = f;
  }
  update(e, f) {
    ((e.transformTemplate || this.props.transformTemplate) &&
      this.scheduleRender(),
      (this.prevProps = this.props),
      (this.props = e),
      (this.prevPresenceContext = this.presenceContext),
      (this.presenceContext = f));
    for (let _ = 0; _ < propEventHandlers.length; _++) {
      const w = propEventHandlers[_];
      this.propEventSubscriptions[w] &&
        (this.propEventSubscriptions[w](),
        delete this.propEventSubscriptions[w]);
      const v = "on" + w,
        S = e[v];
      S && (this.propEventSubscriptions[w] = this.on(w, S));
    }
    ((this.prevMotionValues = updateMotionValuesFromProps(
      this,
      this.scrapeMotionValuesFromProps(e, this.prevProps, this),
      this.prevMotionValues,
    )),
      this.handleChildMotionValue && this.handleChildMotionValue(),
      this.onUpdate && this.onUpdate(this));
  }
  getProps() {
    return this.props;
  }
  getVariant(e) {
    return this.props.variants ? this.props.variants[e] : void 0;
  }
  getDefaultTransition() {
    return this.props.transition;
  }
  getTransformPagePoint() {
    return this.props.transformPagePoint;
  }
  getClosestVariantNode() {
    return this.isVariantNode
      ? this
      : this.parent
        ? this.parent.getClosestVariantNode()
        : void 0;
  }
  addVariantChild(e) {
    const f = this.getClosestVariantNode();
    if (f)
      return (
        f.variantChildren && f.variantChildren.add(e),
        () => f.variantChildren.delete(e)
      );
  }
  addValue(e, f) {
    const _ = this.values.get(e);
    f !== _ &&
      (_ && this.removeValue(e),
      this.bindToMotionValue(e, f),
      this.values.set(e, f),
      (this.latestValues[e] = f.get()));
  }
  removeValue(e) {
    this.values.delete(e);
    const f = this.valueSubscriptions.get(e);
    (f && (f(), this.valueSubscriptions.delete(e)),
      delete this.latestValues[e],
      this.removeValueFromRenderState(e, this.renderState));
  }
  hasValue(e) {
    return this.values.has(e);
  }
  getValue(e, f) {
    if (this.props.values && this.props.values[e]) return this.props.values[e];
    let _ = this.values.get(e);
    return (
      _ === void 0 &&
        f !== void 0 &&
        ((_ = motionValue(f === null ? void 0 : f, { owner: this })),
        this.addValue(e, _)),
      _
    );
  }
  readValue(e, f) {
    var _;
    let w =
      this.latestValues[e] !== void 0 || !this.current
        ? this.latestValues[e]
        : (_ = this.getBaseTargetFromProps(this.props, e)) !== null &&
            _ !== void 0
          ? _
          : this.readValueFromInstance(this.current, e, this.options);
    return (
      w != null &&
        (typeof w == "string" && (isNumericalString(w) || isZeroValueString(w))
          ? (w = parseFloat(w))
          : !findValueType(w) &&
            complex.test(f) &&
            (w = getAnimatableNone(e, f)),
        this.setBaseTarget(e, isMotionValue(w) ? w.get() : w)),
      isMotionValue(w) ? w.get() : w
    );
  }
  setBaseTarget(e, f) {
    this.baseTarget[e] = f;
  }
  getBaseTarget(e) {
    var f;
    const { initial: _ } = this.props;
    let w;
    if (typeof _ == "string" || typeof _ == "object") {
      const S = resolveVariantFromProps(
        this.props,
        _,
        (f = this.presenceContext) === null || f === void 0 ? void 0 : f.custom,
      );
      S && (w = S[e]);
    }
    if (_ && w !== void 0) return w;
    const v = this.getBaseTargetFromProps(this.props, e);
    return v !== void 0 && !isMotionValue(v)
      ? v
      : this.initialValues[e] !== void 0 && w === void 0
        ? void 0
        : this.baseTarget[e];
  }
  on(e, f) {
    return (
      this.events[e] || (this.events[e] = new SubscriptionManager()),
      this.events[e].add(f)
    );
  }
  notify(e, ...f) {
    this.events[e] && this.events[e].notify(...f);
  }
}
class DOMVisualElement extends VisualElement {
  constructor() {
    (super(...arguments), (this.KeyframeResolver = DOMKeyframesResolver));
  }
  sortInstanceNodePosition(e, f) {
    return e.compareDocumentPosition(f) & 2 ? 1 : -1;
  }
  getBaseTargetFromProps(e, f) {
    return e.style ? e.style[f] : void 0;
  }
  removeValueFromRenderState(e, { vars: f, style: _ }) {
    (delete f[e], delete _[e]);
  }
  handleChildMotionValue() {
    this.childSubscription &&
      (this.childSubscription(), delete this.childSubscription);
    const { children: e } = this.props;
    isMotionValue(e) &&
      (this.childSubscription = e.on("change", (f) => {
        this.current && (this.current.textContent = `${f}`);
      }));
  }
}
function getComputedStyle$1(a) {
  return window.getComputedStyle(a);
}
class HTMLVisualElement extends DOMVisualElement {
  constructor() {
    (super(...arguments),
      (this.type = "html"),
      (this.renderInstance = renderHTML));
  }
  readValueFromInstance(e, f) {
    if (transformProps.has(f)) {
      const _ = getDefaultValueType(f);
      return (_ && _.default) || 0;
    } else {
      const _ = getComputedStyle$1(e),
        w = (isCSSVariableName(f) ? _.getPropertyValue(f) : _[f]) || 0;
      return typeof w == "string" ? w.trim() : w;
    }
  }
  measureInstanceViewportBox(e, { transformPagePoint: f }) {
    return measureViewportBox(e, f);
  }
  build(e, f, _) {
    buildHTMLStyles(e, f, _.transformTemplate);
  }
  scrapeMotionValuesFromProps(e, f, _) {
    return scrapeMotionValuesFromProps$1(e, f, _);
  }
}
class SVGVisualElement extends DOMVisualElement {
  constructor() {
    (super(...arguments),
      (this.type = "svg"),
      (this.isSVGTag = !1),
      (this.measureInstanceViewportBox = createBox));
  }
  getBaseTargetFromProps(e, f) {
    return e[f];
  }
  readValueFromInstance(e, f) {
    if (transformProps.has(f)) {
      const _ = getDefaultValueType(f);
      return (_ && _.default) || 0;
    }
    return (
      (f = camelCaseAttributes.has(f) ? f : camelToDash(f)),
      e.getAttribute(f)
    );
  }
  scrapeMotionValuesFromProps(e, f, _) {
    return scrapeMotionValuesFromProps(e, f, _);
  }
  build(e, f, _) {
    buildSVGAttrs(e, f, this.isSVGTag, _.transformTemplate);
  }
  renderInstance(e, f, _, w) {
    renderSVG(e, f, _, w);
  }
  mount(e) {
    ((this.isSVGTag = isSVGTag(e.tagName)), super.mount(e));
  }
}
const createDomVisualElement = (a, e) =>
    isSVGComponent(a)
      ? new SVGVisualElement(e)
      : new HTMLVisualElement(e, {
          allowProjection: a !== reactExports.Fragment,
        }),
  createMotionComponent = createMotionComponentFactory(
    { ...animations, ...gestureAnimations, ...drag, ...layout },
    createDomVisualElement,
  ),
  motion = createDOMMotionComponentProxy(createMotionComponent),
  Greeting = () =>
    jsxRuntimeExports.jsxs(
      "div",
      {
        className:
          "mx-auto mt-4 flex size-full max-w-3xl flex-col justify-center px-4 md:mt-16 md:px-8",
        children: [
          jsxRuntimeExports.jsx(motion.div, {
            animate: { opacity: 1, y: 0 },
            className: "font-semibold text-xl md:text-2xl",
            exit: { opacity: 0, y: 10 },
            initial: { opacity: 0, y: 10 },
            transition: { delay: 0.5, duration: 0.15 },
            children: "Hello there!",
          }),
          jsxRuntimeExports.jsx(motion.div, {
            animate: { opacity: 1, y: 0 },
            className: "text-xl text-muted-foreground md:text-2xl",
            exit: { opacity: 0, y: 10 },
            initial: { opacity: 0, y: 10 },
            transition: { delay: 0.6, duration: 0.15 },
            children: "How can I help you today?",
          }),
        ],
      },
      "overview",
    ),
  PlusIcon = ({ size: a = 16 }) =>
    jsxRuntimeExports.jsx("svg", {
      height: a,
      strokeLinejoin: "round",
      style: { color: "currentcolor" },
      viewBox: "0 0 16 16",
      width: a,
      children: jsxRuntimeExports.jsx("path", {
        clipRule: "evenodd",
        d: "M 8.75,1 H7.25 V7.25 H1.5 V8.75 H7.25 V15 H8.75 V8.75 H14.5 V7.25 H8.75 V1.75 Z",
        fill: "currentColor",
        fillRule: "evenodd",
      }),
    }),
  TrashIcon = ({ size: a = 16 }) =>
    jsxRuntimeExports.jsx("svg", {
      height: a,
      strokeLinejoin: "round",
      style: { color: "currentcolor" },
      viewBox: "0 0 16 16",
      width: a,
      children: jsxRuntimeExports.jsx("path", {
        clipRule: "evenodd",
        d: "M6.75 2.75C6.75 2.05964 7.30964 1.5 8 1.5C8.69036 1.5 9.25 2.05964 9.25 2.75V3H6.75V2.75ZM5.25 3V2.75C5.25 1.23122 6.48122 0 8 0C9.51878 0 10.75 1.23122 10.75 2.75V3H12.9201H14.25H15V4.5H14.25H13.8846L13.1776 13.6917C13.0774 14.9942 11.9913 16 10.6849 16H5.31508C4.00874 16 2.92263 14.9942 2.82244 13.6917L2.11538 4.5H1.75H1V3H1.75H3.07988H5.25ZM4.31802 13.5767L3.61982 4.5H12.3802L11.682 13.5767C11.6419 14.0977 11.2075 14.5 10.6849 14.5H5.31508C4.79254 14.5 4.3581 14.0977 4.31802 13.5767Z",
        fill: "currentColor",
        fillRule: "evenodd",
      }),
    }),
  ArrowUpIcon = ({ size: a = 16, ...e }) =>
    jsxRuntimeExports.jsx("svg", {
      height: a,
      strokeLinejoin: "round",
      style: { color: "currentcolor", ...e.style },
      viewBox: "0 0 16 16",
      width: a,
      ...e,
      children: jsxRuntimeExports.jsx("path", {
        clipRule: "evenodd",
        d: "M8.70711 1.39644C8.31659 1.00592 7.68342 1.00592 7.2929 1.39644L2.21968 6.46966L1.68935 6.99999L2.75001 8.06065L3.28034 7.53032L7.25001 3.56065V14.25V15H8.75001V14.25V3.56065L12.7197 7.53032L13.25 8.06065L14.3107 6.99999L13.7803 6.46966L8.70711 1.39644Z",
        fill: "currentColor",
        fillRule: "evenodd",
      }),
    }),
  PaperclipIcon = ({ size: a = 16, ...e }) =>
    jsxRuntimeExports.jsx("svg", {
      className: "-rotate-45",
      height: a,
      strokeLinejoin: "round",
      style: { color: "currentcolor", ...e.style },
      viewBox: "0 0 16 16",
      width: a,
      ...e,
      children: jsxRuntimeExports.jsx("path", {
        clipRule: "evenodd",
        d: "M10.8591 1.70735C10.3257 1.70735 9.81417 1.91925 9.437 2.29643L3.19455 8.53886C2.56246 9.17095 2.20735 10.0282 2.20735 10.9222C2.20735 11.8161 2.56246 12.6734 3.19455 13.3055C3.82665 13.9376 4.68395 14.2927 5.57786 14.2927C6.47178 14.2927 7.32908 13.9376 7.96117 13.3055L14.2036 7.06304L14.7038 6.56287L15.7041 7.56321L15.204 8.06337L8.96151 14.3058C8.06411 15.2032 6.84698 15.7074 5.57786 15.7074C4.30875 15.7074 3.09162 15.2032 2.19422 14.3058C1.29682 13.4084 0.792664 12.1913 0.792664 10.9222C0.792664 9.65305 1.29682 8.43592 2.19422 7.53852L8.43666 1.29609C9.07914 0.653606 9.95054 0.292664 10.8591 0.292664C11.7678 0.292664 12.6392 0.653606 13.2816 1.29609C13.9241 1.93857 14.2851 2.80997 14.2851 3.71857C14.2851 4.62718 13.9241 5.49858 13.2816 6.14106L13.2814 6.14133L7.0324 12.3835C7.03231 12.3836 7.03222 12.3837 7.03213 12.3838C6.64459 12.7712 6.11905 12.9888 5.57107 12.9888C5.02297 12.9888 4.49731 12.7711 4.10974 12.3835C3.72217 11.9959 3.50444 11.4703 3.50444 10.9222C3.50444 10.3741 3.72217 9.8484 4.10974 9.46084L4.11004 9.46054L9.877 3.70039L10.3775 3.20051L11.3772 4.20144L10.8767 4.70131L5.11008 10.4612C5.11005 10.4612 5.11003 10.4612 5.11 10.4613C4.98779 10.5835 4.91913 10.7493 4.91913 10.9222C4.91913 11.0951 4.98782 11.2609 5.11008 11.3832C5.23234 11.5054 5.39817 11.5741 5.57107 11.5741C5.74398 11.5741 5.9098 11.5054 6.03206 11.3832L6.03233 11.3829L12.2813 5.14072C12.2814 5.14063 12.2815 5.14054 12.2816 5.14045C12.6586 4.7633 12.8704 4.25185 12.8704 3.71857C12.8704 3.18516 12.6585 2.6736 12.2813 2.29643C11.9041 1.91925 11.3926 1.70735 10.8591 1.70735Z",
        fill: "currentColor",
        fillRule: "evenodd",
      }),
    }),
  SidebarLeftIcon = ({ size: a = 16 }) =>
    jsxRuntimeExports.jsx("svg", {
      height: a,
      strokeLinejoin: "round",
      style: { color: "currentcolor" },
      viewBox: "0 0 16 16",
      width: a,
      children: jsxRuntimeExports.jsx("path", {
        clipRule: "evenodd",
        d: "M6.245 2.5H14.5V12.5C14.5 13.0523 14.0523 13.5 13.5 13.5H6.245V2.5ZM4.995 2.5H1.5V12.5C1.5 13.0523 1.94772 13.5 2.5 13.5H4.995V2.5ZM0 1H1.5H14.5H16V2.5V12.5C16 13.8807 14.8807 15 13.5 15H2.5C1.11929 15 0 13.8807 0 12.5V2.5V1Z",
        fill: "currentColor",
        fillRule: "evenodd",
      }),
    });
function SidebarToggle({ className: a }) {
  const { toggleSidebar: e } = useSidebar();
  return jsxRuntimeExports.jsxs(Tooltip, {
    children: [
      jsxRuntimeExports.jsx(TooltipTrigger, {
        asChild: !0,
        children: jsxRuntimeExports.jsx(Button, {
          className: cn("h-8 px-2 md:h-fit md:px-2", a),
          "data-testid": "sidebar-toggle-button",
          onClick: e,
          variant: "outline",
          children: jsxRuntimeExports.jsx(SidebarLeftIcon, { size: 16 }),
        }),
      }),
      jsxRuntimeExports.jsx(TooltipContent, {
        align: "start",
        className: "hidden md:block",
        children: "Toggle Sidebar",
      }),
    ],
  });
}
function PureChatHeader({ chatId: a, isReadonly: e }) {
  const { open: f } = useSidebar();
  return jsxRuntimeExports.jsx("header", {
    className:
      "sticky top-0 flex items-center gap-2 bg-background px-2 py-1.5 md:px-2",
    children: jsxRuntimeExports.jsx(SidebarToggle, {}),
  });
}
const ChatHeader = reactExports.memo(
  PureChatHeader,
  (a, e) => a.chatId === e.chatId && a.isReadonly === e.isReadonly,
);
var U = 1,
  Y$1 = 0.9,
  H = 0.8,
  J = 0.17,
  p = 0.1,
  u = 0.999,
  $ = 0.9999,
  k$2 = 0.99,
  m$1 = /[\\\/_+.#"@\[\(\{&]/,
  B$1 = /[\\\/_+.#"@\[\(\{&]/g,
  K$1 = /[\s-]/,
  X = /[\s-]/g;
function G$1(a, e, f, _, w, v, S) {
  if (v === e.length) return w === a.length ? U : k$2;
  var R = `${w},${v}`;
  if (S[R] !== void 0) return S[R];
  for (var O = _.charAt(v), j = f.indexOf(O, w), F = 0, q, Q, te, se; j >= 0; )
    ((q = G$1(a, e, f, _, j + 1, v + 1, S)),
      q > F &&
        (j === w
          ? (q *= U)
          : m$1.test(a.charAt(j - 1))
            ? ((q *= H),
              (te = a.slice(w, j - 1).match(B$1)),
              te && w > 0 && (q *= Math.pow(u, te.length)))
            : K$1.test(a.charAt(j - 1))
              ? ((q *= Y$1),
                (se = a.slice(w, j - 1).match(X)),
                se && w > 0 && (q *= Math.pow(u, se.length)))
              : ((q *= J), w > 0 && (q *= Math.pow(u, j - w))),
        a.charAt(j) !== e.charAt(v) && (q *= $)),
      ((q < p && f.charAt(j - 1) === _.charAt(v + 1)) ||
        (_.charAt(v + 1) === _.charAt(v) && f.charAt(j - 1) !== _.charAt(v))) &&
        ((Q = G$1(a, e, f, _, j + 1, v + 2, S)), Q * p > q && (q = Q * p)),
      q > F && (F = q),
      (j = f.indexOf(O, j + 1)));
  return ((S[R] = F), F);
}
function D(a) {
  return a.toLowerCase().replace(X, " ");
}
function W$1(a, e, f) {
  return (
    (a = f && f.length > 0 ? `${a + " " + f.join(" ")}` : a),
    G$1(a, e, D(a), D(e), 0, 0, {})
  );
}
var NODES = [
    "a",
    "button",
    "div",
    "form",
    "h2",
    "h3",
    "img",
    "input",
    "label",
    "li",
    "nav",
    "ol",
    "p",
    "select",
    "span",
    "svg",
    "ul",
  ],
  Primitive = NODES.reduce((a, e) => {
    const f = createSlot$5(`Primitive.${e}`),
      _ = reactExports.forwardRef((w, v) => {
        const { asChild: S, ...R } = w,
          O = S ? f : e;
        return (
          typeof window < "u" && (window[Symbol.for("radix-ui")] = !0),
          jsxRuntimeExports.jsx(O, { ...R, ref: v })
        );
      });
    return ((_.displayName = `Primitive.${e}`), { ...a, [e]: _ });
  }, {}),
  N$1 = '[cmdk-group=""]',
  Y = '[cmdk-group-items=""]',
  be$1 = '[cmdk-group-heading=""]',
  le = '[cmdk-item=""]',
  ce$1 = `${le}:not([aria-disabled="true"])`,
  Z = "cmdk-item-select",
  T$1 = "data-value",
  Re$1 = (a, e, f) => W$1(a, e, f),
  ue = reactExports.createContext(void 0),
  K = () => reactExports.useContext(ue),
  de$1 = reactExports.createContext(void 0),
  ee = () => reactExports.useContext(de$1),
  fe$2 = reactExports.createContext(void 0),
  me$1 = reactExports.forwardRef((a, e) => {
    let f = L(() => {
        var Ue, ot;
        return {
          search: "",
          value:
            (ot = (Ue = a.value) != null ? Ue : a.defaultValue) != null
              ? ot
              : "",
          selectedItemId: void 0,
          filtered: { count: 0, items: new Map(), groups: new Set() },
        };
      }),
      _ = L(() => new Set()),
      w = L(() => new Map()),
      v = L(() => new Map()),
      S = L(() => new Set()),
      R = pe$1(a),
      {
        label: O,
        children: j,
        value: F,
        onValueChange: q,
        filter: Q,
        shouldFilter: te,
        loop: se,
        disablePointerSelection: re = !1,
        vimBindings: Oe = !0,
        ...Le
      } = a,
      Be = useId(),
      Ve = useId(),
      ze = useId(),
      Ge = reactExports.useRef(null),
      Ke = ke$1();
    (k$1(() => {
      if (F !== void 0) {
        let Ue = F.trim();
        ((f.current.value = Ue), qe.emit());
      }
    }, [F]),
      k$1(() => {
        Ke(6, _t);
      }, []));
    let qe = reactExports.useMemo(
        () => ({
          subscribe: (Ue) => (S.current.add(Ue), () => S.current.delete(Ue)),
          snapshot: () => f.current,
          setState: (Ue, ot, lt) => {
            var ut, yt, it, Et;
            if (!Object.is(f.current[Ue], ot)) {
              if (((f.current[Ue] = ot), Ue === "search"))
                (dt(), gt(), Ke(1, mt));
              else if (Ue === "value") {
                if (
                  document.activeElement.hasAttribute("cmdk-input") ||
                  document.activeElement.hasAttribute("cmdk-root")
                ) {
                  let xt = document.getElementById(ze);
                  xt
                    ? xt.focus()
                    : (ut = document.getElementById(Be)) == null || ut.focus();
                }
                if (
                  (Ke(7, () => {
                    var xt;
                    ((f.current.selectedItemId =
                      (xt = bt()) == null ? void 0 : xt.id),
                      qe.emit());
                  }),
                  lt || Ke(5, _t),
                  ((yt = R.current) == null ? void 0 : yt.value) !== void 0)
                ) {
                  let xt = ot ?? "";
                  (Et = (it = R.current).onValueChange) == null ||
                    Et.call(it, xt);
                  return;
                }
              }
              qe.emit();
            }
          },
          emit: () => {
            S.current.forEach((Ue) => Ue());
          },
        }),
        [],
      ),
      nt = reactExports.useMemo(
        () => ({
          value: (Ue, ot, lt) => {
            var ut;
            ot !== ((ut = v.current.get(Ue)) == null ? void 0 : ut.value) &&
              (v.current.set(Ue, { value: ot, keywords: lt }),
              f.current.filtered.items.set(Ue, pt(ot, lt)),
              Ke(2, () => {
                (gt(), qe.emit());
              }));
          },
          item: (Ue, ot) => (
            _.current.add(Ue),
            ot &&
              (w.current.has(ot)
                ? w.current.get(ot).add(Ue)
                : w.current.set(ot, new Set([Ue]))),
            Ke(3, () => {
              (dt(), gt(), f.current.value || mt(), qe.emit());
            }),
            () => {
              (v.current.delete(Ue),
                _.current.delete(Ue),
                f.current.filtered.items.delete(Ue));
              let lt = bt();
              Ke(4, () => {
                (dt(), lt?.getAttribute("id") === Ue && mt(), qe.emit());
              });
            }
          ),
          group: (Ue) => (
            w.current.has(Ue) || w.current.set(Ue, new Set()),
            () => {
              (v.current.delete(Ue), w.current.delete(Ue));
            }
          ),
          filter: () => R.current.shouldFilter,
          label: O || a["aria-label"],
          getDisablePointerSelection: () => R.current.disablePointerSelection,
          listId: Be,
          inputId: ze,
          labelId: Ve,
          listInnerRef: Ge,
        }),
        [],
      );
    function pt(Ue, ot) {
      var lt, ut;
      let yt =
        (ut = (lt = R.current) == null ? void 0 : lt.filter) != null
          ? ut
          : Re$1;
      return Ue ? yt(Ue, f.current.search, ot) : 0;
    }
    function gt() {
      if (!f.current.search || R.current.shouldFilter === !1) return;
      let Ue = f.current.filtered.items,
        ot = [];
      f.current.filtered.groups.forEach((ut) => {
        let yt = w.current.get(ut),
          it = 0;
        (yt.forEach((Et) => {
          let xt = Ue.get(Et);
          it = Math.max(xt, it);
        }),
          ot.push([ut, it]));
      });
      let lt = Ge.current;
      (at()
        .sort((ut, yt) => {
          var it, Et;
          let xt = ut.getAttribute("id"),
            At = yt.getAttribute("id");
          return (
            ((it = Ue.get(At)) != null ? it : 0) -
            ((Et = Ue.get(xt)) != null ? Et : 0)
          );
        })
        .forEach((ut) => {
          let yt = ut.closest(Y);
          yt
            ? yt.appendChild(
                ut.parentElement === yt ? ut : ut.closest(`${Y} > *`),
              )
            : lt.appendChild(
                ut.parentElement === lt ? ut : ut.closest(`${Y} > *`),
              );
        }),
        ot
          .sort((ut, yt) => yt[1] - ut[1])
          .forEach((ut) => {
            var yt;
            let it =
              (yt = Ge.current) == null
                ? void 0
                : yt.querySelector(
                    `${N$1}[${T$1}="${encodeURIComponent(ut[0])}"]`,
                  );
            it?.parentElement.appendChild(it);
          }));
    }
    function mt() {
      let Ue = at().find((lt) => lt.getAttribute("aria-disabled") !== "true"),
        ot = Ue?.getAttribute(T$1);
      qe.setState("value", ot || void 0);
    }
    function dt() {
      var Ue, ot, lt, ut;
      if (!f.current.search || R.current.shouldFilter === !1) {
        f.current.filtered.count = _.current.size;
        return;
      }
      f.current.filtered.groups = new Set();
      let yt = 0;
      for (let it of _.current) {
        let Et =
            (ot = (Ue = v.current.get(it)) == null ? void 0 : Ue.value) != null
              ? ot
              : "",
          xt =
            (ut = (lt = v.current.get(it)) == null ? void 0 : lt.keywords) !=
            null
              ? ut
              : [],
          At = pt(Et, xt);
        (f.current.filtered.items.set(it, At), At > 0 && yt++);
      }
      for (let [it, Et] of w.current)
        for (let xt of Et)
          if (f.current.filtered.items.get(xt) > 0) {
            f.current.filtered.groups.add(it);
            break;
          }
      f.current.filtered.count = yt;
    }
    function _t() {
      var Ue, ot, lt;
      let ut = bt();
      ut &&
        (((Ue = ut.parentElement) == null ? void 0 : Ue.firstChild) === ut &&
          ((lt =
            (ot = ut.closest(N$1)) == null ? void 0 : ot.querySelector(be$1)) ==
            null ||
            lt.scrollIntoView({ block: "nearest" })),
        ut.scrollIntoView({ block: "nearest" }));
    }
    function bt() {
      var Ue;
      return (Ue = Ge.current) == null
        ? void 0
        : Ue.querySelector(`${le}[aria-selected="true"]`);
    }
    function at() {
      var Ue;
      return Array.from(
        ((Ue = Ge.current) == null ? void 0 : Ue.querySelectorAll(ce$1)) || [],
      );
    }
    function $e(Ue) {
      let ot = at()[Ue];
      ot && qe.setState("value", ot.getAttribute(T$1));
    }
    function Ye(Ue) {
      var ot;
      let lt = bt(),
        ut = at(),
        yt = ut.findIndex((Et) => Et === lt),
        it = ut[yt + Ue];
      ((ot = R.current) != null &&
        ot.loop &&
        (it =
          yt + Ue < 0
            ? ut[ut.length - 1]
            : yt + Ue === ut.length
              ? ut[0]
              : ut[yt + Ue]),
        it && qe.setState("value", it.getAttribute(T$1)));
    }
    function Qe(Ue) {
      let ot = bt(),
        lt = ot?.closest(N$1),
        ut;
      for (; lt && !ut; )
        ((lt = Ue > 0 ? we$1(lt, N$1) : De$1(lt, N$1)),
          (ut = lt?.querySelector(ce$1)));
      ut ? qe.setState("value", ut.getAttribute(T$1)) : Ye(Ue);
    }
    let tt = () => $e(at().length - 1),
      ht = (Ue) => {
        (Ue.preventDefault(), Ue.metaKey ? tt() : Ue.altKey ? Qe(1) : Ye(1));
      },
      Fe = (Ue) => {
        (Ue.preventDefault(), Ue.metaKey ? $e(0) : Ue.altKey ? Qe(-1) : Ye(-1));
      };
    return reactExports.createElement(
      Primitive.div,
      {
        ref: e,
        tabIndex: -1,
        ...Le,
        "cmdk-root": "",
        onKeyDown: (Ue) => {
          var ot;
          (ot = Le.onKeyDown) == null || ot.call(Le, Ue);
          let lt = Ue.nativeEvent.isComposing || Ue.keyCode === 229;
          if (!(Ue.defaultPrevented || lt))
            switch (Ue.key) {
              case "n":
              case "j": {
                Oe && Ue.ctrlKey && ht(Ue);
                break;
              }
              case "ArrowDown": {
                ht(Ue);
                break;
              }
              case "p":
              case "k": {
                Oe && Ue.ctrlKey && Fe(Ue);
                break;
              }
              case "ArrowUp": {
                Fe(Ue);
                break;
              }
              case "Home": {
                (Ue.preventDefault(), $e(0));
                break;
              }
              case "End": {
                (Ue.preventDefault(), tt());
                break;
              }
              case "Enter": {
                Ue.preventDefault();
                let ut = bt();
                if (ut) {
                  let yt = new Event(Z);
                  ut.dispatchEvent(yt);
                }
              }
            }
        },
      },
      reactExports.createElement(
        "label",
        { "cmdk-label": "", htmlFor: nt.inputId, id: nt.labelId, style: Te$1 },
        O,
      ),
      B(a, (Ue) =>
        reactExports.createElement(
          de$1.Provider,
          { value: qe },
          reactExports.createElement(ue.Provider, { value: nt }, Ue),
        ),
      ),
    );
  }),
  he$1 = reactExports.forwardRef((a, e) => {
    var f, _;
    let w = useId(),
      v = reactExports.useRef(null),
      S = reactExports.useContext(fe$2),
      R = K(),
      O = pe$1(a),
      j =
        (_ = (f = O.current) == null ? void 0 : f.forceMount) != null
          ? _
          : S?.forceMount;
    k$1(() => {
      if (!j) return R.item(w, S?.id);
    }, [j]);
    let F = ve$1(w, v, [a.value, a.children, v], a.keywords),
      q = ee(),
      Q = P$1((Ke) => Ke.value && Ke.value === F.current),
      te = P$1((Ke) =>
        j || R.filter() === !1
          ? !0
          : Ke.search
            ? Ke.filtered.items.get(w) > 0
            : !0,
      );
    reactExports.useEffect(() => {
      let Ke = v.current;
      if (!(!Ke || a.disabled))
        return (
          Ke.addEventListener(Z, se),
          () => Ke.removeEventListener(Z, se)
        );
    }, [te, a.onSelect, a.disabled]);
    function se() {
      var Ke, qe;
      (re(),
        (qe = (Ke = O.current).onSelect) == null || qe.call(Ke, F.current));
    }
    function re() {
      q.setState("value", F.current, !0);
    }
    if (!te) return null;
    let {
      disabled: Oe,
      value: Le,
      onSelect: Be,
      forceMount: Ve,
      keywords: ze,
      ...Ge
    } = a;
    return reactExports.createElement(
      Primitive.div,
      {
        ref: composeRefs(v, e),
        ...Ge,
        id: w,
        "cmdk-item": "",
        role: "option",
        "aria-disabled": !!Oe,
        "aria-selected": !!Q,
        "data-disabled": !!Oe,
        "data-selected": !!Q,
        onPointerMove: Oe || R.getDisablePointerSelection() ? void 0 : re,
        onClick: Oe ? void 0 : se,
      },
      a.children,
    );
  }),
  Ee = reactExports.forwardRef((a, e) => {
    let { heading: f, children: _, forceMount: w, ...v } = a,
      S = useId(),
      R = reactExports.useRef(null),
      O = reactExports.useRef(null),
      j = useId(),
      F = K(),
      q = P$1((te) =>
        w || F.filter() === !1
          ? !0
          : te.search
            ? te.filtered.groups.has(S)
            : !0,
      );
    (k$1(() => F.group(S), []), ve$1(S, R, [a.value, a.heading, O]));
    let Q = reactExports.useMemo(() => ({ id: S, forceMount: w }), [w]);
    return reactExports.createElement(
      Primitive.div,
      {
        ref: composeRefs(R, e),
        ...v,
        "cmdk-group": "",
        role: "presentation",
        hidden: q ? void 0 : !0,
      },
      f &&
        reactExports.createElement(
          "div",
          { ref: O, "cmdk-group-heading": "", "aria-hidden": !0, id: j },
          f,
        ),
      B(a, (te) =>
        reactExports.createElement(
          "div",
          {
            "cmdk-group-items": "",
            role: "group",
            "aria-labelledby": f ? j : void 0,
          },
          reactExports.createElement(fe$2.Provider, { value: Q }, te),
        ),
      ),
    );
  }),
  ye$1 = reactExports.forwardRef((a, e) => {
    let { alwaysRender: f, ..._ } = a,
      w = reactExports.useRef(null),
      v = P$1((S) => !S.search);
    return !f && !v
      ? null
      : reactExports.createElement(Primitive.div, {
          ref: composeRefs(w, e),
          ..._,
          "cmdk-separator": "",
          role: "separator",
        });
  }),
  Se$1 = reactExports.forwardRef((a, e) => {
    let { onValueChange: f, ..._ } = a,
      w = a.value != null,
      v = ee(),
      S = P$1((j) => j.search),
      R = P$1((j) => j.selectedItemId),
      O = K();
    return (
      reactExports.useEffect(() => {
        a.value != null && v.setState("search", a.value);
      }, [a.value]),
      reactExports.createElement(Primitive.input, {
        ref: e,
        ..._,
        "cmdk-input": "",
        autoComplete: "off",
        autoCorrect: "off",
        spellCheck: !1,
        "aria-autocomplete": "list",
        role: "combobox",
        "aria-expanded": !0,
        "aria-controls": O.listId,
        "aria-labelledby": O.labelId,
        "aria-activedescendant": R,
        id: O.inputId,
        type: "text",
        value: w ? a.value : S,
        onChange: (j) => {
          (w || v.setState("search", j.target.value), f?.(j.target.value));
        },
      })
    );
  }),
  Ce$1 = reactExports.forwardRef((a, e) => {
    let { children: f, label: _ = "Suggestions", ...w } = a,
      v = reactExports.useRef(null),
      S = reactExports.useRef(null),
      R = P$1((j) => j.selectedItemId),
      O = K();
    return (
      reactExports.useEffect(() => {
        if (S.current && v.current) {
          let j = S.current,
            F = v.current,
            q,
            Q = new ResizeObserver(() => {
              q = requestAnimationFrame(() => {
                let te = j.offsetHeight;
                F.style.setProperty("--cmdk-list-height", te.toFixed(1) + "px");
              });
            });
          return (
            Q.observe(j),
            () => {
              (cancelAnimationFrame(q), Q.unobserve(j));
            }
          );
        }
      }, []),
      reactExports.createElement(
        Primitive.div,
        {
          ref: composeRefs(v, e),
          ...w,
          "cmdk-list": "",
          role: "listbox",
          tabIndex: -1,
          "aria-activedescendant": R,
          "aria-label": _,
          id: O.listId,
        },
        B(a, (j) =>
          reactExports.createElement(
            "div",
            { ref: composeRefs(S, O.listInnerRef), "cmdk-list-sizer": "" },
            j,
          ),
        ),
      )
    );
  }),
  xe$1 = reactExports.forwardRef((a, e) => {
    let {
      open: f,
      onOpenChange: _,
      overlayClassName: w,
      contentClassName: v,
      container: S,
      ...R
    } = a;
    return reactExports.createElement(
      Root$4,
      { open: f, onOpenChange: _ },
      reactExports.createElement(
        Portal$2,
        { container: S },
        reactExports.createElement(Overlay, {
          "cmdk-overlay": "",
          className: w,
        }),
        reactExports.createElement(
          Content$1,
          { "aria-label": a.label, "cmdk-dialog": "", className: v },
          reactExports.createElement(me$1, { ref: e, ...R }),
        ),
      ),
    );
  }),
  Ie$1 = reactExports.forwardRef((a, e) =>
    P$1((f) => f.filtered.count === 0)
      ? reactExports.createElement(Primitive.div, {
          ref: e,
          ...a,
          "cmdk-empty": "",
          role: "presentation",
        })
      : null,
  ),
  Pe$1 = reactExports.forwardRef((a, e) => {
    let { progress: f, children: _, label: w = "Loading...", ...v } = a;
    return reactExports.createElement(
      Primitive.div,
      {
        ref: e,
        ...v,
        "cmdk-loading": "",
        role: "progressbar",
        "aria-valuenow": f,
        "aria-valuemin": 0,
        "aria-valuemax": 100,
        "aria-label": w,
      },
      B(a, (S) => reactExports.createElement("div", { "aria-hidden": !0 }, S)),
    );
  }),
  _e = Object.assign(me$1, {
    List: Ce$1,
    Item: he$1,
    Input: Se$1,
    Group: Ee,
    Separator: ye$1,
    Dialog: xe$1,
    Empty: Ie$1,
    Loading: Pe$1,
  });
function we$1(a, e) {
  let f = a.nextElementSibling;
  for (; f; ) {
    if (f.matches(e)) return f;
    f = f.nextElementSibling;
  }
}
function De$1(a, e) {
  let f = a.previousElementSibling;
  for (; f; ) {
    if (f.matches(e)) return f;
    f = f.previousElementSibling;
  }
}
function pe$1(a) {
  let e = reactExports.useRef(a);
  return (
    k$1(() => {
      e.current = a;
    }),
    e
  );
}
var k$1 =
  typeof window > "u" ? reactExports.useEffect : reactExports.useLayoutEffect;
function L(a) {
  let e = reactExports.useRef();
  return (e.current === void 0 && (e.current = a()), e);
}
function P$1(a) {
  let e = ee(),
    f = () => a(e.snapshot());
  return reactExports.useSyncExternalStore(e.subscribe, f, f);
}
function ve$1(a, e, f, _ = []) {
  let w = reactExports.useRef(),
    v = K();
  return (
    k$1(() => {
      var S;
      let R = (() => {
          var j;
          for (let F of f) {
            if (typeof F == "string") return F.trim();
            if (typeof F == "object" && "current" in F)
              return F.current
                ? (j = F.current.textContent) == null
                  ? void 0
                  : j.trim()
                : w.current;
          }
        })(),
        O = _.map((j) => j.trim());
      (v.value(a, R, O),
        (S = e.current) == null || S.setAttribute(T$1, R),
        (w.current = R));
    }),
    w
  );
}
var ke$1 = () => {
  let [a, e] = reactExports.useState(),
    f = L(() => new Map());
  return (
    k$1(() => {
      (f.current.forEach((_) => _()), (f.current = new Map()));
    }, [a]),
    (_, w) => {
      (f.current.set(_, w), e({}));
    }
  );
};
function Me$1(a) {
  let e = a.type;
  return typeof e == "function"
    ? e(a.props)
    : "render" in e
      ? e.render(a.props)
      : a;
}
function B({ asChild: a, children: e }, f) {
  return a && reactExports.isValidElement(e)
    ? reactExports.cloneElement(Me$1(e), { ref: e.ref }, f(e.props.children))
    : f(e);
}
var Te$1 = {
  position: "absolute",
  width: "1px",
  height: "1px",
  padding: "0",
  margin: "-1px",
  overflow: "hidden",
  clip: "rect(0, 0, 0, 0)",
  whiteSpace: "nowrap",
  borderWidth: "0",
};
const Dialog = Root$4,
  DialogTrigger = Trigger$3,
  DialogPortal = Portal$2,
  DialogOverlay = reactExports.forwardRef(({ className: a, ...e }, f) =>
    jsxRuntimeExports.jsx(Overlay, {
      ref: f,
      className: cn(
        "fixed inset-0 z-50 bg-black/80 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
        a,
      ),
      ...e,
    }),
  );
DialogOverlay.displayName = Overlay.displayName;
const DialogContent = reactExports.forwardRef(
  ({ className: a, children: e, ...f }, _) =>
    jsxRuntimeExports.jsxs(DialogPortal, {
      children: [
        jsxRuntimeExports.jsx(DialogOverlay, {}),
        jsxRuntimeExports.jsxs(Content$1, {
          ref: _,
          className: cn(
            "fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border bg-background p-6 duration-150 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg",
            a,
          ),
          ...f,
          children: [
            e,
            jsxRuntimeExports.jsxs(Close, {
              className:
                "absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-accent data-[state=open]:text-muted-foreground",
              children: [
                jsxRuntimeExports.jsx(X$1, { className: "h-4 w-4" }),
                jsxRuntimeExports.jsx("span", {
                  className: "sr-only",
                  children: "Close",
                }),
              ],
            }),
          ],
        }),
      ],
    }),
);
DialogContent.displayName = Content$1.displayName;
const DialogTitle = reactExports.forwardRef(({ className: a, ...e }, f) =>
  jsxRuntimeExports.jsx(Title, {
    ref: f,
    className: cn("text-lg font-semibold leading-none tracking-tight", a),
    ...e,
  }),
);
DialogTitle.displayName = Title.displayName;
const DialogDescription = reactExports.forwardRef(({ className: a, ...e }, f) =>
  jsxRuntimeExports.jsx(Description, {
    ref: f,
    className: cn("text-sm text-muted-foreground", a),
    ...e,
  }),
);
DialogDescription.displayName = Description.displayName;
const Command = reactExports.forwardRef(({ className: a, ...e }, f) =>
  jsxRuntimeExports.jsx(_e, {
    ref: f,
    className: cn(
      "flex h-full w-full flex-col overflow-hidden rounded-md bg-popover text-popover-foreground",
      a,
    ),
    ...e,
  }),
);
Command.displayName = _e.displayName;
const CommandInput = reactExports.forwardRef(({ className: a, ...e }, f) =>
  jsxRuntimeExports.jsxs("div", {
    className: "flex items-center border-b px-3",
    "cmdk-input-wrapper": "",
    children: [
      jsxRuntimeExports.jsx(Search, {
        className: "mr-2 h-4 w-4 shrink-0 opacity-50",
      }),
      jsxRuntimeExports.jsx(_e.Input, {
        ref: f,
        className: cn(
          "flex h-11 w-full rounded-md bg-transparent py-3 text-sm outline-none placeholder:text-muted-foreground disabled:cursor-not-allowed disabled:opacity-50",
          a,
        ),
        ...e,
      }),
    ],
  }),
);
CommandInput.displayName = _e.Input.displayName;
const CommandList = reactExports.forwardRef(({ className: a, ...e }, f) =>
  jsxRuntimeExports.jsx(_e.List, {
    ref: f,
    className: cn("max-h-[300px] overflow-y-auto overflow-x-hidden", a),
    ...e,
  }),
);
CommandList.displayName = _e.List.displayName;
const CommandEmpty = reactExports.forwardRef((a, e) =>
  jsxRuntimeExports.jsx(_e.Empty, {
    ref: e,
    className: "py-6 text-center text-sm",
    ...a,
  }),
);
CommandEmpty.displayName = _e.Empty.displayName;
const CommandGroup = reactExports.forwardRef(({ className: a, ...e }, f) =>
  jsxRuntimeExports.jsx(_e.Group, {
    ref: f,
    className: cn(
      "overflow-hidden p-1 text-foreground [&_[cmdk-group-heading]]:px-2 [&_[cmdk-group-heading]]:py-1.5 [&_[cmdk-group-heading]]:text-xs [&_[cmdk-group-heading]]:font-medium [&_[cmdk-group-heading]]:text-muted-foreground",
      a,
    ),
    ...e,
  }),
);
CommandGroup.displayName = _e.Group.displayName;
const CommandSeparator = reactExports.forwardRef(({ className: a, ...e }, f) =>
  jsxRuntimeExports.jsx(_e.Separator, {
    ref: f,
    className: cn("-mx-1 h-px bg-border", a),
    ...e,
  }),
);
CommandSeparator.displayName = _e.Separator.displayName;
const CommandItem = reactExports.forwardRef(({ className: a, ...e }, f) =>
  jsxRuntimeExports.jsx(_e.Item, {
    ref: f,
    className: cn(
      "relative flex cursor-default gap-2 select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none data-[disabled=true]:pointer-events-none data-[selected='true']:bg-accent data-[selected=true]:text-accent-foreground data-[disabled=true]:opacity-50 [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0",
      a,
    ),
    ...e,
  }),
);
CommandItem.displayName = _e.Item.displayName;
const ModelSelector = (a) => jsxRuntimeExports.jsx(Dialog, { ...a }),
  ModelSelectorTrigger = (a) => jsxRuntimeExports.jsx(DialogTrigger, { ...a }),
  ModelSelectorContent = ({
    className: a,
    children: e,
    title: f = "Model Selector",
    ..._
  }) =>
    jsxRuntimeExports.jsxs(DialogContent, {
      className: cn("p-0", a),
      ..._,
      children: [
        jsxRuntimeExports.jsx(DialogTitle, {
          className: "sr-only",
          children: f,
        }),
        jsxRuntimeExports.jsx(Command, {
          className: "**:data-[slot=command-input-wrapper]:h-auto",
          children: e,
        }),
      ],
    }),
  ModelSelectorInput = ({ className: a, ...e }) =>
    jsxRuntimeExports.jsx(CommandInput, {
      className: cn("h-auto py-3.5", a),
      ...e,
    }),
  ModelSelectorList = (a) => jsxRuntimeExports.jsx(CommandList, { ...a }),
  ModelSelectorGroup = (a) => jsxRuntimeExports.jsx(CommandGroup, { ...a }),
  ModelSelectorItem = (a) => jsxRuntimeExports.jsx(CommandItem, { ...a }),
  ModelSelectorName = ({ className: a, ...e }) =>
    jsxRuntimeExports.jsx("span", {
      className: cn("flex-1 truncate text-left", a),
      ...e,
    });
function clamp(a, [e, f]) {
  return Math.min(f, Math.max(e, a));
}
function createSlot$2(a) {
  const e = createSlotClone$2(a),
    f = reactExports.forwardRef((_, w) => {
      const { children: v, ...S } = _,
        R = reactExports.Children.toArray(v),
        O = R.find(isSlottable$2);
      if (O) {
        const j = O.props.children,
          F = R.map((q) =>
            q === O
              ? reactExports.Children.count(j) > 1
                ? reactExports.Children.only(null)
                : reactExports.isValidElement(j)
                  ? j.props.children
                  : null
              : q,
          );
        return jsxRuntimeExports.jsx(e, {
          ...S,
          ref: w,
          children: reactExports.isValidElement(j)
            ? reactExports.cloneElement(j, void 0, F)
            : null,
        });
      }
      return jsxRuntimeExports.jsx(e, { ...S, ref: w, children: v });
    });
  return ((f.displayName = `${a}.Slot`), f);
}
function createSlotClone$2(a) {
  const e = reactExports.forwardRef((f, _) => {
    const { children: w, ...v } = f;
    if (reactExports.isValidElement(w)) {
      const S = getElementRef$2(w),
        R = mergeProps$2(v, w.props);
      return (
        w.type !== reactExports.Fragment && (R.ref = _ ? composeRefs(_, S) : S),
        reactExports.cloneElement(w, R)
      );
    }
    return reactExports.Children.count(w) > 1
      ? reactExports.Children.only(null)
      : null;
  });
  return ((e.displayName = `${a}.SlotClone`), e);
}
var SLOTTABLE_IDENTIFIER$2 = Symbol("radix.slottable");
function isSlottable$2(a) {
  return (
    reactExports.isValidElement(a) &&
    typeof a.type == "function" &&
    "__radixId" in a.type &&
    a.type.__radixId === SLOTTABLE_IDENTIFIER$2
  );
}
function mergeProps$2(a, e) {
  const f = { ...e };
  for (const _ in e) {
    const w = a[_],
      v = e[_];
    /^on[A-Z]/.test(_)
      ? w && v
        ? (f[_] = (...R) => {
            const O = v(...R);
            return (w(...R), O);
          })
        : w && (f[_] = w)
      : _ === "style"
        ? (f[_] = { ...w, ...v })
        : _ === "className" && (f[_] = [w, v].filter(Boolean).join(" "));
  }
  return { ...a, ...f };
}
function getElementRef$2(a) {
  let e = Object.getOwnPropertyDescriptor(a.props, "ref")?.get,
    f = e && "isReactWarning" in e && e.isReactWarning;
  return f
    ? a.ref
    : ((e = Object.getOwnPropertyDescriptor(a, "ref")?.get),
      (f = e && "isReactWarning" in e && e.isReactWarning),
      f ? a.props.ref : a.props.ref || a.ref);
}
function createCollection(a) {
  const e = a + "CollectionProvider",
    [f, _] = createContextScope(e),
    [w, v] = f(e, { collectionRef: { current: null }, itemMap: new Map() }),
    S = (re) => {
      const { scope: Oe, children: Le } = re,
        Be = React2.useRef(null),
        Ve = React2.useRef(new Map()).current;
      return jsxRuntimeExports.jsx(w, {
        scope: Oe,
        itemMap: Ve,
        collectionRef: Be,
        children: Le,
      });
    };
  S.displayName = e;
  const R = a + "CollectionSlot",
    O = createSlot$2(R),
    j = React2.forwardRef((re, Oe) => {
      const { scope: Le, children: Be } = re,
        Ve = v(R, Le),
        ze = useComposedRefs(Oe, Ve.collectionRef);
      return jsxRuntimeExports.jsx(O, { ref: ze, children: Be });
    });
  j.displayName = R;
  const F = a + "CollectionItemSlot",
    q = "data-radix-collection-item",
    Q = createSlot$2(F),
    te = React2.forwardRef((re, Oe) => {
      const { scope: Le, children: Be, ...Ve } = re,
        ze = React2.useRef(null),
        Ge = useComposedRefs(Oe, ze),
        Ke = v(F, Le);
      return (
        React2.useEffect(
          () => (
            Ke.itemMap.set(ze, { ref: ze, ...Ve }),
            () => void Ke.itemMap.delete(ze)
          ),
        ),
        jsxRuntimeExports.jsx(Q, { [q]: "", ref: Ge, children: Be })
      );
    });
  te.displayName = F;
  function se(re) {
    const Oe = v(a + "CollectionConsumer", re);
    return React2.useCallback(() => {
      const Be = Oe.collectionRef.current;
      if (!Be) return [];
      const Ve = Array.from(Be.querySelectorAll(`[${q}]`));
      return Array.from(Oe.itemMap.values()).sort(
        (Ke, qe) => Ve.indexOf(Ke.ref.current) - Ve.indexOf(qe.ref.current),
      );
    }, [Oe.collectionRef, Oe.itemMap]);
  }
  return [{ Provider: S, Slot: j, ItemSlot: te }, se, _];
}
var DirectionContext = reactExports.createContext(void 0);
function useDirection(a) {
  const e = reactExports.useContext(DirectionContext);
  return a || e || "ltr";
}
function createSlot$1(a) {
  const e = createSlotClone$1(a),
    f = reactExports.forwardRef((_, w) => {
      const { children: v, ...S } = _,
        R = reactExports.Children.toArray(v),
        O = R.find(isSlottable$1);
      if (O) {
        const j = O.props.children,
          F = R.map((q) =>
            q === O
              ? reactExports.Children.count(j) > 1
                ? reactExports.Children.only(null)
                : reactExports.isValidElement(j)
                  ? j.props.children
                  : null
              : q,
          );
        return jsxRuntimeExports.jsx(e, {
          ...S,
          ref: w,
          children: reactExports.isValidElement(j)
            ? reactExports.cloneElement(j, void 0, F)
            : null,
        });
      }
      return jsxRuntimeExports.jsx(e, { ...S, ref: w, children: v });
    });
  return ((f.displayName = `${a}.Slot`), f);
}
function createSlotClone$1(a) {
  const e = reactExports.forwardRef((f, _) => {
    const { children: w, ...v } = f;
    if (reactExports.isValidElement(w)) {
      const S = getElementRef$1(w),
        R = mergeProps$1(v, w.props);
      return (
        w.type !== reactExports.Fragment && (R.ref = _ ? composeRefs(_, S) : S),
        reactExports.cloneElement(w, R)
      );
    }
    return reactExports.Children.count(w) > 1
      ? reactExports.Children.only(null)
      : null;
  });
  return ((e.displayName = `${a}.SlotClone`), e);
}
var SLOTTABLE_IDENTIFIER$1 = Symbol("radix.slottable");
function isSlottable$1(a) {
  return (
    reactExports.isValidElement(a) &&
    typeof a.type == "function" &&
    "__radixId" in a.type &&
    a.type.__radixId === SLOTTABLE_IDENTIFIER$1
  );
}
function mergeProps$1(a, e) {
  const f = { ...e };
  for (const _ in e) {
    const w = a[_],
      v = e[_];
    /^on[A-Z]/.test(_)
      ? w && v
        ? (f[_] = (...R) => {
            const O = v(...R);
            return (w(...R), O);
          })
        : w && (f[_] = w)
      : _ === "style"
        ? (f[_] = { ...w, ...v })
        : _ === "className" && (f[_] = [w, v].filter(Boolean).join(" "));
  }
  return { ...a, ...f };
}
function getElementRef$1(a) {
  let e = Object.getOwnPropertyDescriptor(a.props, "ref")?.get,
    f = e && "isReactWarning" in e && e.isReactWarning;
  return f
    ? a.ref
    : ((e = Object.getOwnPropertyDescriptor(a, "ref")?.get),
      (f = e && "isReactWarning" in e && e.isReactWarning),
      f ? a.props.ref : a.props.ref || a.ref);
}
function usePrevious(a) {
  const e = reactExports.useRef({ value: a, previous: a });
  return reactExports.useMemo(
    () => (
      e.current.value !== a &&
        ((e.current.previous = e.current.value), (e.current.value = a)),
      e.current.previous
    ),
    [a],
  );
}
var OPEN_KEYS = [" ", "Enter", "ArrowUp", "ArrowDown"],
  SELECTION_KEYS$1 = [" ", "Enter"],
  SELECT_NAME = "Select",
  [Collection$2, useCollection$2, createCollectionScope$2] =
    createCollection(SELECT_NAME),
  [createSelectContext] = createContextScope(SELECT_NAME, [
    createCollectionScope$2,
    createPopperScope,
  ]),
  usePopperScope$1 = createPopperScope(),
  [SelectProvider, useSelectContext] = createSelectContext(SELECT_NAME),
  [SelectNativeOptionsProvider, useSelectNativeOptionsContext] =
    createSelectContext(SELECT_NAME),
  TRIGGER_NAME$1 = "SelectTrigger",
  SelectTrigger$1 = reactExports.forwardRef((a, e) => {
    const { __scopeSelect: f, disabled: _ = !1, ...w } = a,
      v = usePopperScope$1(f),
      S = useSelectContext(TRIGGER_NAME$1, f),
      R = S.disabled || _,
      O = useComposedRefs(e, S.onTriggerChange),
      j = useCollection$2(f),
      F = reactExports.useRef("touch"),
      [q, Q, te] = useTypeaheadSearch((re) => {
        const Oe = j().filter((Ve) => !Ve.disabled),
          Le = Oe.find((Ve) => Ve.value === S.value),
          Be = findNextItem(Oe, re, Le);
        Be !== void 0 && S.onValueChange(Be.value);
      }),
      se = (re) => {
        (R || (S.onOpenChange(!0), te()),
          re &&
            (S.triggerPointerDownPosRef.current = {
              x: Math.round(re.pageX),
              y: Math.round(re.pageY),
            }));
      };
    return jsxRuntimeExports.jsx(Anchor, {
      asChild: !0,
      ...v,
      children: jsxRuntimeExports.jsx(Primitive$1.button, {
        type: "button",
        role: "combobox",
        "aria-controls": S.contentId,
        "aria-expanded": S.open,
        "aria-required": S.required,
        "aria-autocomplete": "none",
        dir: S.dir,
        "data-state": S.open ? "open" : "closed",
        disabled: R,
        "data-disabled": R ? "" : void 0,
        "data-placeholder": shouldShowPlaceholder(S.value) ? "" : void 0,
        ...w,
        ref: O,
        onClick: composeEventHandlers(w.onClick, (re) => {
          (re.currentTarget.focus(), F.current !== "mouse" && se(re));
        }),
        onPointerDown: composeEventHandlers(w.onPointerDown, (re) => {
          F.current = re.pointerType;
          const Oe = re.target;
          (Oe.hasPointerCapture(re.pointerId) &&
            Oe.releasePointerCapture(re.pointerId),
            re.button === 0 &&
              re.ctrlKey === !1 &&
              re.pointerType === "mouse" &&
              (se(re), re.preventDefault()));
        }),
        onKeyDown: composeEventHandlers(w.onKeyDown, (re) => {
          const Oe = q.current !== "";
          (!(re.ctrlKey || re.altKey || re.metaKey) &&
            re.key.length === 1 &&
            Q(re.key),
            !(Oe && re.key === " ") &&
              OPEN_KEYS.includes(re.key) &&
              (se(), re.preventDefault()));
        }),
      }),
    });
  });
SelectTrigger$1.displayName = TRIGGER_NAME$1;
var VALUE_NAME = "SelectValue",
  SelectValue = reactExports.forwardRef((a, e) => {
    const {
        __scopeSelect: f,
        className: _,
        style: w,
        children: v,
        placeholder: S = "",
        ...R
      } = a,
      O = useSelectContext(VALUE_NAME, f),
      { onValueNodeHasChildrenChange: j } = O,
      F = v !== void 0,
      q = useComposedRefs(e, O.onValueNodeChange);
    return (
      useLayoutEffect2(() => {
        j(F);
      }, [j, F]),
      jsxRuntimeExports.jsx(Primitive$1.span, {
        ...R,
        ref: q,
        style: { pointerEvents: "none" },
        children: shouldShowPlaceholder(O.value)
          ? jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: S })
          : v,
      })
    );
  });
SelectValue.displayName = VALUE_NAME;
var ICON_NAME = "SelectIcon",
  SelectIcon = reactExports.forwardRef((a, e) => {
    const { __scopeSelect: f, children: _, ...w } = a;
    return jsxRuntimeExports.jsx(Primitive$1.span, {
      "aria-hidden": !0,
      ...w,
      ref: e,
      children: _ || "",
    });
  });
SelectIcon.displayName = ICON_NAME;
var PORTAL_NAME$2 = "SelectPortal",
  SelectPortal = (a) => jsxRuntimeExports.jsx(Portal$3, { asChild: !0, ...a });
SelectPortal.displayName = PORTAL_NAME$2;
var CONTENT_NAME$2 = "SelectContent",
  SelectContent$1 = reactExports.forwardRef((a, e) => {
    const f = useSelectContext(CONTENT_NAME$2, a.__scopeSelect),
      [_, w] = reactExports.useState();
    if (
      (useLayoutEffect2(() => {
        w(new DocumentFragment());
      }, []),
      !f.open)
    ) {
      const v = _;
      return v
        ? reactDomExports.createPortal(
            jsxRuntimeExports.jsx(SelectContentProvider, {
              scope: a.__scopeSelect,
              children: jsxRuntimeExports.jsx(Collection$2.Slot, {
                scope: a.__scopeSelect,
                children: jsxRuntimeExports.jsx("div", {
                  children: a.children,
                }),
              }),
            }),
            v,
          )
        : null;
    }
    return jsxRuntimeExports.jsx(SelectContentImpl, { ...a, ref: e });
  });
SelectContent$1.displayName = CONTENT_NAME$2;
var CONTENT_MARGIN = 10,
  [SelectContentProvider, useSelectContentContext] =
    createSelectContext(CONTENT_NAME$2),
  CONTENT_IMPL_NAME = "SelectContentImpl",
  Slot$1 = createSlot$1("SelectContent.RemoveScroll"),
  SelectContentImpl = reactExports.forwardRef((a, e) => {
    const {
        __scopeSelect: f,
        position: _ = "item-aligned",
        onCloseAutoFocus: w,
        onEscapeKeyDown: v,
        onPointerDownOutside: S,
        side: R,
        sideOffset: O,
        align: j,
        alignOffset: F,
        arrowPadding: q,
        collisionBoundary: Q,
        collisionPadding: te,
        sticky: se,
        hideWhenDetached: re,
        avoidCollisions: Oe,
        ...Le
      } = a,
      Be = useSelectContext(CONTENT_NAME$2, f),
      [Ve, ze] = reactExports.useState(null),
      [Ge, Ke] = reactExports.useState(null),
      qe = useComposedRefs(e, (it) => ze(it)),
      [nt, pt] = reactExports.useState(null),
      [gt, mt] = reactExports.useState(null),
      dt = useCollection$2(f),
      [_t, bt] = reactExports.useState(!1),
      at = reactExports.useRef(!1);
    (reactExports.useEffect(() => {
      if (Ve) return hideOthers(Ve);
    }, [Ve]),
      useFocusGuards());
    const $e = reactExports.useCallback(
        (it) => {
          const [Et, ...xt] = dt().map((Vt) => Vt.ref.current),
            [At] = xt.slice(-1),
            Lt = document.activeElement;
          for (const Vt of it)
            if (
              Vt === Lt ||
              (Vt?.scrollIntoView({ block: "nearest" }),
              Vt === Et && Ge && (Ge.scrollTop = 0),
              Vt === At && Ge && (Ge.scrollTop = Ge.scrollHeight),
              Vt?.focus(),
              document.activeElement !== Lt)
            )
              return;
        },
        [dt, Ge],
      ),
      Ye = reactExports.useCallback(() => $e([nt, Ve]), [$e, nt, Ve]);
    reactExports.useEffect(() => {
      _t && Ye();
    }, [_t, Ye]);
    const { onOpenChange: Qe, triggerPointerDownPosRef: tt } = Be;
    (reactExports.useEffect(() => {
      if (Ve) {
        let it = { x: 0, y: 0 };
        const Et = (At) => {
            it = {
              x: Math.abs(Math.round(At.pageX) - (tt.current?.x ?? 0)),
              y: Math.abs(Math.round(At.pageY) - (tt.current?.y ?? 0)),
            };
          },
          xt = (At) => {
            (it.x <= 10 && it.y <= 10
              ? At.preventDefault()
              : Ve.contains(At.target) || Qe(!1),
              document.removeEventListener("pointermove", Et),
              (tt.current = null));
          };
        return (
          tt.current !== null &&
            (document.addEventListener("pointermove", Et),
            document.addEventListener("pointerup", xt, {
              capture: !0,
              once: !0,
            })),
          () => {
            (document.removeEventListener("pointermove", Et),
              document.removeEventListener("pointerup", xt, { capture: !0 }));
          }
        );
      }
    }, [Ve, Qe, tt]),
      reactExports.useEffect(() => {
        const it = () => Qe(!1);
        return (
          window.addEventListener("blur", it),
          window.addEventListener("resize", it),
          () => {
            (window.removeEventListener("blur", it),
              window.removeEventListener("resize", it));
          }
        );
      }, [Qe]));
    const [ht, Fe] = useTypeaheadSearch((it) => {
        const Et = dt().filter((Lt) => !Lt.disabled),
          xt = Et.find((Lt) => Lt.ref.current === document.activeElement),
          At = findNextItem(Et, it, xt);
        At && setTimeout(() => At.ref.current.focus());
      }),
      Ue = reactExports.useCallback(
        (it, Et, xt) => {
          const At = !at.current && !xt;
          ((Be.value !== void 0 && Be.value === Et) || At) &&
            (pt(it), At && (at.current = !0));
        },
        [Be.value],
      ),
      ot = reactExports.useCallback(() => Ve?.focus(), [Ve]),
      lt = reactExports.useCallback(
        (it, Et, xt) => {
          const At = !at.current && !xt;
          ((Be.value !== void 0 && Be.value === Et) || At) && mt(it);
        },
        [Be.value],
      ),
      ut = _ === "popper" ? SelectPopperPosition : SelectItemAlignedPosition,
      yt =
        ut === SelectPopperPosition
          ? {
              side: R,
              sideOffset: O,
              align: j,
              alignOffset: F,
              arrowPadding: q,
              collisionBoundary: Q,
              collisionPadding: te,
              sticky: se,
              hideWhenDetached: re,
              avoidCollisions: Oe,
            }
          : {};
    return jsxRuntimeExports.jsx(SelectContentProvider, {
      scope: f,
      content: Ve,
      viewport: Ge,
      onViewportChange: Ke,
      itemRefCallback: Ue,
      selectedItem: nt,
      onItemLeave: ot,
      itemTextRefCallback: lt,
      focusSelectedItem: Ye,
      selectedItemText: gt,
      position: _,
      isPositioned: _t,
      searchRef: ht,
      children: jsxRuntimeExports.jsx(ReactRemoveScroll, {
        as: Slot$1,
        allowPinchZoom: !0,
        children: jsxRuntimeExports.jsx(FocusScope, {
          asChild: !0,
          trapped: Be.open,
          onMountAutoFocus: (it) => {
            it.preventDefault();
          },
          onUnmountAutoFocus: composeEventHandlers(w, (it) => {
            (Be.trigger?.focus({ preventScroll: !0 }), it.preventDefault());
          }),
          children: jsxRuntimeExports.jsx(DismissableLayer, {
            asChild: !0,
            disableOutsidePointerEvents: !0,
            onEscapeKeyDown: v,
            onPointerDownOutside: S,
            onFocusOutside: (it) => it.preventDefault(),
            onDismiss: () => Be.onOpenChange(!1),
            children: jsxRuntimeExports.jsx(ut, {
              role: "listbox",
              id: Be.contentId,
              "data-state": Be.open ? "open" : "closed",
              dir: Be.dir,
              onContextMenu: (it) => it.preventDefault(),
              ...Le,
              ...yt,
              onPlaced: () => bt(!0),
              ref: qe,
              style: {
                display: "flex",
                flexDirection: "column",
                outline: "none",
                ...Le.style,
              },
              onKeyDown: composeEventHandlers(Le.onKeyDown, (it) => {
                const Et = it.ctrlKey || it.altKey || it.metaKey;
                if (
                  (it.key === "Tab" && it.preventDefault(),
                  !Et && it.key.length === 1 && Fe(it.key),
                  ["ArrowUp", "ArrowDown", "Home", "End"].includes(it.key))
                ) {
                  let At = dt()
                    .filter((Lt) => !Lt.disabled)
                    .map((Lt) => Lt.ref.current);
                  if (
                    (["ArrowUp", "End"].includes(it.key) &&
                      (At = At.slice().reverse()),
                    ["ArrowUp", "ArrowDown"].includes(it.key))
                  ) {
                    const Lt = it.target,
                      Vt = At.indexOf(Lt);
                    At = At.slice(Vt + 1);
                  }
                  (setTimeout(() => $e(At)), it.preventDefault());
                }
              }),
            }),
          }),
        }),
      }),
    });
  });
SelectContentImpl.displayName = CONTENT_IMPL_NAME;
var ITEM_ALIGNED_POSITION_NAME = "SelectItemAlignedPosition",
  SelectItemAlignedPosition = reactExports.forwardRef((a, e) => {
    const { __scopeSelect: f, onPlaced: _, ...w } = a,
      v = useSelectContext(CONTENT_NAME$2, f),
      S = useSelectContentContext(CONTENT_NAME$2, f),
      [R, O] = reactExports.useState(null),
      [j, F] = reactExports.useState(null),
      q = useComposedRefs(e, (qe) => F(qe)),
      Q = useCollection$2(f),
      te = reactExports.useRef(!1),
      se = reactExports.useRef(!0),
      {
        viewport: re,
        selectedItem: Oe,
        selectedItemText: Le,
        focusSelectedItem: Be,
      } = S,
      Ve = reactExports.useCallback(() => {
        if (v.trigger && v.valueNode && R && j && re && Oe && Le) {
          const qe = v.trigger.getBoundingClientRect(),
            nt = j.getBoundingClientRect(),
            pt = v.valueNode.getBoundingClientRect(),
            gt = Le.getBoundingClientRect();
          if (v.dir !== "rtl") {
            const Lt = gt.left - nt.left,
              Vt = pt.left - Lt,
              Yt = qe.left - Vt,
              Zt = qe.width + Yt,
              gn = Math.max(Zt, nt.width),
              Wn = window.innerWidth - CONTENT_MARGIN,
              Ho = clamp(Vt, [
                CONTENT_MARGIN,
                Math.max(CONTENT_MARGIN, Wn - gn),
              ]);
            ((R.style.minWidth = Zt + "px"), (R.style.left = Ho + "px"));
          } else {
            const Lt = nt.right - gt.right,
              Vt = window.innerWidth - pt.right - Lt,
              Yt = window.innerWidth - qe.right - Vt,
              Zt = qe.width + Yt,
              gn = Math.max(Zt, nt.width),
              Wn = window.innerWidth - CONTENT_MARGIN,
              Ho = clamp(Vt, [
                CONTENT_MARGIN,
                Math.max(CONTENT_MARGIN, Wn - gn),
              ]);
            ((R.style.minWidth = Zt + "px"), (R.style.right = Ho + "px"));
          }
          const mt = Q(),
            dt = window.innerHeight - CONTENT_MARGIN * 2,
            _t = re.scrollHeight,
            bt = window.getComputedStyle(j),
            at = parseInt(bt.borderTopWidth, 10),
            $e = parseInt(bt.paddingTop, 10),
            Ye = parseInt(bt.borderBottomWidth, 10),
            Qe = parseInt(bt.paddingBottom, 10),
            tt = at + $e + _t + Qe + Ye,
            ht = Math.min(Oe.offsetHeight * 5, tt),
            Fe = window.getComputedStyle(re),
            Ue = parseInt(Fe.paddingTop, 10),
            ot = parseInt(Fe.paddingBottom, 10),
            lt = qe.top + qe.height / 2 - CONTENT_MARGIN,
            ut = dt - lt,
            yt = Oe.offsetHeight / 2,
            it = Oe.offsetTop + yt,
            Et = at + $e + it,
            xt = tt - Et;
          if (Et <= lt) {
            const Lt = mt.length > 0 && Oe === mt[mt.length - 1].ref.current;
            R.style.bottom = "0px";
            const Vt = j.clientHeight - re.offsetTop - re.offsetHeight,
              Yt = Math.max(ut, yt + (Lt ? ot : 0) + Vt + Ye),
              Zt = Et + Yt;
            R.style.height = Zt + "px";
          } else {
            const Lt = mt.length > 0 && Oe === mt[0].ref.current;
            R.style.top = "0px";
            const Yt =
              Math.max(lt, at + re.offsetTop + (Lt ? Ue : 0) + yt) + xt;
            ((R.style.height = Yt + "px"),
              (re.scrollTop = Et - lt + re.offsetTop));
          }
          ((R.style.margin = `${CONTENT_MARGIN}px 0`),
            (R.style.minHeight = ht + "px"),
            (R.style.maxHeight = dt + "px"),
            _?.(),
            requestAnimationFrame(() => (te.current = !0)));
        }
      }, [Q, v.trigger, v.valueNode, R, j, re, Oe, Le, v.dir, _]);
    useLayoutEffect2(() => Ve(), [Ve]);
    const [ze, Ge] = reactExports.useState();
    useLayoutEffect2(() => {
      j && Ge(window.getComputedStyle(j).zIndex);
    }, [j]);
    const Ke = reactExports.useCallback(
      (qe) => {
        qe && se.current === !0 && (Ve(), Be?.(), (se.current = !1));
      },
      [Ve, Be],
    );
    return jsxRuntimeExports.jsx(SelectViewportProvider, {
      scope: f,
      contentWrapper: R,
      shouldExpandOnScrollRef: te,
      onScrollButtonChange: Ke,
      children: jsxRuntimeExports.jsx("div", {
        ref: O,
        style: {
          display: "flex",
          flexDirection: "column",
          position: "fixed",
          zIndex: ze,
        },
        children: jsxRuntimeExports.jsx(Primitive$1.div, {
          ...w,
          ref: q,
          style: { boxSizing: "border-box", maxHeight: "100%", ...w.style },
        }),
      }),
    });
  });
SelectItemAlignedPosition.displayName = ITEM_ALIGNED_POSITION_NAME;
var POPPER_POSITION_NAME = "SelectPopperPosition",
  SelectPopperPosition = reactExports.forwardRef((a, e) => {
    const {
        __scopeSelect: f,
        align: _ = "start",
        collisionPadding: w = CONTENT_MARGIN,
        ...v
      } = a,
      S = usePopperScope$1(f);
    return jsxRuntimeExports.jsx(Content, {
      ...S,
      ...v,
      ref: e,
      align: _,
      collisionPadding: w,
      style: {
        boxSizing: "border-box",
        ...v.style,
        "--radix-select-content-transform-origin":
          "var(--radix-popper-transform-origin)",
        "--radix-select-content-available-width":
          "var(--radix-popper-available-width)",
        "--radix-select-content-available-height":
          "var(--radix-popper-available-height)",
        "--radix-select-trigger-width": "var(--radix-popper-anchor-width)",
        "--radix-select-trigger-height": "var(--radix-popper-anchor-height)",
      },
    });
  });
SelectPopperPosition.displayName = POPPER_POSITION_NAME;
var [SelectViewportProvider, useSelectViewportContext] = createSelectContext(
    CONTENT_NAME$2,
    {},
  ),
  VIEWPORT_NAME$1 = "SelectViewport",
  SelectViewport = reactExports.forwardRef((a, e) => {
    const { __scopeSelect: f, nonce: _, ...w } = a,
      v = useSelectContentContext(VIEWPORT_NAME$1, f),
      S = useSelectViewportContext(VIEWPORT_NAME$1, f),
      R = useComposedRefs(e, v.onViewportChange),
      O = reactExports.useRef(0);
    return jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
      children: [
        jsxRuntimeExports.jsx("style", {
          dangerouslySetInnerHTML: {
            __html:
              "[data-radix-select-viewport]{scrollbar-width:none;-ms-overflow-style:none;-webkit-overflow-scrolling:touch;}[data-radix-select-viewport]::-webkit-scrollbar{display:none}",
          },
          nonce: _,
        }),
        jsxRuntimeExports.jsx(Collection$2.Slot, {
          scope: f,
          children: jsxRuntimeExports.jsx(Primitive$1.div, {
            "data-radix-select-viewport": "",
            role: "presentation",
            ...w,
            ref: R,
            style: {
              position: "relative",
              flex: 1,
              overflow: "hidden auto",
              ...w.style,
            },
            onScroll: composeEventHandlers(w.onScroll, (j) => {
              const F = j.currentTarget,
                { contentWrapper: q, shouldExpandOnScrollRef: Q } = S;
              if (Q?.current && q) {
                const te = Math.abs(O.current - F.scrollTop);
                if (te > 0) {
                  const se = window.innerHeight - CONTENT_MARGIN * 2,
                    re = parseFloat(q.style.minHeight),
                    Oe = parseFloat(q.style.height),
                    Le = Math.max(re, Oe);
                  if (Le < se) {
                    const Be = Le + te,
                      Ve = Math.min(se, Be),
                      ze = Be - Ve;
                    ((q.style.height = Ve + "px"),
                      q.style.bottom === "0px" &&
                        ((F.scrollTop = ze > 0 ? ze : 0),
                        (q.style.justifyContent = "flex-end")));
                  }
                }
              }
              O.current = F.scrollTop;
            }),
          }),
        }),
      ],
    });
  });
SelectViewport.displayName = VIEWPORT_NAME$1;
var GROUP_NAME$3 = "SelectGroup",
  [SelectGroupContextProvider, useSelectGroupContext] =
    createSelectContext(GROUP_NAME$3),
  SelectGroup = reactExports.forwardRef((a, e) => {
    const { __scopeSelect: f, ..._ } = a,
      w = useId();
    return jsxRuntimeExports.jsx(SelectGroupContextProvider, {
      scope: f,
      id: w,
      children: jsxRuntimeExports.jsx(Primitive$1.div, {
        role: "group",
        "aria-labelledby": w,
        ..._,
        ref: e,
      }),
    });
  });
SelectGroup.displayName = GROUP_NAME$3;
var LABEL_NAME$2 = "SelectLabel",
  SelectLabel$1 = reactExports.forwardRef((a, e) => {
    const { __scopeSelect: f, ..._ } = a,
      w = useSelectGroupContext(LABEL_NAME$2, f);
    return jsxRuntimeExports.jsx(Primitive$1.div, { id: w.id, ..._, ref: e });
  });
SelectLabel$1.displayName = LABEL_NAME$2;
var ITEM_NAME$3 = "SelectItem",
  [SelectItemContextProvider, useSelectItemContext] =
    createSelectContext(ITEM_NAME$3),
  SelectItem$1 = reactExports.forwardRef((a, e) => {
    const {
        __scopeSelect: f,
        value: _,
        disabled: w = !1,
        textValue: v,
        ...S
      } = a,
      R = useSelectContext(ITEM_NAME$3, f),
      O = useSelectContentContext(ITEM_NAME$3, f),
      j = R.value === _,
      [F, q] = reactExports.useState(v ?? ""),
      [Q, te] = reactExports.useState(!1),
      se = useComposedRefs(e, (Be) => O.itemRefCallback?.(Be, _, w)),
      re = useId(),
      Oe = reactExports.useRef("touch"),
      Le = () => {
        w || (R.onValueChange(_), R.onOpenChange(!1));
      };
    if (_ === "")
      throw new Error(
        "A <Select.Item /> must have a value prop that is not an empty string. This is because the Select value can be set to an empty string to clear the selection and show the placeholder.",
      );
    return jsxRuntimeExports.jsx(SelectItemContextProvider, {
      scope: f,
      value: _,
      disabled: w,
      textId: re,
      isSelected: j,
      onItemTextChange: reactExports.useCallback((Be) => {
        q((Ve) => Ve || (Be?.textContent ?? "").trim());
      }, []),
      children: jsxRuntimeExports.jsx(Collection$2.ItemSlot, {
        scope: f,
        value: _,
        disabled: w,
        textValue: F,
        children: jsxRuntimeExports.jsx(Primitive$1.div, {
          role: "option",
          "aria-labelledby": re,
          "data-highlighted": Q ? "" : void 0,
          "aria-selected": j && Q,
          "data-state": j ? "checked" : "unchecked",
          "aria-disabled": w || void 0,
          "data-disabled": w ? "" : void 0,
          tabIndex: w ? void 0 : -1,
          ...S,
          ref: se,
          onFocus: composeEventHandlers(S.onFocus, () => te(!0)),
          onBlur: composeEventHandlers(S.onBlur, () => te(!1)),
          onClick: composeEventHandlers(S.onClick, () => {
            Oe.current !== "mouse" && Le();
          }),
          onPointerUp: composeEventHandlers(S.onPointerUp, () => {
            Oe.current === "mouse" && Le();
          }),
          onPointerDown: composeEventHandlers(S.onPointerDown, (Be) => {
            Oe.current = Be.pointerType;
          }),
          onPointerMove: composeEventHandlers(S.onPointerMove, (Be) => {
            ((Oe.current = Be.pointerType),
              w
                ? O.onItemLeave?.()
                : Oe.current === "mouse" &&
                  Be.currentTarget.focus({ preventScroll: !0 }));
          }),
          onPointerLeave: composeEventHandlers(S.onPointerLeave, (Be) => {
            Be.currentTarget === document.activeElement && O.onItemLeave?.();
          }),
          onKeyDown: composeEventHandlers(S.onKeyDown, (Be) => {
            (O.searchRef?.current !== "" && Be.key === " ") ||
              (SELECTION_KEYS$1.includes(Be.key) && Le(),
              Be.key === " " && Be.preventDefault());
          }),
        }),
      }),
    });
  });
SelectItem$1.displayName = ITEM_NAME$3;
var ITEM_TEXT_NAME = "SelectItemText",
  SelectItemText = reactExports.forwardRef((a, e) => {
    const { __scopeSelect: f, className: _, style: w, ...v } = a,
      S = useSelectContext(ITEM_TEXT_NAME, f),
      R = useSelectContentContext(ITEM_TEXT_NAME, f),
      O = useSelectItemContext(ITEM_TEXT_NAME, f),
      j = useSelectNativeOptionsContext(ITEM_TEXT_NAME, f),
      [F, q] = reactExports.useState(null),
      Q = useComposedRefs(
        e,
        (Le) => q(Le),
        O.onItemTextChange,
        (Le) => R.itemTextRefCallback?.(Le, O.value, O.disabled),
      ),
      te = F?.textContent,
      se = reactExports.useMemo(
        () =>
          jsxRuntimeExports.jsx(
            "option",
            { value: O.value, disabled: O.disabled, children: te },
            O.value,
          ),
        [O.disabled, O.value, te],
      ),
      { onNativeOptionAdd: re, onNativeOptionRemove: Oe } = j;
    return (
      useLayoutEffect2(() => (re(se), () => Oe(se)), [re, Oe, se]),
      jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
        children: [
          jsxRuntimeExports.jsx(Primitive$1.span, {
            id: O.textId,
            ...v,
            ref: Q,
          }),
          O.isSelected && S.valueNode && !S.valueNodeHasChildren
            ? reactDomExports.createPortal(v.children, S.valueNode)
            : null,
        ],
      })
    );
  });
SelectItemText.displayName = ITEM_TEXT_NAME;
var ITEM_INDICATOR_NAME$1 = "SelectItemIndicator",
  SelectItemIndicator = reactExports.forwardRef((a, e) => {
    const { __scopeSelect: f, ..._ } = a;
    return useSelectItemContext(ITEM_INDICATOR_NAME$1, f).isSelected
      ? jsxRuntimeExports.jsx(Primitive$1.span, {
          "aria-hidden": !0,
          ..._,
          ref: e,
        })
      : null;
  });
SelectItemIndicator.displayName = ITEM_INDICATOR_NAME$1;
var SCROLL_UP_BUTTON_NAME = "SelectScrollUpButton",
  SelectScrollUpButton$1 = reactExports.forwardRef((a, e) => {
    const f = useSelectContentContext(SCROLL_UP_BUTTON_NAME, a.__scopeSelect),
      _ = useSelectViewportContext(SCROLL_UP_BUTTON_NAME, a.__scopeSelect),
      [w, v] = reactExports.useState(!1),
      S = useComposedRefs(e, _.onScrollButtonChange);
    return (
      useLayoutEffect2(() => {
        if (f.viewport && f.isPositioned) {
          let R = function () {
            const j = O.scrollTop > 0;
            v(j);
          };
          const O = f.viewport;
          return (
            R(),
            O.addEventListener("scroll", R),
            () => O.removeEventListener("scroll", R)
          );
        }
      }, [f.viewport, f.isPositioned]),
      w
        ? jsxRuntimeExports.jsx(SelectScrollButtonImpl, {
            ...a,
            ref: S,
            onAutoScroll: () => {
              const { viewport: R, selectedItem: O } = f;
              R && O && (R.scrollTop = R.scrollTop - O.offsetHeight);
            },
          })
        : null
    );
  });
SelectScrollUpButton$1.displayName = SCROLL_UP_BUTTON_NAME;
var SCROLL_DOWN_BUTTON_NAME = "SelectScrollDownButton",
  SelectScrollDownButton$1 = reactExports.forwardRef((a, e) => {
    const f = useSelectContentContext(SCROLL_DOWN_BUTTON_NAME, a.__scopeSelect),
      _ = useSelectViewportContext(SCROLL_DOWN_BUTTON_NAME, a.__scopeSelect),
      [w, v] = reactExports.useState(!1),
      S = useComposedRefs(e, _.onScrollButtonChange);
    return (
      useLayoutEffect2(() => {
        if (f.viewport && f.isPositioned) {
          let R = function () {
            const j = O.scrollHeight - O.clientHeight,
              F = Math.ceil(O.scrollTop) < j;
            v(F);
          };
          const O = f.viewport;
          return (
            R(),
            O.addEventListener("scroll", R),
            () => O.removeEventListener("scroll", R)
          );
        }
      }, [f.viewport, f.isPositioned]),
      w
        ? jsxRuntimeExports.jsx(SelectScrollButtonImpl, {
            ...a,
            ref: S,
            onAutoScroll: () => {
              const { viewport: R, selectedItem: O } = f;
              R && O && (R.scrollTop = R.scrollTop + O.offsetHeight);
            },
          })
        : null
    );
  });
SelectScrollDownButton$1.displayName = SCROLL_DOWN_BUTTON_NAME;
var SelectScrollButtonImpl = reactExports.forwardRef((a, e) => {
    const { __scopeSelect: f, onAutoScroll: _, ...w } = a,
      v = useSelectContentContext("SelectScrollButton", f),
      S = reactExports.useRef(null),
      R = useCollection$2(f),
      O = reactExports.useCallback(() => {
        S.current !== null &&
          (window.clearInterval(S.current), (S.current = null));
      }, []);
    return (
      reactExports.useEffect(() => () => O(), [O]),
      useLayoutEffect2(() => {
        R()
          .find((F) => F.ref.current === document.activeElement)
          ?.ref.current?.scrollIntoView({ block: "nearest" });
      }, [R]),
      jsxRuntimeExports.jsx(Primitive$1.div, {
        "aria-hidden": !0,
        ...w,
        ref: e,
        style: { flexShrink: 0, ...w.style },
        onPointerDown: composeEventHandlers(w.onPointerDown, () => {
          S.current === null && (S.current = window.setInterval(_, 50));
        }),
        onPointerMove: composeEventHandlers(w.onPointerMove, () => {
          (v.onItemLeave?.(),
            S.current === null && (S.current = window.setInterval(_, 50)));
        }),
        onPointerLeave: composeEventHandlers(w.onPointerLeave, () => {
          O();
        }),
      })
    );
  }),
  SEPARATOR_NAME$2 = "SelectSeparator",
  SelectSeparator$1 = reactExports.forwardRef((a, e) => {
    const { __scopeSelect: f, ..._ } = a;
    return jsxRuntimeExports.jsx(Primitive$1.div, {
      "aria-hidden": !0,
      ..._,
      ref: e,
    });
  });
SelectSeparator$1.displayName = SEPARATOR_NAME$2;
var ARROW_NAME$2 = "SelectArrow",
  SelectArrow = reactExports.forwardRef((a, e) => {
    const { __scopeSelect: f, ..._ } = a,
      w = usePopperScope$1(f),
      v = useSelectContext(ARROW_NAME$2, f),
      S = useSelectContentContext(ARROW_NAME$2, f);
    return v.open && S.position === "popper"
      ? jsxRuntimeExports.jsx(Arrow, { ...w, ..._, ref: e })
      : null;
  });
SelectArrow.displayName = ARROW_NAME$2;
var BUBBLE_INPUT_NAME = "SelectBubbleInput",
  SelectBubbleInput = reactExports.forwardRef(
    ({ __scopeSelect: a, value: e, ...f }, _) => {
      const w = reactExports.useRef(null),
        v = useComposedRefs(_, w),
        S = usePrevious(e);
      return (
        reactExports.useEffect(() => {
          const R = w.current;
          if (!R) return;
          const O = window.HTMLSelectElement.prototype,
            F = Object.getOwnPropertyDescriptor(O, "value").set;
          if (S !== e && F) {
            const q = new Event("change", { bubbles: !0 });
            (F.call(R, e), R.dispatchEvent(q));
          }
        }, [S, e]),
        jsxRuntimeExports.jsx(Primitive$1.select, {
          ...f,
          style: { ...VISUALLY_HIDDEN_STYLES, ...f.style },
          ref: v,
          defaultValue: e,
        })
      );
    },
  );
SelectBubbleInput.displayName = BUBBLE_INPUT_NAME;
function shouldShowPlaceholder(a) {
  return a === "" || a === void 0;
}
function useTypeaheadSearch(a) {
  const e = useCallbackRef$1(a),
    f = reactExports.useRef(""),
    _ = reactExports.useRef(0),
    w = reactExports.useCallback(
      (S) => {
        const R = f.current + S;
        (e(R),
          (function O(j) {
            ((f.current = j),
              window.clearTimeout(_.current),
              j !== "" && (_.current = window.setTimeout(() => O(""), 1e3)));
          })(R));
      },
      [e],
    ),
    v = reactExports.useCallback(() => {
      ((f.current = ""), window.clearTimeout(_.current));
    }, []);
  return (
    reactExports.useEffect(() => () => window.clearTimeout(_.current), []),
    [f, w, v]
  );
}
function findNextItem(a, e, f) {
  const w = e.length > 1 && Array.from(e).every((j) => j === e[0]) ? e[0] : e,
    v = f ? a.indexOf(f) : -1;
  let S = wrapArray$2(a, Math.max(v, 0));
  w.length === 1 && (S = S.filter((j) => j !== f));
  const O = S.find((j) =>
    j.textValue.toLowerCase().startsWith(w.toLowerCase()),
  );
  return O !== f ? O : void 0;
}
function wrapArray$2(a, e) {
  return a.map((f, _) => a[(e + _) % a.length]);
}
var Trigger$1 = SelectTrigger$1,
  Icon = SelectIcon,
  Portal$1 = SelectPortal,
  Content2$2 = SelectContent$1,
  Viewport$1 = SelectViewport,
  Label$1 = SelectLabel$1,
  Item$1 = SelectItem$1,
  ItemText = SelectItemText,
  ItemIndicator$1 = SelectItemIndicator,
  ScrollUpButton = SelectScrollUpButton$1,
  ScrollDownButton = SelectScrollDownButton$1,
  Separator$1 = SelectSeparator$1;
const SelectTrigger = reactExports.forwardRef(
  ({ className: a, children: e, ...f }, _) =>
    jsxRuntimeExports.jsxs(Trigger$1, {
      ref: _,
      className: cn(
        "flex h-10 w-full items-center justify-between rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background data-[placeholder]:text-muted-foreground focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 [&>span]:line-clamp-1",
        a,
      ),
      ...f,
      children: [
        e,
        jsxRuntimeExports.jsx(Icon, {
          asChild: !0,
          children: jsxRuntimeExports.jsx(ChevronDown, {
            className: "h-4 w-4 opacity-50",
          }),
        }),
      ],
    }),
);
SelectTrigger.displayName = Trigger$1.displayName;
const SelectScrollUpButton = reactExports.forwardRef(
  ({ className: a, ...e }, f) =>
    jsxRuntimeExports.jsx(ScrollUpButton, {
      ref: f,
      className: cn("flex cursor-default items-center justify-center py-1", a),
      ...e,
      children: jsxRuntimeExports.jsx(ChevronUp, { className: "h-4 w-4" }),
    }),
);
SelectScrollUpButton.displayName = ScrollUpButton.displayName;
const SelectScrollDownButton = reactExports.forwardRef(
  ({ className: a, ...e }, f) =>
    jsxRuntimeExports.jsx(ScrollDownButton, {
      ref: f,
      className: cn("flex cursor-default items-center justify-center py-1", a),
      ...e,
      children: jsxRuntimeExports.jsx(ChevronDown, { className: "h-4 w-4" }),
    }),
);
SelectScrollDownButton.displayName = ScrollDownButton.displayName;
const SelectContent = reactExports.forwardRef(
  ({ className: a, children: e, position: f = "popper", ..._ }, w) =>
    jsxRuntimeExports.jsx(Portal$1, {
      children: jsxRuntimeExports.jsxs(Content2$2, {
        ref: w,
        className: cn(
          "relative z-50 max-h-[--radix-select-content-available-height] min-w-[8rem] overflow-y-auto overflow-x-hidden rounded-md border bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 origin-[--radix-select-content-transform-origin]",
          f === "popper" &&
            "data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1",
          a,
        ),
        position: f,
        ..._,
        children: [
          jsxRuntimeExports.jsx(SelectScrollUpButton, {}),
          jsxRuntimeExports.jsx(Viewport$1, {
            className: cn(
              "p-1",
              f === "popper" &&
                "h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)]",
            ),
            children: e,
          }),
          jsxRuntimeExports.jsx(SelectScrollDownButton, {}),
        ],
      }),
    }),
);
SelectContent.displayName = Content2$2.displayName;
const SelectLabel = reactExports.forwardRef(({ className: a, ...e }, f) =>
  jsxRuntimeExports.jsx(Label$1, {
    ref: f,
    className: cn("py-1.5 pl-8 pr-2 text-sm font-semibold", a),
    ...e,
  }),
);
SelectLabel.displayName = Label$1.displayName;
const SelectItem = reactExports.forwardRef(
  ({ className: a, children: e, ...f }, _) =>
    jsxRuntimeExports.jsxs(Item$1, {
      ref: _,
      className: cn(
        "relative flex w-full cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
        a,
      ),
      ...f,
      children: [
        jsxRuntimeExports.jsx("span", {
          className:
            "absolute left-2 flex h-3.5 w-3.5 items-center justify-center",
          children: jsxRuntimeExports.jsx(ItemIndicator$1, {
            children: jsxRuntimeExports.jsx(Check, { className: "h-4 w-4" }),
          }),
        }),
        jsxRuntimeExports.jsx(ItemText, { children: e }),
      ],
    }),
);
SelectItem.displayName = Item$1.displayName;
const SelectSeparator = reactExports.forwardRef(({ className: a, ...e }, f) =>
  jsxRuntimeExports.jsx(Separator$1, {
    ref: f,
    className: cn("-mx-1 my-1 h-px bg-muted", a),
    ...e,
  }),
);
SelectSeparator.displayName = Separator$1.displayName;
const Textarea = reactExports.forwardRef(({ className: a, ...e }, f) =>
  jsxRuntimeExports.jsx("textarea", {
    className: cn(
      "flex min-h-[80px] w-full rounded-md border border-border bg-input px-3 py-2 text-base text-foreground ring-offset-0 placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-0 disabled:cursor-not-allowed disabled:opacity-50 md:text-sm transition-colors duration-150",
      a,
    ),
    ref: f,
    ...e,
  }),
);
Textarea.displayName = "Textarea";
const PromptInput = ({ className: a, ...e }) =>
    jsxRuntimeExports.jsx("form", {
      className: cn(
        "w-full overflow-hidden rounded-md border bg-background",
        a,
      ),
      ...e,
    }),
  PromptInputTextarea = ({
    onChange: a,
    className: e,
    placeholder: f = "What would you like to know?",
    minHeight: _ = 48,
    maxHeight: w = 164,
    disableAutoResize: v = !1,
    resizeOnNewLinesOnly: S = !1,
    ...R
  }) => {
    const O = (j) => {
      if (j.key === "Enter") {
        if (j.nativeEvent.isComposing || j.shiftKey) return;
        j.preventDefault();
        const F = j.currentTarget.form;
        F && F.requestSubmit();
      }
    };
    return jsxRuntimeExports.jsx(Textarea, {
      className: cn(
        "w-full resize-none rounded-none border-none p-3 shadow-none outline-hidden ring-0",
        v || S ? "field-sizing-fixed" : "field-sizing-content max-h-[6lh]",
        "bg-transparent dark:bg-transparent",
        "focus-visible:ring-0",
        e,
      ),
      name: "message",
      onChange: (j) => {
        a?.(j);
      },
      onKeyDown: O,
      placeholder: f,
      ...R,
    });
  },
  PromptInputToolbar = ({ className: a, ...e }) =>
    jsxRuntimeExports.jsx("div", {
      className: cn("flex items-center justify-between p-1", a),
      ...e,
    }),
  PromptInputTools = ({ className: a, ...e }) =>
    jsxRuntimeExports.jsx("div", {
      className: cn(
        "flex items-center gap-1",
        "[&_button:first-child]:rounded-bl-xl",
        a,
      ),
      ...e,
    }),
  PromptInputSubmit = ({
    className: a,
    variant: e = "default",
    size: f = "icon",
    status: _,
    children: w,
    ...v
  }) => {
    let S = jsxRuntimeExports.jsx(Send, { className: "size-4" });
    return (
      _ === "submitted"
        ? (S = jsxRuntimeExports.jsx(LoaderCircle, {
            className: "size-4 animate-spin",
          }))
        : _ === "streaming"
          ? (S = jsxRuntimeExports.jsx(Square, { className: "size-4" }))
          : _ === "error" &&
            (S = jsxRuntimeExports.jsx(X$1, { className: "size-4" })),
      jsxRuntimeExports.jsx(Button, {
        className: cn("gap-1.5 rounded-md", a),
        size: f,
        type: "submit",
        variant: e,
        ...v,
        children: w ?? S,
      })
    );
  };
function useStateMachine(a, e) {
  return reactExports.useReducer((f, _) => e[f][_] ?? f, a);
}
var SCROLL_AREA_NAME = "ScrollArea",
  [createScrollAreaContext] = createContextScope(SCROLL_AREA_NAME),
  [ScrollAreaProvider, useScrollAreaContext] =
    createScrollAreaContext(SCROLL_AREA_NAME),
  ScrollArea$1 = reactExports.forwardRef((a, e) => {
    const {
        __scopeScrollArea: f,
        type: _ = "hover",
        dir: w,
        scrollHideDelay: v = 600,
        ...S
      } = a,
      [R, O] = reactExports.useState(null),
      [j, F] = reactExports.useState(null),
      [q, Q] = reactExports.useState(null),
      [te, se] = reactExports.useState(null),
      [re, Oe] = reactExports.useState(null),
      [Le, Be] = reactExports.useState(0),
      [Ve, ze] = reactExports.useState(0),
      [Ge, Ke] = reactExports.useState(!1),
      [qe, nt] = reactExports.useState(!1),
      pt = useComposedRefs(e, (mt) => O(mt)),
      gt = useDirection(w);
    return jsxRuntimeExports.jsx(ScrollAreaProvider, {
      scope: f,
      type: _,
      dir: gt,
      scrollHideDelay: v,
      scrollArea: R,
      viewport: j,
      onViewportChange: F,
      content: q,
      onContentChange: Q,
      scrollbarX: te,
      onScrollbarXChange: se,
      scrollbarXEnabled: Ge,
      onScrollbarXEnabledChange: Ke,
      scrollbarY: re,
      onScrollbarYChange: Oe,
      scrollbarYEnabled: qe,
      onScrollbarYEnabledChange: nt,
      onCornerWidthChange: Be,
      onCornerHeightChange: ze,
      children: jsxRuntimeExports.jsx(Primitive$1.div, {
        dir: gt,
        ...S,
        ref: pt,
        style: {
          position: "relative",
          "--radix-scroll-area-corner-width": Le + "px",
          "--radix-scroll-area-corner-height": Ve + "px",
          ...a.style,
        },
      }),
    });
  });
ScrollArea$1.displayName = SCROLL_AREA_NAME;
var VIEWPORT_NAME = "ScrollAreaViewport",
  ScrollAreaViewport = reactExports.forwardRef((a, e) => {
    const { __scopeScrollArea: f, children: _, nonce: w, ...v } = a,
      S = useScrollAreaContext(VIEWPORT_NAME, f),
      R = reactExports.useRef(null),
      O = useComposedRefs(e, R, S.onViewportChange);
    return jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
      children: [
        jsxRuntimeExports.jsx("style", {
          dangerouslySetInnerHTML: {
            __html:
              "[data-radix-scroll-area-viewport]{scrollbar-width:none;-ms-overflow-style:none;-webkit-overflow-scrolling:touch;}[data-radix-scroll-area-viewport]::-webkit-scrollbar{display:none}",
          },
          nonce: w,
        }),
        jsxRuntimeExports.jsx(Primitive$1.div, {
          "data-radix-scroll-area-viewport": "",
          ...v,
          ref: O,
          style: {
            overflowX: S.scrollbarXEnabled ? "scroll" : "hidden",
            overflowY: S.scrollbarYEnabled ? "scroll" : "hidden",
            ...a.style,
          },
          children: jsxRuntimeExports.jsx("div", {
            ref: S.onContentChange,
            style: { minWidth: "100%", display: "table" },
            children: _,
          }),
        }),
      ],
    });
  });
ScrollAreaViewport.displayName = VIEWPORT_NAME;
var SCROLLBAR_NAME = "ScrollAreaScrollbar",
  ScrollAreaScrollbar = reactExports.forwardRef((a, e) => {
    const { forceMount: f, ..._ } = a,
      w = useScrollAreaContext(SCROLLBAR_NAME, a.__scopeScrollArea),
      { onScrollbarXEnabledChange: v, onScrollbarYEnabledChange: S } = w,
      R = a.orientation === "horizontal";
    return (
      reactExports.useEffect(
        () => (
          R ? v(!0) : S(!0),
          () => {
            R ? v(!1) : S(!1);
          }
        ),
        [R, v, S],
      ),
      w.type === "hover"
        ? jsxRuntimeExports.jsx(ScrollAreaScrollbarHover, {
            ..._,
            ref: e,
            forceMount: f,
          })
        : w.type === "scroll"
          ? jsxRuntimeExports.jsx(ScrollAreaScrollbarScroll, {
              ..._,
              ref: e,
              forceMount: f,
            })
          : w.type === "auto"
            ? jsxRuntimeExports.jsx(ScrollAreaScrollbarAuto, {
                ..._,
                ref: e,
                forceMount: f,
              })
            : w.type === "always"
              ? jsxRuntimeExports.jsx(ScrollAreaScrollbarVisible, {
                  ..._,
                  ref: e,
                })
              : null
    );
  });
ScrollAreaScrollbar.displayName = SCROLLBAR_NAME;
var ScrollAreaScrollbarHover = reactExports.forwardRef((a, e) => {
    const { forceMount: f, ..._ } = a,
      w = useScrollAreaContext(SCROLLBAR_NAME, a.__scopeScrollArea),
      [v, S] = reactExports.useState(!1);
    return (
      reactExports.useEffect(() => {
        const R = w.scrollArea;
        let O = 0;
        if (R) {
          const j = () => {
              (window.clearTimeout(O), S(!0));
            },
            F = () => {
              O = window.setTimeout(() => S(!1), w.scrollHideDelay);
            };
          return (
            R.addEventListener("pointerenter", j),
            R.addEventListener("pointerleave", F),
            () => {
              (window.clearTimeout(O),
                R.removeEventListener("pointerenter", j),
                R.removeEventListener("pointerleave", F));
            }
          );
        }
      }, [w.scrollArea, w.scrollHideDelay]),
      jsxRuntimeExports.jsx(Presence, {
        present: f || v,
        children: jsxRuntimeExports.jsx(ScrollAreaScrollbarAuto, {
          "data-state": v ? "visible" : "hidden",
          ..._,
          ref: e,
        }),
      })
    );
  }),
  ScrollAreaScrollbarScroll = reactExports.forwardRef((a, e) => {
    const { forceMount: f, ..._ } = a,
      w = useScrollAreaContext(SCROLLBAR_NAME, a.__scopeScrollArea),
      v = a.orientation === "horizontal",
      S = useDebounceCallback(() => O("SCROLL_END"), 100),
      [R, O] = useStateMachine("hidden", {
        hidden: { SCROLL: "scrolling" },
        scrolling: { SCROLL_END: "idle", POINTER_ENTER: "interacting" },
        interacting: { SCROLL: "interacting", POINTER_LEAVE: "idle" },
        idle: {
          HIDE: "hidden",
          SCROLL: "scrolling",
          POINTER_ENTER: "interacting",
        },
      });
    return (
      reactExports.useEffect(() => {
        if (R === "idle") {
          const j = window.setTimeout(() => O("HIDE"), w.scrollHideDelay);
          return () => window.clearTimeout(j);
        }
      }, [R, w.scrollHideDelay, O]),
      reactExports.useEffect(() => {
        const j = w.viewport,
          F = v ? "scrollLeft" : "scrollTop";
        if (j) {
          let q = j[F];
          const Q = () => {
            const te = j[F];
            (q !== te && (O("SCROLL"), S()), (q = te));
          };
          return (
            j.addEventListener("scroll", Q),
            () => j.removeEventListener("scroll", Q)
          );
        }
      }, [w.viewport, v, O, S]),
      jsxRuntimeExports.jsx(Presence, {
        present: f || R !== "hidden",
        children: jsxRuntimeExports.jsx(ScrollAreaScrollbarVisible, {
          "data-state": R === "hidden" ? "hidden" : "visible",
          ..._,
          ref: e,
          onPointerEnter: composeEventHandlers(a.onPointerEnter, () =>
            O("POINTER_ENTER"),
          ),
          onPointerLeave: composeEventHandlers(a.onPointerLeave, () =>
            O("POINTER_LEAVE"),
          ),
        }),
      })
    );
  }),
  ScrollAreaScrollbarAuto = reactExports.forwardRef((a, e) => {
    const f = useScrollAreaContext(SCROLLBAR_NAME, a.__scopeScrollArea),
      { forceMount: _, ...w } = a,
      [v, S] = reactExports.useState(!1),
      R = a.orientation === "horizontal",
      O = useDebounceCallback(() => {
        if (f.viewport) {
          const j = f.viewport.offsetWidth < f.viewport.scrollWidth,
            F = f.viewport.offsetHeight < f.viewport.scrollHeight;
          S(R ? j : F);
        }
      }, 10);
    return (
      useResizeObserver(f.viewport, O),
      useResizeObserver(f.content, O),
      jsxRuntimeExports.jsx(Presence, {
        present: _ || v,
        children: jsxRuntimeExports.jsx(ScrollAreaScrollbarVisible, {
          "data-state": v ? "visible" : "hidden",
          ...w,
          ref: e,
        }),
      })
    );
  }),
  ScrollAreaScrollbarVisible = reactExports.forwardRef((a, e) => {
    const { orientation: f = "vertical", ..._ } = a,
      w = useScrollAreaContext(SCROLLBAR_NAME, a.__scopeScrollArea),
      v = reactExports.useRef(null),
      S = reactExports.useRef(0),
      [R, O] = reactExports.useState({
        content: 0,
        viewport: 0,
        scrollbar: { size: 0, paddingStart: 0, paddingEnd: 0 },
      }),
      j = getThumbRatio(R.viewport, R.content),
      F = {
        ..._,
        sizes: R,
        onSizesChange: O,
        hasThumb: j > 0 && j < 1,
        onThumbChange: (Q) => (v.current = Q),
        onThumbPointerUp: () => (S.current = 0),
        onThumbPointerDown: (Q) => (S.current = Q),
      };
    function q(Q, te) {
      return getScrollPositionFromPointer(Q, S.current, R, te);
    }
    return f === "horizontal"
      ? jsxRuntimeExports.jsx(ScrollAreaScrollbarX, {
          ...F,
          ref: e,
          onThumbPositionChange: () => {
            if (w.viewport && v.current) {
              const Q = w.viewport.scrollLeft,
                te = getThumbOffsetFromScroll(Q, R, w.dir);
              v.current.style.transform = `translate3d(${te}px, 0, 0)`;
            }
          },
          onWheelScroll: (Q) => {
            w.viewport && (w.viewport.scrollLeft = Q);
          },
          onDragScroll: (Q) => {
            w.viewport && (w.viewport.scrollLeft = q(Q, w.dir));
          },
        })
      : f === "vertical"
        ? jsxRuntimeExports.jsx(ScrollAreaScrollbarY, {
            ...F,
            ref: e,
            onThumbPositionChange: () => {
              if (w.viewport && v.current) {
                const Q = w.viewport.scrollTop,
                  te = getThumbOffsetFromScroll(Q, R);
                v.current.style.transform = `translate3d(0, ${te}px, 0)`;
              }
            },
            onWheelScroll: (Q) => {
              w.viewport && (w.viewport.scrollTop = Q);
            },
            onDragScroll: (Q) => {
              w.viewport && (w.viewport.scrollTop = q(Q));
            },
          })
        : null;
  }),
  ScrollAreaScrollbarX = reactExports.forwardRef((a, e) => {
    const { sizes: f, onSizesChange: _, ...w } = a,
      v = useScrollAreaContext(SCROLLBAR_NAME, a.__scopeScrollArea),
      [S, R] = reactExports.useState(),
      O = reactExports.useRef(null),
      j = useComposedRefs(e, O, v.onScrollbarXChange);
    return (
      reactExports.useEffect(() => {
        O.current && R(getComputedStyle(O.current));
      }, [O]),
      jsxRuntimeExports.jsx(ScrollAreaScrollbarImpl, {
        "data-orientation": "horizontal",
        ...w,
        ref: j,
        sizes: f,
        style: {
          bottom: 0,
          left: v.dir === "rtl" ? "var(--radix-scroll-area-corner-width)" : 0,
          right: v.dir === "ltr" ? "var(--radix-scroll-area-corner-width)" : 0,
          "--radix-scroll-area-thumb-width": getThumbSize(f) + "px",
          ...a.style,
        },
        onThumbPointerDown: (F) => a.onThumbPointerDown(F.x),
        onDragScroll: (F) => a.onDragScroll(F.x),
        onWheelScroll: (F, q) => {
          if (v.viewport) {
            const Q = v.viewport.scrollLeft + F.deltaX;
            (a.onWheelScroll(Q),
              isScrollingWithinScrollbarBounds(Q, q) && F.preventDefault());
          }
        },
        onResize: () => {
          O.current &&
            v.viewport &&
            S &&
            _({
              content: v.viewport.scrollWidth,
              viewport: v.viewport.offsetWidth,
              scrollbar: {
                size: O.current.clientWidth,
                paddingStart: toInt(S.paddingLeft),
                paddingEnd: toInt(S.paddingRight),
              },
            });
        },
      })
    );
  }),
  ScrollAreaScrollbarY = reactExports.forwardRef((a, e) => {
    const { sizes: f, onSizesChange: _, ...w } = a,
      v = useScrollAreaContext(SCROLLBAR_NAME, a.__scopeScrollArea),
      [S, R] = reactExports.useState(),
      O = reactExports.useRef(null),
      j = useComposedRefs(e, O, v.onScrollbarYChange);
    return (
      reactExports.useEffect(() => {
        O.current && R(getComputedStyle(O.current));
      }, [O]),
      jsxRuntimeExports.jsx(ScrollAreaScrollbarImpl, {
        "data-orientation": "vertical",
        ...w,
        ref: j,
        sizes: f,
        style: {
          top: 0,
          right: v.dir === "ltr" ? 0 : void 0,
          left: v.dir === "rtl" ? 0 : void 0,
          bottom: "var(--radix-scroll-area-corner-height)",
          "--radix-scroll-area-thumb-height": getThumbSize(f) + "px",
          ...a.style,
        },
        onThumbPointerDown: (F) => a.onThumbPointerDown(F.y),
        onDragScroll: (F) => a.onDragScroll(F.y),
        onWheelScroll: (F, q) => {
          if (v.viewport) {
            const Q = v.viewport.scrollTop + F.deltaY;
            (a.onWheelScroll(Q),
              isScrollingWithinScrollbarBounds(Q, q) && F.preventDefault());
          }
        },
        onResize: () => {
          O.current &&
            v.viewport &&
            S &&
            _({
              content: v.viewport.scrollHeight,
              viewport: v.viewport.offsetHeight,
              scrollbar: {
                size: O.current.clientHeight,
                paddingStart: toInt(S.paddingTop),
                paddingEnd: toInt(S.paddingBottom),
              },
            });
        },
      })
    );
  }),
  [ScrollbarProvider, useScrollbarContext] =
    createScrollAreaContext(SCROLLBAR_NAME),
  ScrollAreaScrollbarImpl = reactExports.forwardRef((a, e) => {
    const {
        __scopeScrollArea: f,
        sizes: _,
        hasThumb: w,
        onThumbChange: v,
        onThumbPointerUp: S,
        onThumbPointerDown: R,
        onThumbPositionChange: O,
        onDragScroll: j,
        onWheelScroll: F,
        onResize: q,
        ...Q
      } = a,
      te = useScrollAreaContext(SCROLLBAR_NAME, f),
      [se, re] = reactExports.useState(null),
      Oe = useComposedRefs(e, (pt) => re(pt)),
      Le = reactExports.useRef(null),
      Be = reactExports.useRef(""),
      Ve = te.viewport,
      ze = _.content - _.viewport,
      Ge = useCallbackRef$1(F),
      Ke = useCallbackRef$1(O),
      qe = useDebounceCallback(q, 10);
    function nt(pt) {
      if (Le.current) {
        const gt = pt.clientX - Le.current.left,
          mt = pt.clientY - Le.current.top;
        j({ x: gt, y: mt });
      }
    }
    return (
      reactExports.useEffect(() => {
        const pt = (gt) => {
          const mt = gt.target;
          se?.contains(mt) && Ge(gt, ze);
        };
        return (
          document.addEventListener("wheel", pt, { passive: !1 }),
          () => document.removeEventListener("wheel", pt, { passive: !1 })
        );
      }, [Ve, se, ze, Ge]),
      reactExports.useEffect(Ke, [_, Ke]),
      useResizeObserver(se, qe),
      useResizeObserver(te.content, qe),
      jsxRuntimeExports.jsx(ScrollbarProvider, {
        scope: f,
        scrollbar: se,
        hasThumb: w,
        onThumbChange: useCallbackRef$1(v),
        onThumbPointerUp: useCallbackRef$1(S),
        onThumbPositionChange: Ke,
        onThumbPointerDown: useCallbackRef$1(R),
        children: jsxRuntimeExports.jsx(Primitive$1.div, {
          ...Q,
          ref: Oe,
          style: { position: "absolute", ...Q.style },
          onPointerDown: composeEventHandlers(a.onPointerDown, (pt) => {
            pt.button === 0 &&
              (pt.target.setPointerCapture(pt.pointerId),
              (Le.current = se.getBoundingClientRect()),
              (Be.current = document.body.style.webkitUserSelect),
              (document.body.style.webkitUserSelect = "none"),
              te.viewport && (te.viewport.style.scrollBehavior = "auto"),
              nt(pt));
          }),
          onPointerMove: composeEventHandlers(a.onPointerMove, nt),
          onPointerUp: composeEventHandlers(a.onPointerUp, (pt) => {
            const gt = pt.target;
            (gt.hasPointerCapture(pt.pointerId) &&
              gt.releasePointerCapture(pt.pointerId),
              (document.body.style.webkitUserSelect = Be.current),
              te.viewport && (te.viewport.style.scrollBehavior = ""),
              (Le.current = null));
          }),
        }),
      })
    );
  }),
  THUMB_NAME = "ScrollAreaThumb",
  ScrollAreaThumb = reactExports.forwardRef((a, e) => {
    const { forceMount: f, ..._ } = a,
      w = useScrollbarContext(THUMB_NAME, a.__scopeScrollArea);
    return jsxRuntimeExports.jsx(Presence, {
      present: f || w.hasThumb,
      children: jsxRuntimeExports.jsx(ScrollAreaThumbImpl, { ref: e, ..._ }),
    });
  }),
  ScrollAreaThumbImpl = reactExports.forwardRef((a, e) => {
    const { __scopeScrollArea: f, style: _, ...w } = a,
      v = useScrollAreaContext(THUMB_NAME, f),
      S = useScrollbarContext(THUMB_NAME, f),
      { onThumbPositionChange: R } = S,
      O = useComposedRefs(e, (q) => S.onThumbChange(q)),
      j = reactExports.useRef(void 0),
      F = useDebounceCallback(() => {
        j.current && (j.current(), (j.current = void 0));
      }, 100);
    return (
      reactExports.useEffect(() => {
        const q = v.viewport;
        if (q) {
          const Q = () => {
            if ((F(), !j.current)) {
              const te = addUnlinkedScrollListener(q, R);
              ((j.current = te), R());
            }
          };
          return (
            R(),
            q.addEventListener("scroll", Q),
            () => q.removeEventListener("scroll", Q)
          );
        }
      }, [v.viewport, F, R]),
      jsxRuntimeExports.jsx(Primitive$1.div, {
        "data-state": S.hasThumb ? "visible" : "hidden",
        ...w,
        ref: O,
        style: {
          width: "var(--radix-scroll-area-thumb-width)",
          height: "var(--radix-scroll-area-thumb-height)",
          ..._,
        },
        onPointerDownCapture: composeEventHandlers(
          a.onPointerDownCapture,
          (q) => {
            const te = q.target.getBoundingClientRect(),
              se = q.clientX - te.left,
              re = q.clientY - te.top;
            S.onThumbPointerDown({ x: se, y: re });
          },
        ),
        onPointerUp: composeEventHandlers(a.onPointerUp, S.onThumbPointerUp),
      })
    );
  });
ScrollAreaThumb.displayName = THUMB_NAME;
var CORNER_NAME = "ScrollAreaCorner",
  ScrollAreaCorner = reactExports.forwardRef((a, e) => {
    const f = useScrollAreaContext(CORNER_NAME, a.__scopeScrollArea),
      _ = !!(f.scrollbarX && f.scrollbarY);
    return f.type !== "scroll" && _
      ? jsxRuntimeExports.jsx(ScrollAreaCornerImpl, { ...a, ref: e })
      : null;
  });
ScrollAreaCorner.displayName = CORNER_NAME;
var ScrollAreaCornerImpl = reactExports.forwardRef((a, e) => {
  const { __scopeScrollArea: f, ..._ } = a,
    w = useScrollAreaContext(CORNER_NAME, f),
    [v, S] = reactExports.useState(0),
    [R, O] = reactExports.useState(0),
    j = !!(v && R);
  return (
    useResizeObserver(w.scrollbarX, () => {
      const F = w.scrollbarX?.offsetHeight || 0;
      (w.onCornerHeightChange(F), O(F));
    }),
    useResizeObserver(w.scrollbarY, () => {
      const F = w.scrollbarY?.offsetWidth || 0;
      (w.onCornerWidthChange(F), S(F));
    }),
    j
      ? jsxRuntimeExports.jsx(Primitive$1.div, {
          ..._,
          ref: e,
          style: {
            width: v,
            height: R,
            position: "absolute",
            right: w.dir === "ltr" ? 0 : void 0,
            left: w.dir === "rtl" ? 0 : void 0,
            bottom: 0,
            ...a.style,
          },
        })
      : null
  );
});
function toInt(a) {
  return a ? parseInt(a, 10) : 0;
}
function getThumbRatio(a, e) {
  const f = a / e;
  return isNaN(f) ? 0 : f;
}
function getThumbSize(a) {
  const e = getThumbRatio(a.viewport, a.content),
    f = a.scrollbar.paddingStart + a.scrollbar.paddingEnd,
    _ = (a.scrollbar.size - f) * e;
  return Math.max(_, 18);
}
function getScrollPositionFromPointer(a, e, f, _ = "ltr") {
  const w = getThumbSize(f),
    v = w / 2,
    S = e || v,
    R = w - S,
    O = f.scrollbar.paddingStart + S,
    j = f.scrollbar.size - f.scrollbar.paddingEnd - R,
    F = f.content - f.viewport,
    q = _ === "ltr" ? [0, F] : [F * -1, 0];
  return linearScale([O, j], q)(a);
}
function getThumbOffsetFromScroll(a, e, f = "ltr") {
  const _ = getThumbSize(e),
    w = e.scrollbar.paddingStart + e.scrollbar.paddingEnd,
    v = e.scrollbar.size - w,
    S = e.content - e.viewport,
    R = v - _,
    O = f === "ltr" ? [0, S] : [S * -1, 0],
    j = clamp(a, O);
  return linearScale([0, S], [0, R])(j);
}
function linearScale(a, e) {
  return (f) => {
    if (a[0] === a[1] || e[0] === e[1]) return e[0];
    const _ = (e[1] - e[0]) / (a[1] - a[0]);
    return e[0] + _ * (f - a[0]);
  };
}
function isScrollingWithinScrollbarBounds(a, e) {
  return a > 0 && a < e;
}
var addUnlinkedScrollListener = (a, e = () => {}) => {
  let f = { left: a.scrollLeft, top: a.scrollTop },
    _ = 0;
  return (
    (function w() {
      const v = { left: a.scrollLeft, top: a.scrollTop },
        S = f.left !== v.left,
        R = f.top !== v.top;
      ((S || R) && e(), (f = v), (_ = window.requestAnimationFrame(w)));
    })(),
    () => window.cancelAnimationFrame(_)
  );
};
function useDebounceCallback(a, e) {
  const f = useCallbackRef$1(a),
    _ = reactExports.useRef(0);
  return (
    reactExports.useEffect(() => () => window.clearTimeout(_.current), []),
    reactExports.useCallback(() => {
      (window.clearTimeout(_.current), (_.current = window.setTimeout(f, e)));
    }, [f, e])
  );
}
function useResizeObserver(a, e) {
  const f = useCallbackRef$1(e);
  useLayoutEffect2(() => {
    let _ = 0;
    if (a) {
      const w = new ResizeObserver(() => {
        (cancelAnimationFrame(_), (_ = window.requestAnimationFrame(f)));
      });
      return (
        w.observe(a),
        () => {
          (window.cancelAnimationFrame(_), w.unobserve(a));
        }
      );
    }
  }, [a, f]);
}
var Root$1 = ScrollArea$1,
  Viewport = ScrollAreaViewport,
  Corner = ScrollAreaCorner;
const ScrollArea = reactExports.forwardRef(
  ({ className: a, children: e, ...f }, _) =>
    jsxRuntimeExports.jsxs(Root$1, {
      ref: _,
      className: cn("relative overflow-hidden", a),
      ...f,
      children: [
        jsxRuntimeExports.jsx(Viewport, {
          className: "h-full w-full rounded-[inherit]",
          children: e,
        }),
        jsxRuntimeExports.jsx(ScrollBar, {}),
        jsxRuntimeExports.jsx(Corner, {}),
      ],
    }),
);
ScrollArea.displayName = Root$1.displayName;
const ScrollBar = reactExports.forwardRef(
  ({ className: a, orientation: e = "vertical", ...f }, _) =>
    jsxRuntimeExports.jsx(ScrollAreaScrollbar, {
      ref: _,
      orientation: e,
      className: cn(
        "flex touch-none select-none transition-colors",
        e === "vertical" &&
          "h-full w-2.5 border-l border-l-transparent p-[1px]",
        e === "horizontal" &&
          "h-2.5 flex-col border-t border-t-transparent p-[1px]",
        a,
      ),
      ...f,
      children: jsxRuntimeExports.jsx(ScrollAreaThumb, {
        className: "relative flex-1 rounded-full bg-border",
      }),
    }),
);
ScrollBar.displayName = ScrollAreaScrollbar.displayName;
const Suggestion = ({
  suggestion: a,
  onClick: e,
  className: f,
  variant: _ = "outline",
  size: w = "sm",
  children: v,
  ...S
}) => {
  const R = () => {
    e?.(a);
  };
  return jsxRuntimeExports.jsx(Button, {
    className: cn("cursor-pointer rounded-full px-4", f),
    onClick: R,
    size: w,
    type: "button",
    variant: _,
    ...S,
    children: v || a,
  });
};
function SuggestedActions({ chatId: a, sendMessage: e }) {
  const f = [
    "Write code to demonstrate Dijkstra's algorithm",
    "Help me write an essay about Silicon Valley",
    "What is the weather in San Francisco?",
    "Explain how React hooks work",
  ];
  return jsxRuntimeExports.jsx("div", {
    className: "grid w-full gap-2 sm:grid-cols-2",
    "data-testid": "suggested-actions",
    children: f.map((_, w) =>
      jsxRuntimeExports.jsx(
        motion.div,
        {
          animate: { opacity: 1, y: 0 },
          exit: { opacity: 0, y: 20 },
          initial: { opacity: 0, y: 20 },
          transition: { delay: 0.05 * w },
          children: jsxRuntimeExports.jsx(Suggestion, {
            className: "h-auto w-full whitespace-normal p-3 text-left",
            onClick: (v) => {
              e(v);
            },
            suggestion: _,
            children: _,
          }),
        },
        _,
      ),
    ),
  });
}
const AI_AGENTS = [
  {
    name: "elsa",
    address: "0xe15aa1ba585aea8a4639331ce5f9aec86f8c4541",
    networks: ["production"],
    live: !0,
  },
  {
    name: "flaunchy",
    address: "0x557463B158F70e4E269bB7BCcF6C587e3BC878F4",
    networks: ["production"],
    live: !0,
  },
  {
    name: "mamo",
    address: "0x99B10779557cc52c6E3a97C9A6C3446f021290cc",
    networks: ["production"],
    live: !0,
  },
  {
    name: "alphie.base.eth",
    address: "0x5154C8707f7Fa18961E03F5b51edB2fb56a206dc",
    networks: ["production"],
    live: !0,
  },
  {
    name: "arma",
    address: "0x1456350CD79c51814567b0c1E767d3032dBD1647",
    networks: ["production"],
    live: !0,
  },
  {
    name: "jesse",
    address: "0x2f9e2F8FdDEae391720D58D656a8Af0578006eD2",
    networks: ["production"],
    live: !0,
  },
  {
    name: "freysa",
    address: "0xEb7DB3ED8609165Ec5d99966CfDdeaE587070cD8",
    networks: ["production"],
    live: !0,
  },
  {
    name: "neurobro",
    address: "0x9D2B24b027F4732BB87cD6531E16ce4Dc571c30c",
    networks: ["production"],
    live: !0,
  },
  {
    name: "bracky",
    address: "0x62db4c5A8fdF004754b9EFe92dF39927aB68920d",
    networks: ["production"],
    live: !0,
  },
  {
    name: "bankr",
    address: "0x7f1c0d2955f873fc91f1728c19b2ed7be7a9684d",
    networks: ["production"],
    live: !0,
  },
  {
    name: "basemate",
    address: "0xB257b5C180b7b2cb80E35d6079AbE68D9CF0467F",
    networks: ["production"],
    live: !1,
  },
  {
    name: "echo",
    address: "0x194c31cae1418d5256e8c58e0d08aee1046c6ed0",
    networks: ["dev"],
    live: !1,
  },
  {
    name: "gm",
    address: "0x194c31cae1418d5256e8c58e0d08aee1046c6ed0",
    networks: ["dev", "production"],
    live: !1,
  },
  {
    name: "key-check",
    address: "0x235017975ed5F55e23a71979697Cd67DcAE614Fa",
    networks: ["dev", "production"],
    live: !1,
  },
  {
    name: "xmtp-docs",
    address: "0x212906fdbdb70771461e6cb3376a740132e56b14",
    networks: ["production"],
    live: !1,
  },
];
function InputArea({ messages: a = [], sendMessage: e }) {
  const [f, _] = reactExports.useState(""),
    [w, v] = reactExports.useState(!1),
    [S] = reactExports.useState([]),
    R = AI_AGENTS.filter((q) => q.live),
    [O, j] = reactExports.useState(R[0]),
    F = (q) => {
      q.preventDefault();
      const Q = f.trim();
      if (!Q) {
        console.log("[InputArea] Submit attempted but message is empty");
        return;
      }
      (console.log("[InputArea] Form submitted with message:", Q),
        console.log("[InputArea] Calling sendMessage callback"),
        e
          ? (e(Q),
            _(""),
            console.log("[InputArea] Message sent, input cleared"))
          : console.error("[InputArea] sendMessage callback is not provided!"));
    };
  return jsxRuntimeExports.jsxs("div", {
    className: "relative flex w-full flex-col gap-4",
    children: [
      a.length === 0 &&
        S.length === 0 &&
        jsxRuntimeExports.jsx(SuggestedActions, {
          chatId: "wireframe",
          sendMessage: e || (() => {}),
        }),
      jsxRuntimeExports.jsxs(PromptInput, {
        className:
          "rounded-md border border-border bg-background p-3 transition-all duration-150 focus-within:border-border hover:border-muted-foreground/50",
        onSubmit: F,
        children: [
          jsxRuntimeExports.jsx("div", {
            className: "flex flex-row items-start gap-1 sm:gap-2",
            children: jsxRuntimeExports.jsx(PromptInputTextarea, {
              className:
                "grow resize-none border-0! border-none! bg-transparent p-2 text-sm outline-none ring-0 [-ms-overflow-style:none] [scrollbar-width:none] placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-0 focus-visible:ring-offset-0 [&::-webkit-scrollbar]:hidden",
              placeholder: "Send a message...",
              value: f,
              onChange: (q) => _(q.target.value),
            }),
          }),
          jsxRuntimeExports.jsxs(PromptInputToolbar, {
            className:
              "border-top-0! border-t-0! p-0 shadow-none dark:border-0 dark:border-transparent!",
            children: [
              jsxRuntimeExports.jsxs(PromptInputTools, {
                className: "gap-0 sm:gap-0.5",
                children: [
                  jsxRuntimeExports.jsx(Button, {
                    className: "h-8 p-1 md:h-fit md:p-2",
                    type: "button",
                    variant: "ghost",
                    children: jsxRuntimeExports.jsx(PaperclipIcon, {
                      size: 16,
                    }),
                  }),
                  jsxRuntimeExports.jsxs(ModelSelector, {
                    onOpenChange: v,
                    open: w,
                    value: O.address,
                    onValueChange: (q) => {
                      const Q = R.find((te) => te.address === q);
                      Q && j(Q);
                    },
                    children: [
                      jsxRuntimeExports.jsx(ModelSelectorTrigger, {
                        asChild: !0,
                        children: jsxRuntimeExports.jsx(Button, {
                          className: "h-8 w-[200px] justify-between px-2",
                          variant: "ghost",
                          children: jsxRuntimeExports.jsx(ModelSelectorName, {
                            children: O.name,
                          }),
                        }),
                      }),
                      jsxRuntimeExports.jsxs(ModelSelectorContent, {
                        children: [
                          jsxRuntimeExports.jsx(ModelSelectorInput, {
                            placeholder: "Search agents...",
                          }),
                          jsxRuntimeExports.jsx(ModelSelectorList, {
                            children: jsxRuntimeExports.jsx(
                              ModelSelectorGroup,
                              {
                                heading: "AI Agents",
                                children: R.map((q) =>
                                  jsxRuntimeExports.jsx(
                                    ModelSelectorItem,
                                    {
                                      value: q.address,
                                      children: jsxRuntimeExports.jsx(
                                        ModelSelectorName,
                                        { children: q.name },
                                      ),
                                    },
                                    q.address,
                                  ),
                                ),
                              },
                            ),
                          }),
                        ],
                      }),
                    ],
                  }),
                ],
              }),
              jsxRuntimeExports.jsx(PromptInputSubmit, {
                className:
                  "size-8 rounded-full bg-primary text-primary-foreground transition-colors duration-150 hover:bg-[#3d8aff] disabled:bg-muted disabled:text-muted-foreground",
                disabled: !f.trim(),
                children: jsxRuntimeExports.jsx(ArrowUpIcon, { size: 14 }),
              }),
            ],
          }),
        ],
      }),
    ],
  });
}
const crypto$1 =
  typeof globalThis == "object" && "crypto" in globalThis
    ? globalThis.crypto
    : void 0;
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */ function isBytes$1(
  a,
) {
  return (
    a instanceof Uint8Array ||
    (ArrayBuffer.isView(a) && a.constructor.name === "Uint8Array")
  );
}
function anumber(a) {
  if (!Number.isSafeInteger(a) || a < 0)
    throw new Error("positive integer expected, got " + a);
}
function abytes$1(a, ...e) {
  if (!isBytes$1(a)) throw new Error("Uint8Array expected");
  if (e.length > 0 && !e.includes(a.length))
    throw new Error(
      "Uint8Array expected of length " + e + ", got length=" + a.length,
    );
}
function ahash(a) {
  if (typeof a != "function" || typeof a.create != "function")
    throw new Error("Hash should be wrapped by utils.createHasher");
  (anumber(a.outputLen), anumber(a.blockLen));
}
function aexists(a, e = !0) {
  if (a.destroyed) throw new Error("Hash instance has been destroyed");
  if (e && a.finished) throw new Error("Hash#digest() has already been called");
}
function aoutput(a, e) {
  abytes$1(a);
  const f = e.outputLen;
  if (a.length < f)
    throw new Error(
      "digestInto() expects output buffer of length at least " + f,
    );
}
function u32(a) {
  return new Uint32Array(a.buffer, a.byteOffset, Math.floor(a.byteLength / 4));
}
function clean(...a) {
  for (let e = 0; e < a.length; e++) a[e].fill(0);
}
function createView(a) {
  return new DataView(a.buffer, a.byteOffset, a.byteLength);
}
function rotr(a, e) {
  return (a << (32 - e)) | (a >>> e);
}
const isLE = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
function byteSwap(a) {
  return (
    ((a << 24) & 4278190080) |
    ((a << 8) & 16711680) |
    ((a >>> 8) & 65280) |
    ((a >>> 24) & 255)
  );
}
function byteSwap32(a) {
  for (let e = 0; e < a.length; e++) a[e] = byteSwap(a[e]);
  return a;
}
const swap32IfBE = isLE ? (a) => a : byteSwap32;
function utf8ToBytes(a) {
  if (typeof a != "string") throw new Error("string expected");
  return new Uint8Array(new TextEncoder().encode(a));
}
function toBytes$1(a) {
  return (typeof a == "string" && (a = utf8ToBytes(a)), abytes$1(a), a);
}
function concatBytes$2(...a) {
  let e = 0;
  for (let _ = 0; _ < a.length; _++) {
    const w = a[_];
    (abytes$1(w), (e += w.length));
  }
  const f = new Uint8Array(e);
  for (let _ = 0, w = 0; _ < a.length; _++) {
    const v = a[_];
    (f.set(v, w), (w += v.length));
  }
  return f;
}
class Hash {}
function createHasher(a) {
  const e = (_) => a().update(toBytes$1(_)).digest(),
    f = a();
  return (
    (e.outputLen = f.outputLen),
    (e.blockLen = f.blockLen),
    (e.create = () => a()),
    e
  );
}
function randomBytes(a = 32) {
  if (crypto$1 && typeof crypto$1.getRandomValues == "function")
    return crypto$1.getRandomValues(new Uint8Array(a));
  if (crypto$1 && typeof crypto$1.randomBytes == "function")
    return Uint8Array.from(crypto$1.randomBytes(a));
  throw new Error("crypto.getRandomValues must be defined");
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ const _0n$5 =
    BigInt(0),
  _1n$5 = BigInt(1);
function isBytes(a) {
  return (
    a instanceof Uint8Array ||
    (ArrayBuffer.isView(a) && a.constructor.name === "Uint8Array")
  );
}
function abytes(a) {
  if (!isBytes(a)) throw new Error("Uint8Array expected");
}
function abool(a, e) {
  if (typeof e != "boolean") throw new Error(a + " boolean expected, got " + e);
}
function numberToHexUnpadded(a) {
  const e = a.toString(16);
  return e.length & 1 ? "0" + e : e;
}
function hexToNumber$1(a) {
  if (typeof a != "string")
    throw new Error("hex string expected, got " + typeof a);
  return a === "" ? _0n$5 : BigInt("0x" + a);
}
const hasHexBuiltin =
    typeof Uint8Array.from([]).toHex == "function" &&
    typeof Uint8Array.fromHex == "function",
  hexes$1 = Array.from({ length: 256 }, (a, e) =>
    e.toString(16).padStart(2, "0"),
  );
function bytesToHex$1(a) {
  if ((abytes(a), hasHexBuiltin)) return a.toHex();
  let e = "";
  for (let f = 0; f < a.length; f++) e += hexes$1[a[f]];
  return e;
}
const asciis = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };
function asciiToBase16(a) {
  if (a >= asciis._0 && a <= asciis._9) return a - asciis._0;
  if (a >= asciis.A && a <= asciis.F) return a - (asciis.A - 10);
  if (a >= asciis.a && a <= asciis.f) return a - (asciis.a - 10);
}
function hexToBytes$1(a) {
  if (typeof a != "string")
    throw new Error("hex string expected, got " + typeof a);
  if (hasHexBuiltin) return Uint8Array.fromHex(a);
  const e = a.length,
    f = e / 2;
  if (e % 2)
    throw new Error("hex string expected, got unpadded hex of length " + e);
  const _ = new Uint8Array(f);
  for (let w = 0, v = 0; w < f; w++, v += 2) {
    const S = asciiToBase16(a.charCodeAt(v)),
      R = asciiToBase16(a.charCodeAt(v + 1));
    if (S === void 0 || R === void 0) {
      const O = a[v] + a[v + 1];
      throw new Error(
        'hex string expected, got non-hex character "' + O + '" at index ' + v,
      );
    }
    _[w] = S * 16 + R;
  }
  return _;
}
function bytesToNumberBE(a) {
  return hexToNumber$1(bytesToHex$1(a));
}
function bytesToNumberLE(a) {
  return (abytes(a), hexToNumber$1(bytesToHex$1(Uint8Array.from(a).reverse())));
}
function numberToBytesBE(a, e) {
  return hexToBytes$1(a.toString(16).padStart(e * 2, "0"));
}
function numberToBytesLE(a, e) {
  return numberToBytesBE(a, e).reverse();
}
function ensureBytes(a, e, f) {
  let _;
  if (typeof e == "string")
    try {
      _ = hexToBytes$1(e);
    } catch (v) {
      throw new Error(a + " must be hex string or Uint8Array, cause: " + v);
    }
  else if (isBytes(e)) _ = Uint8Array.from(e);
  else throw new Error(a + " must be hex string or Uint8Array");
  const w = _.length;
  if (typeof f == "number" && w !== f)
    throw new Error(a + " of length " + f + " expected, got " + w);
  return _;
}
function concatBytes$1(...a) {
  let e = 0;
  for (let _ = 0; _ < a.length; _++) {
    const w = a[_];
    (abytes(w), (e += w.length));
  }
  const f = new Uint8Array(e);
  for (let _ = 0, w = 0; _ < a.length; _++) {
    const v = a[_];
    (f.set(v, w), (w += v.length));
  }
  return f;
}
const isPosBig = (a) => typeof a == "bigint" && _0n$5 <= a;
function inRange(a, e, f) {
  return isPosBig(a) && isPosBig(e) && isPosBig(f) && e <= a && a < f;
}
function aInRange(a, e, f, _) {
  if (!inRange(e, f, _))
    throw new Error(
      "expected valid " + a + ": " + f + " <= n < " + _ + ", got " + e,
    );
}
function bitLen(a) {
  let e;
  for (e = 0; a > _0n$5; a >>= _1n$5, e += 1);
  return e;
}
const bitMask = (a) => (_1n$5 << BigInt(a)) - _1n$5,
  u8n$1 = (a) => new Uint8Array(a),
  u8fr = (a) => Uint8Array.from(a);
function createHmacDrbg(a, e, f) {
  if (typeof a != "number" || a < 2)
    throw new Error("hashLen must be a number");
  if (typeof e != "number" || e < 2)
    throw new Error("qByteLen must be a number");
  if (typeof f != "function") throw new Error("hmacFn must be a function");
  let _ = u8n$1(a),
    w = u8n$1(a),
    v = 0;
  const S = () => {
      (_.fill(1), w.fill(0), (v = 0));
    },
    R = (...q) => f(w, _, ...q),
    O = (q = u8n$1(0)) => {
      ((w = R(u8fr([0]), q)),
        (_ = R()),
        q.length !== 0 && ((w = R(u8fr([1]), q)), (_ = R())));
    },
    j = () => {
      if (v++ >= 1e3) throw new Error("drbg: tried 1000 values");
      let q = 0;
      const Q = [];
      for (; q < e; ) {
        _ = R();
        const te = _.slice();
        (Q.push(te), (q += _.length));
      }
      return concatBytes$1(...Q);
    };
  return (q, Q) => {
    (S(), O(q));
    let te;
    for (; !(te = Q(j())); ) O();
    return (S(), te);
  };
}
const validatorFns = {
  bigint: (a) => typeof a == "bigint",
  function: (a) => typeof a == "function",
  boolean: (a) => typeof a == "boolean",
  string: (a) => typeof a == "string",
  stringOrUint8Array: (a) => typeof a == "string" || isBytes(a),
  isSafeInteger: (a) => Number.isSafeInteger(a),
  array: (a) => Array.isArray(a),
  field: (a, e) => e.Fp.isValid(a),
  hash: (a) => typeof a == "function" && Number.isSafeInteger(a.outputLen),
};
function validateObject(a, e, f = {}) {
  const _ = (w, v, S) => {
    const R = validatorFns[v];
    if (typeof R != "function") throw new Error("invalid validator function");
    const O = a[w];
    if (!(S && O === void 0) && !R(O, a))
      throw new Error(
        "param " + String(w) + " is invalid. Expected " + v + ", got " + O,
      );
  };
  for (const [w, v] of Object.entries(e)) _(w, v, !1);
  for (const [w, v] of Object.entries(f)) _(w, v, !0);
  return a;
}
function memoized(a) {
  const e = new WeakMap();
  return (f, ..._) => {
    const w = e.get(f);
    if (w !== void 0) return w;
    const v = a(f, ..._);
    return (e.set(f, v), v);
  };
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ const _0n$4 =
    BigInt(0),
  _1n$4 = BigInt(1),
  _2n$2 = BigInt(2),
  _3n$1 = BigInt(3),
  _4n$1 = BigInt(4),
  _5n = BigInt(5),
  _8n = BigInt(8);
function mod(a, e) {
  const f = a % e;
  return f >= _0n$4 ? f : e + f;
}
function pow2(a, e, f) {
  let _ = a;
  for (; e-- > _0n$4; ) ((_ *= _), (_ %= f));
  return _;
}
function invert(a, e) {
  if (a === _0n$4) throw new Error("invert: expected non-zero number");
  if (e <= _0n$4)
    throw new Error("invert: expected positive modulus, got " + e);
  let f = mod(a, e),
    _ = e,
    w = _0n$4,
    v = _1n$4;
  for (; f !== _0n$4; ) {
    const R = _ / f,
      O = _ % f,
      j = w - v * R;
    ((_ = f), (f = O), (w = v), (v = j));
  }
  if (_ !== _1n$4) throw new Error("invert: does not exist");
  return mod(w, e);
}
function sqrt3mod4(a, e) {
  const f = (a.ORDER + _1n$4) / _4n$1,
    _ = a.pow(e, f);
  if (!a.eql(a.sqr(_), e)) throw new Error("Cannot find square root");
  return _;
}
function sqrt5mod8(a, e) {
  const f = (a.ORDER - _5n) / _8n,
    _ = a.mul(e, _2n$2),
    w = a.pow(_, f),
    v = a.mul(e, w),
    S = a.mul(a.mul(v, _2n$2), w),
    R = a.mul(v, a.sub(S, a.ONE));
  if (!a.eql(a.sqr(R), e)) throw new Error("Cannot find square root");
  return R;
}
function tonelliShanks(a) {
  if (a < BigInt(3)) throw new Error("sqrt is not defined for small field");
  let e = a - _1n$4,
    f = 0;
  for (; e % _2n$2 === _0n$4; ) ((e /= _2n$2), f++);
  let _ = _2n$2;
  const w = Field(a);
  for (; FpLegendre(w, _) === 1; )
    if (_++ > 1e3)
      throw new Error("Cannot find square root: probably non-prime P");
  if (f === 1) return sqrt3mod4;
  let v = w.pow(_, e);
  const S = (e + _1n$4) / _2n$2;
  return function (O, j) {
    if (O.is0(j)) return j;
    if (FpLegendre(O, j) !== 1) throw new Error("Cannot find square root");
    let F = f,
      q = O.mul(O.ONE, v),
      Q = O.pow(j, e),
      te = O.pow(j, S);
    for (; !O.eql(Q, O.ONE); ) {
      if (O.is0(Q)) return O.ZERO;
      let se = 1,
        re = O.sqr(Q);
      for (; !O.eql(re, O.ONE); )
        if ((se++, (re = O.sqr(re)), se === F))
          throw new Error("Cannot find square root");
      const Oe = _1n$4 << BigInt(F - se - 1),
        Le = O.pow(q, Oe);
      ((F = se), (q = O.sqr(Le)), (Q = O.mul(Q, q)), (te = O.mul(te, Le)));
    }
    return te;
  };
}
function FpSqrt(a) {
  return a % _4n$1 === _3n$1
    ? sqrt3mod4
    : a % _8n === _5n
      ? sqrt5mod8
      : tonelliShanks(a);
}
const FIELD_FIELDS = [
  "create",
  "isValid",
  "is0",
  "neg",
  "inv",
  "sqrt",
  "sqr",
  "eql",
  "add",
  "sub",
  "mul",
  "pow",
  "div",
  "addN",
  "subN",
  "mulN",
  "sqrN",
];
function validateField(a) {
  const e = {
      ORDER: "bigint",
      MASK: "bigint",
      BYTES: "isSafeInteger",
      BITS: "isSafeInteger",
    },
    f = FIELD_FIELDS.reduce((_, w) => ((_[w] = "function"), _), e);
  return validateObject(a, f);
}
function FpPow(a, e, f) {
  if (f < _0n$4) throw new Error("invalid exponent, negatives unsupported");
  if (f === _0n$4) return a.ONE;
  if (f === _1n$4) return e;
  let _ = a.ONE,
    w = e;
  for (; f > _0n$4; )
    (f & _1n$4 && (_ = a.mul(_, w)), (w = a.sqr(w)), (f >>= _1n$4));
  return _;
}
function FpInvertBatch(a, e, f = !1) {
  const _ = new Array(e.length).fill(f ? a.ZERO : void 0),
    w = e.reduce(
      (S, R, O) => (a.is0(R) ? S : ((_[O] = S), a.mul(S, R))),
      a.ONE,
    ),
    v = a.inv(w);
  return (
    e.reduceRight(
      (S, R, O) => (a.is0(R) ? S : ((_[O] = a.mul(S, _[O])), a.mul(S, R))),
      v,
    ),
    _
  );
}
function FpLegendre(a, e) {
  const f = (a.ORDER - _1n$4) / _2n$2,
    _ = a.pow(e, f),
    w = a.eql(_, a.ONE),
    v = a.eql(_, a.ZERO),
    S = a.eql(_, a.neg(a.ONE));
  if (!w && !v && !S) throw new Error("invalid Legendre symbol result");
  return w ? 1 : v ? 0 : -1;
}
function nLength(a, e) {
  e !== void 0 && anumber(e);
  const f = e !== void 0 ? e : a.toString(2).length,
    _ = Math.ceil(f / 8);
  return { nBitLength: f, nByteLength: _ };
}
function Field(a, e, f = !1, _ = {}) {
  if (a <= _0n$4)
    throw new Error("invalid field: expected ORDER > 0, got " + a);
  const { nBitLength: w, nByteLength: v } = nLength(a, e);
  if (v > 2048)
    throw new Error("invalid field: expected ORDER of <= 2048 bytes");
  let S;
  const R = Object.freeze({
    ORDER: a,
    isLE: f,
    BITS: w,
    BYTES: v,
    MASK: bitMask(w),
    ZERO: _0n$4,
    ONE: _1n$4,
    create: (O) => mod(O, a),
    isValid: (O) => {
      if (typeof O != "bigint")
        throw new Error(
          "invalid field element: expected bigint, got " + typeof O,
        );
      return _0n$4 <= O && O < a;
    },
    is0: (O) => O === _0n$4,
    isOdd: (O) => (O & _1n$4) === _1n$4,
    neg: (O) => mod(-O, a),
    eql: (O, j) => O === j,
    sqr: (O) => mod(O * O, a),
    add: (O, j) => mod(O + j, a),
    sub: (O, j) => mod(O - j, a),
    mul: (O, j) => mod(O * j, a),
    pow: (O, j) => FpPow(R, O, j),
    div: (O, j) => mod(O * invert(j, a), a),
    sqrN: (O) => O * O,
    addN: (O, j) => O + j,
    subN: (O, j) => O - j,
    mulN: (O, j) => O * j,
    inv: (O) => invert(O, a),
    sqrt: _.sqrt || ((O) => (S || (S = FpSqrt(a)), S(R, O))),
    toBytes: (O) => (f ? numberToBytesLE(O, v) : numberToBytesBE(O, v)),
    fromBytes: (O) => {
      if (O.length !== v)
        throw new Error(
          "Field.fromBytes: expected " + v + " bytes, got " + O.length,
        );
      return f ? bytesToNumberLE(O) : bytesToNumberBE(O);
    },
    invertBatch: (O) => FpInvertBatch(R, O),
    cmov: (O, j, F) => (F ? j : O),
  });
  return Object.freeze(R);
}
function getFieldBytesLength(a) {
  if (typeof a != "bigint") throw new Error("field order must be bigint");
  const e = a.toString(2).length;
  return Math.ceil(e / 8);
}
function getMinHashLength(a) {
  const e = getFieldBytesLength(a);
  return e + Math.ceil(e / 2);
}
function mapHashToField(a, e, f = !1) {
  const _ = a.length,
    w = getFieldBytesLength(e),
    v = getMinHashLength(e);
  if (_ < 16 || _ < v || _ > 1024)
    throw new Error("expected " + v + "-1024 bytes of input, got " + _);
  const S = f ? bytesToNumberLE(a) : bytesToNumberBE(a),
    R = mod(S, e - _1n$4) + _1n$4;
  return f ? numberToBytesLE(R, w) : numberToBytesBE(R, w);
}
function setBigUint64(a, e, f, _) {
  if (typeof a.setBigUint64 == "function") return a.setBigUint64(e, f, _);
  const w = BigInt(32),
    v = BigInt(4294967295),
    S = Number((f >> w) & v),
    R = Number(f & v),
    O = _ ? 4 : 0,
    j = _ ? 0 : 4;
  (a.setUint32(e + O, S, _), a.setUint32(e + j, R, _));
}
function Chi(a, e, f) {
  return (a & e) ^ (~a & f);
}
function Maj(a, e, f) {
  return (a & e) ^ (a & f) ^ (e & f);
}
class HashMD extends Hash {
  constructor(e, f, _, w) {
    (super(),
      (this.finished = !1),
      (this.length = 0),
      (this.pos = 0),
      (this.destroyed = !1),
      (this.blockLen = e),
      (this.outputLen = f),
      (this.padOffset = _),
      (this.isLE = w),
      (this.buffer = new Uint8Array(e)),
      (this.view = createView(this.buffer)));
  }
  update(e) {
    (aexists(this), (e = toBytes$1(e)), abytes$1(e));
    const { view: f, buffer: _, blockLen: w } = this,
      v = e.length;
    for (let S = 0; S < v; ) {
      const R = Math.min(w - this.pos, v - S);
      if (R === w) {
        const O = createView(e);
        for (; w <= v - S; S += w) this.process(O, S);
        continue;
      }
      (_.set(e.subarray(S, S + R), this.pos),
        (this.pos += R),
        (S += R),
        this.pos === w && (this.process(f, 0), (this.pos = 0)));
    }
    return ((this.length += e.length), this.roundClean(), this);
  }
  digestInto(e) {
    (aexists(this), aoutput(e, this), (this.finished = !0));
    const { buffer: f, view: _, blockLen: w, isLE: v } = this;
    let { pos: S } = this;
    ((f[S++] = 128),
      clean(this.buffer.subarray(S)),
      this.padOffset > w - S && (this.process(_, 0), (S = 0)));
    for (let q = S; q < w; q++) f[q] = 0;
    (setBigUint64(_, w - 8, BigInt(this.length * 8), v), this.process(_, 0));
    const R = createView(e),
      O = this.outputLen;
    if (O % 4) throw new Error("_sha2: outputLen should be aligned to 32bit");
    const j = O / 4,
      F = this.get();
    if (j > F.length) throw new Error("_sha2: outputLen bigger than state");
    for (let q = 0; q < j; q++) R.setUint32(4 * q, F[q], v);
  }
  digest() {
    const { buffer: e, outputLen: f } = this;
    this.digestInto(e);
    const _ = e.slice(0, f);
    return (this.destroy(), _);
  }
  _cloneInto(e) {
    (e || (e = new this.constructor()), e.set(...this.get()));
    const {
      blockLen: f,
      buffer: _,
      length: w,
      finished: v,
      destroyed: S,
      pos: R,
    } = this;
    return (
      (e.destroyed = S),
      (e.finished = v),
      (e.length = w),
      (e.pos = R),
      w % f && e.buffer.set(_),
      e
    );
  }
  clone() {
    return this._cloneInto();
  }
}
const SHA256_IV = Uint32Array.from([
    1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924,
    528734635, 1541459225,
  ]),
  U32_MASK64 = BigInt(2 ** 32 - 1),
  _32n = BigInt(32);
function fromBig(a, e = !1) {
  return e
    ? { h: Number(a & U32_MASK64), l: Number((a >> _32n) & U32_MASK64) }
    : {
        h: Number((a >> _32n) & U32_MASK64) | 0,
        l: Number(a & U32_MASK64) | 0,
      };
}
function split(a, e = !1) {
  const f = a.length;
  let _ = new Uint32Array(f),
    w = new Uint32Array(f);
  for (let v = 0; v < f; v++) {
    const { h: S, l: R } = fromBig(a[v], e);
    [_[v], w[v]] = [S, R];
  }
  return [_, w];
}
const rotlSH = (a, e, f) => (a << f) | (e >>> (32 - f)),
  rotlSL = (a, e, f) => (e << f) | (a >>> (32 - f)),
  rotlBH = (a, e, f) => (e << (f - 32)) | (a >>> (64 - f)),
  rotlBL = (a, e, f) => (a << (f - 32)) | (e >>> (64 - f)),
  SHA256_K = Uint32Array.from([
    1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993,
    2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987,
    1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774,
    264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986,
    2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711,
    113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291,
    1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411,
    3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344,
    430227734, 506948616, 659060556, 883997877, 958139571, 1322822218,
    1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424,
    2428436474, 2756734187, 3204031479, 3329325298,
  ]),
  SHA256_W = new Uint32Array(64);
class SHA256 extends HashMD {
  constructor(e = 32) {
    (super(64, e, 8, !1),
      (this.A = SHA256_IV[0] | 0),
      (this.B = SHA256_IV[1] | 0),
      (this.C = SHA256_IV[2] | 0),
      (this.D = SHA256_IV[3] | 0),
      (this.E = SHA256_IV[4] | 0),
      (this.F = SHA256_IV[5] | 0),
      (this.G = SHA256_IV[6] | 0),
      (this.H = SHA256_IV[7] | 0));
  }
  get() {
    const { A: e, B: f, C: _, D: w, E: v, F: S, G: R, H: O } = this;
    return [e, f, _, w, v, S, R, O];
  }
  set(e, f, _, w, v, S, R, O) {
    ((this.A = e | 0),
      (this.B = f | 0),
      (this.C = _ | 0),
      (this.D = w | 0),
      (this.E = v | 0),
      (this.F = S | 0),
      (this.G = R | 0),
      (this.H = O | 0));
  }
  process(e, f) {
    for (let q = 0; q < 16; q++, f += 4) SHA256_W[q] = e.getUint32(f, !1);
    for (let q = 16; q < 64; q++) {
      const Q = SHA256_W[q - 15],
        te = SHA256_W[q - 2],
        se = rotr(Q, 7) ^ rotr(Q, 18) ^ (Q >>> 3),
        re = rotr(te, 17) ^ rotr(te, 19) ^ (te >>> 10);
      SHA256_W[q] = (re + SHA256_W[q - 7] + se + SHA256_W[q - 16]) | 0;
    }
    let { A: _, B: w, C: v, D: S, E: R, F: O, G: j, H: F } = this;
    for (let q = 0; q < 64; q++) {
      const Q = rotr(R, 6) ^ rotr(R, 11) ^ rotr(R, 25),
        te = (F + Q + Chi(R, O, j) + SHA256_K[q] + SHA256_W[q]) | 0,
        re = ((rotr(_, 2) ^ rotr(_, 13) ^ rotr(_, 22)) + Maj(_, w, v)) | 0;
      ((F = j),
        (j = O),
        (O = R),
        (R = (S + te) | 0),
        (S = v),
        (v = w),
        (w = _),
        (_ = (te + re) | 0));
    }
    ((_ = (_ + this.A) | 0),
      (w = (w + this.B) | 0),
      (v = (v + this.C) | 0),
      (S = (S + this.D) | 0),
      (R = (R + this.E) | 0),
      (O = (O + this.F) | 0),
      (j = (j + this.G) | 0),
      (F = (F + this.H) | 0),
      this.set(_, w, v, S, R, O, j, F));
  }
  roundClean() {
    clean(SHA256_W);
  }
  destroy() {
    (this.set(0, 0, 0, 0, 0, 0, 0, 0), clean(this.buffer));
  }
}
const sha256$2 = createHasher(() => new SHA256());
class HMAC extends Hash {
  constructor(e, f) {
    (super(), (this.finished = !1), (this.destroyed = !1), ahash(e));
    const _ = toBytes$1(f);
    if (((this.iHash = e.create()), typeof this.iHash.update != "function"))
      throw new Error("Expected instance of class which extends utils.Hash");
    ((this.blockLen = this.iHash.blockLen),
      (this.outputLen = this.iHash.outputLen));
    const w = this.blockLen,
      v = new Uint8Array(w);
    v.set(_.length > w ? e.create().update(_).digest() : _);
    for (let S = 0; S < v.length; S++) v[S] ^= 54;
    (this.iHash.update(v), (this.oHash = e.create()));
    for (let S = 0; S < v.length; S++) v[S] ^= 106;
    (this.oHash.update(v), clean(v));
  }
  update(e) {
    return (aexists(this), this.iHash.update(e), this);
  }
  digestInto(e) {
    (aexists(this),
      abytes$1(e, this.outputLen),
      (this.finished = !0),
      this.iHash.digestInto(e),
      this.oHash.update(e),
      this.oHash.digestInto(e),
      this.destroy());
  }
  digest() {
    const e = new Uint8Array(this.oHash.outputLen);
    return (this.digestInto(e), e);
  }
  _cloneInto(e) {
    e || (e = Object.create(Object.getPrototypeOf(this), {}));
    const {
      oHash: f,
      iHash: _,
      finished: w,
      destroyed: v,
      blockLen: S,
      outputLen: R,
    } = this;
    return (
      (e = e),
      (e.finished = w),
      (e.destroyed = v),
      (e.blockLen = S),
      (e.outputLen = R),
      (e.oHash = f._cloneInto(e.oHash)),
      (e.iHash = _._cloneInto(e.iHash)),
      e
    );
  }
  clone() {
    return this._cloneInto();
  }
  destroy() {
    ((this.destroyed = !0), this.oHash.destroy(), this.iHash.destroy());
  }
}
const hmac = (a, e, f) => new HMAC(a, e).update(f).digest();
hmac.create = (a, e) => new HMAC(a, e);
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ const _0n$3 =
    BigInt(0),
  _1n$3 = BigInt(1);
function constTimeNegate(a, e) {
  const f = e.negate();
  return a ? f : e;
}
function validateW(a, e) {
  if (!Number.isSafeInteger(a) || a <= 0 || a > e)
    throw new Error("invalid window size, expected [1.." + e + "], got W=" + a);
}
function calcWOpts(a, e) {
  validateW(a, e);
  const f = Math.ceil(e / a) + 1,
    _ = 2 ** (a - 1),
    w = 2 ** a,
    v = bitMask(a),
    S = BigInt(a);
  return { windows: f, windowSize: _, mask: v, maxNumber: w, shiftBy: S };
}
function calcOffsets(a, e, f) {
  const { windowSize: _, mask: w, maxNumber: v, shiftBy: S } = f;
  let R = Number(a & w),
    O = a >> S;
  R > _ && ((R -= v), (O += _1n$3));
  const j = e * _,
    F = j + Math.abs(R) - 1,
    q = R === 0,
    Q = R < 0,
    te = e % 2 !== 0;
  return { nextN: O, offset: F, isZero: q, isNeg: Q, isNegF: te, offsetF: j };
}
function validateMSMPoints(a, e) {
  if (!Array.isArray(a)) throw new Error("array expected");
  a.forEach((f, _) => {
    if (!(f instanceof e)) throw new Error("invalid point at index " + _);
  });
}
function validateMSMScalars(a, e) {
  if (!Array.isArray(a)) throw new Error("array of scalars expected");
  a.forEach((f, _) => {
    if (!e.isValid(f)) throw new Error("invalid scalar at index " + _);
  });
}
const pointPrecomputes = new WeakMap(),
  pointWindowSizes = new WeakMap();
function getW(a) {
  return pointWindowSizes.get(a) || 1;
}
function wNAF$1(a, e) {
  return {
    constTimeNegate,
    hasPrecomputes(f) {
      return getW(f) !== 1;
    },
    unsafeLadder(f, _, w = a.ZERO) {
      let v = f;
      for (; _ > _0n$3; )
        (_ & _1n$3 && (w = w.add(v)), (v = v.double()), (_ >>= _1n$3));
      return w;
    },
    precomputeWindow(f, _) {
      const { windows: w, windowSize: v } = calcWOpts(_, e),
        S = [];
      let R = f,
        O = R;
      for (let j = 0; j < w; j++) {
        ((O = R), S.push(O));
        for (let F = 1; F < v; F++) ((O = O.add(R)), S.push(O));
        R = O.double();
      }
      return S;
    },
    wNAF(f, _, w) {
      let v = a.ZERO,
        S = a.BASE;
      const R = calcWOpts(f, e);
      for (let O = 0; O < R.windows; O++) {
        const {
          nextN: j,
          offset: F,
          isZero: q,
          isNeg: Q,
          isNegF: te,
          offsetF: se,
        } = calcOffsets(w, O, R);
        ((w = j),
          q
            ? (S = S.add(constTimeNegate(te, _[se])))
            : (v = v.add(constTimeNegate(Q, _[F]))));
      }
      return { p: v, f: S };
    },
    wNAFUnsafe(f, _, w, v = a.ZERO) {
      const S = calcWOpts(f, e);
      for (let R = 0; R < S.windows && w !== _0n$3; R++) {
        const {
          nextN: O,
          offset: j,
          isZero: F,
          isNeg: q,
        } = calcOffsets(w, R, S);
        if (((w = O), !F)) {
          const Q = _[j];
          v = v.add(q ? Q.negate() : Q);
        }
      }
      return v;
    },
    getPrecomputes(f, _, w) {
      let v = pointPrecomputes.get(_);
      return (
        v ||
          ((v = this.precomputeWindow(_, f)),
          f !== 1 && pointPrecomputes.set(_, w(v))),
        v
      );
    },
    wNAFCached(f, _, w) {
      const v = getW(f);
      return this.wNAF(v, this.getPrecomputes(v, f, w), _);
    },
    wNAFCachedUnsafe(f, _, w, v) {
      const S = getW(f);
      return S === 1
        ? this.unsafeLadder(f, _, v)
        : this.wNAFUnsafe(S, this.getPrecomputes(S, f, w), _, v);
    },
    setWindowSize(f, _) {
      (validateW(_, e), pointWindowSizes.set(f, _), pointPrecomputes.delete(f));
    },
  };
}
function pippenger(a, e, f, _) {
  (validateMSMPoints(f, a), validateMSMScalars(_, e));
  const w = f.length,
    v = _.length;
  if (w !== v)
    throw new Error("arrays of points and scalars must have equal length");
  const S = a.ZERO,
    R = bitLen(BigInt(w));
  let O = 1;
  R > 12 ? (O = R - 3) : R > 4 ? (O = R - 2) : R > 0 && (O = 2);
  const j = bitMask(O),
    F = new Array(Number(j) + 1).fill(S),
    q = Math.floor((e.BITS - 1) / O) * O;
  let Q = S;
  for (let te = q; te >= 0; te -= O) {
    F.fill(S);
    for (let re = 0; re < v; re++) {
      const Oe = _[re],
        Le = Number((Oe >> BigInt(te)) & j);
      F[Le] = F[Le].add(f[re]);
    }
    let se = S;
    for (let re = F.length - 1, Oe = S; re > 0; re--)
      ((Oe = Oe.add(F[re])), (se = se.add(Oe)));
    if (((Q = Q.add(se)), te !== 0))
      for (let re = 0; re < O; re++) Q = Q.double();
  }
  return Q;
}
function validateBasic(a) {
  return (
    validateField(a.Fp),
    validateObject(
      a,
      { n: "bigint", h: "bigint", Gx: "field", Gy: "field" },
      { nBitLength: "isSafeInteger", nByteLength: "isSafeInteger" },
    ),
    Object.freeze({ ...nLength(a.n, a.nBitLength), ...a, p: a.Fp.ORDER })
  );
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ function validateSigVerOpts(
  a,
) {
  (a.lowS !== void 0 && abool("lowS", a.lowS),
    a.prehash !== void 0 && abool("prehash", a.prehash));
}
function validatePointOpts(a) {
  const e = validateBasic(a);
  validateObject(
    e,
    { a: "field", b: "field" },
    {
      allowInfinityPoint: "boolean",
      allowedPrivateKeyLengths: "array",
      clearCofactor: "function",
      fromBytes: "function",
      isTorsionFree: "function",
      toBytes: "function",
      wrapPrivateKey: "boolean",
    },
  );
  const { endo: f, Fp: _, a: w } = e;
  if (f) {
    if (!_.eql(w, _.ZERO)) throw new Error("invalid endo: CURVE.a must be 0");
    if (
      typeof f != "object" ||
      typeof f.beta != "bigint" ||
      typeof f.splitScalar != "function"
    )
      throw new Error(
        'invalid endo: expected "beta": bigint and "splitScalar": function',
      );
  }
  return Object.freeze({ ...e });
}
class DERErr extends Error {
  constructor(e = "") {
    super(e);
  }
}
const DER = {
  Err: DERErr,
  _tlv: {
    encode: (a, e) => {
      const { Err: f } = DER;
      if (a < 0 || a > 256) throw new f("tlv.encode: wrong tag");
      if (e.length & 1) throw new f("tlv.encode: unpadded data");
      const _ = e.length / 2,
        w = numberToHexUnpadded(_);
      if ((w.length / 2) & 128)
        throw new f("tlv.encode: long form length too big");
      const v = _ > 127 ? numberToHexUnpadded((w.length / 2) | 128) : "";
      return numberToHexUnpadded(a) + v + w + e;
    },
    decode(a, e) {
      const { Err: f } = DER;
      let _ = 0;
      if (a < 0 || a > 256) throw new f("tlv.encode: wrong tag");
      if (e.length < 2 || e[_++] !== a) throw new f("tlv.decode: wrong tlv");
      const w = e[_++],
        v = !!(w & 128);
      let S = 0;
      if (!v) S = w;
      else {
        const O = w & 127;
        if (!O)
          throw new f("tlv.decode(long): indefinite length not supported");
        if (O > 4) throw new f("tlv.decode(long): byte length is too big");
        const j = e.subarray(_, _ + O);
        if (j.length !== O)
          throw new f("tlv.decode: length bytes not complete");
        if (j[0] === 0) throw new f("tlv.decode(long): zero leftmost byte");
        for (const F of j) S = (S << 8) | F;
        if (((_ += O), S < 128))
          throw new f("tlv.decode(long): not minimal encoding");
      }
      const R = e.subarray(_, _ + S);
      if (R.length !== S) throw new f("tlv.decode: wrong value length");
      return { v: R, l: e.subarray(_ + S) };
    },
  },
  _int: {
    encode(a) {
      const { Err: e } = DER;
      if (a < _0n$2) throw new e("integer: negative integers are not allowed");
      let f = numberToHexUnpadded(a);
      if ((Number.parseInt(f[0], 16) & 8 && (f = "00" + f), f.length & 1))
        throw new e("unexpected DER parsing assertion: unpadded hex");
      return f;
    },
    decode(a) {
      const { Err: e } = DER;
      if (a[0] & 128) throw new e("invalid signature integer: negative");
      if (a[0] === 0 && !(a[1] & 128))
        throw new e("invalid signature integer: unnecessary leading zero");
      return bytesToNumberBE(a);
    },
  },
  toSig(a) {
    const { Err: e, _int: f, _tlv: _ } = DER,
      w = ensureBytes("signature", a),
      { v, l: S } = _.decode(48, w);
    if (S.length) throw new e("invalid signature: left bytes after parsing");
    const { v: R, l: O } = _.decode(2, v),
      { v: j, l: F } = _.decode(2, O);
    if (F.length) throw new e("invalid signature: left bytes after parsing");
    return { r: f.decode(R), s: f.decode(j) };
  },
  hexFromSig(a) {
    const { _tlv: e, _int: f } = DER,
      _ = e.encode(2, f.encode(a.r)),
      w = e.encode(2, f.encode(a.s)),
      v = _ + w;
    return e.encode(48, v);
  },
};
function numToSizedHex(a, e) {
  return bytesToHex$1(numberToBytesBE(a, e));
}
const _0n$2 = BigInt(0),
  _1n$2 = BigInt(1);
BigInt(2);
const _3n = BigInt(3),
  _4n = BigInt(4);
function weierstrassPoints(a) {
  const e = validatePointOpts(a),
    { Fp: f } = e,
    _ = Field(e.n, e.nBitLength),
    w =
      e.toBytes ||
      ((Ve, ze, Ge) => {
        const Ke = ze.toAffine();
        return concatBytes$1(
          Uint8Array.from([4]),
          f.toBytes(Ke.x),
          f.toBytes(Ke.y),
        );
      }),
    v =
      e.fromBytes ||
      ((Ve) => {
        const ze = Ve.subarray(1),
          Ge = f.fromBytes(ze.subarray(0, f.BYTES)),
          Ke = f.fromBytes(ze.subarray(f.BYTES, 2 * f.BYTES));
        return { x: Ge, y: Ke };
      });
  function S(Ve) {
    const { a: ze, b: Ge } = e,
      Ke = f.sqr(Ve),
      qe = f.mul(Ke, Ve);
    return f.add(f.add(qe, f.mul(Ve, ze)), Ge);
  }
  function R(Ve, ze) {
    const Ge = f.sqr(ze),
      Ke = S(Ve);
    return f.eql(Ge, Ke);
  }
  if (!R(e.Gx, e.Gy)) throw new Error("bad curve params: generator point");
  const O = f.mul(f.pow(e.a, _3n), _4n),
    j = f.mul(f.sqr(e.b), BigInt(27));
  if (f.is0(f.add(O, j))) throw new Error("bad curve params: a or b");
  function F(Ve) {
    return inRange(Ve, _1n$2, e.n);
  }
  function q(Ve) {
    const {
      allowedPrivateKeyLengths: ze,
      nByteLength: Ge,
      wrapPrivateKey: Ke,
      n: qe,
    } = e;
    if (ze && typeof Ve != "bigint") {
      if (
        (isBytes(Ve) && (Ve = bytesToHex$1(Ve)),
        typeof Ve != "string" || !ze.includes(Ve.length))
      )
        throw new Error("invalid private key");
      Ve = Ve.padStart(Ge * 2, "0");
    }
    let nt;
    try {
      nt =
        typeof Ve == "bigint"
          ? Ve
          : bytesToNumberBE(ensureBytes("private key", Ve, Ge));
    } catch {
      throw new Error(
        "invalid private key, expected hex or " +
          Ge +
          " bytes, got " +
          typeof Ve,
      );
    }
    return (
      Ke && (nt = mod(nt, qe)),
      aInRange("private key", nt, _1n$2, qe),
      nt
    );
  }
  function Q(Ve) {
    if (!(Ve instanceof re)) throw new Error("ProjectivePoint expected");
  }
  const te = memoized((Ve, ze) => {
      const { px: Ge, py: Ke, pz: qe } = Ve;
      if (f.eql(qe, f.ONE)) return { x: Ge, y: Ke };
      const nt = Ve.is0();
      ze == null && (ze = nt ? f.ONE : f.inv(qe));
      const pt = f.mul(Ge, ze),
        gt = f.mul(Ke, ze),
        mt = f.mul(qe, ze);
      if (nt) return { x: f.ZERO, y: f.ZERO };
      if (!f.eql(mt, f.ONE)) throw new Error("invZ was invalid");
      return { x: pt, y: gt };
    }),
    se = memoized((Ve) => {
      if (Ve.is0()) {
        if (e.allowInfinityPoint && !f.is0(Ve.py)) return;
        throw new Error("bad point: ZERO");
      }
      const { x: ze, y: Ge } = Ve.toAffine();
      if (!f.isValid(ze) || !f.isValid(Ge))
        throw new Error("bad point: x or y not FE");
      if (!R(ze, Ge)) throw new Error("bad point: equation left != right");
      if (!Ve.isTorsionFree())
        throw new Error("bad point: not in prime-order subgroup");
      return !0;
    });
  class re {
    constructor(ze, Ge, Ke) {
      if (ze == null || !f.isValid(ze)) throw new Error("x required");
      if (Ge == null || !f.isValid(Ge) || f.is0(Ge))
        throw new Error("y required");
      if (Ke == null || !f.isValid(Ke)) throw new Error("z required");
      ((this.px = ze), (this.py = Ge), (this.pz = Ke), Object.freeze(this));
    }
    static fromAffine(ze) {
      const { x: Ge, y: Ke } = ze || {};
      if (!ze || !f.isValid(Ge) || !f.isValid(Ke))
        throw new Error("invalid affine point");
      if (ze instanceof re) throw new Error("projective point not allowed");
      const qe = (nt) => f.eql(nt, f.ZERO);
      return qe(Ge) && qe(Ke) ? re.ZERO : new re(Ge, Ke, f.ONE);
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    static normalizeZ(ze) {
      const Ge = FpInvertBatch(
        f,
        ze.map((Ke) => Ke.pz),
      );
      return ze.map((Ke, qe) => Ke.toAffine(Ge[qe])).map(re.fromAffine);
    }
    static fromHex(ze) {
      const Ge = re.fromAffine(v(ensureBytes("pointHex", ze)));
      return (Ge.assertValidity(), Ge);
    }
    static fromPrivateKey(ze) {
      return re.BASE.multiply(q(ze));
    }
    static msm(ze, Ge) {
      return pippenger(re, _, ze, Ge);
    }
    _setWindowSize(ze) {
      Be.setWindowSize(this, ze);
    }
    assertValidity() {
      se(this);
    }
    hasEvenY() {
      const { y: ze } = this.toAffine();
      if (f.isOdd) return !f.isOdd(ze);
      throw new Error("Field doesn't support isOdd");
    }
    equals(ze) {
      Q(ze);
      const { px: Ge, py: Ke, pz: qe } = this,
        { px: nt, py: pt, pz: gt } = ze,
        mt = f.eql(f.mul(Ge, gt), f.mul(nt, qe)),
        dt = f.eql(f.mul(Ke, gt), f.mul(pt, qe));
      return mt && dt;
    }
    negate() {
      return new re(this.px, f.neg(this.py), this.pz);
    }
    double() {
      const { a: ze, b: Ge } = e,
        Ke = f.mul(Ge, _3n),
        { px: qe, py: nt, pz: pt } = this;
      let gt = f.ZERO,
        mt = f.ZERO,
        dt = f.ZERO,
        _t = f.mul(qe, qe),
        bt = f.mul(nt, nt),
        at = f.mul(pt, pt),
        $e = f.mul(qe, nt);
      return (
        ($e = f.add($e, $e)),
        (dt = f.mul(qe, pt)),
        (dt = f.add(dt, dt)),
        (gt = f.mul(ze, dt)),
        (mt = f.mul(Ke, at)),
        (mt = f.add(gt, mt)),
        (gt = f.sub(bt, mt)),
        (mt = f.add(bt, mt)),
        (mt = f.mul(gt, mt)),
        (gt = f.mul($e, gt)),
        (dt = f.mul(Ke, dt)),
        (at = f.mul(ze, at)),
        ($e = f.sub(_t, at)),
        ($e = f.mul(ze, $e)),
        ($e = f.add($e, dt)),
        (dt = f.add(_t, _t)),
        (_t = f.add(dt, _t)),
        (_t = f.add(_t, at)),
        (_t = f.mul(_t, $e)),
        (mt = f.add(mt, _t)),
        (at = f.mul(nt, pt)),
        (at = f.add(at, at)),
        (_t = f.mul(at, $e)),
        (gt = f.sub(gt, _t)),
        (dt = f.mul(at, bt)),
        (dt = f.add(dt, dt)),
        (dt = f.add(dt, dt)),
        new re(gt, mt, dt)
      );
    }
    add(ze) {
      Q(ze);
      const { px: Ge, py: Ke, pz: qe } = this,
        { px: nt, py: pt, pz: gt } = ze;
      let mt = f.ZERO,
        dt = f.ZERO,
        _t = f.ZERO;
      const bt = e.a,
        at = f.mul(e.b, _3n);
      let $e = f.mul(Ge, nt),
        Ye = f.mul(Ke, pt),
        Qe = f.mul(qe, gt),
        tt = f.add(Ge, Ke),
        ht = f.add(nt, pt);
      ((tt = f.mul(tt, ht)),
        (ht = f.add($e, Ye)),
        (tt = f.sub(tt, ht)),
        (ht = f.add(Ge, qe)));
      let Fe = f.add(nt, gt);
      return (
        (ht = f.mul(ht, Fe)),
        (Fe = f.add($e, Qe)),
        (ht = f.sub(ht, Fe)),
        (Fe = f.add(Ke, qe)),
        (mt = f.add(pt, gt)),
        (Fe = f.mul(Fe, mt)),
        (mt = f.add(Ye, Qe)),
        (Fe = f.sub(Fe, mt)),
        (_t = f.mul(bt, ht)),
        (mt = f.mul(at, Qe)),
        (_t = f.add(mt, _t)),
        (mt = f.sub(Ye, _t)),
        (_t = f.add(Ye, _t)),
        (dt = f.mul(mt, _t)),
        (Ye = f.add($e, $e)),
        (Ye = f.add(Ye, $e)),
        (Qe = f.mul(bt, Qe)),
        (ht = f.mul(at, ht)),
        (Ye = f.add(Ye, Qe)),
        (Qe = f.sub($e, Qe)),
        (Qe = f.mul(bt, Qe)),
        (ht = f.add(ht, Qe)),
        ($e = f.mul(Ye, ht)),
        (dt = f.add(dt, $e)),
        ($e = f.mul(Fe, ht)),
        (mt = f.mul(tt, mt)),
        (mt = f.sub(mt, $e)),
        ($e = f.mul(tt, Ye)),
        (_t = f.mul(Fe, _t)),
        (_t = f.add(_t, $e)),
        new re(mt, dt, _t)
      );
    }
    subtract(ze) {
      return this.add(ze.negate());
    }
    is0() {
      return this.equals(re.ZERO);
    }
    wNAF(ze) {
      return Be.wNAFCached(this, ze, re.normalizeZ);
    }
    multiplyUnsafe(ze) {
      const { endo: Ge, n: Ke } = e;
      aInRange("scalar", ze, _0n$2, Ke);
      const qe = re.ZERO;
      if (ze === _0n$2) return qe;
      if (this.is0() || ze === _1n$2) return this;
      if (!Ge || Be.hasPrecomputes(this))
        return Be.wNAFCachedUnsafe(this, ze, re.normalizeZ);
      let { k1neg: nt, k1: pt, k2neg: gt, k2: mt } = Ge.splitScalar(ze),
        dt = qe,
        _t = qe,
        bt = this;
      for (; pt > _0n$2 || mt > _0n$2; )
        (pt & _1n$2 && (dt = dt.add(bt)),
          mt & _1n$2 && (_t = _t.add(bt)),
          (bt = bt.double()),
          (pt >>= _1n$2),
          (mt >>= _1n$2));
      return (
        nt && (dt = dt.negate()),
        gt && (_t = _t.negate()),
        (_t = new re(f.mul(_t.px, Ge.beta), _t.py, _t.pz)),
        dt.add(_t)
      );
    }
    multiply(ze) {
      const { endo: Ge, n: Ke } = e;
      aInRange("scalar", ze, _1n$2, Ke);
      let qe, nt;
      if (Ge) {
        const { k1neg: pt, k1: gt, k2neg: mt, k2: dt } = Ge.splitScalar(ze);
        let { p: _t, f: bt } = this.wNAF(gt),
          { p: at, f: $e } = this.wNAF(dt);
        ((_t = Be.constTimeNegate(pt, _t)),
          (at = Be.constTimeNegate(mt, at)),
          (at = new re(f.mul(at.px, Ge.beta), at.py, at.pz)),
          (qe = _t.add(at)),
          (nt = bt.add($e)));
      } else {
        const { p: pt, f: gt } = this.wNAF(ze);
        ((qe = pt), (nt = gt));
      }
      return re.normalizeZ([qe, nt])[0];
    }
    multiplyAndAddUnsafe(ze, Ge, Ke) {
      const qe = re.BASE,
        nt = (gt, mt) =>
          mt === _0n$2 || mt === _1n$2 || !gt.equals(qe)
            ? gt.multiplyUnsafe(mt)
            : gt.multiply(mt),
        pt = nt(this, Ge).add(nt(ze, Ke));
      return pt.is0() ? void 0 : pt;
    }
    toAffine(ze) {
      return te(this, ze);
    }
    isTorsionFree() {
      const { h: ze, isTorsionFree: Ge } = e;
      if (ze === _1n$2) return !0;
      if (Ge) return Ge(re, this);
      throw new Error(
        "isTorsionFree() has not been declared for the elliptic curve",
      );
    }
    clearCofactor() {
      const { h: ze, clearCofactor: Ge } = e;
      return ze === _1n$2 ? this : Ge ? Ge(re, this) : this.multiplyUnsafe(e.h);
    }
    toRawBytes(ze = !0) {
      return (
        abool("isCompressed", ze),
        this.assertValidity(),
        w(re, this, ze)
      );
    }
    toHex(ze = !0) {
      return (abool("isCompressed", ze), bytesToHex$1(this.toRawBytes(ze)));
    }
  }
  ((re.BASE = new re(e.Gx, e.Gy, f.ONE)),
    (re.ZERO = new re(f.ZERO, f.ONE, f.ZERO)));
  const { endo: Oe, nBitLength: Le } = e,
    Be = wNAF$1(re, Oe ? Math.ceil(Le / 2) : Le);
  return {
    CURVE: e,
    ProjectivePoint: re,
    normPrivateKeyToScalar: q,
    weierstrassEquation: S,
    isWithinCurveOrder: F,
  };
}
function validateOpts(a) {
  const e = validateBasic(a);
  return (
    validateObject(
      e,
      { hash: "hash", hmac: "function", randomBytes: "function" },
      { bits2int: "function", bits2int_modN: "function", lowS: "boolean" },
    ),
    Object.freeze({ lowS: !0, ...e })
  );
}
function weierstrass(a) {
  const e = validateOpts(a),
    { Fp: f, n: _, nByteLength: w, nBitLength: v } = e,
    S = f.BYTES + 1,
    R = 2 * f.BYTES + 1;
  function O(at) {
    return mod(at, _);
  }
  function j(at) {
    return invert(at, _);
  }
  const {
    ProjectivePoint: F,
    normPrivateKeyToScalar: q,
    weierstrassEquation: Q,
    isWithinCurveOrder: te,
  } = weierstrassPoints({
    ...e,
    toBytes(at, $e, Ye) {
      const Qe = $e.toAffine(),
        tt = f.toBytes(Qe.x),
        ht = concatBytes$1;
      return (
        abool("isCompressed", Ye),
        Ye
          ? ht(Uint8Array.from([$e.hasEvenY() ? 2 : 3]), tt)
          : ht(Uint8Array.from([4]), tt, f.toBytes(Qe.y))
      );
    },
    fromBytes(at) {
      const $e = at.length,
        Ye = at[0],
        Qe = at.subarray(1);
      if ($e === S && (Ye === 2 || Ye === 3)) {
        const tt = bytesToNumberBE(Qe);
        if (!inRange(tt, _1n$2, f.ORDER))
          throw new Error("Point is not on curve");
        const ht = Q(tt);
        let Fe;
        try {
          Fe = f.sqrt(ht);
        } catch (lt) {
          const ut = lt instanceof Error ? ": " + lt.message : "";
          throw new Error("Point is not on curve" + ut);
        }
        const Ue = (Fe & _1n$2) === _1n$2;
        return (((Ye & 1) === 1) !== Ue && (Fe = f.neg(Fe)), { x: tt, y: Fe });
      } else if ($e === R && Ye === 4) {
        const tt = f.fromBytes(Qe.subarray(0, f.BYTES)),
          ht = f.fromBytes(Qe.subarray(f.BYTES, 2 * f.BYTES));
        return { x: tt, y: ht };
      } else {
        const tt = S,
          ht = R;
        throw new Error(
          "invalid Point, expected length of " +
            tt +
            ", or uncompressed " +
            ht +
            ", got " +
            $e,
        );
      }
    },
  });
  function se(at) {
    const $e = _ >> _1n$2;
    return at > $e;
  }
  function re(at) {
    return se(at) ? O(-at) : at;
  }
  const Oe = (at, $e, Ye) => bytesToNumberBE(at.slice($e, Ye));
  class Le {
    constructor($e, Ye, Qe) {
      (aInRange("r", $e, _1n$2, _),
        aInRange("s", Ye, _1n$2, _),
        (this.r = $e),
        (this.s = Ye),
        Qe != null && (this.recovery = Qe),
        Object.freeze(this));
    }
    static fromCompact($e) {
      const Ye = w;
      return (
        ($e = ensureBytes("compactSignature", $e, Ye * 2)),
        new Le(Oe($e, 0, Ye), Oe($e, Ye, 2 * Ye))
      );
    }
    static fromDER($e) {
      const { r: Ye, s: Qe } = DER.toSig(ensureBytes("DER", $e));
      return new Le(Ye, Qe);
    }
    assertValidity() {}
    addRecoveryBit($e) {
      return new Le(this.r, this.s, $e);
    }
    recoverPublicKey($e) {
      const { r: Ye, s: Qe, recovery: tt } = this,
        ht = qe(ensureBytes("msgHash", $e));
      if (tt == null || ![0, 1, 2, 3].includes(tt))
        throw new Error("recovery id invalid");
      const Fe = tt === 2 || tt === 3 ? Ye + e.n : Ye;
      if (Fe >= f.ORDER) throw new Error("recovery id 2 or 3 invalid");
      const Ue = (tt & 1) === 0 ? "02" : "03",
        ot = F.fromHex(Ue + numToSizedHex(Fe, f.BYTES)),
        lt = j(Fe),
        ut = O(-ht * lt),
        yt = O(Qe * lt),
        it = F.BASE.multiplyAndAddUnsafe(ot, ut, yt);
      if (!it) throw new Error("point at infinify");
      return (it.assertValidity(), it);
    }
    hasHighS() {
      return se(this.s);
    }
    normalizeS() {
      return this.hasHighS() ? new Le(this.r, O(-this.s), this.recovery) : this;
    }
    toDERRawBytes() {
      return hexToBytes$1(this.toDERHex());
    }
    toDERHex() {
      return DER.hexFromSig(this);
    }
    toCompactRawBytes() {
      return hexToBytes$1(this.toCompactHex());
    }
    toCompactHex() {
      const $e = w;
      return numToSizedHex(this.r, $e) + numToSizedHex(this.s, $e);
    }
  }
  const Be = {
    isValidPrivateKey(at) {
      try {
        return (q(at), !0);
      } catch {
        return !1;
      }
    },
    normPrivateKeyToScalar: q,
    randomPrivateKey: () => {
      const at = getMinHashLength(e.n);
      return mapHashToField(e.randomBytes(at), e.n);
    },
    precompute(at = 8, $e = F.BASE) {
      return ($e._setWindowSize(at), $e.multiply(BigInt(3)), $e);
    },
  };
  function Ve(at, $e = !0) {
    return F.fromPrivateKey(at).toRawBytes($e);
  }
  function ze(at) {
    if (typeof at == "bigint") return !1;
    if (at instanceof F) return !0;
    const Ye = ensureBytes("key", at).length,
      Qe = f.BYTES,
      tt = Qe + 1,
      ht = 2 * Qe + 1;
    if (!(e.allowedPrivateKeyLengths || w === tt))
      return Ye === tt || Ye === ht;
  }
  function Ge(at, $e, Ye = !0) {
    if (ze(at) === !0) throw new Error("first arg must be private key");
    if (ze($e) === !1) throw new Error("second arg must be public key");
    return F.fromHex($e).multiply(q(at)).toRawBytes(Ye);
  }
  const Ke =
      e.bits2int ||
      function (at) {
        if (at.length > 8192) throw new Error("input is too large");
        const $e = bytesToNumberBE(at),
          Ye = at.length * 8 - v;
        return Ye > 0 ? $e >> BigInt(Ye) : $e;
      },
    qe =
      e.bits2int_modN ||
      function (at) {
        return O(Ke(at));
      },
    nt = bitMask(v);
  function pt(at) {
    return (aInRange("num < 2^" + v, at, _0n$2, nt), numberToBytesBE(at, w));
  }
  function gt(at, $e, Ye = mt) {
    if (["recovered", "canonical"].some((xt) => xt in Ye))
      throw new Error("sign() legacy options not supported");
    const { hash: Qe, randomBytes: tt } = e;
    let { lowS: ht, prehash: Fe, extraEntropy: Ue } = Ye;
    (ht == null && (ht = !0),
      (at = ensureBytes("msgHash", at)),
      validateSigVerOpts(Ye),
      Fe && (at = ensureBytes("prehashed msgHash", Qe(at))));
    const ot = qe(at),
      lt = q($e),
      ut = [pt(lt), pt(ot)];
    if (Ue != null && Ue !== !1) {
      const xt = Ue === !0 ? tt(f.BYTES) : Ue;
      ut.push(ensureBytes("extraEntropy", xt));
    }
    const yt = concatBytes$1(...ut),
      it = ot;
    function Et(xt) {
      const At = Ke(xt);
      if (!te(At)) return;
      const Lt = j(At),
        Vt = F.BASE.multiply(At).toAffine(),
        Yt = O(Vt.x);
      if (Yt === _0n$2) return;
      const Zt = O(Lt * O(it + Yt * lt));
      if (Zt === _0n$2) return;
      let gn = (Vt.x === Yt ? 0 : 2) | Number(Vt.y & _1n$2),
        Wn = Zt;
      return (ht && se(Zt) && ((Wn = re(Zt)), (gn ^= 1)), new Le(Yt, Wn, gn));
    }
    return { seed: yt, k2sig: Et };
  }
  const mt = { lowS: e.lowS, prehash: !1 },
    dt = { lowS: e.lowS, prehash: !1 };
  function _t(at, $e, Ye = mt) {
    const { seed: Qe, k2sig: tt } = gt(at, $e, Ye),
      ht = e;
    return createHmacDrbg(ht.hash.outputLen, ht.nByteLength, ht.hmac)(Qe, tt);
  }
  F.BASE._setWindowSize(8);
  function bt(at, $e, Ye, Qe = dt) {
    const tt = at;
    (($e = ensureBytes("msgHash", $e)), (Ye = ensureBytes("publicKey", Ye)));
    const { lowS: ht, prehash: Fe, format: Ue } = Qe;
    if ((validateSigVerOpts(Qe), "strict" in Qe))
      throw new Error("options.strict was renamed to lowS");
    if (Ue !== void 0 && Ue !== "compact" && Ue !== "der")
      throw new Error("format must be compact or der");
    const ot = typeof tt == "string" || isBytes(tt),
      lt =
        !ot &&
        !Ue &&
        typeof tt == "object" &&
        tt !== null &&
        typeof tt.r == "bigint" &&
        typeof tt.s == "bigint";
    if (!ot && !lt)
      throw new Error(
        "invalid signature, expected Uint8Array, hex string or Signature instance",
      );
    let ut, yt;
    try {
      if ((lt && (ut = new Le(tt.r, tt.s)), ot)) {
        try {
          Ue !== "compact" && (ut = Le.fromDER(tt));
        } catch (gn) {
          if (!(gn instanceof DER.Err)) throw gn;
        }
        !ut && Ue !== "der" && (ut = Le.fromCompact(tt));
      }
      yt = F.fromHex(Ye);
    } catch {
      return !1;
    }
    if (!ut || (ht && ut.hasHighS())) return !1;
    Fe && ($e = e.hash($e));
    const { r: it, s: Et } = ut,
      xt = qe($e),
      At = j(Et),
      Lt = O(xt * At),
      Vt = O(it * At),
      Yt = F.BASE.multiplyAndAddUnsafe(yt, Lt, Vt)?.toAffine();
    return Yt ? O(Yt.x) === it : !1;
  }
  return {
    CURVE: e,
    getPublicKey: Ve,
    getSharedSecret: Ge,
    sign: _t,
    verify: bt,
    ProjectivePoint: F,
    Signature: Le,
    utils: Be,
  };
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ function getHash(
  a,
) {
  return {
    hash: a,
    hmac: (e, ...f) => hmac(a, e, concatBytes$2(...f)),
    randomBytes,
  };
}
function createCurve(a, e) {
  const f = (_) => weierstrass({ ...a, ...getHash(_) });
  return { ...f(e), create: f };
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ const secp256k1P =
    BigInt(
      "0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f",
    ),
  secp256k1N = BigInt(
    "0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141",
  ),
  _0n$1 = BigInt(0),
  _1n$1 = BigInt(1),
  _2n$1 = BigInt(2),
  divNearest = (a, e) => (a + e / _2n$1) / e;
function sqrtMod(a) {
  const e = secp256k1P,
    f = BigInt(3),
    _ = BigInt(6),
    w = BigInt(11),
    v = BigInt(22),
    S = BigInt(23),
    R = BigInt(44),
    O = BigInt(88),
    j = (a * a * a) % e,
    F = (j * j * a) % e,
    q = (pow2(F, f, e) * F) % e,
    Q = (pow2(q, f, e) * F) % e,
    te = (pow2(Q, _2n$1, e) * j) % e,
    se = (pow2(te, w, e) * te) % e,
    re = (pow2(se, v, e) * se) % e,
    Oe = (pow2(re, R, e) * re) % e,
    Le = (pow2(Oe, O, e) * Oe) % e,
    Be = (pow2(Le, R, e) * re) % e,
    Ve = (pow2(Be, f, e) * F) % e,
    ze = (pow2(Ve, S, e) * se) % e,
    Ge = (pow2(ze, _, e) * j) % e,
    Ke = pow2(Ge, _2n$1, e);
  if (!Fpk1.eql(Fpk1.sqr(Ke), a)) throw new Error("Cannot find square root");
  return Ke;
}
const Fpk1 = Field(secp256k1P, void 0, void 0, { sqrt: sqrtMod }),
  secp256k1 = createCurve(
    {
      a: _0n$1,
      b: BigInt(7),
      Fp: Fpk1,
      n: secp256k1N,
      Gx: BigInt(
        "55066263022277343669578718895168534326250603453777594175500187360389116729240",
      ),
      Gy: BigInt(
        "32670510020758816978083085130507043184471273380659243275938904335757337482424",
      ),
      h: BigInt(1),
      lowS: !0,
      endo: {
        beta: BigInt(
          "0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee",
        ),
        splitScalar: (a) => {
          const e = secp256k1N,
            f = BigInt("0x3086d221a7d46bcde86c90e49284eb15"),
            _ = -_1n$1 * BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),
            w = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),
            v = f,
            S = BigInt("0x100000000000000000000000000000000"),
            R = divNearest(v * a, e),
            O = divNearest(-_ * a, e);
          let j = mod(a - R * f - O * w, e),
            F = mod(-R * _ - O * v, e);
          const q = j > S,
            Q = F > S;
          if ((q && (j = e - j), Q && (F = e - F), j > S || F > S))
            throw new Error("splitScalar: Endomorphism failed, k=" + a);
          return { k1neg: q, k1: j, k2neg: Q, k2: F };
        },
      },
    },
    sha256$2,
  ),
  version = "2.38.4";
let errorConfig = {
  getDocsUrl: ({ docsBaseUrl: a, docsPath: e = "", docsSlug: f }) =>
    e ? `${a ?? "https://viem.sh"}${e}${f ? `#${f}` : ""}` : void 0,
  version: `viem@${version}`,
};
class BaseError extends Error {
  constructor(e, f = {}) {
    const _ =
        f.cause instanceof BaseError
          ? f.cause.details
          : f.cause?.message
            ? f.cause.message
            : f.details,
      w = (f.cause instanceof BaseError && f.cause.docsPath) || f.docsPath,
      v = errorConfig.getDocsUrl?.({ ...f, docsPath: w }),
      S = [
        e || "An error occurred.",
        "",
        ...(f.metaMessages ? [...f.metaMessages, ""] : []),
        ...(v ? [`Docs: ${v}`] : []),
        ...(_ ? [`Details: ${_}`] : []),
        ...(errorConfig.version ? [`Version: ${errorConfig.version}`] : []),
      ].join(`
`);
    (super(S, f.cause ? { cause: f.cause } : void 0),
      Object.defineProperty(this, "details", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0,
      }),
      Object.defineProperty(this, "docsPath", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0,
      }),
      Object.defineProperty(this, "metaMessages", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0,
      }),
      Object.defineProperty(this, "shortMessage", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0,
      }),
      Object.defineProperty(this, "version", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0,
      }),
      Object.defineProperty(this, "name", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: "BaseError",
      }),
      (this.details = _),
      (this.docsPath = w),
      (this.metaMessages = f.metaMessages),
      (this.name = f.name ?? this.name),
      (this.shortMessage = e),
      (this.version = version));
  }
  walk(e) {
    return walk(this, e);
  }
}
function walk(a, e) {
  return e?.(a)
    ? a
    : a && typeof a == "object" && "cause" in a && a.cause !== void 0
      ? walk(a.cause, e)
      : e
        ? null
        : a;
}
class IntegerOutOfRangeError extends BaseError {
  constructor({ max: e, min: f, signed: _, size: w, value: v }) {
    super(
      `Number "${v}" is not in safe ${w ? `${w * 8}-bit ${_ ? "signed" : "unsigned"} ` : ""}integer range ${e ? `(${f} to ${e})` : `(above ${f})`}`,
      { name: "IntegerOutOfRangeError" },
    );
  }
}
class SizeOverflowError extends BaseError {
  constructor({ givenSize: e, maxSize: f }) {
    super(`Size cannot exceed ${f} bytes. Given size: ${e} bytes.`, {
      name: "SizeOverflowError",
    });
  }
}
function isHex(a, { strict: e = !0 } = {}) {
  return !a || typeof a != "string"
    ? !1
    : e
      ? /^0x[0-9a-fA-F]*$/.test(a)
      : a.startsWith("0x");
}
function size(a) {
  return isHex(a, { strict: !1 }) ? Math.ceil((a.length - 2) / 2) : a.length;
}
function trim(a, { dir: e = "left" } = {}) {
  let f = typeof a == "string" ? a.replace("0x", "") : a,
    _ = 0;
  for (
    let w = 0;
    w < f.length - 1 &&
    f[e === "left" ? w : f.length - w - 1].toString() === "0";
    w++
  )
    _++;
  return (
    (f = e === "left" ? f.slice(_) : f.slice(0, f.length - _)),
    typeof a == "string"
      ? (f.length === 1 && e === "right" && (f = `${f}0`),
        `0x${f.length % 2 === 1 ? `0${f}` : f}`)
      : f
  );
}
class SliceOffsetOutOfBoundsError extends BaseError {
  constructor({ offset: e, position: f, size: _ }) {
    super(
      `Slice ${f === "start" ? "starting" : "ending"} at offset "${e}" is out-of-bounds (size: ${_}).`,
      { name: "SliceOffsetOutOfBoundsError" },
    );
  }
}
class SizeExceedsPaddingSizeError extends BaseError {
  constructor({ size: e, targetSize: f, type: _ }) {
    super(
      `${_.charAt(0).toUpperCase()}${_.slice(1).toLowerCase()} size (${e}) exceeds padding size (${f}).`,
      { name: "SizeExceedsPaddingSizeError" },
    );
  }
}
function pad(a, { dir: e, size: f = 32 } = {}) {
  return typeof a == "string"
    ? padHex(a, { dir: e, size: f })
    : padBytes(a, { dir: e, size: f });
}
function padHex(a, { dir: e, size: f = 32 } = {}) {
  if (f === null) return a;
  const _ = a.replace("0x", "");
  if (_.length > f * 2)
    throw new SizeExceedsPaddingSizeError({
      size: Math.ceil(_.length / 2),
      targetSize: f,
      type: "hex",
    });
  return `0x${_[e === "right" ? "padEnd" : "padStart"](f * 2, "0")}`;
}
function padBytes(a, { dir: e, size: f = 32 } = {}) {
  if (f === null) return a;
  if (a.length > f)
    throw new SizeExceedsPaddingSizeError({
      size: a.length,
      targetSize: f,
      type: "bytes",
    });
  const _ = new Uint8Array(f);
  for (let w = 0; w < f; w++) {
    const v = e === "right";
    _[v ? w : f - w - 1] = a[v ? w : a.length - w - 1];
  }
  return _;
}
const hexes = Array.from({ length: 256 }, (a, e) =>
  e.toString(16).padStart(2, "0"),
);
function toHex(a, e = {}) {
  return typeof a == "number" || typeof a == "bigint"
    ? numberToHex(a, e)
    : typeof a == "string"
      ? stringToHex(a, e)
      : typeof a == "boolean"
        ? boolToHex(a, e)
        : bytesToHex(a, e);
}
function boolToHex(a, e = {}) {
  const f = `0x${Number(a)}`;
  return typeof e.size == "number"
    ? (assertSize(f, { size: e.size }), pad(f, { size: e.size }))
    : f;
}
function bytesToHex(a, e = {}) {
  let f = "";
  for (let w = 0; w < a.length; w++) f += hexes[a[w]];
  const _ = `0x${f}`;
  return typeof e.size == "number"
    ? (assertSize(_, { size: e.size }), pad(_, { dir: "right", size: e.size }))
    : _;
}
function numberToHex(a, e = {}) {
  const { signed: f, size: _ } = e,
    w = BigInt(a);
  let v;
  _
    ? f
      ? (v = (1n << (BigInt(_) * 8n - 1n)) - 1n)
      : (v = 2n ** (BigInt(_) * 8n) - 1n)
    : typeof a == "number" && (v = BigInt(Number.MAX_SAFE_INTEGER));
  const S = typeof v == "bigint" && f ? -v - 1n : 0;
  if ((v && w > v) || w < S) {
    const O = typeof a == "bigint" ? "n" : "";
    throw new IntegerOutOfRangeError({
      max: v ? `${v}${O}` : void 0,
      min: `${S}${O}`,
      signed: f,
      size: _,
      value: `${a}${O}`,
    });
  }
  const R = `0x${(f && w < 0 ? (1n << BigInt(_ * 8)) + BigInt(w) : w).toString(16)}`;
  return _ ? pad(R, { size: _ }) : R;
}
const encoder$1 = new TextEncoder();
function stringToHex(a, e = {}) {
  const f = encoder$1.encode(a);
  return bytesToHex(f, e);
}
const encoder = new TextEncoder();
function toBytes(a, e = {}) {
  return typeof a == "number" || typeof a == "bigint"
    ? numberToBytes(a, e)
    : typeof a == "boolean"
      ? boolToBytes(a, e)
      : isHex(a)
        ? hexToBytes(a, e)
        : stringToBytes(a, e);
}
function boolToBytes(a, e = {}) {
  const f = new Uint8Array(1);
  return (
    (f[0] = Number(a)),
    typeof e.size == "number"
      ? (assertSize(f, { size: e.size }), pad(f, { size: e.size }))
      : f
  );
}
const charCodeMap = { zero: 48, nine: 57, A: 65, F: 70, a: 97, f: 102 };
function charCodeToBase16(a) {
  if (a >= charCodeMap.zero && a <= charCodeMap.nine)
    return a - charCodeMap.zero;
  if (a >= charCodeMap.A && a <= charCodeMap.F) return a - (charCodeMap.A - 10);
  if (a >= charCodeMap.a && a <= charCodeMap.f) return a - (charCodeMap.a - 10);
}
function hexToBytes(a, e = {}) {
  let f = a;
  e.size &&
    (assertSize(f, { size: e.size }),
    (f = pad(f, { dir: "right", size: e.size })));
  let _ = f.slice(2);
  _.length % 2 && (_ = `0${_}`);
  const w = _.length / 2,
    v = new Uint8Array(w);
  for (let S = 0, R = 0; S < w; S++) {
    const O = charCodeToBase16(_.charCodeAt(R++)),
      j = charCodeToBase16(_.charCodeAt(R++));
    if (O === void 0 || j === void 0)
      throw new BaseError(
        `Invalid byte sequence ("${_[R - 2]}${_[R - 1]}" in "${_}").`,
      );
    v[S] = O * 16 + j;
  }
  return v;
}
function numberToBytes(a, e) {
  const f = numberToHex(a, e);
  return hexToBytes(f);
}
function stringToBytes(a, e = {}) {
  const f = encoder.encode(a);
  return typeof e.size == "number"
    ? (assertSize(f, { size: e.size }), pad(f, { dir: "right", size: e.size }))
    : f;
}
function assertSize(a, { size: e }) {
  if (size(a) > e)
    throw new SizeOverflowError({ givenSize: size(a), maxSize: e });
}
function hexToBigInt(a, e = {}) {
  const { signed: f } = e;
  e.size && assertSize(a, { size: e.size });
  const _ = BigInt(a);
  if (!f) return _;
  const w = (a.length - 2) / 2,
    v = (1n << (BigInt(w) * 8n - 1n)) - 1n;
  return _ <= v ? _ : _ - BigInt(`0x${"f".padStart(w * 2, "f")}`) - 1n;
}
function hexToNumber(a, e = {}) {
  return Number(hexToBigInt(a, e));
}
class LruMap extends Map {
  constructor(e) {
    (super(),
      Object.defineProperty(this, "maxSize", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0,
      }),
      (this.maxSize = e));
  }
  get(e) {
    const f = super.get(e);
    return (
      super.has(e) && f !== void 0 && (this.delete(e), super.set(e, f)),
      f
    );
  }
  set(e, f) {
    if ((super.set(e, f), this.maxSize && this.size > this.maxSize)) {
      const _ = this.keys().next().value;
      _ && this.delete(_);
    }
    return this;
  }
}
function serializeSignature({ r: a, s: e, to: f = "hex", v: _, yParity: w }) {
  const v = (() => {
      if (w === 0 || w === 1) return w;
      if (_ && (_ === 27n || _ === 28n || _ >= 35n))
        return _ % 2n === 0n ? 1 : 0;
      throw new Error("Invalid `v` or `yParity` value");
    })(),
    S = `0x${new secp256k1.Signature(hexToBigInt(a), hexToBigInt(e)).toCompactHex()}${v === 0 ? "1b" : "1c"}`;
  return f === "hex" ? S : hexToBytes(S);
}
function generatePrivateKey() {
  return toHex(secp256k1.utils.randomPrivateKey());
}
class InvalidAddressError extends BaseError {
  constructor({ address: e }) {
    super(`Address "${e}" is invalid.`, {
      metaMessages: [
        "- Address must be a hex value of 20 bytes (40 hex characters).",
        "- Address must match its checksum counterpart.",
      ],
      name: "InvalidAddressError",
    });
  }
}
const _0n = BigInt(0),
  _1n = BigInt(1),
  _2n = BigInt(2),
  _7n = BigInt(7),
  _256n = BigInt(256),
  _0x71n = BigInt(113),
  SHA3_PI = [],
  SHA3_ROTL = [],
  _SHA3_IOTA = [];
for (let a = 0, e = _1n, f = 1, _ = 0; a < 24; a++) {
  (([f, _] = [_, (2 * f + 3 * _) % 5]),
    SHA3_PI.push(2 * (5 * _ + f)),
    SHA3_ROTL.push((((a + 1) * (a + 2)) / 2) % 64));
  let w = _0n;
  for (let v = 0; v < 7; v++)
    ((e = ((e << _1n) ^ ((e >> _7n) * _0x71n)) % _256n),
      e & _2n && (w ^= _1n << ((_1n << BigInt(v)) - _1n)));
  _SHA3_IOTA.push(w);
}
const IOTAS = split(_SHA3_IOTA, !0),
  SHA3_IOTA_H = IOTAS[0],
  SHA3_IOTA_L = IOTAS[1],
  rotlH = (a, e, f) => (f > 32 ? rotlBH(a, e, f) : rotlSH(a, e, f)),
  rotlL = (a, e, f) => (f > 32 ? rotlBL(a, e, f) : rotlSL(a, e, f));
function keccakP(a, e = 24) {
  const f = new Uint32Array(10);
  for (let _ = 24 - e; _ < 24; _++) {
    for (let S = 0; S < 10; S++)
      f[S] = a[S] ^ a[S + 10] ^ a[S + 20] ^ a[S + 30] ^ a[S + 40];
    for (let S = 0; S < 10; S += 2) {
      const R = (S + 8) % 10,
        O = (S + 2) % 10,
        j = f[O],
        F = f[O + 1],
        q = rotlH(j, F, 1) ^ f[R],
        Q = rotlL(j, F, 1) ^ f[R + 1];
      for (let te = 0; te < 50; te += 10)
        ((a[S + te] ^= q), (a[S + te + 1] ^= Q));
    }
    let w = a[2],
      v = a[3];
    for (let S = 0; S < 24; S++) {
      const R = SHA3_ROTL[S],
        O = rotlH(w, v, R),
        j = rotlL(w, v, R),
        F = SHA3_PI[S];
      ((w = a[F]), (v = a[F + 1]), (a[F] = O), (a[F + 1] = j));
    }
    for (let S = 0; S < 50; S += 10) {
      for (let R = 0; R < 10; R++) f[R] = a[S + R];
      for (let R = 0; R < 10; R++)
        a[S + R] ^= ~f[(R + 2) % 10] & f[(R + 4) % 10];
    }
    ((a[0] ^= SHA3_IOTA_H[_]), (a[1] ^= SHA3_IOTA_L[_]));
  }
  clean(f);
}
class Keccak extends Hash {
  constructor(e, f, _, w = !1, v = 24) {
    if (
      (super(),
      (this.pos = 0),
      (this.posOut = 0),
      (this.finished = !1),
      (this.destroyed = !1),
      (this.enableXOF = !1),
      (this.blockLen = e),
      (this.suffix = f),
      (this.outputLen = _),
      (this.enableXOF = w),
      (this.rounds = v),
      anumber(_),
      !(0 < e && e < 200))
    )
      throw new Error("only keccak-f1600 function is supported");
    ((this.state = new Uint8Array(200)), (this.state32 = u32(this.state)));
  }
  clone() {
    return this._cloneInto();
  }
  keccak() {
    (swap32IfBE(this.state32),
      keccakP(this.state32, this.rounds),
      swap32IfBE(this.state32),
      (this.posOut = 0),
      (this.pos = 0));
  }
  update(e) {
    (aexists(this), (e = toBytes$1(e)), abytes$1(e));
    const { blockLen: f, state: _ } = this,
      w = e.length;
    for (let v = 0; v < w; ) {
      const S = Math.min(f - this.pos, w - v);
      for (let R = 0; R < S; R++) _[this.pos++] ^= e[v++];
      this.pos === f && this.keccak();
    }
    return this;
  }
  finish() {
    if (this.finished) return;
    this.finished = !0;
    const { state: e, suffix: f, pos: _, blockLen: w } = this;
    ((e[_] ^= f),
      (f & 128) !== 0 && _ === w - 1 && this.keccak(),
      (e[w - 1] ^= 128),
      this.keccak());
  }
  writeInto(e) {
    (aexists(this, !1), abytes$1(e), this.finish());
    const f = this.state,
      { blockLen: _ } = this;
    for (let w = 0, v = e.length; w < v; ) {
      this.posOut >= _ && this.keccak();
      const S = Math.min(_ - this.posOut, v - w);
      (e.set(f.subarray(this.posOut, this.posOut + S), w),
        (this.posOut += S),
        (w += S));
    }
    return e;
  }
  xofInto(e) {
    if (!this.enableXOF)
      throw new Error("XOF is not possible for this instance");
    return this.writeInto(e);
  }
  xof(e) {
    return (anumber(e), this.xofInto(new Uint8Array(e)));
  }
  digestInto(e) {
    if ((aoutput(e, this), this.finished))
      throw new Error("digest() was already called");
    return (this.writeInto(e), this.destroy(), e);
  }
  digest() {
    return this.digestInto(new Uint8Array(this.outputLen));
  }
  destroy() {
    ((this.destroyed = !0), clean(this.state));
  }
  _cloneInto(e) {
    const {
      blockLen: f,
      suffix: _,
      outputLen: w,
      rounds: v,
      enableXOF: S,
    } = this;
    return (
      e || (e = new Keccak(f, _, w, S, v)),
      e.state32.set(this.state32),
      (e.pos = this.pos),
      (e.posOut = this.posOut),
      (e.finished = this.finished),
      (e.rounds = v),
      (e.suffix = _),
      (e.outputLen = w),
      (e.enableXOF = S),
      (e.destroyed = this.destroyed),
      e
    );
  }
}
const gen = (a, e, f) => createHasher(() => new Keccak(e, a, f)),
  keccak_256 = gen(1, 136, 256 / 8);
function keccak256(a, e) {
  const f = e || "hex",
    _ = keccak_256(isHex(a, { strict: !1 }) ? toBytes(a) : a);
  return f === "bytes" ? _ : toHex(_);
}
const checksumAddressCache = new LruMap(8192);
function checksumAddress(a, e) {
  if (checksumAddressCache.has(`${a}.${e}`))
    return checksumAddressCache.get(`${a}.${e}`);
  const f = a.substring(2).toLowerCase(),
    _ = keccak256(stringToBytes(f), "bytes"),
    w = f.split("");
  for (let S = 0; S < 40; S += 2)
    (_[S >> 1] >> 4 >= 8 && w[S] && (w[S] = w[S].toUpperCase()),
      (_[S >> 1] & 15) >= 8 && w[S + 1] && (w[S + 1] = w[S + 1].toUpperCase()));
  const v = `0x${w.join("")}`;
  return (checksumAddressCache.set(`${a}.${e}`, v), v);
}
const addressRegex = /^0x[a-fA-F0-9]{40}$/,
  isAddressCache = new LruMap(8192);
function isAddress(a, e) {
  const { strict: f = !0 } = e ?? {},
    _ = `${a}.${f}`;
  if (isAddressCache.has(_)) return isAddressCache.get(_);
  const w = addressRegex.test(a)
    ? a.toLowerCase() === a
      ? !0
      : f
        ? checksumAddress(a) === a
        : !0
    : !1;
  return (isAddressCache.set(_, w), w);
}
function toAccount(a) {
  if (typeof a == "string") {
    if (!isAddress(a, { strict: !1 }))
      throw new InvalidAddressError({ address: a });
    return { address: a, type: "json-rpc" };
  }
  if (!isAddress(a.address, { strict: !1 }))
    throw new InvalidAddressError({ address: a.address });
  return {
    address: a.address,
    nonceManager: a.nonceManager,
    sign: a.sign,
    signAuthorization: a.signAuthorization,
    signMessage: a.signMessage,
    signTransaction: a.signTransaction,
    signTypedData: a.signTypedData,
    source: "custom",
    type: "local",
  };
}
function publicKeyToAddress(a) {
  const e = keccak256(`0x${a.substring(4)}`).substring(26);
  return checksumAddress(`0x${e}`);
}
let extraEntropy = !1;
async function sign({ hash: a, privateKey: e, to: f = "object" }) {
  const {
      r: _,
      s: w,
      recovery: v,
    } = secp256k1.sign(a.slice(2), e.slice(2), {
      lowS: !0,
      extraEntropy: isHex(extraEntropy, { strict: !1 })
        ? hexToBytes(extraEntropy)
        : extraEntropy,
    }),
    S = {
      r: numberToHex(_, { size: 32 }),
      s: numberToHex(w, { size: 32 }),
      v: v ? 28n : 27n,
      yParity: v,
    };
  return f === "bytes" || f === "hex" ? serializeSignature({ ...S, to: f }) : S;
}
function concat(a) {
  return typeof a[0] == "string" ? concatHex(a) : concatBytes(a);
}
function concatBytes(a) {
  let e = 0;
  for (const w of a) e += w.length;
  const f = new Uint8Array(e);
  let _ = 0;
  for (const w of a) (f.set(w, _), (_ += w.length));
  return f;
}
function concatHex(a) {
  return `0x${a.reduce((e, f) => e + f.replace("0x", ""), "")}`;
}
class NegativeOffsetError extends BaseError {
  constructor({ offset: e }) {
    super(`Offset \`${e}\` cannot be negative.`, {
      name: "NegativeOffsetError",
    });
  }
}
class PositionOutOfBoundsError extends BaseError {
  constructor({ length: e, position: f }) {
    super(`Position \`${f}\` is out of bounds (\`0 < position < ${e}\`).`, {
      name: "PositionOutOfBoundsError",
    });
  }
}
class RecursiveReadLimitExceededError extends BaseError {
  constructor({ count: e, limit: f }) {
    super(
      `Recursive read limit of \`${f}\` exceeded (recursive read count: \`${e}\`).`,
      { name: "RecursiveReadLimitExceededError" },
    );
  }
}
const staticCursor = {
  bytes: new Uint8Array(),
  dataView: new DataView(new ArrayBuffer(0)),
  position: 0,
  positionReadCount: new Map(),
  recursiveReadCount: 0,
  recursiveReadLimit: Number.POSITIVE_INFINITY,
  assertReadLimit() {
    if (this.recursiveReadCount >= this.recursiveReadLimit)
      throw new RecursiveReadLimitExceededError({
        count: this.recursiveReadCount + 1,
        limit: this.recursiveReadLimit,
      });
  },
  assertPosition(a) {
    if (a < 0 || a > this.bytes.length - 1)
      throw new PositionOutOfBoundsError({
        length: this.bytes.length,
        position: a,
      });
  },
  decrementPosition(a) {
    if (a < 0) throw new NegativeOffsetError({ offset: a });
    const e = this.position - a;
    (this.assertPosition(e), (this.position = e));
  },
  getReadCount(a) {
    return this.positionReadCount.get(a || this.position) || 0;
  },
  incrementPosition(a) {
    if (a < 0) throw new NegativeOffsetError({ offset: a });
    const e = this.position + a;
    (this.assertPosition(e), (this.position = e));
  },
  inspectByte(a) {
    const e = a ?? this.position;
    return (this.assertPosition(e), this.bytes[e]);
  },
  inspectBytes(a, e) {
    const f = e ?? this.position;
    return (this.assertPosition(f + a - 1), this.bytes.subarray(f, f + a));
  },
  inspectUint8(a) {
    const e = a ?? this.position;
    return (this.assertPosition(e), this.bytes[e]);
  },
  inspectUint16(a) {
    const e = a ?? this.position;
    return (this.assertPosition(e + 1), this.dataView.getUint16(e));
  },
  inspectUint24(a) {
    const e = a ?? this.position;
    return (
      this.assertPosition(e + 2),
      (this.dataView.getUint16(e) << 8) + this.dataView.getUint8(e + 2)
    );
  },
  inspectUint32(a) {
    const e = a ?? this.position;
    return (this.assertPosition(e + 3), this.dataView.getUint32(e));
  },
  pushByte(a) {
    (this.assertPosition(this.position),
      (this.bytes[this.position] = a),
      this.position++);
  },
  pushBytes(a) {
    (this.assertPosition(this.position + a.length - 1),
      this.bytes.set(a, this.position),
      (this.position += a.length));
  },
  pushUint8(a) {
    (this.assertPosition(this.position),
      (this.bytes[this.position] = a),
      this.position++);
  },
  pushUint16(a) {
    (this.assertPosition(this.position + 1),
      this.dataView.setUint16(this.position, a),
      (this.position += 2));
  },
  pushUint24(a) {
    (this.assertPosition(this.position + 2),
      this.dataView.setUint16(this.position, a >> 8),
      this.dataView.setUint8(this.position + 2, a & 255),
      (this.position += 3));
  },
  pushUint32(a) {
    (this.assertPosition(this.position + 3),
      this.dataView.setUint32(this.position, a),
      (this.position += 4));
  },
  readByte() {
    (this.assertReadLimit(), this._touch());
    const a = this.inspectByte();
    return (this.position++, a);
  },
  readBytes(a, e) {
    (this.assertReadLimit(), this._touch());
    const f = this.inspectBytes(a);
    return ((this.position += e ?? a), f);
  },
  readUint8() {
    (this.assertReadLimit(), this._touch());
    const a = this.inspectUint8();
    return ((this.position += 1), a);
  },
  readUint16() {
    (this.assertReadLimit(), this._touch());
    const a = this.inspectUint16();
    return ((this.position += 2), a);
  },
  readUint24() {
    (this.assertReadLimit(), this._touch());
    const a = this.inspectUint24();
    return ((this.position += 3), a);
  },
  readUint32() {
    (this.assertReadLimit(), this._touch());
    const a = this.inspectUint32();
    return ((this.position += 4), a);
  },
  get remaining() {
    return this.bytes.length - this.position;
  },
  setPosition(a) {
    const e = this.position;
    return (
      this.assertPosition(a),
      (this.position = a),
      () => (this.position = e)
    );
  },
  _touch() {
    if (this.recursiveReadLimit === Number.POSITIVE_INFINITY) return;
    const a = this.getReadCount();
    (this.positionReadCount.set(this.position, a + 1),
      a > 0 && this.recursiveReadCount++);
  },
};
function createCursor(a, { recursiveReadLimit: e = 8192 } = {}) {
  const f = Object.create(staticCursor);
  return (
    (f.bytes = a),
    (f.dataView = new DataView(a.buffer, a.byteOffset, a.byteLength)),
    (f.positionReadCount = new Map()),
    (f.recursiveReadLimit = e),
    f
  );
}
function toRlp(a, e = "hex") {
  const f = getEncodable(a),
    _ = createCursor(new Uint8Array(f.length));
  return (f.encode(_), e === "hex" ? bytesToHex(_.bytes) : _.bytes);
}
function getEncodable(a) {
  return Array.isArray(a)
    ? getEncodableList(a.map((e) => getEncodable(e)))
    : getEncodableBytes(a);
}
function getEncodableList(a) {
  const e = a.reduce((w, v) => w + v.length, 0),
    f = getSizeOfLength(e);
  return {
    length: e <= 55 ? 1 + e : 1 + f + e,
    encode(w) {
      e <= 55
        ? w.pushByte(192 + e)
        : (w.pushByte(247 + f),
          f === 1
            ? w.pushUint8(e)
            : f === 2
              ? w.pushUint16(e)
              : f === 3
                ? w.pushUint24(e)
                : w.pushUint32(e));
      for (const { encode: v } of a) v(w);
    },
  };
}
function getEncodableBytes(a) {
  const e = typeof a == "string" ? hexToBytes(a) : a,
    f = getSizeOfLength(e.length);
  return {
    length:
      e.length === 1 && e[0] < 128
        ? 1
        : e.length <= 55
          ? 1 + e.length
          : 1 + f + e.length,
    encode(w) {
      e.length === 1 && e[0] < 128
        ? w.pushBytes(e)
        : e.length <= 55
          ? (w.pushByte(128 + e.length), w.pushBytes(e))
          : (w.pushByte(183 + f),
            f === 1
              ? w.pushUint8(e.length)
              : f === 2
                ? w.pushUint16(e.length)
                : f === 3
                  ? w.pushUint24(e.length)
                  : w.pushUint32(e.length),
            w.pushBytes(e));
    },
  };
}
function getSizeOfLength(a) {
  if (a < 2 ** 8) return 1;
  if (a < 2 ** 16) return 2;
  if (a < 2 ** 24) return 3;
  if (a < 2 ** 32) return 4;
  throw new BaseError("Length is too large.");
}
function hashAuthorization(a) {
  const { chainId: e, nonce: f, to: _ } = a,
    w = a.contractAddress ?? a.address,
    v = keccak256(
      concatHex([
        "0x05",
        toRlp([e ? numberToHex(e) : "0x", w, f ? numberToHex(f) : "0x"]),
      ]),
    );
  return _ === "bytes" ? hexToBytes(v) : v;
}
async function signAuthorization(a) {
  const { chainId: e, nonce: f, privateKey: _, to: w = "object" } = a,
    v = a.contractAddress ?? a.address,
    S = await sign({
      hash: hashAuthorization({ address: v, chainId: e, nonce: f }),
      privateKey: _,
      to: w,
    });
  return w === "object" ? { address: v, chainId: e, nonce: f, ...S } : S;
}
const presignMessagePrefix = `Ethereum Signed Message:
`;
function toPrefixedMessage(a) {
  const e =
      typeof a == "string"
        ? stringToHex(a)
        : typeof a.raw == "string"
          ? a.raw
          : bytesToHex(a.raw),
    f = stringToHex(`${presignMessagePrefix}${size(e)}`);
  return concat([f, e]);
}
function hashMessage(a, e) {
  return keccak256(toPrefixedMessage(a), e);
}
async function signMessage({ message: a, privateKey: e }) {
  return await sign({ hash: hashMessage(a), privateKey: e, to: "hex" });
}
const gweiUnits = { ether: -9, wei: 9 };
function formatUnits(a, e) {
  let f = a.toString();
  const _ = f.startsWith("-");
  (_ && (f = f.slice(1)), (f = f.padStart(e, "0")));
  let [w, v] = [f.slice(0, f.length - e), f.slice(f.length - e)];
  return (
    (v = v.replace(/(0+)$/, "")),
    `${_ ? "-" : ""}${w || "0"}${v ? `.${v}` : ""}`
  );
}
function formatGwei(a, e = "wei") {
  return formatUnits(a, gweiUnits[e]);
}
function prettyPrint(a) {
  const e = Object.entries(a)
      .map(([_, w]) => (w === void 0 || w === !1 ? null : [_, w]))
      .filter(Boolean),
    f = e.reduce((_, [w]) => Math.max(_, w.length), 0);
  return e.map(([_, w]) => `  ${`${_}:`.padEnd(f + 1)}  ${w}`).join(`
`);
}
class InvalidLegacyVError extends BaseError {
  constructor({ v: e }) {
    super(`Invalid \`v\` value "${e}". Expected 27 or 28.`, {
      name: "InvalidLegacyVError",
    });
  }
}
class InvalidSerializableTransactionError extends BaseError {
  constructor({ transaction: e }) {
    super("Cannot infer a transaction type from provided transaction.", {
      metaMessages: [
        "Provided Transaction:",
        "{",
        prettyPrint(e),
        "}",
        "",
        "To infer the type, either provide:",
        "- a `type` to the Transaction, or",
        "- an EIP-1559 Transaction with `maxFeePerGas`, or",
        "- an EIP-2930 Transaction with `gasPrice` & `accessList`, or",
        "- an EIP-4844 Transaction with `blobs`, `blobVersionedHashes`, `sidecars`, or",
        "- an EIP-7702 Transaction with `authorizationList`, or",
        "- a Legacy Transaction with `gasPrice`",
      ],
      name: "InvalidSerializableTransactionError",
    });
  }
}
class InvalidStorageKeySizeError extends BaseError {
  constructor({ storageKey: e }) {
    super(
      `Size for storage key "${e}" is invalid. Expected 32 bytes. Got ${Math.floor((e.length - 2) / 2)} bytes.`,
      { name: "InvalidStorageKeySizeError" },
    );
  }
}
function serializeAuthorizationList(a) {
  if (!a || a.length === 0) return [];
  const e = [];
  for (const f of a) {
    const { chainId: _, nonce: w, ...v } = f,
      S = f.address;
    e.push([
      _ ? toHex(_) : "0x",
      S,
      w ? toHex(w) : "0x",
      ...toYParitySignatureArray({}, v),
    ]);
  }
  return e;
}
function blobsToCommitments(a) {
  const { kzg: e } = a,
    f = a.to ?? (typeof a.blobs[0] == "string" ? "hex" : "bytes"),
    _ =
      typeof a.blobs[0] == "string"
        ? a.blobs.map((v) => hexToBytes(v))
        : a.blobs,
    w = [];
  for (const v of _) w.push(Uint8Array.from(e.blobToKzgCommitment(v)));
  return f === "bytes" ? w : w.map((v) => bytesToHex(v));
}
function blobsToProofs(a) {
  const { kzg: e } = a,
    f = a.to ?? (typeof a.blobs[0] == "string" ? "hex" : "bytes"),
    _ =
      typeof a.blobs[0] == "string"
        ? a.blobs.map((S) => hexToBytes(S))
        : a.blobs,
    w =
      typeof a.commitments[0] == "string"
        ? a.commitments.map((S) => hexToBytes(S))
        : a.commitments,
    v = [];
  for (let S = 0; S < _.length; S++) {
    const R = _[S],
      O = w[S];
    v.push(Uint8Array.from(e.computeBlobKzgProof(R, O)));
  }
  return f === "bytes" ? v : v.map((S) => bytesToHex(S));
}
const sha256$1 = sha256$2;
function sha256(a, e) {
  return sha256$1(isHex(a, { strict: !1 }) ? toBytes(a) : a);
}
function commitmentToVersionedHash(a) {
  const { commitment: e, version: f = 1 } = a,
    _ = a.to ?? (typeof e == "string" ? "hex" : "bytes"),
    w = sha256(e);
  return (w.set([f], 0), _ === "bytes" ? w : bytesToHex(w));
}
function commitmentsToVersionedHashes(a) {
  const { commitments: e, version: f } = a,
    _ = a.to ?? (typeof e[0] == "string" ? "hex" : "bytes"),
    w = [];
  for (const v of e)
    w.push(commitmentToVersionedHash({ commitment: v, to: _, version: f }));
  return w;
}
const blobsPerTransaction = 6,
  bytesPerFieldElement = 32,
  fieldElementsPerBlob = 4096,
  bytesPerBlob = bytesPerFieldElement * fieldElementsPerBlob,
  maxBytesPerTransaction =
    bytesPerBlob * blobsPerTransaction -
    1 -
    1 * fieldElementsPerBlob * blobsPerTransaction,
  versionedHashVersionKzg = 1;
class BlobSizeTooLargeError extends BaseError {
  constructor({ maxSize: e, size: f }) {
    super("Blob size is too large.", {
      metaMessages: [`Max: ${e} bytes`, `Given: ${f} bytes`],
      name: "BlobSizeTooLargeError",
    });
  }
}
class EmptyBlobError extends BaseError {
  constructor() {
    super("Blob data must not be empty.", { name: "EmptyBlobError" });
  }
}
class InvalidVersionedHashSizeError extends BaseError {
  constructor({ hash: e, size: f }) {
    super(`Versioned hash "${e}" size is invalid.`, {
      metaMessages: ["Expected: 32", `Received: ${f}`],
      name: "InvalidVersionedHashSizeError",
    });
  }
}
class InvalidVersionedHashVersionError extends BaseError {
  constructor({ hash: e, version: f }) {
    super(`Versioned hash "${e}" version is invalid.`, {
      metaMessages: [`Expected: ${versionedHashVersionKzg}`, `Received: ${f}`],
      name: "InvalidVersionedHashVersionError",
    });
  }
}
function toBlobs(a) {
  const e = a.to ?? (typeof a.data == "string" ? "hex" : "bytes"),
    f = typeof a.data == "string" ? hexToBytes(a.data) : a.data,
    _ = size(f);
  if (!_) throw new EmptyBlobError();
  if (_ > maxBytesPerTransaction)
    throw new BlobSizeTooLargeError({
      maxSize: maxBytesPerTransaction,
      size: _,
    });
  const w = [];
  let v = !0,
    S = 0;
  for (; v; ) {
    const R = createCursor(new Uint8Array(bytesPerBlob));
    let O = 0;
    for (; O < fieldElementsPerBlob; ) {
      const j = f.slice(S, S + (bytesPerFieldElement - 1));
      if ((R.pushByte(0), R.pushBytes(j), j.length < 31)) {
        (R.pushByte(128), (v = !1));
        break;
      }
      (O++, (S += 31));
    }
    w.push(R);
  }
  return e === "bytes"
    ? w.map((R) => R.bytes)
    : w.map((R) => bytesToHex(R.bytes));
}
function toBlobSidecars(a) {
  const { data: e, kzg: f, to: _ } = a,
    w = a.blobs ?? toBlobs({ data: e, to: _ }),
    v = a.commitments ?? blobsToCommitments({ blobs: w, kzg: f, to: _ }),
    S = a.proofs ?? blobsToProofs({ blobs: w, commitments: v, kzg: f, to: _ }),
    R = [];
  for (let O = 0; O < w.length; O++)
    R.push({ blob: w[O], commitment: v[O], proof: S[O] });
  return R;
}
const maxUint256 = 2n ** 256n - 1n;
class InvalidChainIdError extends BaseError {
  constructor({ chainId: e }) {
    super(
      typeof e == "number"
        ? `Chain ID "${e}" is invalid.`
        : "Chain ID is invalid.",
      { name: "InvalidChainIdError" },
    );
  }
}
class FeeCapTooHighError extends BaseError {
  constructor({ cause: e, maxFeePerGas: f } = {}) {
    super(
      `The fee cap (\`maxFeePerGas\`${f ? ` = ${formatGwei(f)} gwei` : ""}) cannot be higher than the maximum allowed value (2^256-1).`,
      { cause: e, name: "FeeCapTooHighError" },
    );
  }
}
Object.defineProperty(FeeCapTooHighError, "nodeMessage", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /max fee per gas higher than 2\^256-1|fee cap higher than 2\^256-1/,
});
class TipAboveFeeCapError extends BaseError {
  constructor({ cause: e, maxPriorityFeePerGas: f, maxFeePerGas: _ } = {}) {
    super(
      [
        `The provided tip (\`maxPriorityFeePerGas\`${f ? ` = ${formatGwei(f)} gwei` : ""}) cannot be higher than the fee cap (\`maxFeePerGas\`${_ ? ` = ${formatGwei(_)} gwei` : ""}).`,
      ].join(`
`),
      { cause: e, name: "TipAboveFeeCapError" },
    );
  }
}
Object.defineProperty(TipAboveFeeCapError, "nodeMessage", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value:
    /max priority fee per gas higher than max fee per gas|tip higher than fee cap/,
});
function slice(a, e, f, { strict: _ } = {}) {
  return isHex(a, { strict: !1 })
    ? sliceHex(a, e, f, { strict: _ })
    : sliceBytes(a, e, f, { strict: _ });
}
function assertStartOffset(a, e) {
  if (typeof e == "number" && e > 0 && e > size(a) - 1)
    throw new SliceOffsetOutOfBoundsError({
      offset: e,
      position: "start",
      size: size(a),
    });
}
function assertEndOffset(a, e, f) {
  if (typeof e == "number" && typeof f == "number" && size(a) !== f - e)
    throw new SliceOffsetOutOfBoundsError({
      offset: f,
      position: "end",
      size: size(a),
    });
}
function sliceBytes(a, e, f, { strict: _ } = {}) {
  assertStartOffset(a, e);
  const w = a.slice(e, f);
  return (_ && assertEndOffset(w, e, f), w);
}
function sliceHex(a, e, f, { strict: _ } = {}) {
  assertStartOffset(a, e);
  const w = `0x${a.replace("0x", "").slice((e ?? 0) * 2, (f ?? a.length) * 2)}`;
  return (_ && assertEndOffset(w, e, f), w);
}
function assertTransactionEIP7702(a) {
  const { authorizationList: e } = a;
  if (e)
    for (const f of e) {
      const { chainId: _ } = f,
        w = f.address;
      if (!isAddress(w)) throw new InvalidAddressError({ address: w });
      if (_ < 0) throw new InvalidChainIdError({ chainId: _ });
    }
  assertTransactionEIP1559(a);
}
function assertTransactionEIP4844(a) {
  const { blobVersionedHashes: e } = a;
  if (e) {
    if (e.length === 0) throw new EmptyBlobError();
    for (const f of e) {
      const _ = size(f),
        w = hexToNumber(slice(f, 0, 1));
      if (_ !== 32)
        throw new InvalidVersionedHashSizeError({ hash: f, size: _ });
      if (w !== versionedHashVersionKzg)
        throw new InvalidVersionedHashVersionError({ hash: f, version: w });
    }
  }
  assertTransactionEIP1559(a);
}
function assertTransactionEIP1559(a) {
  const { chainId: e, maxPriorityFeePerGas: f, maxFeePerGas: _, to: w } = a;
  if (e <= 0) throw new InvalidChainIdError({ chainId: e });
  if (w && !isAddress(w)) throw new InvalidAddressError({ address: w });
  if (_ && _ > maxUint256) throw new FeeCapTooHighError({ maxFeePerGas: _ });
  if (f && _ && f > _)
    throw new TipAboveFeeCapError({ maxFeePerGas: _, maxPriorityFeePerGas: f });
}
function assertTransactionEIP2930(a) {
  const {
    chainId: e,
    maxPriorityFeePerGas: f,
    gasPrice: _,
    maxFeePerGas: w,
    to: v,
  } = a;
  if (e <= 0) throw new InvalidChainIdError({ chainId: e });
  if (v && !isAddress(v)) throw new InvalidAddressError({ address: v });
  if (f || w)
    throw new BaseError(
      "`maxFeePerGas`/`maxPriorityFeePerGas` is not a valid EIP-2930 Transaction attribute.",
    );
  if (_ && _ > maxUint256) throw new FeeCapTooHighError({ maxFeePerGas: _ });
}
function assertTransactionLegacy(a) {
  const {
    chainId: e,
    maxPriorityFeePerGas: f,
    gasPrice: _,
    maxFeePerGas: w,
    to: v,
  } = a;
  if (v && !isAddress(v)) throw new InvalidAddressError({ address: v });
  if (typeof e < "u" && e <= 0) throw new InvalidChainIdError({ chainId: e });
  if (f || w)
    throw new BaseError(
      "`maxFeePerGas`/`maxPriorityFeePerGas` is not a valid Legacy Transaction attribute.",
    );
  if (_ && _ > maxUint256) throw new FeeCapTooHighError({ maxFeePerGas: _ });
}
function getTransactionType(a) {
  if (a.type) return a.type;
  if (typeof a.authorizationList < "u") return "eip7702";
  if (
    typeof a.blobs < "u" ||
    typeof a.blobVersionedHashes < "u" ||
    typeof a.maxFeePerBlobGas < "u" ||
    typeof a.sidecars < "u"
  )
    return "eip4844";
  if (typeof a.maxFeePerGas < "u" || typeof a.maxPriorityFeePerGas < "u")
    return "eip1559";
  if (typeof a.gasPrice < "u")
    return typeof a.accessList < "u" ? "eip2930" : "legacy";
  throw new InvalidSerializableTransactionError({ transaction: a });
}
function serializeAccessList(a) {
  if (!a || a.length === 0) return [];
  const e = [];
  for (let f = 0; f < a.length; f++) {
    const { address: _, storageKeys: w } = a[f];
    for (let v = 0; v < w.length; v++)
      if (w[v].length - 2 !== 64)
        throw new InvalidStorageKeySizeError({ storageKey: w[v] });
    if (!isAddress(_, { strict: !1 }))
      throw new InvalidAddressError({ address: _ });
    e.push([_, w]);
  }
  return e;
}
function serializeTransaction(a, e) {
  const f = getTransactionType(a);
  return f === "eip1559"
    ? serializeTransactionEIP1559(a, e)
    : f === "eip2930"
      ? serializeTransactionEIP2930(a, e)
      : f === "eip4844"
        ? serializeTransactionEIP4844(a, e)
        : f === "eip7702"
          ? serializeTransactionEIP7702(a, e)
          : serializeTransactionLegacy(a, e);
}
function serializeTransactionEIP7702(a, e) {
  const {
    authorizationList: f,
    chainId: _,
    gas: w,
    nonce: v,
    to: S,
    value: R,
    maxFeePerGas: O,
    maxPriorityFeePerGas: j,
    accessList: F,
    data: q,
  } = a;
  assertTransactionEIP7702(a);
  const Q = serializeAccessList(F),
    te = serializeAuthorizationList(f);
  return concatHex([
    "0x04",
    toRlp([
      numberToHex(_),
      v ? numberToHex(v) : "0x",
      j ? numberToHex(j) : "0x",
      O ? numberToHex(O) : "0x",
      w ? numberToHex(w) : "0x",
      S ?? "0x",
      R ? numberToHex(R) : "0x",
      q ?? "0x",
      Q,
      te,
      ...toYParitySignatureArray(a, e),
    ]),
  ]);
}
function serializeTransactionEIP4844(a, e) {
  const {
    chainId: f,
    gas: _,
    nonce: w,
    to: v,
    value: S,
    maxFeePerBlobGas: R,
    maxFeePerGas: O,
    maxPriorityFeePerGas: j,
    accessList: F,
    data: q,
  } = a;
  assertTransactionEIP4844(a);
  let Q = a.blobVersionedHashes,
    te = a.sidecars;
  if (a.blobs && (typeof Q > "u" || typeof te > "u")) {
    const Ve =
        typeof a.blobs[0] == "string"
          ? a.blobs
          : a.blobs.map((Ke) => bytesToHex(Ke)),
      ze = a.kzg,
      Ge = blobsToCommitments({ blobs: Ve, kzg: ze });
    if (
      (typeof Q > "u" &&
        (Q = commitmentsToVersionedHashes({ commitments: Ge })),
      typeof te > "u")
    ) {
      const Ke = blobsToProofs({ blobs: Ve, commitments: Ge, kzg: ze });
      te = toBlobSidecars({ blobs: Ve, commitments: Ge, proofs: Ke });
    }
  }
  const se = serializeAccessList(F),
    re = [
      numberToHex(f),
      w ? numberToHex(w) : "0x",
      j ? numberToHex(j) : "0x",
      O ? numberToHex(O) : "0x",
      _ ? numberToHex(_) : "0x",
      v ?? "0x",
      S ? numberToHex(S) : "0x",
      q ?? "0x",
      se,
      R ? numberToHex(R) : "0x",
      Q ?? [],
      ...toYParitySignatureArray(a, e),
    ],
    Oe = [],
    Le = [],
    Be = [];
  if (te)
    for (let Ve = 0; Ve < te.length; Ve++) {
      const { blob: ze, commitment: Ge, proof: Ke } = te[Ve];
      (Oe.push(ze), Le.push(Ge), Be.push(Ke));
    }
  return concatHex(["0x03", toRlp(te ? [re, Oe, Le, Be] : re)]);
}
function serializeTransactionEIP1559(a, e) {
  const {
    chainId: f,
    gas: _,
    nonce: w,
    to: v,
    value: S,
    maxFeePerGas: R,
    maxPriorityFeePerGas: O,
    accessList: j,
    data: F,
  } = a;
  assertTransactionEIP1559(a);
  const q = serializeAccessList(j),
    Q = [
      numberToHex(f),
      w ? numberToHex(w) : "0x",
      O ? numberToHex(O) : "0x",
      R ? numberToHex(R) : "0x",
      _ ? numberToHex(_) : "0x",
      v ?? "0x",
      S ? numberToHex(S) : "0x",
      F ?? "0x",
      q,
      ...toYParitySignatureArray(a, e),
    ];
  return concatHex(["0x02", toRlp(Q)]);
}
function serializeTransactionEIP2930(a, e) {
  const {
    chainId: f,
    gas: _,
    data: w,
    nonce: v,
    to: S,
    value: R,
    accessList: O,
    gasPrice: j,
  } = a;
  assertTransactionEIP2930(a);
  const F = serializeAccessList(O),
    q = [
      numberToHex(f),
      v ? numberToHex(v) : "0x",
      j ? numberToHex(j) : "0x",
      _ ? numberToHex(_) : "0x",
      S ?? "0x",
      R ? numberToHex(R) : "0x",
      w ?? "0x",
      F,
      ...toYParitySignatureArray(a, e),
    ];
  return concatHex(["0x01", toRlp(q)]);
}
function serializeTransactionLegacy(a, e) {
  const {
    chainId: f = 0,
    gas: _,
    data: w,
    nonce: v,
    to: S,
    value: R,
    gasPrice: O,
  } = a;
  assertTransactionLegacy(a);
  let j = [
    v ? numberToHex(v) : "0x",
    O ? numberToHex(O) : "0x",
    _ ? numberToHex(_) : "0x",
    S ?? "0x",
    R ? numberToHex(R) : "0x",
    w ?? "0x",
  ];
  if (e) {
    const F = (() => {
        if (e.v >= 35n)
          return (e.v - 35n) / 2n > 0 ? e.v : 27n + (e.v === 35n ? 0n : 1n);
        if (f > 0) return BigInt(f * 2) + BigInt(35n + e.v - 27n);
        const te = 27n + (e.v === 27n ? 0n : 1n);
        if (e.v !== te) throw new InvalidLegacyVError({ v: e.v });
        return te;
      })(),
      q = trim(e.r),
      Q = trim(e.s);
    j = [
      ...j,
      numberToHex(F),
      q === "0x00" ? "0x" : q,
      Q === "0x00" ? "0x" : Q,
    ];
  } else f > 0 && (j = [...j, numberToHex(f), "0x", "0x"]);
  return toRlp(j);
}
function toYParitySignatureArray(a, e) {
  const f = e ?? a,
    { v: _, yParity: w } = f;
  if (typeof f.r > "u") return [];
  if (typeof f.s > "u") return [];
  if (typeof _ > "u" && typeof w > "u") return [];
  const v = trim(f.r),
    S = trim(f.s);
  return [
    typeof w == "number"
      ? w
        ? numberToHex(1)
        : "0x"
      : _ === 0n
        ? "0x"
        : _ === 1n
          ? numberToHex(1)
          : _ === 27n
            ? "0x"
            : numberToHex(1),
    v === "0x00" ? "0x" : v,
    S === "0x00" ? "0x" : S,
  ];
}
async function signTransaction(a) {
  const {
      privateKey: e,
      transaction: f,
      serializer: _ = serializeTransaction,
    } = a,
    w = f.type === "eip4844" ? { ...f, sidecars: !1 } : f,
    v = await sign({ hash: keccak256(await _(w)), privateKey: e });
  return await _(f, v);
}
class AbiEncodingArrayLengthMismatchError extends BaseError {
  constructor({ expectedLength: e, givenLength: f, type: _ }) {
    super(
      [
        `ABI encoding array length mismatch for type ${_}.`,
        `Expected length: ${e}`,
        `Given length: ${f}`,
      ].join(`
`),
      { name: "AbiEncodingArrayLengthMismatchError" },
    );
  }
}
class AbiEncodingBytesSizeMismatchError extends BaseError {
  constructor({ expectedSize: e, value: f }) {
    super(
      `Size of bytes "${f}" (bytes${size(f)}) does not match expected size (bytes${e}).`,
      { name: "AbiEncodingBytesSizeMismatchError" },
    );
  }
}
class AbiEncodingLengthMismatchError extends BaseError {
  constructor({ expectedLength: e, givenLength: f }) {
    super(
      [
        "ABI encoding params/values length mismatch.",
        `Expected length (params): ${e}`,
        `Given length (values): ${f}`,
      ].join(`
`),
      { name: "AbiEncodingLengthMismatchError" },
    );
  }
}
class BytesSizeMismatchError extends BaseError {
  constructor({ expectedSize: e, givenSize: f }) {
    super(`Expected bytes${e}, got bytes${f}.`, {
      name: "BytesSizeMismatchError",
    });
  }
}
class InvalidAbiEncodingTypeError extends BaseError {
  constructor(e, { docsPath: f }) {
    super(
      [
        `Type "${e}" is not a valid encoding type.`,
        "Please provide a valid ABI type.",
      ].join(`
`),
      { docsPath: f, name: "InvalidAbiEncodingType" },
    );
  }
}
class InvalidArrayError extends BaseError {
  constructor(e) {
    super(
      [`Value "${e}" is not a valid array.`].join(`
`),
      { name: "InvalidArrayError" },
    );
  }
}
const bytesRegex = /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/,
  integerRegex =
    /^(u?int)(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/;
function encodeAbiParameters(a, e) {
  if (a.length !== e.length)
    throw new AbiEncodingLengthMismatchError({
      expectedLength: a.length,
      givenLength: e.length,
    });
  const f = prepareParams({ params: a, values: e }),
    _ = encodeParams(f);
  return _.length === 0 ? "0x" : _;
}
function prepareParams({ params: a, values: e }) {
  const f = [];
  for (let _ = 0; _ < a.length; _++)
    f.push(prepareParam({ param: a[_], value: e[_] }));
  return f;
}
function prepareParam({ param: a, value: e }) {
  const f = getArrayComponents(a.type);
  if (f) {
    const [_, w] = f;
    return encodeArray(e, { length: _, param: { ...a, type: w } });
  }
  if (a.type === "tuple") return encodeTuple(e, { param: a });
  if (a.type === "address") return encodeAddress(e);
  if (a.type === "bool") return encodeBool(e);
  if (a.type.startsWith("uint") || a.type.startsWith("int")) {
    const _ = a.type.startsWith("int"),
      [, , w = "256"] = integerRegex.exec(a.type) ?? [];
    return encodeNumber(e, { signed: _, size: Number(w) });
  }
  if (a.type.startsWith("bytes")) return encodeBytes(e, { param: a });
  if (a.type === "string") return encodeString(e);
  throw new InvalidAbiEncodingTypeError(a.type, {
    docsPath: "/docs/contract/encodeAbiParameters",
  });
}
function encodeParams(a) {
  let e = 0;
  for (let v = 0; v < a.length; v++) {
    const { dynamic: S, encoded: R } = a[v];
    S ? (e += 32) : (e += size(R));
  }
  const f = [],
    _ = [];
  let w = 0;
  for (let v = 0; v < a.length; v++) {
    const { dynamic: S, encoded: R } = a[v];
    S
      ? (f.push(numberToHex(e + w, { size: 32 })), _.push(R), (w += size(R)))
      : f.push(R);
  }
  return concat([...f, ..._]);
}
function encodeAddress(a) {
  if (!isAddress(a)) throw new InvalidAddressError({ address: a });
  return { dynamic: !1, encoded: padHex(a.toLowerCase()) };
}
function encodeArray(a, { length: e, param: f }) {
  const _ = e === null;
  if (!Array.isArray(a)) throw new InvalidArrayError(a);
  if (!_ && a.length !== e)
    throw new AbiEncodingArrayLengthMismatchError({
      expectedLength: e,
      givenLength: a.length,
      type: `${f.type}[${e}]`,
    });
  let w = !1;
  const v = [];
  for (let S = 0; S < a.length; S++) {
    const R = prepareParam({ param: f, value: a[S] });
    (R.dynamic && (w = !0), v.push(R));
  }
  if (_ || w) {
    const S = encodeParams(v);
    if (_) {
      const R = numberToHex(v.length, { size: 32 });
      return { dynamic: !0, encoded: v.length > 0 ? concat([R, S]) : R };
    }
    if (w) return { dynamic: !0, encoded: S };
  }
  return { dynamic: !1, encoded: concat(v.map(({ encoded: S }) => S)) };
}
function encodeBytes(a, { param: e }) {
  const [, f] = e.type.split("bytes"),
    _ = size(a);
  if (!f) {
    let w = a;
    return (
      _ % 32 !== 0 &&
        (w = padHex(w, {
          dir: "right",
          size: Math.ceil((a.length - 2) / 2 / 32) * 32,
        })),
      {
        dynamic: !0,
        encoded: concat([padHex(numberToHex(_, { size: 32 })), w]),
      }
    );
  }
  if (_ !== Number.parseInt(f, 10))
    throw new AbiEncodingBytesSizeMismatchError({
      expectedSize: Number.parseInt(f, 10),
      value: a,
    });
  return { dynamic: !1, encoded: padHex(a, { dir: "right" }) };
}
function encodeBool(a) {
  if (typeof a != "boolean")
    throw new BaseError(
      `Invalid boolean value: "${a}" (type: ${typeof a}). Expected: \`true\` or \`false\`.`,
    );
  return { dynamic: !1, encoded: padHex(boolToHex(a)) };
}
function encodeNumber(a, { signed: e, size: f = 256 }) {
  if (typeof f == "number") {
    const _ = 2n ** (BigInt(f) - (e ? 1n : 0n)) - 1n,
      w = e ? -_ - 1n : 0n;
    if (a > _ || a < w)
      throw new IntegerOutOfRangeError({
        max: _.toString(),
        min: w.toString(),
        signed: e,
        size: f / 8,
        value: a.toString(),
      });
  }
  return { dynamic: !1, encoded: numberToHex(a, { size: 32, signed: e }) };
}
function encodeString(a) {
  const e = stringToHex(a),
    f = Math.ceil(size(e) / 32),
    _ = [];
  for (let w = 0; w < f; w++)
    _.push(padHex(slice(e, w * 32, (w + 1) * 32), { dir: "right" }));
  return {
    dynamic: !0,
    encoded: concat([padHex(numberToHex(size(e), { size: 32 })), ..._]),
  };
}
function encodeTuple(a, { param: e }) {
  let f = !1;
  const _ = [];
  for (let w = 0; w < e.components.length; w++) {
    const v = e.components[w],
      S = Array.isArray(a) ? w : v.name,
      R = prepareParam({ param: v, value: a[S] });
    (_.push(R), R.dynamic && (f = !0));
  }
  return {
    dynamic: f,
    encoded: f ? encodeParams(_) : concat(_.map(({ encoded: w }) => w)),
  };
}
function getArrayComponents(a) {
  const e = a.match(/^(.*)\[(\d+)?\]$/);
  return e ? [e[2] ? Number(e[2]) : null, e[1]] : void 0;
}
const stringify = (a, e, f) =>
  JSON.stringify(a, (_, w) => (typeof w == "bigint" ? w.toString() : w), f);
class InvalidDomainError extends BaseError {
  constructor({ domain: e }) {
    super(`Invalid domain "${stringify(e)}".`, {
      metaMessages: ["Must be a valid EIP-712 domain."],
    });
  }
}
class InvalidPrimaryTypeError extends BaseError {
  constructor({ primaryType: e, types: f }) {
    super(
      `Invalid primary type \`${e}\` must be one of \`${JSON.stringify(Object.keys(f))}\`.`,
      {
        docsPath: "/api/glossary/Errors#typeddatainvalidprimarytypeerror",
        metaMessages: ["Check that the primary type is a key in `types`."],
      },
    );
  }
}
class InvalidStructTypeError extends BaseError {
  constructor({ type: e }) {
    super(`Struct type "${e}" is invalid.`, {
      metaMessages: ["Struct type must not be a Solidity type."],
      name: "InvalidStructTypeError",
    });
  }
}
function validateTypedData(a) {
  const { domain: e, message: f, primaryType: _, types: w } = a,
    v = (S, R) => {
      for (const O of S) {
        const { name: j, type: F } = O,
          q = R[j],
          Q = F.match(integerRegex);
        if (Q && (typeof q == "number" || typeof q == "bigint")) {
          const [re, Oe, Le] = Q;
          numberToHex(q, {
            signed: Oe === "int",
            size: Number.parseInt(Le, 10) / 8,
          });
        }
        if (F === "address" && typeof q == "string" && !isAddress(q))
          throw new InvalidAddressError({ address: q });
        const te = F.match(bytesRegex);
        if (te) {
          const [re, Oe] = te;
          if (Oe && size(q) !== Number.parseInt(Oe, 10))
            throw new BytesSizeMismatchError({
              expectedSize: Number.parseInt(Oe, 10),
              givenSize: size(q),
            });
        }
        const se = w[F];
        se && (validateReference(F), v(se, q));
      }
    };
  if (w.EIP712Domain && e) {
    if (typeof e != "object") throw new InvalidDomainError({ domain: e });
    v(w.EIP712Domain, e);
  }
  if (_ !== "EIP712Domain")
    if (w[_]) v(w[_], f);
    else throw new InvalidPrimaryTypeError({ primaryType: _, types: w });
}
function getTypesForEIP712Domain({ domain: a }) {
  return [
    typeof a?.name == "string" && { name: "name", type: "string" },
    a?.version && { name: "version", type: "string" },
    (typeof a?.chainId == "number" || typeof a?.chainId == "bigint") && {
      name: "chainId",
      type: "uint256",
    },
    a?.verifyingContract && { name: "verifyingContract", type: "address" },
    a?.salt && { name: "salt", type: "bytes32" },
  ].filter(Boolean);
}
function validateReference(a) {
  if (
    a === "address" ||
    a === "bool" ||
    a === "string" ||
    a.startsWith("bytes") ||
    a.startsWith("uint") ||
    a.startsWith("int")
  )
    throw new InvalidStructTypeError({ type: a });
}
function hashTypedData(a) {
  const { domain: e = {}, message: f, primaryType: _ } = a,
    w = { EIP712Domain: getTypesForEIP712Domain({ domain: e }), ...a.types };
  validateTypedData({ domain: e, message: f, primaryType: _, types: w });
  const v = ["0x1901"];
  return (
    e && v.push(hashDomain({ domain: e, types: w })),
    _ !== "EIP712Domain" &&
      v.push(hashStruct({ data: f, primaryType: _, types: w })),
    keccak256(concat(v))
  );
}
function hashDomain({ domain: a, types: e }) {
  return hashStruct({ data: a, primaryType: "EIP712Domain", types: e });
}
function hashStruct({ data: a, primaryType: e, types: f }) {
  const _ = encodeData({ data: a, primaryType: e, types: f });
  return keccak256(_);
}
function encodeData({ data: a, primaryType: e, types: f }) {
  const _ = [{ type: "bytes32" }],
    w = [hashType({ primaryType: e, types: f })];
  for (const v of f[e]) {
    const [S, R] = encodeField({
      types: f,
      name: v.name,
      type: v.type,
      value: a[v.name],
    });
    (_.push(S), w.push(R));
  }
  return encodeAbiParameters(_, w);
}
function hashType({ primaryType: a, types: e }) {
  const f = toHex(encodeType({ primaryType: a, types: e }));
  return keccak256(f);
}
function encodeType({ primaryType: a, types: e }) {
  let f = "";
  const _ = findTypeDependencies({ primaryType: a, types: e });
  _.delete(a);
  const w = [a, ...Array.from(_).sort()];
  for (const v of w)
    f += `${v}(${e[v].map(({ name: S, type: R }) => `${R} ${S}`).join(",")})`;
  return f;
}
function findTypeDependencies({ primaryType: a, types: e }, f = new Set()) {
  const w = a.match(/^\w*/u)?.[0];
  if (f.has(w) || e[w] === void 0) return f;
  f.add(w);
  for (const v of e[w])
    findTypeDependencies({ primaryType: v.type, types: e }, f);
  return f;
}
function encodeField({ types: a, name: e, type: f, value: _ }) {
  if (a[f] !== void 0)
    return [
      { type: "bytes32" },
      keccak256(encodeData({ data: _, primaryType: f, types: a })),
    ];
  if (f === "bytes")
    return (
      (_ = `0x${(_.length % 2 ? "0" : "") + _.slice(2)}`),
      [{ type: "bytes32" }, keccak256(_)]
    );
  if (f === "string") return [{ type: "bytes32" }, keccak256(toHex(_))];
  if (f.lastIndexOf("]") === f.length - 1) {
    const w = f.slice(0, f.lastIndexOf("[")),
      v = _.map((S) => encodeField({ name: e, type: w, types: a, value: S }));
    return [
      { type: "bytes32" },
      keccak256(
        encodeAbiParameters(
          v.map(([S]) => S),
          v.map(([, S]) => S),
        ),
      ),
    ];
  }
  return [{ type: f }, _];
}
async function signTypedData(a) {
  const { privateKey: e, ...f } = a;
  return await sign({ hash: hashTypedData(f), privateKey: e, to: "hex" });
}
function privateKeyToAccount(a, e = {}) {
  const { nonceManager: f } = e,
    _ = toHex(secp256k1.getPublicKey(a.slice(2), !1)),
    w = publicKeyToAddress(_);
  return {
    ...toAccount({
      address: w,
      nonceManager: f,
      async sign({ hash: S }) {
        return sign({ hash: S, privateKey: a, to: "hex" });
      },
      async signAuthorization(S) {
        return signAuthorization({ ...S, privateKey: a });
      },
      async signMessage({ message: S }) {
        return signMessage({ message: S, privateKey: a });
      },
      async signTransaction(S, { serializer: R } = {}) {
        return signTransaction({
          privateKey: a,
          transaction: S,
          serializer: R,
        });
      },
      async signTypedData(S) {
        return signTypedData({ ...S, privateKey: a });
      },
    }),
    publicKey: _,
    source: "privateKey",
  };
}
function getOrCreateEphemeralAccountKey() {
  if (typeof window > "u")
    throw new Error(
      "Ephemeral account key can only be created in browser environment",
    );
  return generatePrivateKey();
}
let t$7 = class _p {
  authorityId;
  typeId;
  versionMajor;
  versionMinor;
  constructor(e) {
    ((this.authorityId = e.authorityId),
      (this.typeId = e.typeId),
      (this.versionMajor = e.versionMajor),
      (this.versionMinor = e.versionMinor));
  }
  toString() {
    return `${this.authorityId}/${this.typeId}:${this.versionMajor}.${this.versionMinor}`;
  }
  static fromString(e) {
    const [f, _] = e.split(":"),
      [w, v] = f.split("/"),
      [S, R] = _.split(".");
    return new _p({
      authorityId: w,
      typeId: v,
      versionMajor: Number(S),
      versionMinor: Number(R),
    });
  }
  sameAs(e) {
    return this.authorityId === e.authorityId && this.typeId === e.typeId;
  }
};
const b64 = new Array(64),
  s64 = new Array(123);
for (let a = 0; a < 64; )
  s64[
    (b64[a] =
      a < 26 ? a + 65 : a < 52 ? a + 71 : a < 62 ? a - 4 : (a - 59) | 43)
  ] = a++;
var SortDirection$1;
(function (a) {
  ((a.SORT_DIRECTION_UNSPECIFIED = "SORT_DIRECTION_UNSPECIFIED"),
    (a.SORT_DIRECTION_ASCENDING = "SORT_DIRECTION_ASCENDING"),
    (a.SORT_DIRECTION_DESCENDING = "SORT_DIRECTION_DESCENDING"));
})(SortDirection$1 || (SortDirection$1 = {}));
/**
 * @license
 * Copyright 2009 The Closure Library Authors
 * Copyright 2020 Daniel Wirtz / The long.js Authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */ var wasm$1 = null;
try {
  wasm$1 = new WebAssembly.Instance(
    new WebAssembly.Module(
      new Uint8Array([
        0, 97, 115, 109, 1, 0, 0, 0, 1, 13, 2, 96, 0, 1, 127, 96, 4, 127, 127,
        127, 127, 1, 127, 3, 7, 6, 0, 1, 1, 1, 1, 1, 6, 6, 1, 127, 1, 65, 0, 11,
        7, 50, 6, 3, 109, 117, 108, 0, 1, 5, 100, 105, 118, 95, 115, 0, 2, 5,
        100, 105, 118, 95, 117, 0, 3, 5, 114, 101, 109, 95, 115, 0, 4, 5, 114,
        101, 109, 95, 117, 0, 5, 8, 103, 101, 116, 95, 104, 105, 103, 104, 0, 0,
        10, 191, 1, 6, 4, 0, 35, 0, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173,
        66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 126, 34, 4,
        66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32,
        1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 127,
        34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0,
        173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134,
        132, 128, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126,
        32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66,
        32, 134, 132, 129, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36,
        1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3,
        173, 66, 32, 134, 132, 130, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167,
        11,
      ]),
    ),
    {},
  ).exports;
} catch {}
function Long(a, e, f) {
  ((this.low = a | 0), (this.high = e | 0), (this.unsigned = !!f));
}
Long.prototype.__isLong__;
Object.defineProperty(Long.prototype, "__isLong__", { value: !0 });
function isLong(a) {
  return (a && a.__isLong__) === !0;
}
function ctz32(a) {
  var e = Math.clz32(a & -a);
  return a ? 31 - e : e;
}
Long.isLong = isLong;
var INT_CACHE = {},
  UINT_CACHE = {};
function fromInt(a, e) {
  var f, _, w;
  return e
    ? ((a >>>= 0),
      (w = 0 <= a && a < 256) && ((_ = UINT_CACHE[a]), _)
        ? _
        : ((f = fromBits(a, 0, !0)), w && (UINT_CACHE[a] = f), f))
    : ((a |= 0),
      (w = -128 <= a && a < 128) && ((_ = INT_CACHE[a]), _)
        ? _
        : ((f = fromBits(a, a < 0 ? -1 : 0, !1)), w && (INT_CACHE[a] = f), f));
}
Long.fromInt = fromInt;
function fromNumber(a, e) {
  if (isNaN(a)) return e ? UZERO : ZERO;
  if (e) {
    if (a < 0) return UZERO;
    if (a >= TWO_PWR_64_DBL) return MAX_UNSIGNED_VALUE;
  } else {
    if (a <= -TWO_PWR_63_DBL) return MIN_VALUE;
    if (a + 1 >= TWO_PWR_63_DBL) return MAX_VALUE;
  }
  return a < 0
    ? fromNumber(-a, e).neg()
    : fromBits(a % TWO_PWR_32_DBL | 0, (a / TWO_PWR_32_DBL) | 0, e);
}
Long.fromNumber = fromNumber;
function fromBits(a, e, f) {
  return new Long(a, e, f);
}
Long.fromBits = fromBits;
var pow_dbl = Math.pow;
function fromString(a, e, f) {
  if (a.length === 0) throw Error("empty string");
  if (
    (typeof e == "number" ? ((f = e), (e = !1)) : (e = !!e),
    a === "NaN" || a === "Infinity" || a === "+Infinity" || a === "-Infinity")
  )
    return e ? UZERO : ZERO;
  if (((f = f || 10), f < 2 || 36 < f)) throw RangeError("radix");
  var _;
  if ((_ = a.indexOf("-")) > 0) throw Error("interior hyphen");
  if (_ === 0) return fromString(a.substring(1), e, f).neg();
  for (
    var w = fromNumber(pow_dbl(f, 8)), v = ZERO, S = 0;
    S < a.length;
    S += 8
  ) {
    var R = Math.min(8, a.length - S),
      O = parseInt(a.substring(S, S + R), f);
    if (R < 8) {
      var j = fromNumber(pow_dbl(f, R));
      v = v.mul(j).add(fromNumber(O));
    } else ((v = v.mul(w)), (v = v.add(fromNumber(O))));
  }
  return ((v.unsigned = e), v);
}
Long.fromString = fromString;
function fromValue(a, e) {
  return typeof a == "number"
    ? fromNumber(a, e)
    : typeof a == "string"
      ? fromString(a, e)
      : fromBits(a.low, a.high, typeof e == "boolean" ? e : a.unsigned);
}
Long.fromValue = fromValue;
var TWO_PWR_16_DBL = 65536,
  TWO_PWR_24_DBL = 1 << 24,
  TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL,
  TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL,
  TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2,
  TWO_PWR_24 = fromInt(TWO_PWR_24_DBL),
  ZERO = fromInt(0);
Long.ZERO = ZERO;
var UZERO = fromInt(0, !0);
Long.UZERO = UZERO;
var ONE = fromInt(1);
Long.ONE = ONE;
var UONE = fromInt(1, !0);
Long.UONE = UONE;
var NEG_ONE = fromInt(-1);
Long.NEG_ONE = NEG_ONE;
var MAX_VALUE = fromBits(-1, 2147483647, !1);
Long.MAX_VALUE = MAX_VALUE;
var MAX_UNSIGNED_VALUE = fromBits(-1, -1, !0);
Long.MAX_UNSIGNED_VALUE = MAX_UNSIGNED_VALUE;
var MIN_VALUE = fromBits(0, -2147483648, !1);
Long.MIN_VALUE = MIN_VALUE;
var LongPrototype = Long.prototype;
LongPrototype.toInt = function () {
  return this.unsigned ? this.low >>> 0 : this.low;
};
LongPrototype.toNumber = function () {
  return this.unsigned
    ? (this.high >>> 0) * TWO_PWR_32_DBL + (this.low >>> 0)
    : this.high * TWO_PWR_32_DBL + (this.low >>> 0);
};
LongPrototype.toString = function (e) {
  if (((e = e || 10), e < 2 || 36 < e)) throw RangeError("radix");
  if (this.isZero()) return "0";
  if (this.isNegative())
    if (this.eq(MIN_VALUE)) {
      var f = fromNumber(e),
        _ = this.div(f),
        w = _.mul(f).sub(this);
      return _.toString(e) + w.toInt().toString(e);
    } else return "-" + this.neg().toString(e);
  for (var v = fromNumber(pow_dbl(e, 6), this.unsigned), S = this, R = ""; ; ) {
    var O = S.div(v),
      j = S.sub(O.mul(v)).toInt() >>> 0,
      F = j.toString(e);
    if (((S = O), S.isZero())) return F + R;
    for (; F.length < 6; ) F = "0" + F;
    R = "" + F + R;
  }
};
LongPrototype.getHighBits = function () {
  return this.high;
};
LongPrototype.getHighBitsUnsigned = function () {
  return this.high >>> 0;
};
LongPrototype.getLowBits = function () {
  return this.low;
};
LongPrototype.getLowBitsUnsigned = function () {
  return this.low >>> 0;
};
LongPrototype.getNumBitsAbs = function () {
  if (this.isNegative())
    return this.eq(MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();
  for (
    var e = this.high != 0 ? this.high : this.low, f = 31;
    f > 0 && (e & (1 << f)) == 0;
    f--
  );
  return this.high != 0 ? f + 33 : f + 1;
};
LongPrototype.isZero = function () {
  return this.high === 0 && this.low === 0;
};
LongPrototype.eqz = LongPrototype.isZero;
LongPrototype.isNegative = function () {
  return !this.unsigned && this.high < 0;
};
LongPrototype.isPositive = function () {
  return this.unsigned || this.high >= 0;
};
LongPrototype.isOdd = function () {
  return (this.low & 1) === 1;
};
LongPrototype.isEven = function () {
  return (this.low & 1) === 0;
};
LongPrototype.equals = function (e) {
  return (
    isLong(e) || (e = fromValue(e)),
    this.unsigned !== e.unsigned &&
    this.high >>> 31 === 1 &&
    e.high >>> 31 === 1
      ? !1
      : this.high === e.high && this.low === e.low
  );
};
LongPrototype.eq = LongPrototype.equals;
LongPrototype.notEquals = function (e) {
  return !this.eq(e);
};
LongPrototype.neq = LongPrototype.notEquals;
LongPrototype.ne = LongPrototype.notEquals;
LongPrototype.lessThan = function (e) {
  return this.comp(e) < 0;
};
LongPrototype.lt = LongPrototype.lessThan;
LongPrototype.lessThanOrEqual = function (e) {
  return this.comp(e) <= 0;
};
LongPrototype.lte = LongPrototype.lessThanOrEqual;
LongPrototype.le = LongPrototype.lessThanOrEqual;
LongPrototype.greaterThan = function (e) {
  return this.comp(e) > 0;
};
LongPrototype.gt = LongPrototype.greaterThan;
LongPrototype.greaterThanOrEqual = function (e) {
  return this.comp(e) >= 0;
};
LongPrototype.gte = LongPrototype.greaterThanOrEqual;
LongPrototype.ge = LongPrototype.greaterThanOrEqual;
LongPrototype.compare = function (e) {
  if ((isLong(e) || (e = fromValue(e)), this.eq(e))) return 0;
  var f = this.isNegative(),
    _ = e.isNegative();
  return f && !_
    ? -1
    : !f && _
      ? 1
      : this.unsigned
        ? e.high >>> 0 > this.high >>> 0 ||
          (e.high === this.high && e.low >>> 0 > this.low >>> 0)
          ? -1
          : 1
        : this.sub(e).isNegative()
          ? -1
          : 1;
};
LongPrototype.comp = LongPrototype.compare;
LongPrototype.negate = function () {
  return !this.unsigned && this.eq(MIN_VALUE) ? MIN_VALUE : this.not().add(ONE);
};
LongPrototype.neg = LongPrototype.negate;
LongPrototype.add = function (e) {
  isLong(e) || (e = fromValue(e));
  var f = this.high >>> 16,
    _ = this.high & 65535,
    w = this.low >>> 16,
    v = this.low & 65535,
    S = e.high >>> 16,
    R = e.high & 65535,
    O = e.low >>> 16,
    j = e.low & 65535,
    F = 0,
    q = 0,
    Q = 0,
    te = 0;
  return (
    (te += v + j),
    (Q += te >>> 16),
    (te &= 65535),
    (Q += w + O),
    (q += Q >>> 16),
    (Q &= 65535),
    (q += _ + R),
    (F += q >>> 16),
    (q &= 65535),
    (F += f + S),
    (F &= 65535),
    fromBits((Q << 16) | te, (F << 16) | q, this.unsigned)
  );
};
LongPrototype.subtract = function (e) {
  return (isLong(e) || (e = fromValue(e)), this.add(e.neg()));
};
LongPrototype.sub = LongPrototype.subtract;
LongPrototype.multiply = function (e) {
  if (this.isZero()) return this;
  if ((isLong(e) || (e = fromValue(e)), wasm$1)) {
    var f = wasm$1.mul(this.low, this.high, e.low, e.high);
    return fromBits(f, wasm$1.get_high(), this.unsigned);
  }
  if (e.isZero()) return this.unsigned ? UZERO : ZERO;
  if (this.eq(MIN_VALUE)) return e.isOdd() ? MIN_VALUE : ZERO;
  if (e.eq(MIN_VALUE)) return this.isOdd() ? MIN_VALUE : ZERO;
  if (this.isNegative())
    return e.isNegative() ? this.neg().mul(e.neg()) : this.neg().mul(e).neg();
  if (e.isNegative()) return this.mul(e.neg()).neg();
  if (this.lt(TWO_PWR_24) && e.lt(TWO_PWR_24))
    return fromNumber(this.toNumber() * e.toNumber(), this.unsigned);
  var _ = this.high >>> 16,
    w = this.high & 65535,
    v = this.low >>> 16,
    S = this.low & 65535,
    R = e.high >>> 16,
    O = e.high & 65535,
    j = e.low >>> 16,
    F = e.low & 65535,
    q = 0,
    Q = 0,
    te = 0,
    se = 0;
  return (
    (se += S * F),
    (te += se >>> 16),
    (se &= 65535),
    (te += v * F),
    (Q += te >>> 16),
    (te &= 65535),
    (te += S * j),
    (Q += te >>> 16),
    (te &= 65535),
    (Q += w * F),
    (q += Q >>> 16),
    (Q &= 65535),
    (Q += v * j),
    (q += Q >>> 16),
    (Q &= 65535),
    (Q += S * O),
    (q += Q >>> 16),
    (Q &= 65535),
    (q += _ * F + w * j + v * O + S * R),
    (q &= 65535),
    fromBits((te << 16) | se, (q << 16) | Q, this.unsigned)
  );
};
LongPrototype.mul = LongPrototype.multiply;
LongPrototype.divide = function (e) {
  if ((isLong(e) || (e = fromValue(e)), e.isZero()))
    throw Error("division by zero");
  if (wasm$1) {
    if (
      !this.unsigned &&
      this.high === -2147483648 &&
      e.low === -1 &&
      e.high === -1
    )
      return this;
    var f = (this.unsigned ? wasm$1.div_u : wasm$1.div_s)(
      this.low,
      this.high,
      e.low,
      e.high,
    );
    return fromBits(f, wasm$1.get_high(), this.unsigned);
  }
  if (this.isZero()) return this.unsigned ? UZERO : ZERO;
  var _, w, v;
  if (this.unsigned) {
    if ((e.unsigned || (e = e.toUnsigned()), e.gt(this))) return UZERO;
    if (e.gt(this.shru(1))) return UONE;
    v = UZERO;
  } else {
    if (this.eq(MIN_VALUE)) {
      if (e.eq(ONE) || e.eq(NEG_ONE)) return MIN_VALUE;
      if (e.eq(MIN_VALUE)) return ONE;
      var S = this.shr(1);
      return (
        (_ = S.div(e).shl(1)),
        _.eq(ZERO)
          ? e.isNegative()
            ? ONE
            : NEG_ONE
          : ((w = this.sub(e.mul(_))), (v = _.add(w.div(e))), v)
      );
    } else if (e.eq(MIN_VALUE)) return this.unsigned ? UZERO : ZERO;
    if (this.isNegative())
      return e.isNegative() ? this.neg().div(e.neg()) : this.neg().div(e).neg();
    if (e.isNegative()) return this.div(e.neg()).neg();
    v = ZERO;
  }
  for (w = this; w.gte(e); ) {
    _ = Math.max(1, Math.floor(w.toNumber() / e.toNumber()));
    for (
      var R = Math.ceil(Math.log(_) / Math.LN2),
        O = R <= 48 ? 1 : pow_dbl(2, R - 48),
        j = fromNumber(_),
        F = j.mul(e);
      F.isNegative() || F.gt(w);

    )
      ((_ -= O), (j = fromNumber(_, this.unsigned)), (F = j.mul(e)));
    (j.isZero() && (j = ONE), (v = v.add(j)), (w = w.sub(F)));
  }
  return v;
};
LongPrototype.div = LongPrototype.divide;
LongPrototype.modulo = function (e) {
  if ((isLong(e) || (e = fromValue(e)), wasm$1)) {
    var f = (this.unsigned ? wasm$1.rem_u : wasm$1.rem_s)(
      this.low,
      this.high,
      e.low,
      e.high,
    );
    return fromBits(f, wasm$1.get_high(), this.unsigned);
  }
  return this.sub(this.div(e).mul(e));
};
LongPrototype.mod = LongPrototype.modulo;
LongPrototype.rem = LongPrototype.modulo;
LongPrototype.not = function () {
  return fromBits(~this.low, ~this.high, this.unsigned);
};
LongPrototype.countLeadingZeros = function () {
  return this.high ? Math.clz32(this.high) : Math.clz32(this.low) + 32;
};
LongPrototype.clz = LongPrototype.countLeadingZeros;
LongPrototype.countTrailingZeros = function () {
  return this.low ? ctz32(this.low) : ctz32(this.high) + 32;
};
LongPrototype.ctz = LongPrototype.countTrailingZeros;
LongPrototype.and = function (e) {
  return (
    isLong(e) || (e = fromValue(e)),
    fromBits(this.low & e.low, this.high & e.high, this.unsigned)
  );
};
LongPrototype.or = function (e) {
  return (
    isLong(e) || (e = fromValue(e)),
    fromBits(this.low | e.low, this.high | e.high, this.unsigned)
  );
};
LongPrototype.xor = function (e) {
  return (
    isLong(e) || (e = fromValue(e)),
    fromBits(this.low ^ e.low, this.high ^ e.high, this.unsigned)
  );
};
LongPrototype.shiftLeft = function (e) {
  return (
    isLong(e) && (e = e.toInt()),
    (e &= 63) === 0
      ? this
      : e < 32
        ? fromBits(
            this.low << e,
            (this.high << e) | (this.low >>> (32 - e)),
            this.unsigned,
          )
        : fromBits(0, this.low << (e - 32), this.unsigned)
  );
};
LongPrototype.shl = LongPrototype.shiftLeft;
LongPrototype.shiftRight = function (e) {
  return (
    isLong(e) && (e = e.toInt()),
    (e &= 63) === 0
      ? this
      : e < 32
        ? fromBits(
            (this.low >>> e) | (this.high << (32 - e)),
            this.high >> e,
            this.unsigned,
          )
        : fromBits(
            this.high >> (e - 32),
            this.high >= 0 ? 0 : -1,
            this.unsigned,
          )
  );
};
LongPrototype.shr = LongPrototype.shiftRight;
LongPrototype.shiftRightUnsigned = function (e) {
  return (
    isLong(e) && (e = e.toInt()),
    (e &= 63) === 0
      ? this
      : e < 32
        ? fromBits(
            (this.low >>> e) | (this.high << (32 - e)),
            this.high >>> e,
            this.unsigned,
          )
        : e === 32
          ? fromBits(this.high, 0, this.unsigned)
          : fromBits(this.high >>> (e - 32), 0, this.unsigned)
  );
};
LongPrototype.shru = LongPrototype.shiftRightUnsigned;
LongPrototype.shr_u = LongPrototype.shiftRightUnsigned;
LongPrototype.rotateLeft = function (e) {
  var f;
  return (
    isLong(e) && (e = e.toInt()),
    (e &= 63) === 0
      ? this
      : e === 32
        ? fromBits(this.high, this.low, this.unsigned)
        : e < 32
          ? ((f = 32 - e),
            fromBits(
              (this.low << e) | (this.high >>> f),
              (this.high << e) | (this.low >>> f),
              this.unsigned,
            ))
          : ((e -= 32),
            (f = 32 - e),
            fromBits(
              (this.high << e) | (this.low >>> f),
              (this.low << e) | (this.high >>> f),
              this.unsigned,
            ))
  );
};
LongPrototype.rotl = LongPrototype.rotateLeft;
LongPrototype.rotateRight = function (e) {
  var f;
  return (
    isLong(e) && (e = e.toInt()),
    (e &= 63) === 0
      ? this
      : e === 32
        ? fromBits(this.high, this.low, this.unsigned)
        : e < 32
          ? ((f = 32 - e),
            fromBits(
              (this.high << f) | (this.low >>> e),
              (this.low << f) | (this.high >>> e),
              this.unsigned,
            ))
          : ((e -= 32),
            (f = 32 - e),
            fromBits(
              (this.low << f) | (this.high >>> e),
              (this.high << f) | (this.low >>> e),
              this.unsigned,
            ))
  );
};
LongPrototype.rotr = LongPrototype.rotateRight;
LongPrototype.toSigned = function () {
  return this.unsigned ? fromBits(this.low, this.high, !1) : this;
};
LongPrototype.toUnsigned = function () {
  return this.unsigned ? this : fromBits(this.low, this.high, !0);
};
LongPrototype.toBytes = function (e) {
  return e ? this.toBytesLE() : this.toBytesBE();
};
LongPrototype.toBytesLE = function () {
  var e = this.high,
    f = this.low;
  return [
    f & 255,
    (f >>> 8) & 255,
    (f >>> 16) & 255,
    f >>> 24,
    e & 255,
    (e >>> 8) & 255,
    (e >>> 16) & 255,
    e >>> 24,
  ];
};
LongPrototype.toBytesBE = function () {
  var e = this.high,
    f = this.low;
  return [
    e >>> 24,
    (e >>> 16) & 255,
    (e >>> 8) & 255,
    e & 255,
    f >>> 24,
    (f >>> 16) & 255,
    (f >>> 8) & 255,
    f & 255,
  ];
};
Long.fromBytes = function (e, f, _) {
  return _ ? Long.fromBytesLE(e, f) : Long.fromBytesBE(e, f);
};
Long.fromBytesLE = function (e, f) {
  return new Long(
    e[0] | (e[1] << 8) | (e[2] << 16) | (e[3] << 24),
    e[4] | (e[5] << 8) | (e[6] << 16) | (e[7] << 24),
    f,
  );
};
Long.fromBytesBE = function (e, f) {
  return new Long(
    (e[4] << 24) | (e[5] << 16) | (e[6] << 8) | e[7],
    (e[0] << 24) | (e[1] << 16) | (e[2] << 8) | e[3],
    f,
  );
};
var indexMinimal = {},
  minimal$1 = {},
  aspromise,
  hasRequiredAspromise;
function requireAspromise() {
  if (hasRequiredAspromise) return aspromise;
  ((hasRequiredAspromise = 1), (aspromise = a));
  function a(e, f) {
    for (
      var _ = new Array(arguments.length - 1), w = 0, v = 2, S = !0;
      v < arguments.length;

    )
      _[w++] = arguments[v++];
    return new Promise(function (O, j) {
      _[w] = function (q) {
        if (S)
          if (((S = !1), q)) j(q);
          else {
            for (
              var Q = new Array(arguments.length - 1), te = 0;
              te < Q.length;

            )
              Q[te++] = arguments[te];
            O.apply(null, Q);
          }
      };
      try {
        e.apply(f || null, _);
      } catch (F) {
        S && ((S = !1), j(F));
      }
    });
  }
  return aspromise;
}
var base64 = {},
  hasRequiredBase64;
function requireBase64() {
  return (
    hasRequiredBase64 ||
      ((hasRequiredBase64 = 1),
      (function (a) {
        var e = a;
        e.length = function (R) {
          var O = R.length;
          if (!O) return 0;
          for (var j = 0; --O % 4 > 1 && R.charAt(O) === "="; ) ++j;
          return Math.ceil(R.length * 3) / 4 - j;
        };
        for (var f = new Array(64), _ = new Array(123), w = 0; w < 64; )
          _[
            (f[w] =
              w < 26
                ? w + 65
                : w < 52
                  ? w + 71
                  : w < 62
                    ? w - 4
                    : (w - 59) | 43)
          ] = w++;
        e.encode = function (R, O, j) {
          for (var F = null, q = [], Q = 0, te = 0, se; O < j; ) {
            var re = R[O++];
            switch (te) {
              case 0:
                ((q[Q++] = f[re >> 2]), (se = (re & 3) << 4), (te = 1));
                break;
              case 1:
                ((q[Q++] = f[se | (re >> 4)]), (se = (re & 15) << 2), (te = 2));
                break;
              case 2:
                ((q[Q++] = f[se | (re >> 6)]), (q[Q++] = f[re & 63]), (te = 0));
                break;
            }
            Q > 8191 &&
              ((F || (F = [])).push(String.fromCharCode.apply(String, q)),
              (Q = 0));
          }
          return (
            te && ((q[Q++] = f[se]), (q[Q++] = 61), te === 1 && (q[Q++] = 61)),
            F
              ? (Q && F.push(String.fromCharCode.apply(String, q.slice(0, Q))),
                F.join(""))
              : String.fromCharCode.apply(String, q.slice(0, Q))
          );
        };
        var v = "invalid encoding";
        ((e.decode = function (R, O, j) {
          for (var F = j, q = 0, Q, te = 0; te < R.length; ) {
            var se = R.charCodeAt(te++);
            if (se === 61 && q > 1) break;
            if ((se = _[se]) === void 0) throw Error(v);
            switch (q) {
              case 0:
                ((Q = se), (q = 1));
                break;
              case 1:
                ((O[j++] = (Q << 2) | ((se & 48) >> 4)), (Q = se), (q = 2));
                break;
              case 2:
                ((O[j++] = ((Q & 15) << 4) | ((se & 60) >> 2)),
                  (Q = se),
                  (q = 3));
                break;
              case 3:
                ((O[j++] = ((Q & 3) << 6) | se), (q = 0));
                break;
            }
          }
          if (q === 1) throw Error(v);
          return j - F;
        }),
          (e.test = function (R) {
            return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(
              R,
            );
          }));
      })(base64)),
    base64
  );
}
var eventemitter, hasRequiredEventemitter;
function requireEventemitter() {
  if (hasRequiredEventemitter) return eventemitter;
  ((hasRequiredEventemitter = 1), (eventemitter = a));
  function a() {
    this._listeners = {};
  }
  return (
    (a.prototype.on = function (f, _, w) {
      return (
        (this._listeners[f] || (this._listeners[f] = [])).push({
          fn: _,
          ctx: w || this,
        }),
        this
      );
    }),
    (a.prototype.off = function (f, _) {
      if (f === void 0) this._listeners = {};
      else if (_ === void 0) this._listeners[f] = [];
      else
        for (var w = this._listeners[f], v = 0; v < w.length; )
          w[v].fn === _ ? w.splice(v, 1) : ++v;
      return this;
    }),
    (a.prototype.emit = function (f) {
      var _ = this._listeners[f];
      if (_) {
        for (var w = [], v = 1; v < arguments.length; ) w.push(arguments[v++]);
        for (v = 0; v < _.length; ) _[v].fn.apply(_[v++].ctx, w);
      }
      return this;
    }),
    eventemitter
  );
}
var float, hasRequiredFloat;
function requireFloat() {
  if (hasRequiredFloat) return float;
  ((hasRequiredFloat = 1), (float = a(a)));
  function a(v) {
    return (
      typeof Float32Array < "u"
        ? (function () {
            var S = new Float32Array([-0]),
              R = new Uint8Array(S.buffer),
              O = R[3] === 128;
            function j(te, se, re) {
              ((S[0] = te),
                (se[re] = R[0]),
                (se[re + 1] = R[1]),
                (se[re + 2] = R[2]),
                (se[re + 3] = R[3]));
            }
            function F(te, se, re) {
              ((S[0] = te),
                (se[re] = R[3]),
                (se[re + 1] = R[2]),
                (se[re + 2] = R[1]),
                (se[re + 3] = R[0]));
            }
            ((v.writeFloatLE = O ? j : F), (v.writeFloatBE = O ? F : j));
            function q(te, se) {
              return (
                (R[0] = te[se]),
                (R[1] = te[se + 1]),
                (R[2] = te[se + 2]),
                (R[3] = te[se + 3]),
                S[0]
              );
            }
            function Q(te, se) {
              return (
                (R[3] = te[se]),
                (R[2] = te[se + 1]),
                (R[1] = te[se + 2]),
                (R[0] = te[se + 3]),
                S[0]
              );
            }
            ((v.readFloatLE = O ? q : Q), (v.readFloatBE = O ? Q : q));
          })()
        : (function () {
            function S(O, j, F, q) {
              var Q = j < 0 ? 1 : 0;
              if ((Q && (j = -j), j === 0)) O(1 / j > 0 ? 0 : 2147483648, F, q);
              else if (isNaN(j)) O(2143289344, F, q);
              else if (j > 34028234663852886e22)
                O(((Q << 31) | 2139095040) >>> 0, F, q);
              else if (j < 11754943508222875e-54)
                O(
                  ((Q << 31) | Math.round(j / 1401298464324817e-60)) >>> 0,
                  F,
                  q,
                );
              else {
                var te = Math.floor(Math.log(j) / Math.LN2),
                  se = Math.round(j * Math.pow(2, -te) * 8388608) & 8388607;
                O(((Q << 31) | ((te + 127) << 23) | se) >>> 0, F, q);
              }
            }
            ((v.writeFloatLE = S.bind(null, e)),
              (v.writeFloatBE = S.bind(null, f)));
            function R(O, j, F) {
              var q = O(j, F),
                Q = (q >> 31) * 2 + 1,
                te = (q >>> 23) & 255,
                se = q & 8388607;
              return te === 255
                ? se
                  ? NaN
                  : Q * (1 / 0)
                : te === 0
                  ? Q * 1401298464324817e-60 * se
                  : Q * Math.pow(2, te - 150) * (se + 8388608);
            }
            ((v.readFloatLE = R.bind(null, _)),
              (v.readFloatBE = R.bind(null, w)));
          })(),
      typeof Float64Array < "u"
        ? (function () {
            var S = new Float64Array([-0]),
              R = new Uint8Array(S.buffer),
              O = R[7] === 128;
            function j(te, se, re) {
              ((S[0] = te),
                (se[re] = R[0]),
                (se[re + 1] = R[1]),
                (se[re + 2] = R[2]),
                (se[re + 3] = R[3]),
                (se[re + 4] = R[4]),
                (se[re + 5] = R[5]),
                (se[re + 6] = R[6]),
                (se[re + 7] = R[7]));
            }
            function F(te, se, re) {
              ((S[0] = te),
                (se[re] = R[7]),
                (se[re + 1] = R[6]),
                (se[re + 2] = R[5]),
                (se[re + 3] = R[4]),
                (se[re + 4] = R[3]),
                (se[re + 5] = R[2]),
                (se[re + 6] = R[1]),
                (se[re + 7] = R[0]));
            }
            ((v.writeDoubleLE = O ? j : F), (v.writeDoubleBE = O ? F : j));
            function q(te, se) {
              return (
                (R[0] = te[se]),
                (R[1] = te[se + 1]),
                (R[2] = te[se + 2]),
                (R[3] = te[se + 3]),
                (R[4] = te[se + 4]),
                (R[5] = te[se + 5]),
                (R[6] = te[se + 6]),
                (R[7] = te[se + 7]),
                S[0]
              );
            }
            function Q(te, se) {
              return (
                (R[7] = te[se]),
                (R[6] = te[se + 1]),
                (R[5] = te[se + 2]),
                (R[4] = te[se + 3]),
                (R[3] = te[se + 4]),
                (R[2] = te[se + 5]),
                (R[1] = te[se + 6]),
                (R[0] = te[se + 7]),
                S[0]
              );
            }
            ((v.readDoubleLE = O ? q : Q), (v.readDoubleBE = O ? Q : q));
          })()
        : (function () {
            function S(O, j, F, q, Q, te) {
              var se = q < 0 ? 1 : 0;
              if ((se && (q = -q), q === 0))
                (O(0, Q, te + j), O(1 / q > 0 ? 0 : 2147483648, Q, te + F));
              else if (isNaN(q)) (O(0, Q, te + j), O(2146959360, Q, te + F));
              else if (q > 17976931348623157e292)
                (O(0, Q, te + j),
                  O(((se << 31) | 2146435072) >>> 0, Q, te + F));
              else {
                var re;
                if (q < 22250738585072014e-324)
                  ((re = q / 5e-324),
                    O(re >>> 0, Q, te + j),
                    O(((se << 31) | (re / 4294967296)) >>> 0, Q, te + F));
                else {
                  var Oe = Math.floor(Math.log(q) / Math.LN2);
                  (Oe === 1024 && (Oe = 1023),
                    (re = q * Math.pow(2, -Oe)),
                    O((re * 4503599627370496) >>> 0, Q, te + j),
                    O(
                      ((se << 31) |
                        ((Oe + 1023) << 20) |
                        ((re * 1048576) & 1048575)) >>>
                        0,
                      Q,
                      te + F,
                    ));
                }
              }
            }
            ((v.writeDoubleLE = S.bind(null, e, 0, 4)),
              (v.writeDoubleBE = S.bind(null, f, 4, 0)));
            function R(O, j, F, q, Q) {
              var te = O(q, Q + j),
                se = O(q, Q + F),
                re = (se >> 31) * 2 + 1,
                Oe = (se >>> 20) & 2047,
                Le = 4294967296 * (se & 1048575) + te;
              return Oe === 2047
                ? Le
                  ? NaN
                  : re * (1 / 0)
                : Oe === 0
                  ? re * 5e-324 * Le
                  : re * Math.pow(2, Oe - 1075) * (Le + 4503599627370496);
            }
            ((v.readDoubleLE = R.bind(null, _, 0, 4)),
              (v.readDoubleBE = R.bind(null, w, 4, 0)));
          })(),
      v
    );
  }
  function e(v, S, R) {
    ((S[R] = v & 255),
      (S[R + 1] = (v >>> 8) & 255),
      (S[R + 2] = (v >>> 16) & 255),
      (S[R + 3] = v >>> 24));
  }
  function f(v, S, R) {
    ((S[R] = v >>> 24),
      (S[R + 1] = (v >>> 16) & 255),
      (S[R + 2] = (v >>> 8) & 255),
      (S[R + 3] = v & 255));
  }
  function _(v, S) {
    return (v[S] | (v[S + 1] << 8) | (v[S + 2] << 16) | (v[S + 3] << 24)) >>> 0;
  }
  function w(v, S) {
    return ((v[S] << 24) | (v[S + 1] << 16) | (v[S + 2] << 8) | v[S + 3]) >>> 0;
  }
  return float;
}
var inquire_1, hasRequiredInquire;
function requireInquire() {
  if (hasRequiredInquire) return inquire_1;
  ((hasRequiredInquire = 1), (inquire_1 = inquire));
  function inquire(moduleName) {
    try {
      var mod = eval("quire".replace(/^/, "re"))(moduleName);
      if (mod && (mod.length || Object.keys(mod).length)) return mod;
    } catch (a) {}
    return null;
  }
  return inquire_1;
}
var utf8 = {},
  hasRequiredUtf8;
function requireUtf8() {
  return (
    hasRequiredUtf8 ||
      ((hasRequiredUtf8 = 1),
      (function (a) {
        var e = a;
        ((e.length = function (_) {
          for (var w = 0, v = 0, S = 0; S < _.length; ++S)
            ((v = _.charCodeAt(S)),
              v < 128
                ? (w += 1)
                : v < 2048
                  ? (w += 2)
                  : (v & 64512) === 55296 &&
                      (_.charCodeAt(S + 1) & 64512) === 56320
                    ? (++S, (w += 4))
                    : (w += 3));
          return w;
        }),
          (e.read = function (_, w, v) {
            var S = v - w;
            if (S < 1) return "";
            for (var R = null, O = [], j = 0, F; w < v; )
              ((F = _[w++]),
                F < 128
                  ? (O[j++] = F)
                  : F > 191 && F < 224
                    ? (O[j++] = ((F & 31) << 6) | (_[w++] & 63))
                    : F > 239 && F < 365
                      ? ((F =
                          (((F & 7) << 18) |
                            ((_[w++] & 63) << 12) |
                            ((_[w++] & 63) << 6) |
                            (_[w++] & 63)) -
                          65536),
                        (O[j++] = 55296 + (F >> 10)),
                        (O[j++] = 56320 + (F & 1023)))
                      : (O[j++] =
                          ((F & 15) << 12) |
                          ((_[w++] & 63) << 6) |
                          (_[w++] & 63)),
                j > 8191 &&
                  ((R || (R = [])).push(String.fromCharCode.apply(String, O)),
                  (j = 0)));
            return R
              ? (j && R.push(String.fromCharCode.apply(String, O.slice(0, j))),
                R.join(""))
              : String.fromCharCode.apply(String, O.slice(0, j));
          }),
          (e.write = function (_, w, v) {
            for (var S = v, R, O, j = 0; j < _.length; ++j)
              ((R = _.charCodeAt(j)),
                R < 128
                  ? (w[v++] = R)
                  : R < 2048
                    ? ((w[v++] = (R >> 6) | 192), (w[v++] = (R & 63) | 128))
                    : (R & 64512) === 55296 &&
                        ((O = _.charCodeAt(j + 1)) & 64512) === 56320
                      ? ((R = 65536 + ((R & 1023) << 10) + (O & 1023)),
                        ++j,
                        (w[v++] = (R >> 18) | 240),
                        (w[v++] = ((R >> 12) & 63) | 128),
                        (w[v++] = ((R >> 6) & 63) | 128),
                        (w[v++] = (R & 63) | 128))
                      : ((w[v++] = (R >> 12) | 224),
                        (w[v++] = ((R >> 6) & 63) | 128),
                        (w[v++] = (R & 63) | 128)));
            return v - S;
          }));
      })(utf8)),
    utf8
  );
}
var pool_1, hasRequiredPool;
function requirePool() {
  if (hasRequiredPool) return pool_1;
  ((hasRequiredPool = 1), (pool_1 = a));
  function a(e, f, _) {
    var w = _ || 8192,
      v = w >>> 1,
      S = null,
      R = w;
    return function (j) {
      if (j < 1 || j > v) return e(j);
      R + j > w && ((S = e(w)), (R = 0));
      var F = f.call(S, R, (R += j));
      return (R & 7 && (R = (R | 7) + 1), F);
    };
  }
  return pool_1;
}
var longbits, hasRequiredLongbits;
function requireLongbits() {
  if (hasRequiredLongbits) return longbits;
  ((hasRequiredLongbits = 1), (longbits = e));
  var a = requireMinimal$1();
  function e(v, S) {
    ((this.lo = v >>> 0), (this.hi = S >>> 0));
  }
  var f = (e.zero = new e(0, 0));
  ((f.toNumber = function () {
    return 0;
  }),
    (f.zzEncode = f.zzDecode =
      function () {
        return this;
      }),
    (f.length = function () {
      return 1;
    }));
  var _ = (e.zeroHash = "\0\0\0\0\0\0\0\0");
  ((e.fromNumber = function (S) {
    if (S === 0) return f;
    var R = S < 0;
    R && (S = -S);
    var O = S >>> 0,
      j = ((S - O) / 4294967296) >>> 0;
    return (
      R &&
        ((j = ~j >>> 0),
        (O = ~O >>> 0),
        ++O > 4294967295 && ((O = 0), ++j > 4294967295 && (j = 0))),
      new e(O, j)
    );
  }),
    (e.from = function (S) {
      if (typeof S == "number") return e.fromNumber(S);
      if (a.isString(S))
        if (a.Long) S = a.Long.fromString(S);
        else return e.fromNumber(parseInt(S, 10));
      return S.low || S.high ? new e(S.low >>> 0, S.high >>> 0) : f;
    }),
    (e.prototype.toNumber = function (S) {
      if (!S && this.hi >>> 31) {
        var R = (~this.lo + 1) >>> 0,
          O = ~this.hi >>> 0;
        return (R || (O = (O + 1) >>> 0), -(R + O * 4294967296));
      }
      return this.lo + this.hi * 4294967296;
    }),
    (e.prototype.toLong = function (S) {
      return a.Long
        ? new a.Long(this.lo | 0, this.hi | 0, !!S)
        : { low: this.lo | 0, high: this.hi | 0, unsigned: !!S };
    }));
  var w = String.prototype.charCodeAt;
  return (
    (e.fromHash = function (S) {
      return S === _
        ? f
        : new e(
            (w.call(S, 0) |
              (w.call(S, 1) << 8) |
              (w.call(S, 2) << 16) |
              (w.call(S, 3) << 24)) >>>
              0,
            (w.call(S, 4) |
              (w.call(S, 5) << 8) |
              (w.call(S, 6) << 16) |
              (w.call(S, 7) << 24)) >>>
              0,
          );
    }),
    (e.prototype.toHash = function () {
      return String.fromCharCode(
        this.lo & 255,
        (this.lo >>> 8) & 255,
        (this.lo >>> 16) & 255,
        this.lo >>> 24,
        this.hi & 255,
        (this.hi >>> 8) & 255,
        (this.hi >>> 16) & 255,
        this.hi >>> 24,
      );
    }),
    (e.prototype.zzEncode = function () {
      var S = this.hi >> 31;
      return (
        (this.hi = (((this.hi << 1) | (this.lo >>> 31)) ^ S) >>> 0),
        (this.lo = ((this.lo << 1) ^ S) >>> 0),
        this
      );
    }),
    (e.prototype.zzDecode = function () {
      var S = -(this.lo & 1);
      return (
        (this.lo = (((this.lo >>> 1) | (this.hi << 31)) ^ S) >>> 0),
        (this.hi = ((this.hi >>> 1) ^ S) >>> 0),
        this
      );
    }),
    (e.prototype.length = function () {
      var S = this.lo,
        R = ((this.lo >>> 28) | (this.hi << 4)) >>> 0,
        O = this.hi >>> 24;
      return O === 0
        ? R === 0
          ? S < 16384
            ? S < 128
              ? 1
              : 2
            : S < 2097152
              ? 3
              : 4
          : R < 16384
            ? R < 128
              ? 5
              : 6
            : R < 2097152
              ? 7
              : 8
        : O < 128
          ? 9
          : 10;
    }),
    longbits
  );
}
var hasRequiredMinimal$1;
function requireMinimal$1() {
  return (
    hasRequiredMinimal$1 ||
      ((hasRequiredMinimal$1 = 1),
      (function (a) {
        var e = a;
        ((e.asPromise = requireAspromise()),
          (e.base64 = requireBase64()),
          (e.EventEmitter = requireEventemitter()),
          (e.float = requireFloat()),
          (e.inquire = requireInquire()),
          (e.utf8 = requireUtf8()),
          (e.pool = requirePool()),
          (e.LongBits = requireLongbits()),
          (e.isNode = !!(
            typeof commonjsGlobal < "u" &&
            commonjsGlobal &&
            commonjsGlobal.process &&
            commonjsGlobal.process.versions &&
            commonjsGlobal.process.versions.node
          )),
          (e.global =
            (e.isNode && commonjsGlobal) ||
            (typeof window < "u" && window) ||
            (typeof self < "u" && self) ||
            minimal$1),
          (e.emptyArray = Object.freeze ? Object.freeze([]) : []),
          (e.emptyObject = Object.freeze ? Object.freeze({}) : {}),
          (e.isInteger =
            Number.isInteger ||
            function (v) {
              return typeof v == "number" && isFinite(v) && Math.floor(v) === v;
            }),
          (e.isString = function (v) {
            return typeof v == "string" || v instanceof String;
          }),
          (e.isObject = function (v) {
            return v && typeof v == "object";
          }),
          (e.isset = e.isSet =
            function (v, S) {
              var R = v[S];
              return R != null && v.hasOwnProperty(S)
                ? typeof R != "object" ||
                    (Array.isArray(R) ? R.length : Object.keys(R).length) > 0
                : !1;
            }),
          (e.Buffer = (function () {
            try {
              var w = e.inquire("buffer").Buffer;
              return w.prototype.utf8Write ? w : null;
            } catch {
              return null;
            }
          })()),
          (e._Buffer_from = null),
          (e._Buffer_allocUnsafe = null),
          (e.newBuffer = function (v) {
            return typeof v == "number"
              ? e.Buffer
                ? e._Buffer_allocUnsafe(v)
                : new e.Array(v)
              : e.Buffer
                ? e._Buffer_from(v)
                : typeof Uint8Array > "u"
                  ? v
                  : new Uint8Array(v);
          }),
          (e.Array = typeof Uint8Array < "u" ? Uint8Array : Array),
          (e.Long =
            (e.global.dcodeIO && e.global.dcodeIO.Long) ||
            e.global.Long ||
            e.inquire("long")),
          (e.key2Re = /^true|false|0|1$/),
          (e.key32Re = /^-?(?:0|[1-9][0-9]*)$/),
          (e.key64Re = /^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/),
          (e.longToHash = function (v) {
            return v ? e.LongBits.from(v).toHash() : e.LongBits.zeroHash;
          }),
          (e.longFromHash = function (v, S) {
            var R = e.LongBits.fromHash(v);
            return e.Long ? e.Long.fromBits(R.lo, R.hi, S) : R.toNumber(!!S);
          }));
        function f(w, v, S) {
          for (var R = Object.keys(v), O = 0; O < R.length; ++O)
            (w[R[O]] === void 0 || !S) && (w[R[O]] = v[R[O]]);
          return w;
        }
        ((e.merge = f),
          (e.lcFirst = function (v) {
            return v.charAt(0).toLowerCase() + v.substring(1);
          }));
        function _(w) {
          function v(S, R) {
            if (!(this instanceof v)) return new v(S, R);
            (Object.defineProperty(this, "message", {
              get: function () {
                return S;
              },
            }),
              Error.captureStackTrace
                ? Error.captureStackTrace(this, v)
                : Object.defineProperty(this, "stack", {
                    value: new Error().stack || "",
                  }),
              R && f(this, R));
          }
          return (
            (v.prototype = Object.create(Error.prototype, {
              constructor: {
                value: v,
                writable: !0,
                enumerable: !1,
                configurable: !0,
              },
              name: {
                get: function () {
                  return w;
                },
                set: void 0,
                enumerable: !1,
                configurable: !0,
              },
              toString: {
                value: function () {
                  return this.name + ": " + this.message;
                },
                writable: !0,
                enumerable: !1,
                configurable: !0,
              },
            })),
            v
          );
        }
        ((e.newError = _),
          (e.ProtocolError = _("ProtocolError")),
          (e.oneOfGetter = function (v) {
            for (var S = {}, R = 0; R < v.length; ++R) S[v[R]] = 1;
            return function () {
              for (var O = Object.keys(this), j = O.length - 1; j > -1; --j)
                if (
                  S[O[j]] === 1 &&
                  this[O[j]] !== void 0 &&
                  this[O[j]] !== null
                )
                  return O[j];
            };
          }),
          (e.oneOfSetter = function (v) {
            return function (S) {
              for (var R = 0; R < v.length; ++R)
                v[R] !== S && delete this[v[R]];
            };
          }),
          (e.toJSONOptions = {
            longs: String,
            enums: String,
            bytes: String,
            json: !0,
          }),
          (e._configure = function () {
            var w = e.Buffer;
            if (!w) {
              e._Buffer_from = e._Buffer_allocUnsafe = null;
              return;
            }
            ((e._Buffer_from =
              (w.from !== Uint8Array.from && w.from) ||
              function (S, R) {
                return new w(S, R);
              }),
              (e._Buffer_allocUnsafe =
                w.allocUnsafe ||
                function (S) {
                  return new w(S);
                }));
          }));
      })(minimal$1)),
    minimal$1
  );
}
var writer, hasRequiredWriter;
function requireWriter() {
  if (hasRequiredWriter) return writer;
  ((hasRequiredWriter = 1), (writer = O));
  var a = requireMinimal$1(),
    e,
    f = a.LongBits,
    _ = a.base64,
    w = a.utf8;
  function v(Oe, Le, Be) {
    ((this.fn = Oe), (this.len = Le), (this.next = void 0), (this.val = Be));
  }
  function S() {}
  function R(Oe) {
    ((this.head = Oe.head),
      (this.tail = Oe.tail),
      (this.len = Oe.len),
      (this.next = Oe.states));
  }
  function O() {
    ((this.len = 0),
      (this.head = new v(S, 0, 0)),
      (this.tail = this.head),
      (this.states = null));
  }
  var j = function () {
    return a.Buffer
      ? function () {
          return (O.create = function () {
            return new e();
          })();
        }
      : function () {
          return new O();
        };
  };
  ((O.create = j()),
    (O.alloc = function (Le) {
      return new a.Array(Le);
    }),
    a.Array !== Array &&
      (O.alloc = a.pool(O.alloc, a.Array.prototype.subarray)),
    (O.prototype._push = function (Le, Be, Ve) {
      return (
        (this.tail = this.tail.next = new v(Le, Be, Ve)),
        (this.len += Be),
        this
      );
    }));
  function F(Oe, Le, Be) {
    Le[Be] = Oe & 255;
  }
  function q(Oe, Le, Be) {
    for (; Oe > 127; ) ((Le[Be++] = (Oe & 127) | 128), (Oe >>>= 7));
    Le[Be] = Oe;
  }
  function Q(Oe, Le) {
    ((this.len = Oe), (this.next = void 0), (this.val = Le));
  }
  ((Q.prototype = Object.create(v.prototype)),
    (Q.prototype.fn = q),
    (O.prototype.uint32 = function (Le) {
      return (
        (this.len += (this.tail = this.tail.next =
          new Q(
            (Le = Le >>> 0) < 128
              ? 1
              : Le < 16384
                ? 2
                : Le < 2097152
                  ? 3
                  : Le < 268435456
                    ? 4
                    : 5,
            Le,
          )).len),
        this
      );
    }),
    (O.prototype.int32 = function (Le) {
      return Le < 0 ? this._push(te, 10, f.fromNumber(Le)) : this.uint32(Le);
    }),
    (O.prototype.sint32 = function (Le) {
      return this.uint32(((Le << 1) ^ (Le >> 31)) >>> 0);
    }));
  function te(Oe, Le, Be) {
    for (; Oe.hi; )
      ((Le[Be++] = (Oe.lo & 127) | 128),
        (Oe.lo = ((Oe.lo >>> 7) | (Oe.hi << 25)) >>> 0),
        (Oe.hi >>>= 7));
    for (; Oe.lo > 127; )
      ((Le[Be++] = (Oe.lo & 127) | 128), (Oe.lo = Oe.lo >>> 7));
    Le[Be++] = Oe.lo;
  }
  ((O.prototype.uint64 = function (Le) {
    var Be = f.from(Le);
    return this._push(te, Be.length(), Be);
  }),
    (O.prototype.int64 = O.prototype.uint64),
    (O.prototype.sint64 = function (Le) {
      var Be = f.from(Le).zzEncode();
      return this._push(te, Be.length(), Be);
    }),
    (O.prototype.bool = function (Le) {
      return this._push(F, 1, Le ? 1 : 0);
    }));
  function se(Oe, Le, Be) {
    ((Le[Be] = Oe & 255),
      (Le[Be + 1] = (Oe >>> 8) & 255),
      (Le[Be + 2] = (Oe >>> 16) & 255),
      (Le[Be + 3] = Oe >>> 24));
  }
  ((O.prototype.fixed32 = function (Le) {
    return this._push(se, 4, Le >>> 0);
  }),
    (O.prototype.sfixed32 = O.prototype.fixed32),
    (O.prototype.fixed64 = function (Le) {
      var Be = f.from(Le);
      return this._push(se, 4, Be.lo)._push(se, 4, Be.hi);
    }),
    (O.prototype.sfixed64 = O.prototype.fixed64),
    (O.prototype.float = function (Le) {
      return this._push(a.float.writeFloatLE, 4, Le);
    }),
    (O.prototype.double = function (Le) {
      return this._push(a.float.writeDoubleLE, 8, Le);
    }));
  var re = a.Array.prototype.set
    ? function (Le, Be, Ve) {
        Be.set(Le, Ve);
      }
    : function (Le, Be, Ve) {
        for (var ze = 0; ze < Le.length; ++ze) Be[Ve + ze] = Le[ze];
      };
  return (
    (O.prototype.bytes = function (Le) {
      var Be = Le.length >>> 0;
      if (!Be) return this._push(F, 1, 0);
      if (a.isString(Le)) {
        var Ve = O.alloc((Be = _.length(Le)));
        (_.decode(Le, Ve, 0), (Le = Ve));
      }
      return this.uint32(Be)._push(re, Be, Le);
    }),
    (O.prototype.string = function (Le) {
      var Be = w.length(Le);
      return Be ? this.uint32(Be)._push(w.write, Be, Le) : this._push(F, 1, 0);
    }),
    (O.prototype.fork = function () {
      return (
        (this.states = new R(this)),
        (this.head = this.tail = new v(S, 0, 0)),
        (this.len = 0),
        this
      );
    }),
    (O.prototype.reset = function () {
      return (
        this.states
          ? ((this.head = this.states.head),
            (this.tail = this.states.tail),
            (this.len = this.states.len),
            (this.states = this.states.next))
          : ((this.head = this.tail = new v(S, 0, 0)), (this.len = 0)),
        this
      );
    }),
    (O.prototype.ldelim = function () {
      var Le = this.head,
        Be = this.tail,
        Ve = this.len;
      return (
        this.reset().uint32(Ve),
        Ve && ((this.tail.next = Le.next), (this.tail = Be), (this.len += Ve)),
        this
      );
    }),
    (O.prototype.finish = function () {
      for (
        var Le = this.head.next, Be = this.constructor.alloc(this.len), Ve = 0;
        Le;

      )
        (Le.fn(Le.val, Be, Ve), (Ve += Le.len), (Le = Le.next));
      return Be;
    }),
    (O._configure = function (Oe) {
      ((e = Oe), (O.create = j()), e._configure());
    }),
    writer
  );
}
var writer_buffer, hasRequiredWriter_buffer;
function requireWriter_buffer() {
  if (hasRequiredWriter_buffer) return writer_buffer;
  ((hasRequiredWriter_buffer = 1), (writer_buffer = f));
  var a = requireWriter();
  (f.prototype = Object.create(a.prototype)).constructor = f;
  var e = requireMinimal$1();
  function f() {
    a.call(this);
  }
  ((f._configure = function () {
    ((f.alloc = e._Buffer_allocUnsafe),
      (f.writeBytesBuffer =
        e.Buffer &&
        e.Buffer.prototype instanceof Uint8Array &&
        e.Buffer.prototype.set.name === "set"
          ? function (v, S, R) {
              S.set(v, R);
            }
          : function (v, S, R) {
              if (v.copy) v.copy(S, R, 0, v.length);
              else for (var O = 0; O < v.length; ) S[R++] = v[O++];
            }));
  }),
    (f.prototype.bytes = function (v) {
      e.isString(v) && (v = e._Buffer_from(v, "base64"));
      var S = v.length >>> 0;
      return (this.uint32(S), S && this._push(f.writeBytesBuffer, S, v), this);
    }));
  function _(w, v, S) {
    w.length < 40
      ? e.utf8.write(w, v, S)
      : v.utf8Write
        ? v.utf8Write(w, S)
        : v.write(w, S);
  }
  return (
    (f.prototype.string = function (v) {
      var S = e.Buffer.byteLength(v);
      return (this.uint32(S), S && this._push(_, S, v), this);
    }),
    f._configure(),
    writer_buffer
  );
}
var reader, hasRequiredReader;
function requireReader() {
  if (hasRequiredReader) return reader;
  ((hasRequiredReader = 1), (reader = v));
  var a = requireMinimal$1(),
    e,
    f = a.LongBits,
    _ = a.utf8;
  function w(q, Q) {
    return RangeError(
      "index out of range: " + q.pos + " + " + (Q || 1) + " > " + q.len,
    );
  }
  function v(q) {
    ((this.buf = q), (this.pos = 0), (this.len = q.length));
  }
  var S =
      typeof Uint8Array < "u"
        ? function (Q) {
            if (Q instanceof Uint8Array || Array.isArray(Q)) return new v(Q);
            throw Error("illegal buffer");
          }
        : function (Q) {
            if (Array.isArray(Q)) return new v(Q);
            throw Error("illegal buffer");
          },
    R = function () {
      return a.Buffer
        ? function (te) {
            return (v.create = function (re) {
              return a.Buffer.isBuffer(re) ? new e(re) : S(re);
            })(te);
          }
        : S;
    };
  ((v.create = R()),
    (v.prototype._slice =
      a.Array.prototype.subarray || a.Array.prototype.slice),
    (v.prototype.uint32 = (function () {
      var Q = 4294967295;
      return function () {
        if (
          ((Q = (this.buf[this.pos] & 127) >>> 0),
          this.buf[this.pos++] < 128 ||
            ((Q = (Q | ((this.buf[this.pos] & 127) << 7)) >>> 0),
            this.buf[this.pos++] < 128) ||
            ((Q = (Q | ((this.buf[this.pos] & 127) << 14)) >>> 0),
            this.buf[this.pos++] < 128) ||
            ((Q = (Q | ((this.buf[this.pos] & 127) << 21)) >>> 0),
            this.buf[this.pos++] < 128) ||
            ((Q = (Q | ((this.buf[this.pos] & 15) << 28)) >>> 0),
            this.buf[this.pos++] < 128))
        )
          return Q;
        if ((this.pos += 5) > this.len)
          throw ((this.pos = this.len), w(this, 10));
        return Q;
      };
    })()),
    (v.prototype.int32 = function () {
      return this.uint32() | 0;
    }),
    (v.prototype.sint32 = function () {
      var Q = this.uint32();
      return ((Q >>> 1) ^ -(Q & 1)) | 0;
    }));
  function O() {
    var q = new f(0, 0),
      Q = 0;
    if (this.len - this.pos > 4) {
      for (; Q < 4; ++Q)
        if (
          ((q.lo = (q.lo | ((this.buf[this.pos] & 127) << (Q * 7))) >>> 0),
          this.buf[this.pos++] < 128)
        )
          return q;
      if (
        ((q.lo = (q.lo | ((this.buf[this.pos] & 127) << 28)) >>> 0),
        (q.hi = (q.hi | ((this.buf[this.pos] & 127) >> 4)) >>> 0),
        this.buf[this.pos++] < 128)
      )
        return q;
      Q = 0;
    } else {
      for (; Q < 3; ++Q) {
        if (this.pos >= this.len) throw w(this);
        if (
          ((q.lo = (q.lo | ((this.buf[this.pos] & 127) << (Q * 7))) >>> 0),
          this.buf[this.pos++] < 128)
        )
          return q;
      }
      return (
        (q.lo = (q.lo | ((this.buf[this.pos++] & 127) << (Q * 7))) >>> 0),
        q
      );
    }
    if (this.len - this.pos > 4) {
      for (; Q < 5; ++Q)
        if (
          ((q.hi = (q.hi | ((this.buf[this.pos] & 127) << (Q * 7 + 3))) >>> 0),
          this.buf[this.pos++] < 128)
        )
          return q;
    } else
      for (; Q < 5; ++Q) {
        if (this.pos >= this.len) throw w(this);
        if (
          ((q.hi = (q.hi | ((this.buf[this.pos] & 127) << (Q * 7 + 3))) >>> 0),
          this.buf[this.pos++] < 128)
        )
          return q;
      }
    throw Error("invalid varint encoding");
  }
  v.prototype.bool = function () {
    return this.uint32() !== 0;
  };
  function j(q, Q) {
    return (
      (q[Q - 4] | (q[Q - 3] << 8) | (q[Q - 2] << 16) | (q[Q - 1] << 24)) >>> 0
    );
  }
  ((v.prototype.fixed32 = function () {
    if (this.pos + 4 > this.len) throw w(this, 4);
    return j(this.buf, (this.pos += 4));
  }),
    (v.prototype.sfixed32 = function () {
      if (this.pos + 4 > this.len) throw w(this, 4);
      return j(this.buf, (this.pos += 4)) | 0;
    }));
  function F() {
    if (this.pos + 8 > this.len) throw w(this, 8);
    return new f(j(this.buf, (this.pos += 4)), j(this.buf, (this.pos += 4)));
  }
  return (
    (v.prototype.float = function () {
      if (this.pos + 4 > this.len) throw w(this, 4);
      var Q = a.float.readFloatLE(this.buf, this.pos);
      return ((this.pos += 4), Q);
    }),
    (v.prototype.double = function () {
      if (this.pos + 8 > this.len) throw w(this, 4);
      var Q = a.float.readDoubleLE(this.buf, this.pos);
      return ((this.pos += 8), Q);
    }),
    (v.prototype.bytes = function () {
      var Q = this.uint32(),
        te = this.pos,
        se = this.pos + Q;
      if (se > this.len) throw w(this, Q);
      if (((this.pos += Q), Array.isArray(this.buf)))
        return this.buf.slice(te, se);
      if (te === se) {
        var re = a.Buffer;
        return re ? re.alloc(0) : new this.buf.constructor(0);
      }
      return this._slice.call(this.buf, te, se);
    }),
    (v.prototype.string = function () {
      var Q = this.bytes();
      return _.read(Q, 0, Q.length);
    }),
    (v.prototype.skip = function (Q) {
      if (typeof Q == "number") {
        if (this.pos + Q > this.len) throw w(this, Q);
        this.pos += Q;
      } else
        do if (this.pos >= this.len) throw w(this);
        while (this.buf[this.pos++] & 128);
      return this;
    }),
    (v.prototype.skipType = function (q) {
      switch (q) {
        case 0:
          this.skip();
          break;
        case 1:
          this.skip(8);
          break;
        case 2:
          this.skip(this.uint32());
          break;
        case 3:
          for (; (q = this.uint32() & 7) !== 4; ) this.skipType(q);
          break;
        case 5:
          this.skip(4);
          break;
        default:
          throw Error("invalid wire type " + q + " at offset " + this.pos);
      }
      return this;
    }),
    (v._configure = function (q) {
      ((e = q), (v.create = R()), e._configure());
      var Q = a.Long ? "toLong" : "toNumber";
      a.merge(v.prototype, {
        int64: function () {
          return O.call(this)[Q](!1);
        },
        uint64: function () {
          return O.call(this)[Q](!0);
        },
        sint64: function () {
          return O.call(this).zzDecode()[Q](!1);
        },
        fixed64: function () {
          return F.call(this)[Q](!0);
        },
        sfixed64: function () {
          return F.call(this)[Q](!1);
        },
      });
    }),
    reader
  );
}
var reader_buffer, hasRequiredReader_buffer;
function requireReader_buffer() {
  if (hasRequiredReader_buffer) return reader_buffer;
  ((hasRequiredReader_buffer = 1), (reader_buffer = f));
  var a = requireReader();
  (f.prototype = Object.create(a.prototype)).constructor = f;
  var e = requireMinimal$1();
  function f(_) {
    a.call(this, _);
  }
  return (
    (f._configure = function () {
      e.Buffer && (f.prototype._slice = e.Buffer.prototype.slice);
    }),
    (f.prototype.string = function () {
      var w = this.uint32();
      return this.buf.utf8Slice
        ? this.buf.utf8Slice(
            this.pos,
            (this.pos = Math.min(this.pos + w, this.len)),
          )
        : this.buf.toString(
            "utf-8",
            this.pos,
            (this.pos = Math.min(this.pos + w, this.len)),
          );
    }),
    f._configure(),
    reader_buffer
  );
}
var rpc = {},
  service,
  hasRequiredService;
function requireService() {
  if (hasRequiredService) return service;
  ((hasRequiredService = 1), (service = e));
  var a = requireMinimal$1();
  (e.prototype = Object.create(a.EventEmitter.prototype)).constructor = e;
  function e(f, _, w) {
    if (typeof f != "function") throw TypeError("rpcImpl must be a function");
    (a.EventEmitter.call(this),
      (this.rpcImpl = f),
      (this.requestDelimited = !!_),
      (this.responseDelimited = !!w));
  }
  return (
    (e.prototype.rpcCall = function f(_, w, v, S, R) {
      if (!S) throw TypeError("request must be specified");
      var O = this;
      if (!R) return a.asPromise(f, O, _, w, v, S);
      if (!O.rpcImpl) {
        setTimeout(function () {
          R(Error("already ended"));
        }, 0);
        return;
      }
      try {
        return O.rpcImpl(
          _,
          w[O.requestDelimited ? "encodeDelimited" : "encode"](S).finish(),
          function (F, q) {
            if (F) return (O.emit("error", F, _), R(F));
            if (q === null) {
              O.end(!0);
              return;
            }
            if (!(q instanceof v))
              try {
                q = v[O.responseDelimited ? "decodeDelimited" : "decode"](q);
              } catch (Q) {
                return (O.emit("error", Q, _), R(Q));
              }
            return (O.emit("data", q, _), R(null, q));
          },
        );
      } catch (j) {
        (O.emit("error", j, _),
          setTimeout(function () {
            R(j);
          }, 0));
        return;
      }
    }),
    (e.prototype.end = function (_) {
      return (
        this.rpcImpl &&
          (_ || this.rpcImpl(null, null, null),
          (this.rpcImpl = null),
          this.emit("end").off()),
        this
      );
    }),
    service
  );
}
var hasRequiredRpc;
function requireRpc() {
  return (
    hasRequiredRpc ||
      ((hasRequiredRpc = 1),
      (function (a) {
        var e = a;
        e.Service = requireService();
      })(rpc)),
    rpc
  );
}
var roots, hasRequiredRoots;
function requireRoots() {
  return (hasRequiredRoots || ((hasRequiredRoots = 1), (roots = {})), roots);
}
var hasRequiredIndexMinimal;
function requireIndexMinimal() {
  return (
    hasRequiredIndexMinimal ||
      ((hasRequiredIndexMinimal = 1),
      (function (a) {
        var e = a;
        ((e.build = "minimal"),
          (e.Writer = requireWriter()),
          (e.BufferWriter = requireWriter_buffer()),
          (e.Reader = requireReader()),
          (e.BufferReader = requireReader_buffer()),
          (e.util = requireMinimal$1()),
          (e.rpc = requireRpc()),
          (e.roots = requireRoots()),
          (e.configure = f));
        function f() {
          (e.util._configure(),
            e.Writer._configure(e.BufferWriter),
            e.Reader._configure(e.BufferReader));
        }
        f();
      })(indexMinimal)),
    indexMinimal
  );
}
var minimal, hasRequiredMinimal;
function requireMinimal() {
  return (
    hasRequiredMinimal ||
      ((hasRequiredMinimal = 1), (minimal = requireIndexMinimal())),
    minimal
  );
}
var minimalExports = requireMinimal();
const _m0 = getDefaultExportFromCjs(minimalExports);
var globalThis$l = (() => {
  if (typeof globalThis$l < "u") return globalThis$l;
  if (typeof self < "u") return self;
  if (typeof window < "u") return window;
  if (typeof global < "u") return global;
  throw "Unable to locate global object";
})();
_m0.util.Long !== Long && ((_m0.util.Long = Long), _m0.configure());
var globalThis$k = (() => {
  if (typeof globalThis$k < "u") return globalThis$k;
  if (typeof self < "u") return self;
  if (typeof window < "u") return window;
  if (typeof global < "u") return global;
  throw "Unable to locate global object";
})();
_m0.util.Long !== Long && ((_m0.util.Long = Long), _m0.configure());
var globalThis$j = (() => {
  if (typeof globalThis$j < "u") return globalThis$j;
  if (typeof self < "u") return self;
  if (typeof window < "u") return window;
  if (typeof global < "u") return global;
  throw "Unable to locate global object";
})();
_m0.util.Long !== Long && ((_m0.util.Long = Long), _m0.configure());
function createBaseCiphertext() {
  return { aes256GcmHkdfSha256: void 0 };
}
const Ciphertext = {
  encode(a, e = _m0.Writer.create()) {
    return (
      a.aes256GcmHkdfSha256 !== void 0 &&
        Ciphertext_Aes256gcmHkdfsha256.encode(
          a.aes256GcmHkdfSha256,
          e.uint32(10).fork(),
        ).ldelim(),
      e
    );
  },
  decode(a, e) {
    const f = a instanceof _m0.Reader ? a : new _m0.Reader(a);
    let _ = e === void 0 ? f.len : f.pos + e;
    const w = createBaseCiphertext();
    for (; f.pos < _; ) {
      const v = f.uint32();
      switch (v >>> 3) {
        case 1:
          w.aes256GcmHkdfSha256 = Ciphertext_Aes256gcmHkdfsha256.decode(
            f,
            f.uint32(),
          );
          break;
        default:
          f.skipType(v & 7);
          break;
      }
    }
    return w;
  },
  fromJSON(a) {
    return {
      aes256GcmHkdfSha256: isSet$2(a.aes256GcmHkdfSha256)
        ? Ciphertext_Aes256gcmHkdfsha256.fromJSON(a.aes256GcmHkdfSha256)
        : void 0,
    };
  },
  toJSON(a) {
    const e = {};
    return (
      a.aes256GcmHkdfSha256 !== void 0 &&
        (e.aes256GcmHkdfSha256 = a.aes256GcmHkdfSha256
          ? Ciphertext_Aes256gcmHkdfsha256.toJSON(a.aes256GcmHkdfSha256)
          : void 0),
      e
    );
  },
  fromPartial(a) {
    const e = createBaseCiphertext();
    return (
      (e.aes256GcmHkdfSha256 =
        a.aes256GcmHkdfSha256 !== void 0 && a.aes256GcmHkdfSha256 !== null
          ? Ciphertext_Aes256gcmHkdfsha256.fromPartial(a.aes256GcmHkdfSha256)
          : void 0),
      e
    );
  },
};
function createBaseCiphertext_Aes256gcmHkdfsha256() {
  return {
    hkdfSalt: new Uint8Array(),
    gcmNonce: new Uint8Array(),
    payload: new Uint8Array(),
  };
}
const Ciphertext_Aes256gcmHkdfsha256 = {
  encode(a, e = _m0.Writer.create()) {
    return (
      a.hkdfSalt.length !== 0 && e.uint32(10).bytes(a.hkdfSalt),
      a.gcmNonce.length !== 0 && e.uint32(18).bytes(a.gcmNonce),
      a.payload.length !== 0 && e.uint32(26).bytes(a.payload),
      e
    );
  },
  decode(a, e) {
    const f = a instanceof _m0.Reader ? a : new _m0.Reader(a);
    let _ = e === void 0 ? f.len : f.pos + e;
    const w = createBaseCiphertext_Aes256gcmHkdfsha256();
    for (; f.pos < _; ) {
      const v = f.uint32();
      switch (v >>> 3) {
        case 1:
          w.hkdfSalt = f.bytes();
          break;
        case 2:
          w.gcmNonce = f.bytes();
          break;
        case 3:
          w.payload = f.bytes();
          break;
        default:
          f.skipType(v & 7);
          break;
      }
    }
    return w;
  },
  fromJSON(a) {
    return {
      hkdfSalt: isSet$2(a.hkdfSalt)
        ? bytesFromBase64$1(a.hkdfSalt)
        : new Uint8Array(),
      gcmNonce: isSet$2(a.gcmNonce)
        ? bytesFromBase64$1(a.gcmNonce)
        : new Uint8Array(),
      payload: isSet$2(a.payload)
        ? bytesFromBase64$1(a.payload)
        : new Uint8Array(),
    };
  },
  toJSON(a) {
    const e = {};
    return (
      a.hkdfSalt !== void 0 &&
        (e.hkdfSalt = base64FromBytes$1(
          a.hkdfSalt !== void 0 ? a.hkdfSalt : new Uint8Array(),
        )),
      a.gcmNonce !== void 0 &&
        (e.gcmNonce = base64FromBytes$1(
          a.gcmNonce !== void 0 ? a.gcmNonce : new Uint8Array(),
        )),
      a.payload !== void 0 &&
        (e.payload = base64FromBytes$1(
          a.payload !== void 0 ? a.payload : new Uint8Array(),
        )),
      e
    );
  },
  fromPartial(a) {
    var e, f, _;
    const w = createBaseCiphertext_Aes256gcmHkdfsha256();
    return (
      (w.hkdfSalt =
        (e = a.hkdfSalt) !== null && e !== void 0 ? e : new Uint8Array()),
      (w.gcmNonce =
        (f = a.gcmNonce) !== null && f !== void 0 ? f : new Uint8Array()),
      (w.payload =
        (_ = a.payload) !== null && _ !== void 0 ? _ : new Uint8Array()),
      w
    );
  },
};
var globalThis$i = (() => {
  if (typeof globalThis$i < "u") return globalThis$i;
  if (typeof self < "u") return self;
  if (typeof window < "u") return window;
  if (typeof global < "u") return global;
  throw "Unable to locate global object";
})();
function bytesFromBase64$1(a) {
  if (globalThis$i.Buffer)
    return Uint8Array.from(globalThis$i.Buffer.from(a, "base64"));
  {
    const e = globalThis$i.atob(a),
      f = new Uint8Array(e.length);
    for (let _ = 0; _ < e.length; ++_) f[_] = e.charCodeAt(_);
    return f;
  }
}
function base64FromBytes$1(a) {
  if (globalThis$i.Buffer)
    return globalThis$i.Buffer.from(a).toString("base64");
  {
    const e = [];
    return (
      a.forEach((f) => {
        e.push(String.fromCharCode(f));
      }),
      globalThis$i.btoa(e.join(""))
    );
  }
}
_m0.util.Long !== Long && ((_m0.util.Long = Long), _m0.configure());
function isSet$2(a) {
  return a != null;
}
var ConsentProofPayloadVersion;
(function (a) {
  ((a[(a.CONSENT_PROOF_PAYLOAD_VERSION_UNSPECIFIED = 0)] =
    "CONSENT_PROOF_PAYLOAD_VERSION_UNSPECIFIED"),
    (a[(a.CONSENT_PROOF_PAYLOAD_VERSION_1 = 1)] =
      "CONSENT_PROOF_PAYLOAD_VERSION_1"),
    (a[(a.UNRECOGNIZED = -1)] = "UNRECOGNIZED"));
})(ConsentProofPayloadVersion || (ConsentProofPayloadVersion = {}));
var globalThis$h = (() => {
  if (typeof globalThis$h < "u") return globalThis$h;
  if (typeof self < "u") return self;
  if (typeof window < "u") return window;
  if (typeof global < "u") return global;
  throw "Unable to locate global object";
})();
_m0.util.Long !== Long && ((_m0.util.Long = Long), _m0.configure());
_m0.util.Long !== Long && ((_m0.util.Long = Long), _m0.configure());
var globalThis$g = (() => {
  if (typeof globalThis$g < "u") return globalThis$g;
  if (typeof self < "u") return self;
  if (typeof window < "u") return window;
  if (typeof global < "u") return global;
  throw "Unable to locate global object";
})();
_m0.util.Long !== Long && ((_m0.util.Long = Long), _m0.configure());
var Compression$1;
(function (a) {
  ((a[(a.COMPRESSION_DEFLATE = 0)] = "COMPRESSION_DEFLATE"),
    (a[(a.COMPRESSION_GZIP = 1)] = "COMPRESSION_GZIP"),
    (a[(a.UNRECOGNIZED = -1)] = "UNRECOGNIZED"));
})(Compression$1 || (Compression$1 = {}));
function compressionFromJSON(a) {
  switch (a) {
    case 0:
    case "COMPRESSION_DEFLATE":
      return Compression$1.COMPRESSION_DEFLATE;
    case 1:
    case "COMPRESSION_GZIP":
      return Compression$1.COMPRESSION_GZIP;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Compression$1.UNRECOGNIZED;
  }
}
function compressionToJSON(a) {
  switch (a) {
    case Compression$1.COMPRESSION_DEFLATE:
      return "COMPRESSION_DEFLATE";
    case Compression$1.COMPRESSION_GZIP:
      return "COMPRESSION_GZIP";
    case Compression$1.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}
function createBaseContentTypeId() {
  return { authorityId: "", typeId: "", versionMajor: 0, versionMinor: 0 };
}
const ContentTypeId$1 = {
  encode(a, e = _m0.Writer.create()) {
    return (
      a.authorityId !== "" && e.uint32(10).string(a.authorityId),
      a.typeId !== "" && e.uint32(18).string(a.typeId),
      a.versionMajor !== 0 && e.uint32(24).uint32(a.versionMajor),
      a.versionMinor !== 0 && e.uint32(32).uint32(a.versionMinor),
      e
    );
  },
  decode(a, e) {
    const f = a instanceof _m0.Reader ? a : new _m0.Reader(a);
    let _ = e === void 0 ? f.len : f.pos + e;
    const w = createBaseContentTypeId();
    for (; f.pos < _; ) {
      const v = f.uint32();
      switch (v >>> 3) {
        case 1:
          w.authorityId = f.string();
          break;
        case 2:
          w.typeId = f.string();
          break;
        case 3:
          w.versionMajor = f.uint32();
          break;
        case 4:
          w.versionMinor = f.uint32();
          break;
        default:
          f.skipType(v & 7);
          break;
      }
    }
    return w;
  },
  fromJSON(a) {
    return {
      authorityId: isSet$1(a.authorityId) ? String(a.authorityId) : "",
      typeId: isSet$1(a.typeId) ? String(a.typeId) : "",
      versionMajor: isSet$1(a.versionMajor) ? Number(a.versionMajor) : 0,
      versionMinor: isSet$1(a.versionMinor) ? Number(a.versionMinor) : 0,
    };
  },
  toJSON(a) {
    const e = {};
    return (
      a.authorityId !== void 0 && (e.authorityId = a.authorityId),
      a.typeId !== void 0 && (e.typeId = a.typeId),
      a.versionMajor !== void 0 &&
        (e.versionMajor = Math.round(a.versionMajor)),
      a.versionMinor !== void 0 &&
        (e.versionMinor = Math.round(a.versionMinor)),
      e
    );
  },
  fromPartial(a) {
    var e, f, _, w;
    const v = createBaseContentTypeId();
    return (
      (v.authorityId = (e = a.authorityId) !== null && e !== void 0 ? e : ""),
      (v.typeId = (f = a.typeId) !== null && f !== void 0 ? f : ""),
      (v.versionMajor = (_ = a.versionMajor) !== null && _ !== void 0 ? _ : 0),
      (v.versionMinor = (w = a.versionMinor) !== null && w !== void 0 ? w : 0),
      v
    );
  },
};
function createBaseEncodedContent() {
  return {
    type: void 0,
    parameters: {},
    fallback: void 0,
    compression: void 0,
    content: new Uint8Array(),
  };
}
const EncodedContent$1 = {
  encode(a, e = _m0.Writer.create()) {
    return (
      a.type !== void 0 &&
        ContentTypeId$1.encode(a.type, e.uint32(10).fork()).ldelim(),
      Object.entries(a.parameters).forEach(([f, _]) => {
        EncodedContent_ParametersEntry.encode(
          { key: f, value: _ },
          e.uint32(18).fork(),
        ).ldelim();
      }),
      a.fallback !== void 0 && e.uint32(26).string(a.fallback),
      a.compression !== void 0 && e.uint32(40).int32(a.compression),
      a.content.length !== 0 && e.uint32(34).bytes(a.content),
      e
    );
  },
  decode(a, e) {
    const f = a instanceof _m0.Reader ? a : new _m0.Reader(a);
    let _ = e === void 0 ? f.len : f.pos + e;
    const w = createBaseEncodedContent();
    for (; f.pos < _; ) {
      const v = f.uint32();
      switch (v >>> 3) {
        case 1:
          w.type = ContentTypeId$1.decode(f, f.uint32());
          break;
        case 2:
          const S = EncodedContent_ParametersEntry.decode(f, f.uint32());
          S.value !== void 0 && (w.parameters[S.key] = S.value);
          break;
        case 3:
          w.fallback = f.string();
          break;
        case 5:
          w.compression = f.int32();
          break;
        case 4:
          w.content = f.bytes();
          break;
        default:
          f.skipType(v & 7);
          break;
      }
    }
    return w;
  },
  fromJSON(a) {
    return {
      type: isSet$1(a.type) ? ContentTypeId$1.fromJSON(a.type) : void 0,
      parameters: isObject(a.parameters)
        ? Object.entries(a.parameters).reduce(
            (e, [f, _]) => ((e[f] = String(_)), e),
            {},
          )
        : {},
      fallback: isSet$1(a.fallback) ? String(a.fallback) : void 0,
      compression: isSet$1(a.compression)
        ? compressionFromJSON(a.compression)
        : void 0,
      content: isSet$1(a.content)
        ? bytesFromBase64(a.content)
        : new Uint8Array(),
    };
  },
  toJSON(a) {
    const e = {};
    return (
      a.type !== void 0 &&
        (e.type = a.type ? ContentTypeId$1.toJSON(a.type) : void 0),
      (e.parameters = {}),
      a.parameters &&
        Object.entries(a.parameters).forEach(([f, _]) => {
          e.parameters[f] = _;
        }),
      a.fallback !== void 0 && (e.fallback = a.fallback),
      a.compression !== void 0 &&
        (e.compression =
          a.compression !== void 0 ? compressionToJSON(a.compression) : void 0),
      a.content !== void 0 &&
        (e.content = base64FromBytes(
          a.content !== void 0 ? a.content : new Uint8Array(),
        )),
      e
    );
  },
  fromPartial(a) {
    var e, f, _, w;
    const v = createBaseEncodedContent();
    return (
      (v.type =
        a.type !== void 0 && a.type !== null
          ? ContentTypeId$1.fromPartial(a.type)
          : void 0),
      (v.parameters = Object.entries(
        (e = a.parameters) !== null && e !== void 0 ? e : {},
      ).reduce((S, [R, O]) => (O !== void 0 && (S[R] = String(O)), S), {})),
      (v.fallback = (f = a.fallback) !== null && f !== void 0 ? f : void 0),
      (v.compression =
        (_ = a.compression) !== null && _ !== void 0 ? _ : void 0),
      (v.content =
        (w = a.content) !== null && w !== void 0 ? w : new Uint8Array()),
      v
    );
  },
};
function createBaseEncodedContent_ParametersEntry() {
  return { key: "", value: "" };
}
const EncodedContent_ParametersEntry = {
  encode(a, e = _m0.Writer.create()) {
    return (
      a.key !== "" && e.uint32(10).string(a.key),
      a.value !== "" && e.uint32(18).string(a.value),
      e
    );
  },
  decode(a, e) {
    const f = a instanceof _m0.Reader ? a : new _m0.Reader(a);
    let _ = e === void 0 ? f.len : f.pos + e;
    const w = createBaseEncodedContent_ParametersEntry();
    for (; f.pos < _; ) {
      const v = f.uint32();
      switch (v >>> 3) {
        case 1:
          w.key = f.string();
          break;
        case 2:
          w.value = f.string();
          break;
        default:
          f.skipType(v & 7);
          break;
      }
    }
    return w;
  },
  fromJSON(a) {
    return {
      key: isSet$1(a.key) ? String(a.key) : "",
      value: isSet$1(a.value) ? String(a.value) : "",
    };
  },
  toJSON(a) {
    const e = {};
    return (
      a.key !== void 0 && (e.key = a.key),
      a.value !== void 0 && (e.value = a.value),
      e
    );
  },
  fromPartial(a) {
    var e, f;
    const _ = createBaseEncodedContent_ParametersEntry();
    return (
      (_.key = (e = a.key) !== null && e !== void 0 ? e : ""),
      (_.value = (f = a.value) !== null && f !== void 0 ? f : ""),
      _
    );
  },
};
var globalThis$f = (() => {
  if (typeof globalThis$f < "u") return globalThis$f;
  if (typeof self < "u") return self;
  if (typeof window < "u") return window;
  if (typeof global < "u") return global;
  throw "Unable to locate global object";
})();
function bytesFromBase64(a) {
  if (globalThis$f.Buffer)
    return Uint8Array.from(globalThis$f.Buffer.from(a, "base64"));
  {
    const e = globalThis$f.atob(a),
      f = new Uint8Array(e.length);
    for (let _ = 0; _ < e.length; ++_) f[_] = e.charCodeAt(_);
    return f;
  }
}
function base64FromBytes(a) {
  if (globalThis$f.Buffer)
    return globalThis$f.Buffer.from(a).toString("base64");
  {
    const e = [];
    return (
      a.forEach((f) => {
        e.push(String.fromCharCode(f));
      }),
      globalThis$f.btoa(e.join(""))
    );
  }
}
_m0.util.Long !== Long && ((_m0.util.Long = Long), _m0.configure());
function isObject(a) {
  return typeof a == "object" && a !== null;
}
function isSet$1(a) {
  return a != null;
}
var globalThis$e = (() => {
  if (typeof globalThis$e < "u") return globalThis$e;
  if (typeof self < "u") return self;
  if (typeof window < "u") return window;
  if (typeof global < "u") return global;
  throw "Unable to locate global object";
})();
_m0.util.Long !== Long && ((_m0.util.Long = Long), _m0.configure());
_m0.util.Long !== Long && ((_m0.util.Long = Long), _m0.configure());
var globalThis$d = (() => {
  if (typeof globalThis$d < "u") return globalThis$d;
  if (typeof self < "u") return self;
  if (typeof window < "u") return window;
  if (typeof global < "u") return global;
  throw "Unable to locate global object";
})();
_m0.util.Long !== Long && ((_m0.util.Long = Long), _m0.configure());
_m0.util.Long !== Long && ((_m0.util.Long = Long), _m0.configure());
_m0.util.Long !== Long && ((_m0.util.Long = Long), _m0.configure());
var ErrorCode;
(function (a) {
  ((a[(a.ERROR_CODE_UNSPECIFIED = 0)] = "ERROR_CODE_UNSPECIFIED"),
    (a[(a.ERROR_CODE_INVALID_INPUT = 1)] = "ERROR_CODE_INVALID_INPUT"),
    (a[(a.ERROR_CODE_NO_MATCHING_PREKEY = 2)] =
      "ERROR_CODE_NO_MATCHING_PREKEY"),
    (a[(a.UNRECOGNIZED = -1)] = "UNRECOGNIZED"));
})(ErrorCode || (ErrorCode = {}));
var JobType;
(function (a) {
  ((a[(a.JOB_TYPE_UNSPECIFIED = 0)] = "JOB_TYPE_UNSPECIFIED"),
    (a[(a.JOB_TYPE_REFRESH_V1 = 1)] = "JOB_TYPE_REFRESH_V1"),
    (a[(a.JOB_TYPE_REFRESH_V2 = 2)] = "JOB_TYPE_REFRESH_V2"),
    (a[(a.JOB_TYPE_REFRESH_PPPP = 3)] = "JOB_TYPE_REFRESH_PPPP"),
    (a[(a.UNRECOGNIZED = -1)] = "UNRECOGNIZED"));
})(JobType || (JobType = {}));
var GetKeystoreStatusResponse_KeystoreStatus;
(function (a) {
  ((a[(a.KEYSTORE_STATUS_UNSPECIFIED = 0)] = "KEYSTORE_STATUS_UNSPECIFIED"),
    (a[(a.KEYSTORE_STATUS_UNINITIALIZED = 1)] =
      "KEYSTORE_STATUS_UNINITIALIZED"),
    (a[(a.KEYSTORE_STATUS_INITIALIZED = 2)] = "KEYSTORE_STATUS_INITIALIZED"),
    (a[(a.UNRECOGNIZED = -1)] = "UNRECOGNIZED"));
})(
  GetKeystoreStatusResponse_KeystoreStatus ||
    (GetKeystoreStatusResponse_KeystoreStatus = {}),
);
var globalThis$c = (() => {
  if (typeof globalThis$c < "u") return globalThis$c;
  if (typeof self < "u") return self;
  if (typeof window < "u") return window;
  if (typeof global < "u") return global;
  throw "Unable to locate global object";
})();
_m0.util.Long !== Long && ((_m0.util.Long = Long), _m0.configure());
var globalThis$b = (() => {
  if (typeof globalThis$b < "u") return globalThis$b;
  if (typeof self < "u") return self;
  if (typeof window < "u") return window;
  if (typeof global < "u") return global;
  throw "Unable to locate global object";
})();
_m0.util.Long !== Long && ((_m0.util.Long = Long), _m0.configure());
var globalThis$a = (() => {
  if (typeof globalThis$a < "u") return globalThis$a;
  if (typeof self < "u") return self;
  if (typeof window < "u") return window;
  if (typeof global < "u") return global;
  throw "Unable to locate global object";
})();
_m0.util.Long !== Long && ((_m0.util.Long = Long), _m0.configure());
_m0.util.Long !== Long && ((_m0.util.Long = Long), _m0.configure());
var SortDirection;
(function (a) {
  ((a[(a.SORT_DIRECTION_UNSPECIFIED = 0)] = "SORT_DIRECTION_UNSPECIFIED"),
    (a[(a.SORT_DIRECTION_ASCENDING = 1)] = "SORT_DIRECTION_ASCENDING"),
    (a[(a.SORT_DIRECTION_DESCENDING = 2)] = "SORT_DIRECTION_DESCENDING"),
    (a[(a.UNRECOGNIZED = -1)] = "UNRECOGNIZED"));
})(SortDirection || (SortDirection = {}));
var globalThis$9 = (() => {
  if (typeof globalThis$9 < "u") return globalThis$9;
  if (typeof self < "u") return self;
  if (typeof window < "u") return window;
  if (typeof global < "u") return global;
  throw "Unable to locate global object";
})();
_m0.util.Long !== Long && ((_m0.util.Long = Long), _m0.configure());
var AdminListUpdateType;
(function (a) {
  ((a[(a.ADMIN_LIST_UPDATE_TYPE_UNSPECIFIED = 0)] =
    "ADMIN_LIST_UPDATE_TYPE_UNSPECIFIED"),
    (a[(a.ADMIN_LIST_UPDATE_TYPE_ADD_ADMIN = 1)] =
      "ADMIN_LIST_UPDATE_TYPE_ADD_ADMIN"),
    (a[(a.ADMIN_LIST_UPDATE_TYPE_REMOVE_ADMIN = 2)] =
      "ADMIN_LIST_UPDATE_TYPE_REMOVE_ADMIN"),
    (a[(a.ADMIN_LIST_UPDATE_TYPE_ADD_SUPER_ADMIN = 3)] =
      "ADMIN_LIST_UPDATE_TYPE_ADD_SUPER_ADMIN"),
    (a[(a.ADMIN_LIST_UPDATE_TYPE_REMOVE_SUPER_ADMIN = 4)] =
      "ADMIN_LIST_UPDATE_TYPE_REMOVE_SUPER_ADMIN"),
    (a[(a.UNRECOGNIZED = -1)] = "UNRECOGNIZED"));
})(AdminListUpdateType || (AdminListUpdateType = {}));
var PermissionUpdateType;
(function (a) {
  ((a[(a.PERMISSION_UPDATE_TYPE_UNSPECIFIED = 0)] =
    "PERMISSION_UPDATE_TYPE_UNSPECIFIED"),
    (a[(a.PERMISSION_UPDATE_TYPE_ADD_MEMBER = 1)] =
      "PERMISSION_UPDATE_TYPE_ADD_MEMBER"),
    (a[(a.PERMISSION_UPDATE_TYPE_REMOVE_MEMBER = 2)] =
      "PERMISSION_UPDATE_TYPE_REMOVE_MEMBER"),
    (a[(a.PERMISSION_UPDATE_TYPE_ADD_ADMIN = 3)] =
      "PERMISSION_UPDATE_TYPE_ADD_ADMIN"),
    (a[(a.PERMISSION_UPDATE_TYPE_REMOVE_ADMIN = 4)] =
      "PERMISSION_UPDATE_TYPE_REMOVE_ADMIN"),
    (a[(a.PERMISSION_UPDATE_TYPE_UPDATE_METADATA = 5)] =
      "PERMISSION_UPDATE_TYPE_UPDATE_METADATA"),
    (a[(a.UNRECOGNIZED = -1)] = "UNRECOGNIZED"));
})(PermissionUpdateType || (PermissionUpdateType = {}));
var PermissionPolicyOption;
(function (a) {
  ((a[(a.PERMISSION_POLICY_OPTION_UNSPECIFIED = 0)] =
    "PERMISSION_POLICY_OPTION_UNSPECIFIED"),
    (a[(a.PERMISSION_POLICY_OPTION_ALLOW = 1)] =
      "PERMISSION_POLICY_OPTION_ALLOW"),
    (a[(a.PERMISSION_POLICY_OPTION_DENY = 2)] =
      "PERMISSION_POLICY_OPTION_DENY"),
    (a[(a.PERMISSION_POLICY_OPTION_ADMIN_ONLY = 3)] =
      "PERMISSION_POLICY_OPTION_ADMIN_ONLY"),
    (a[(a.PERMISSION_POLICY_OPTION_SUPER_ADMIN_ONLY = 4)] =
      "PERMISSION_POLICY_OPTION_SUPER_ADMIN_ONLY"),
    (a[(a.UNRECOGNIZED = -1)] = "UNRECOGNIZED"));
})(PermissionPolicyOption || (PermissionPolicyOption = {}));
var globalThis$8 = (() => {
  if (typeof globalThis$8 < "u") return globalThis$8;
  if (typeof self < "u") return self;
  if (typeof window < "u") return window;
  if (typeof global < "u") return global;
  throw "Unable to locate global object";
})();
_m0.util.Long !== Long && ((_m0.util.Long = Long), _m0.configure());
var Compression;
(function (a) {
  ((a[(a.COMPRESSION_DEFLATE = 0)] = "COMPRESSION_DEFLATE"),
    (a[(a.COMPRESSION_GZIP = 1)] = "COMPRESSION_GZIP"),
    (a[(a.UNRECOGNIZED = -1)] = "UNRECOGNIZED"));
})(Compression || (Compression = {}));
var DeviceSyncKind;
(function (a) {
  ((a[(a.DEVICE_SYNC_KIND_UNSPECIFIED = 0)] = "DEVICE_SYNC_KIND_UNSPECIFIED"),
    (a[(a.DEVICE_SYNC_KIND_MESSAGE_HISTORY = 1)] =
      "DEVICE_SYNC_KIND_MESSAGE_HISTORY"),
    (a[(a.DEVICE_SYNC_KIND_CONSENT = 2)] = "DEVICE_SYNC_KIND_CONSENT"),
    (a[(a.UNRECOGNIZED = -1)] = "UNRECOGNIZED"));
})(DeviceSyncKind || (DeviceSyncKind = {}));
var globalThis$7 = (() => {
  if (typeof globalThis$7 < "u") return globalThis$7;
  if (typeof self < "u") return self;
  if (typeof window < "u") return window;
  if (typeof global < "u") return global;
  throw "Unable to locate global object";
})();
_m0.util.Long !== Long && ((_m0.util.Long = Long), _m0.configure());
var globalThis$6 = (() => {
  if (typeof globalThis$6 < "u") return globalThis$6;
  if (typeof self < "u") return self;
  if (typeof window < "u") return window;
  if (typeof global < "u") return global;
  throw "Unable to locate global object";
})();
_m0.util.Long !== Long && ((_m0.util.Long = Long), _m0.configure());
var ConversationType$1;
(function (a) {
  ((a[(a.CONVERSATION_TYPE_UNSPECIFIED = 0)] = "CONVERSATION_TYPE_UNSPECIFIED"),
    (a[(a.CONVERSATION_TYPE_GROUP = 1)] = "CONVERSATION_TYPE_GROUP"),
    (a[(a.CONVERSATION_TYPE_DM = 2)] = "CONVERSATION_TYPE_DM"),
    (a[(a.CONVERSATION_TYPE_SYNC = 3)] = "CONVERSATION_TYPE_SYNC"),
    (a[(a.UNRECOGNIZED = -1)] = "UNRECOGNIZED"));
})(ConversationType$1 || (ConversationType$1 = {}));
_m0.util.Long !== Long && ((_m0.util.Long = Long), _m0.configure());
_m0.util.Long !== Long && ((_m0.util.Long = Long), _m0.configure());
function createBaseGroupUpdated() {
  return {
    initiatedByInboxId: "",
    addedInboxes: [],
    removedInboxes: [],
    metadataFieldChanges: [],
  };
}
const GroupUpdated$1 = {
  encode(a, e = _m0.Writer.create()) {
    a.initiatedByInboxId !== "" && e.uint32(10).string(a.initiatedByInboxId);
    for (const f of a.addedInboxes)
      GroupUpdated_Inbox.encode(f, e.uint32(18).fork()).ldelim();
    for (const f of a.removedInboxes)
      GroupUpdated_Inbox.encode(f, e.uint32(26).fork()).ldelim();
    for (const f of a.metadataFieldChanges)
      GroupUpdated_MetadataFieldChange.encode(f, e.uint32(34).fork()).ldelim();
    return e;
  },
  decode(a, e) {
    const f = a instanceof _m0.Reader ? a : new _m0.Reader(a);
    let _ = e === void 0 ? f.len : f.pos + e;
    const w = createBaseGroupUpdated();
    for (; f.pos < _; ) {
      const v = f.uint32();
      switch (v >>> 3) {
        case 1:
          w.initiatedByInboxId = f.string();
          break;
        case 2:
          w.addedInboxes.push(GroupUpdated_Inbox.decode(f, f.uint32()));
          break;
        case 3:
          w.removedInboxes.push(GroupUpdated_Inbox.decode(f, f.uint32()));
          break;
        case 4:
          w.metadataFieldChanges.push(
            GroupUpdated_MetadataFieldChange.decode(f, f.uint32()),
          );
          break;
        default:
          f.skipType(v & 7);
          break;
      }
    }
    return w;
  },
  fromJSON(a) {
    return {
      initiatedByInboxId: isSet(a.initiatedByInboxId)
        ? String(a.initiatedByInboxId)
        : "",
      addedInboxes: Array.isArray(a?.addedInboxes)
        ? a.addedInboxes.map((e) => GroupUpdated_Inbox.fromJSON(e))
        : [],
      removedInboxes: Array.isArray(a?.removedInboxes)
        ? a.removedInboxes.map((e) => GroupUpdated_Inbox.fromJSON(e))
        : [],
      metadataFieldChanges: Array.isArray(a?.metadataFieldChanges)
        ? a.metadataFieldChanges.map((e) =>
            GroupUpdated_MetadataFieldChange.fromJSON(e),
          )
        : [],
    };
  },
  toJSON(a) {
    const e = {};
    return (
      a.initiatedByInboxId !== void 0 &&
        (e.initiatedByInboxId = a.initiatedByInboxId),
      a.addedInboxes
        ? (e.addedInboxes = a.addedInboxes.map((f) =>
            f ? GroupUpdated_Inbox.toJSON(f) : void 0,
          ))
        : (e.addedInboxes = []),
      a.removedInboxes
        ? (e.removedInboxes = a.removedInboxes.map((f) =>
            f ? GroupUpdated_Inbox.toJSON(f) : void 0,
          ))
        : (e.removedInboxes = []),
      a.metadataFieldChanges
        ? (e.metadataFieldChanges = a.metadataFieldChanges.map((f) =>
            f ? GroupUpdated_MetadataFieldChange.toJSON(f) : void 0,
          ))
        : (e.metadataFieldChanges = []),
      e
    );
  },
  fromPartial(a) {
    var e, f, _, w;
    const v = createBaseGroupUpdated();
    return (
      (v.initiatedByInboxId =
        (e = a.initiatedByInboxId) !== null && e !== void 0 ? e : ""),
      (v.addedInboxes =
        ((f = a.addedInboxes) === null || f === void 0
          ? void 0
          : f.map((S) => GroupUpdated_Inbox.fromPartial(S))) || []),
      (v.removedInboxes =
        ((_ = a.removedInboxes) === null || _ === void 0
          ? void 0
          : _.map((S) => GroupUpdated_Inbox.fromPartial(S))) || []),
      (v.metadataFieldChanges =
        ((w = a.metadataFieldChanges) === null || w === void 0
          ? void 0
          : w.map((S) => GroupUpdated_MetadataFieldChange.fromPartial(S))) ||
        []),
      v
    );
  },
};
function createBaseGroupUpdated_Inbox() {
  return { inboxId: "" };
}
const GroupUpdated_Inbox = {
  encode(a, e = _m0.Writer.create()) {
    return (a.inboxId !== "" && e.uint32(10).string(a.inboxId), e);
  },
  decode(a, e) {
    const f = a instanceof _m0.Reader ? a : new _m0.Reader(a);
    let _ = e === void 0 ? f.len : f.pos + e;
    const w = createBaseGroupUpdated_Inbox();
    for (; f.pos < _; ) {
      const v = f.uint32();
      switch (v >>> 3) {
        case 1:
          w.inboxId = f.string();
          break;
        default:
          f.skipType(v & 7);
          break;
      }
    }
    return w;
  },
  fromJSON(a) {
    return { inboxId: isSet(a.inboxId) ? String(a.inboxId) : "" };
  },
  toJSON(a) {
    const e = {};
    return (a.inboxId !== void 0 && (e.inboxId = a.inboxId), e);
  },
  fromPartial(a) {
    var e;
    const f = createBaseGroupUpdated_Inbox();
    return ((f.inboxId = (e = a.inboxId) !== null && e !== void 0 ? e : ""), f);
  },
};
function createBaseGroupUpdated_MetadataFieldChange() {
  return { fieldName: "", oldValue: void 0, newValue: void 0 };
}
const GroupUpdated_MetadataFieldChange = {
  encode(a, e = _m0.Writer.create()) {
    return (
      a.fieldName !== "" && e.uint32(10).string(a.fieldName),
      a.oldValue !== void 0 && e.uint32(18).string(a.oldValue),
      a.newValue !== void 0 && e.uint32(26).string(a.newValue),
      e
    );
  },
  decode(a, e) {
    const f = a instanceof _m0.Reader ? a : new _m0.Reader(a);
    let _ = e === void 0 ? f.len : f.pos + e;
    const w = createBaseGroupUpdated_MetadataFieldChange();
    for (; f.pos < _; ) {
      const v = f.uint32();
      switch (v >>> 3) {
        case 1:
          w.fieldName = f.string();
          break;
        case 2:
          w.oldValue = f.string();
          break;
        case 3:
          w.newValue = f.string();
          break;
        default:
          f.skipType(v & 7);
          break;
      }
    }
    return w;
  },
  fromJSON(a) {
    return {
      fieldName: isSet(a.fieldName) ? String(a.fieldName) : "",
      oldValue: isSet(a.oldValue) ? String(a.oldValue) : void 0,
      newValue: isSet(a.newValue) ? String(a.newValue) : void 0,
    };
  },
  toJSON(a) {
    const e = {};
    return (
      a.fieldName !== void 0 && (e.fieldName = a.fieldName),
      a.oldValue !== void 0 && (e.oldValue = a.oldValue),
      a.newValue !== void 0 && (e.newValue = a.newValue),
      e
    );
  },
  fromPartial(a) {
    var e, f, _;
    const w = createBaseGroupUpdated_MetadataFieldChange();
    return (
      (w.fieldName = (e = a.fieldName) !== null && e !== void 0 ? e : ""),
      (w.oldValue = (f = a.oldValue) !== null && f !== void 0 ? f : void 0),
      (w.newValue = (_ = a.newValue) !== null && _ !== void 0 ? _ : void 0),
      w
    );
  },
};
var globalThis$5 = (() => {
  if (typeof globalThis$5 < "u") return globalThis$5;
  if (typeof self < "u") return self;
  if (typeof window < "u") return window;
  if (typeof global < "u") return global;
  throw "Unable to locate global object";
})();
_m0.util.Long !== Long && ((_m0.util.Long = Long), _m0.configure());
function isSet(a) {
  return a != null;
}
_m0.util.Long !== Long && ((_m0.util.Long = Long), _m0.configure());
var globalThis$4 = (() => {
  if (typeof globalThis$4 < "u") return globalThis$4;
  if (typeof self < "u") return self;
  if (typeof window < "u") return window;
  if (typeof global < "u") return global;
  throw "Unable to locate global object";
})();
_m0.util.Long !== Long && ((_m0.util.Long = Long), _m0.configure());
var globalThis$3 = (() => {
  if (typeof globalThis$3 < "u") return globalThis$3;
  if (typeof self < "u") return self;
  if (typeof window < "u") return window;
  if (typeof global < "u") return global;
  throw "Unable to locate global object";
})();
_m0.util.Long !== Long && ((_m0.util.Long = Long), _m0.configure());
var globalThis$2 = (() => {
  if (typeof globalThis$2 < "u") return globalThis$2;
  if (typeof self < "u") return self;
  if (typeof window < "u") return window;
  if (typeof global < "u") return global;
  throw "Unable to locate global object";
})();
_m0.util.Long !== Long && ((_m0.util.Long = Long), _m0.configure());
var globalThis$1 = (() => {
  if (typeof globalThis$1 < "u") return globalThis$1;
  if (typeof self < "u") return self;
  if (typeof window < "u") return window;
  if (typeof global < "u") return global;
  throw "Unable to locate global object";
})();
_m0.util.Long !== Long && ((_m0.util.Long = Long), _m0.configure());
const o = new t$7({
  authorityId: "xmtp.org",
  typeId: "group_updated",
  versionMajor: 1,
  versionMinor: 0,
});
let r$5 = class {
  get contentType() {
    return o;
  }
  encode(e) {
    return {
      type: this.contentType,
      parameters: {},
      content: GroupUpdated$1.encode(e).finish(),
    };
  }
  decode(e) {
    return GroupUpdated$1.decode(e.content);
  }
  fallback() {}
  shouldPush() {
    return !1;
  }
};
const n$3 = new t$7({
  authorityId: "xmtp.org",
  typeId: "text",
  versionMajor: 1,
  versionMinor: 0,
});
var t$6;
(function (a) {
  ((a.utf8 = "UTF-8"), (a.unknown = "unknown"));
})(t$6 || (t$6 = {}));
let r$4 = class {
    get contentType() {
      return n$3;
    }
    encode(e) {
      return {
        type: n$3,
        parameters: { encoding: t$6.utf8 },
        content: new TextEncoder().encode(e),
      };
    }
    decode(e) {
      if (e.parameters.encoding !== t$6.utf8)
        throw new Error(`unrecognized encoding ${e.parameters.encoding}`);
      return new TextDecoder().decode(e.content);
    }
    fallback() {}
    shouldPush() {
      return !0;
    }
  },
  wasm,
  cachedUint8ArrayMemory0 = null;
function getUint8ArrayMemory0() {
  return (
    (cachedUint8ArrayMemory0 === null ||
      cachedUint8ArrayMemory0.byteLength === 0) &&
      (cachedUint8ArrayMemory0 = new Uint8Array(wasm.memory.buffer)),
    cachedUint8ArrayMemory0
  );
}
let cachedTextDecoder = new TextDecoder("utf-8", { ignoreBOM: !0, fatal: !0 });
cachedTextDecoder.decode();
const MAX_SAFARI_DECODE_BYTES = 2146435072;
let numBytesDecoded = 0;
function decodeText(a, e) {
  return (
    (numBytesDecoded += e),
    numBytesDecoded >= MAX_SAFARI_DECODE_BYTES &&
      ((cachedTextDecoder = new TextDecoder("utf-8", {
        ignoreBOM: !0,
        fatal: !0,
      })),
      cachedTextDecoder.decode(),
      (numBytesDecoded = e)),
    cachedTextDecoder.decode(getUint8ArrayMemory0().subarray(a, a + e))
  );
}
function getStringFromWasm0(a, e) {
  return ((a = a >>> 0), decodeText(a, e));
}
let WASM_VECTOR_LEN = 0;
const cachedTextEncoder = new TextEncoder();
"encodeInto" in cachedTextEncoder ||
  (cachedTextEncoder.encodeInto = function (a, e) {
    const f = cachedTextEncoder.encode(a);
    return (e.set(f), { read: a.length, written: f.length });
  });
function passStringToWasm0(a, e, f) {
  if (f === void 0) {
    const R = cachedTextEncoder.encode(a),
      O = e(R.length, 1) >>> 0;
    return (
      getUint8ArrayMemory0()
        .subarray(O, O + R.length)
        .set(R),
      (WASM_VECTOR_LEN = R.length),
      O
    );
  }
  let _ = a.length,
    w = e(_, 1) >>> 0;
  const v = getUint8ArrayMemory0();
  let S = 0;
  for (; S < _; S++) {
    const R = a.charCodeAt(S);
    if (R > 127) break;
    v[w + S] = R;
  }
  if (S !== _) {
    (S !== 0 && (a = a.slice(S)),
      (w = f(w, _, (_ = S + a.length * 3), 1) >>> 0));
    const R = getUint8ArrayMemory0().subarray(w + S, w + _),
      O = cachedTextEncoder.encodeInto(a, R);
    ((S += O.written), (w = f(w, _, S, 1) >>> 0));
  }
  return ((WASM_VECTOR_LEN = S), w);
}
let cachedDataViewMemory0 = null;
function getDataViewMemory0() {
  return (
    (cachedDataViewMemory0 === null ||
      cachedDataViewMemory0.buffer.detached === !0 ||
      (cachedDataViewMemory0.buffer.detached === void 0 &&
        cachedDataViewMemory0.buffer !== wasm.memory.buffer)) &&
      (cachedDataViewMemory0 = new DataView(wasm.memory.buffer)),
    cachedDataViewMemory0
  );
}
function isLikeNone(a) {
  return a == null;
}
function addToExternrefTable0(a) {
  const e = wasm.__externref_table_alloc();
  return (wasm.__wbindgen_externrefs.set(e, a), e);
}
function getArrayU8FromWasm0(a, e) {
  return ((a = a >>> 0), getUint8ArrayMemory0().subarray(a / 1, a / 1 + e));
}
function getArrayJsValueFromWasm0(a, e) {
  a = a >>> 0;
  const f = getDataViewMemory0(),
    _ = [];
  for (let w = a; w < a + 4 * e; w += 4)
    _.push(wasm.__wbindgen_externrefs.get(f.getUint32(w, !0)));
  return (wasm.__externref_drop_slice(a, e), _);
}
typeof FinalizationRegistry > "u" ||
  new FinalizationRegistry((a) => a.dtor(a.a, a.b));
function takeFromExternrefTable0(a) {
  const e = wasm.__wbindgen_externrefs.get(a);
  return (wasm.__externref_table_dealloc(a), e);
}
function passArrayJsValueToWasm0(a, e) {
  const f = e(a.length * 4, 4) >>> 0;
  for (let _ = 0; _ < a.length; _++) {
    const w = addToExternrefTable0(a[_]);
    getDataViewMemory0().setUint32(f + 4 * _, w, !0);
  }
  return ((WASM_VECTOR_LEN = a.length), f);
}
function _assertClass(a, e) {
  if (!(a instanceof e)) throw new Error(`expected instance of ${e.name}`);
}
function passArray8ToWasm0(a, e) {
  const f = e(a.length * 1, 1) >>> 0;
  return (
    getUint8ArrayMemory0().set(a, f / 1),
    (WASM_VECTOR_LEN = a.length),
    f
  );
}
const ConversationType = Object.freeze({
    Dm: 0,
    0: "Dm",
    Group: 1,
    1: "Group",
    Sync: 2,
    2: "Sync",
    Oneshot: 3,
    3: "Oneshot",
  }),
  DeliveryStatus = Object.freeze({
    Unpublished: 0,
    0: "Unpublished",
    Published: 1,
    1: "Published",
    Failed: 2,
    2: "Failed",
  }),
  GroupMessageKind = Object.freeze({
    Application: 0,
    0: "Application",
    MembershipChange: 1,
    1: "MembershipChange",
  }),
  __wbindgen_enum_LogLevel = ["off", "error", "warn", "info", "debug", "trace"],
  ActionFinalization =
    typeof FinalizationRegistry > "u"
      ? { register: () => {}, unregister: () => {} }
      : new FinalizationRegistry((a) => wasm.__wbg_action_free(a >>> 0, 1));
class Action {
  static __wrap(e) {
    e = e >>> 0;
    const f = Object.create(Action.prototype);
    return (
      (f.__wbg_ptr = e),
      ActionFinalization.register(f, f.__wbg_ptr, f),
      f
    );
  }
  static __unwrap(e) {
    return e instanceof Action ? e.__destroy_into_raw() : 0;
  }
  __destroy_into_raw() {
    const e = this.__wbg_ptr;
    return ((this.__wbg_ptr = 0), ActionFinalization.unregister(this), e);
  }
  free() {
    const e = this.__destroy_into_raw();
    wasm.__wbg_action_free(e, 0);
  }
  get id() {
    let e, f;
    try {
      const _ = wasm.__wbg_get_action_id(this.__wbg_ptr);
      return ((e = _[0]), (f = _[1]), getStringFromWasm0(_[0], _[1]));
    } finally {
      wasm.__wbindgen_free(e, f, 1);
    }
  }
  set id(e) {
    const f = passStringToWasm0(
        e,
        wasm.__wbindgen_malloc,
        wasm.__wbindgen_realloc,
      ),
      _ = WASM_VECTOR_LEN;
    wasm.__wbg_set_action_id(this.__wbg_ptr, f, _);
  }
  get label() {
    let e, f;
    try {
      const _ = wasm.__wbg_get_action_label(this.__wbg_ptr);
      return ((e = _[0]), (f = _[1]), getStringFromWasm0(_[0], _[1]));
    } finally {
      wasm.__wbindgen_free(e, f, 1);
    }
  }
  set label(e) {
    const f = passStringToWasm0(
        e,
        wasm.__wbindgen_malloc,
        wasm.__wbindgen_realloc,
      ),
      _ = WASM_VECTOR_LEN;
    wasm.__wbg_set_action_label(this.__wbg_ptr, f, _);
  }
  get imageUrl() {
    const e = wasm.__wbg_get_action_imageUrl(this.__wbg_ptr);
    let f;
    return (
      e[0] !== 0 &&
        ((f = getStringFromWasm0(e[0], e[1]).slice()),
        wasm.__wbindgen_free(e[0], e[1] * 1, 1)),
      f
    );
  }
  set imageUrl(e) {
    var f = isLikeNone(e)
        ? 0
        : passStringToWasm0(e, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc),
      _ = WASM_VECTOR_LEN;
    wasm.__wbg_set_action_imageUrl(this.__wbg_ptr, f, _);
  }
  get style() {
    const e = wasm.__wbg_get_action_style(this.__wbg_ptr);
    return e === 3 ? void 0 : e;
  }
  set style(e) {
    wasm.__wbg_set_action_style(this.__wbg_ptr, isLikeNone(e) ? 3 : e);
  }
  get expiresAtNs() {
    const e = wasm.__wbg_get_action_expiresAtNs(this.__wbg_ptr);
    return e[0] === 0 ? void 0 : e[1];
  }
  set expiresAtNs(e) {
    wasm.__wbg_set_action_expiresAtNs(
      this.__wbg_ptr,
      !isLikeNone(e),
      isLikeNone(e) ? BigInt(0) : e,
    );
  }
  constructor(e, f, _, w, v) {
    const S = passStringToWasm0(
        e,
        wasm.__wbindgen_malloc,
        wasm.__wbindgen_realloc,
      ),
      R = WASM_VECTOR_LEN,
      O = passStringToWasm0(f, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc),
      j = WASM_VECTOR_LEN;
    var F = isLikeNone(_)
        ? 0
        : passStringToWasm0(_, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc),
      q = WASM_VECTOR_LEN;
    const Q = wasm.action_new(
      S,
      R,
      O,
      j,
      F,
      q,
      isLikeNone(w) ? 3 : w,
      !isLikeNone(v),
      isLikeNone(v) ? BigInt(0) : v,
    );
    return (
      (this.__wbg_ptr = Q >>> 0),
      ActionFinalization.register(this, this.__wbg_ptr, this),
      this
    );
  }
}
Symbol.dispose && (Action.prototype[Symbol.dispose] = Action.prototype.free);
const ActionsFinalization =
  typeof FinalizationRegistry > "u"
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry((a) => wasm.__wbg_actions_free(a >>> 0, 1));
class Actions {
  static __wrap(e) {
    e = e >>> 0;
    const f = Object.create(Actions.prototype);
    return (
      (f.__wbg_ptr = e),
      ActionsFinalization.register(f, f.__wbg_ptr, f),
      f
    );
  }
  __destroy_into_raw() {
    const e = this.__wbg_ptr;
    return ((this.__wbg_ptr = 0), ActionsFinalization.unregister(this), e);
  }
  free() {
    const e = this.__destroy_into_raw();
    wasm.__wbg_actions_free(e, 0);
  }
  get id() {
    let e, f;
    try {
      const _ = wasm.__wbg_get_actions_id(this.__wbg_ptr);
      return ((e = _[0]), (f = _[1]), getStringFromWasm0(_[0], _[1]));
    } finally {
      wasm.__wbindgen_free(e, f, 1);
    }
  }
  set id(e) {
    const f = passStringToWasm0(
        e,
        wasm.__wbindgen_malloc,
        wasm.__wbindgen_realloc,
      ),
      _ = WASM_VECTOR_LEN;
    wasm.__wbg_set_action_id(this.__wbg_ptr, f, _);
  }
  get description() {
    let e, f;
    try {
      const _ = wasm.__wbg_get_actions_description(this.__wbg_ptr);
      return ((e = _[0]), (f = _[1]), getStringFromWasm0(_[0], _[1]));
    } finally {
      wasm.__wbindgen_free(e, f, 1);
    }
  }
  set description(e) {
    const f = passStringToWasm0(
        e,
        wasm.__wbindgen_malloc,
        wasm.__wbindgen_realloc,
      ),
      _ = WASM_VECTOR_LEN;
    wasm.__wbg_set_action_label(this.__wbg_ptr, f, _);
  }
  get expiresAtNs() {
    const e = wasm.__wbg_get_actions_expiresAtNs(this.__wbg_ptr);
    return e[0] === 0 ? void 0 : e[1];
  }
  set expiresAtNs(e) {
    wasm.__wbg_set_action_expiresAtNs(
      this.__wbg_ptr,
      !isLikeNone(e),
      isLikeNone(e) ? BigInt(0) : e,
    );
  }
  addAction(e) {
    _assertClass(e, Action);
    var f = e.__destroy_into_raw();
    wasm.actions_addAction(this.__wbg_ptr, f);
  }
  getActions() {
    const e = wasm.actions_getActions(this.__wbg_ptr);
    var f = getArrayJsValueFromWasm0(e[0], e[1]).slice();
    return (wasm.__wbindgen_free(e[0], e[1] * 4, 4), f);
  }
  setActions(e) {
    const f = passArrayJsValueToWasm0(e, wasm.__wbindgen_malloc),
      _ = WASM_VECTOR_LEN;
    wasm.actions_setActions(this.__wbg_ptr, f, _);
  }
  constructor(e, f, _) {
    const w = passStringToWasm0(
        e,
        wasm.__wbindgen_malloc,
        wasm.__wbindgen_realloc,
      ),
      v = WASM_VECTOR_LEN,
      S = passStringToWasm0(f, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc),
      R = WASM_VECTOR_LEN,
      O = wasm.actions_new(
        w,
        v,
        S,
        R,
        !isLikeNone(_),
        isLikeNone(_) ? BigInt(0) : _,
      );
    return (
      (this.__wbg_ptr = O >>> 0),
      ActionsFinalization.register(this, this.__wbg_ptr, this),
      this
    );
  }
}
Symbol.dispose && (Actions.prototype[Symbol.dispose] = Actions.prototype.free);
const ApiStatsFinalization =
  typeof FinalizationRegistry > "u"
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry((a) => wasm.__wbg_apistats_free(a >>> 0, 1));
class ApiStats {
  static __wrap(e) {
    e = e >>> 0;
    const f = Object.create(ApiStats.prototype);
    return (
      (f.__wbg_ptr = e),
      ApiStatsFinalization.register(f, f.__wbg_ptr, f),
      f
    );
  }
  __destroy_into_raw() {
    const e = this.__wbg_ptr;
    return ((this.__wbg_ptr = 0), ApiStatsFinalization.unregister(this), e);
  }
  free() {
    const e = this.__destroy_into_raw();
    wasm.__wbg_apistats_free(e, 0);
  }
  get upload_key_package() {
    const e = wasm.__wbg_get_apistats_upload_key_package(this.__wbg_ptr);
    return BigInt.asUintN(64, e);
  }
  set upload_key_package(e) {
    wasm.__wbg_set_apistats_upload_key_package(this.__wbg_ptr, e);
  }
  get fetch_key_package() {
    const e = wasm.__wbg_get_apistats_fetch_key_package(this.__wbg_ptr);
    return BigInt.asUintN(64, e);
  }
  set fetch_key_package(e) {
    wasm.__wbg_set_apistats_fetch_key_package(this.__wbg_ptr, e);
  }
  get send_group_messages() {
    const e = wasm.__wbg_get_apistats_send_group_messages(this.__wbg_ptr);
    return BigInt.asUintN(64, e);
  }
  set send_group_messages(e) {
    wasm.__wbg_set_apistats_send_group_messages(this.__wbg_ptr, e);
  }
  get send_welcome_messages() {
    const e = wasm.__wbg_get_apistats_send_welcome_messages(this.__wbg_ptr);
    return BigInt.asUintN(64, e);
  }
  set send_welcome_messages(e) {
    wasm.__wbg_set_apistats_send_welcome_messages(this.__wbg_ptr, e);
  }
  get query_group_messages() {
    const e = wasm.__wbg_get_apistats_query_group_messages(this.__wbg_ptr);
    return BigInt.asUintN(64, e);
  }
  set query_group_messages(e) {
    wasm.__wbg_set_apistats_query_group_messages(this.__wbg_ptr, e);
  }
  get query_welcome_messages() {
    const e = wasm.__wbg_get_apistats_query_welcome_messages(this.__wbg_ptr);
    return BigInt.asUintN(64, e);
  }
  set query_welcome_messages(e) {
    wasm.__wbg_set_apistats_query_welcome_messages(this.__wbg_ptr, e);
  }
  get subscribe_messages() {
    const e = wasm.__wbg_get_apistats_subscribe_messages(this.__wbg_ptr);
    return BigInt.asUintN(64, e);
  }
  set subscribe_messages(e) {
    wasm.__wbg_set_apistats_subscribe_messages(this.__wbg_ptr, e);
  }
  get subscribe_welcomes() {
    const e = wasm.__wbg_get_apistats_subscribe_welcomes(this.__wbg_ptr);
    return BigInt.asUintN(64, e);
  }
  set subscribe_welcomes(e) {
    wasm.__wbg_set_apistats_subscribe_welcomes(this.__wbg_ptr, e);
  }
}
Symbol.dispose &&
  (ApiStats.prototype[Symbol.dispose] = ApiStats.prototype.free);
const AttachmentFinalization =
  typeof FinalizationRegistry > "u"
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry((a) => wasm.__wbg_attachment_free(a >>> 0, 1));
class Attachment {
  static __wrap(e) {
    e = e >>> 0;
    const f = Object.create(Attachment.prototype);
    return (
      (f.__wbg_ptr = e),
      AttachmentFinalization.register(f, f.__wbg_ptr, f),
      f
    );
  }
  __destroy_into_raw() {
    const e = this.__wbg_ptr;
    return ((this.__wbg_ptr = 0), AttachmentFinalization.unregister(this), e);
  }
  free() {
    const e = this.__destroy_into_raw();
    wasm.__wbg_attachment_free(e, 0);
  }
  get filename() {
    const e = wasm.__wbg_get_attachment_filename(this.__wbg_ptr);
    let f;
    return (
      e[0] !== 0 &&
        ((f = getStringFromWasm0(e[0], e[1]).slice()),
        wasm.__wbindgen_free(e[0], e[1] * 1, 1)),
      f
    );
  }
  set filename(e) {
    var f = isLikeNone(e)
        ? 0
        : passStringToWasm0(e, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc),
      _ = WASM_VECTOR_LEN;
    wasm.__wbg_set_attachment_filename(this.__wbg_ptr, f, _);
  }
  get mimeType() {
    let e, f;
    try {
      const _ = wasm.__wbg_get_attachment_mimeType(this.__wbg_ptr);
      return ((e = _[0]), (f = _[1]), getStringFromWasm0(_[0], _[1]));
    } finally {
      wasm.__wbindgen_free(e, f, 1);
    }
  }
  set mimeType(e) {
    const f = passStringToWasm0(
        e,
        wasm.__wbindgen_malloc,
        wasm.__wbindgen_realloc,
      ),
      _ = WASM_VECTOR_LEN;
    wasm.__wbg_set_attachment_mimeType(this.__wbg_ptr, f, _);
  }
  get content() {
    const e = wasm.__wbg_get_attachment_content(this.__wbg_ptr);
    var f = getArrayU8FromWasm0(e[0], e[1]).slice();
    return (wasm.__wbindgen_free(e[0], e[1] * 1, 1), f);
  }
  set content(e) {
    const f = passArray8ToWasm0(e, wasm.__wbindgen_malloc),
      _ = WASM_VECTOR_LEN;
    wasm.__wbg_set_attachment_content(this.__wbg_ptr, f, _);
  }
}
Symbol.dispose &&
  (Attachment.prototype[Symbol.dispose] = Attachment.prototype.free);
typeof FinalizationRegistry > "u" ||
  new FinalizationRegistry((a) => wasm.__wbg_authhandle_free(a >>> 0, 1));
typeof FinalizationRegistry > "u" ||
  new FinalizationRegistry((a) => wasm.__wbg_client_free(a >>> 0, 1));
const ConsentFinalization =
  typeof FinalizationRegistry > "u"
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry((a) => wasm.__wbg_consent_free(a >>> 0, 1));
class Consent {
  static __unwrap(e) {
    return e instanceof Consent ? e.__destroy_into_raw() : 0;
  }
  __destroy_into_raw() {
    const e = this.__wbg_ptr;
    return ((this.__wbg_ptr = 0), ConsentFinalization.unregister(this), e);
  }
  free() {
    const e = this.__destroy_into_raw();
    wasm.__wbg_consent_free(e, 0);
  }
  get entityType() {
    return wasm.__wbg_get_consent_entityType(this.__wbg_ptr);
  }
  set entityType(e) {
    wasm.__wbg_set_consent_entityType(this.__wbg_ptr, e);
  }
  get state() {
    return wasm.__wbg_get_consent_state(this.__wbg_ptr);
  }
  set state(e) {
    wasm.__wbg_set_consent_state(this.__wbg_ptr, e);
  }
  get entity() {
    let e, f;
    try {
      const _ = wasm.__wbg_get_consent_entity(this.__wbg_ptr);
      return ((e = _[0]), (f = _[1]), getStringFromWasm0(_[0], _[1]));
    } finally {
      wasm.__wbindgen_free(e, f, 1);
    }
  }
  set entity(e) {
    const f = passStringToWasm0(
        e,
        wasm.__wbindgen_malloc,
        wasm.__wbindgen_realloc,
      ),
      _ = WASM_VECTOR_LEN;
    wasm.__wbg_set_consent_entity(this.__wbg_ptr, f, _);
  }
  constructor(e, f, _) {
    const w = passStringToWasm0(
        _,
        wasm.__wbindgen_malloc,
        wasm.__wbindgen_realloc,
      ),
      v = WASM_VECTOR_LEN,
      S = wasm.consent_new(e, f, w, v);
    return (
      (this.__wbg_ptr = S >>> 0),
      ConsentFinalization.register(this, this.__wbg_ptr, this),
      this
    );
  }
}
Symbol.dispose && (Consent.prototype[Symbol.dispose] = Consent.prototype.free);
const ContentTypeIdFinalization =
  typeof FinalizationRegistry > "u"
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry((a) =>
        wasm.__wbg_contenttypeid_free(a >>> 0, 1),
      );
class ContentTypeId {
  static __wrap(e) {
    e = e >>> 0;
    const f = Object.create(ContentTypeId.prototype);
    return (
      (f.__wbg_ptr = e),
      ContentTypeIdFinalization.register(f, f.__wbg_ptr, f),
      f
    );
  }
  __destroy_into_raw() {
    const e = this.__wbg_ptr;
    return (
      (this.__wbg_ptr = 0),
      ContentTypeIdFinalization.unregister(this),
      e
    );
  }
  free() {
    const e = this.__destroy_into_raw();
    wasm.__wbg_contenttypeid_free(e, 0);
  }
  constructor(e, f, _, w) {
    const v = passStringToWasm0(
        e,
        wasm.__wbindgen_malloc,
        wasm.__wbindgen_realloc,
      ),
      S = WASM_VECTOR_LEN,
      R = passStringToWasm0(f, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc),
      O = WASM_VECTOR_LEN,
      j = wasm.contenttypeid_new(v, S, R, O, _, w);
    return (
      (this.__wbg_ptr = j >>> 0),
      ContentTypeIdFinalization.register(this, this.__wbg_ptr, this),
      this
    );
  }
  get authorityId() {
    let e, f;
    try {
      const _ = wasm.__wbg_get_contenttypeid_authorityId(this.__wbg_ptr);
      return ((e = _[0]), (f = _[1]), getStringFromWasm0(_[0], _[1]));
    } finally {
      wasm.__wbindgen_free(e, f, 1);
    }
  }
  set authorityId(e) {
    const f = passStringToWasm0(
        e,
        wasm.__wbindgen_malloc,
        wasm.__wbindgen_realloc,
      ),
      _ = WASM_VECTOR_LEN;
    wasm.__wbg_set_attachment_mimeType(this.__wbg_ptr, f, _);
  }
  get typeId() {
    let e, f;
    try {
      const _ = wasm.__wbg_get_contenttypeid_typeId(this.__wbg_ptr);
      return ((e = _[0]), (f = _[1]), getStringFromWasm0(_[0], _[1]));
    } finally {
      wasm.__wbindgen_free(e, f, 1);
    }
  }
  set typeId(e) {
    const f = passStringToWasm0(
        e,
        wasm.__wbindgen_malloc,
        wasm.__wbindgen_realloc,
      ),
      _ = WASM_VECTOR_LEN;
    wasm.__wbg_set_attachment_content(this.__wbg_ptr, f, _);
  }
  get versionMajor() {
    return wasm.__wbg_get_contenttypeid_versionMajor(this.__wbg_ptr) >>> 0;
  }
  set versionMajor(e) {
    wasm.__wbg_set_contenttypeid_versionMajor(this.__wbg_ptr, e);
  }
  get versionMinor() {
    return wasm.__wbg_get_contenttypeid_versionMinor(this.__wbg_ptr) >>> 0;
  }
  set versionMinor(e) {
    wasm.__wbg_set_contenttypeid_versionMinor(this.__wbg_ptr, e);
  }
}
Symbol.dispose &&
  (ContentTypeId.prototype[Symbol.dispose] = ContentTypeId.prototype.free);
const ConversationFinalization =
  typeof FinalizationRegistry > "u"
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry((a) => wasm.__wbg_conversation_free(a >>> 0, 1));
class Conversation {
  static __wrap(e) {
    e = e >>> 0;
    const f = Object.create(Conversation.prototype);
    return (
      (f.__wbg_ptr = e),
      ConversationFinalization.register(f, f.__wbg_ptr, f),
      f
    );
  }
  __destroy_into_raw() {
    const e = this.__wbg_ptr;
    return ((this.__wbg_ptr = 0), ConversationFinalization.unregister(this), e);
  }
  free() {
    const e = this.__destroy_into_raw();
    wasm.__wbg_conversation_free(e, 0);
  }
  consentState() {
    const e = wasm.conversation_consentState(this.__wbg_ptr);
    if (e[2]) throw takeFromExternrefTable0(e[1]);
    return e[0];
  }
  updateConsentState(e) {
    const f = wasm.conversation_updateConsentState(this.__wbg_ptr, e);
    if (f[1]) throw takeFromExternrefTable0(f[0]);
  }
  adminList() {
    const e = wasm.conversation_adminList(this.__wbg_ptr);
    if (e[3]) throw takeFromExternrefTable0(e[2]);
    var f = getArrayJsValueFromWasm0(e[0], e[1]).slice();
    return (wasm.__wbindgen_free(e[0], e[1] * 4, 4), f);
  }
  getDebugInfo() {
    return wasm.conversation_getDebugInfo(this.__wbg_ptr);
  }
  groupName() {
    let e, f;
    try {
      const v = wasm.conversation_groupName(this.__wbg_ptr);
      var _ = v[0],
        w = v[1];
      if (v[3]) throw ((_ = 0), (w = 0), takeFromExternrefTable0(v[2]));
      return ((e = _), (f = w), getStringFromWasm0(_, w));
    } finally {
      wasm.__wbindgen_free(e, f, 1);
    }
  }
  addMembers(e) {
    const f = passArrayJsValueToWasm0(e, wasm.__wbindgen_malloc),
      _ = WASM_VECTOR_LEN;
    return wasm.conversation_addMembers(this.__wbg_ptr, f, _);
  }
  leaveGroup() {
    return wasm.conversation_leaveGroup(this.__wbg_ptr);
  }
  listMembers() {
    return wasm.conversation_listMembers(this.__wbg_ptr);
  }
  removeAdmin(e) {
    const f = passStringToWasm0(
        e,
        wasm.__wbindgen_malloc,
        wasm.__wbindgen_realloc,
      ),
      _ = WASM_VECTOR_LEN;
    return wasm.conversation_removeAdmin(this.__wbg_ptr, f, _);
  }
  createdAtNs() {
    return wasm.conversation_createdAtNs(this.__wbg_ptr);
  }
  findMessages(e) {
    let f = 0;
    return (
      isLikeNone(e) ||
        (_assertClass(e, ListMessagesOptions), (f = e.__destroy_into_raw())),
      wasm.conversation_findMessages(this.__wbg_ptr, f)
    );
  }
  getHmacKeys() {
    const e = wasm.conversation_getHmacKeys(this.__wbg_ptr);
    if (e[2]) throw takeFromExternrefTable0(e[1]);
    return takeFromExternrefTable0(e[0]);
  }
  countMessages(e) {
    let f = 0;
    return (
      isLikeNone(e) ||
        (_assertClass(e, ListMessagesOptions), (f = e.__destroy_into_raw())),
      wasm.conversation_countMessages(this.__wbg_ptr, f)
    );
  }
  groupMetadata() {
    return wasm.conversation_groupMetadata(this.__wbg_ptr);
  }
  isSuperAdmin(e) {
    const f = passStringToWasm0(
        e,
        wasm.__wbindgen_malloc,
        wasm.__wbindgen_realloc,
      ),
      _ = WASM_VECTOR_LEN,
      w = wasm.conversation_isSuperAdmin(this.__wbg_ptr, f, _);
    if (w[2]) throw takeFromExternrefTable0(w[1]);
    return w[0] !== 0;
  }
  removeMembers(e) {
    const f = passArrayJsValueToWasm0(e, wasm.__wbindgen_malloc),
      _ = WASM_VECTOR_LEN;
    return wasm.conversation_removeMembers(this.__wbg_ptr, f, _);
  }
  addSuperAdmin(e) {
    const f = passStringToWasm0(
        e,
        wasm.__wbindgen_malloc,
        wasm.__wbindgen_realloc,
      ),
      _ = WASM_VECTOR_LEN;
    return wasm.conversation_addSuperAdmin(this.__wbg_ptr, f, _);
  }
  sendOptimistic(e, f) {
    let _, w;
    try {
      _assertClass(e, EncodedContent);
      var v = e.__destroy_into_raw();
      _assertClass(f, SendMessageOpts);
      var S = f.__destroy_into_raw();
      const j = wasm.conversation_sendOptimistic(this.__wbg_ptr, v, S);
      var R = j[0],
        O = j[1];
      if (j[3]) throw ((R = 0), (O = 0), takeFromExternrefTable0(j[2]));
      return ((_ = R), (w = O), getStringFromWasm0(R, O));
    } finally {
      wasm.__wbindgen_free(_, w, 1);
    }
  }
  updateAppData(e) {
    const f = passStringToWasm0(
        e,
        wasm.__wbindgen_malloc,
        wasm.__wbindgen_realloc,
      ),
      _ = WASM_VECTOR_LEN;
    return wasm.conversation_updateAppData(this.__wbg_ptr, f, _);
  }
  dmPeerInboxId() {
    let e, f;
    try {
      const v = wasm.conversation_dmPeerInboxId(this.__wbg_ptr);
      var _ = v[0],
        w = v[1];
      if (v[3]) throw ((_ = 0), (w = 0), takeFromExternrefTable0(v[2]));
      return ((e = _), (f = w), getStringFromWasm0(_, w));
    } finally {
      wasm.__wbindgen_free(e, f, 1);
    }
  }
  membershipState() {
    const e = wasm.conversation_membershipState(this.__wbg_ptr);
    if (e[2]) throw takeFromExternrefTable0(e[1]);
    return e[0];
  }
  publishMessages() {
    return wasm.conversation_publishMessages(this.__wbg_ptr);
  }
  superAdminList() {
    const e = wasm.conversation_superAdminList(this.__wbg_ptr);
    if (e[3]) throw takeFromExternrefTable0(e[2]);
    var f = getArrayJsValueFromWasm0(e[0], e[1]).slice();
    return (wasm.__wbindgen_free(e[0], e[1] * 4, 4), f);
  }
  addedByInboxId() {
    let e, f;
    try {
      const v = wasm.conversation_addedByInboxId(this.__wbg_ptr);
      var _ = v[0],
        w = v[1];
      if (v[3]) throw ((_ = 0), (w = 0), takeFromExternrefTable0(v[2]));
      return ((e = _), (f = w), getStringFromWasm0(_, w));
    } finally {
      wasm.__wbindgen_free(e, f, 1);
    }
  }
  groupDescription() {
    let e, f;
    try {
      const v = wasm.conversation_groupDescription(this.__wbg_ptr);
      var _ = v[0],
        w = v[1];
      if (v[3]) throw ((_ = 0), (w = 0), takeFromExternrefTable0(v[2]));
      return ((e = _), (f = w), getStringFromWasm0(_, w));
    } finally {
      wasm.__wbindgen_free(e, f, 1);
    }
  }
  groupPermissions() {
    const e = wasm.conversation_groupPermissions(this.__wbg_ptr);
    if (e[2]) throw takeFromExternrefTable0(e[1]);
    return GroupPermissions.__wrap(e[0]);
  }
  updateGroupName(e) {
    const f = passStringToWasm0(
        e,
        wasm.__wbindgen_malloc,
        wasm.__wbindgen_realloc,
      ),
      _ = WASM_VECTOR_LEN;
    return wasm.conversation_updateGroupName(this.__wbg_ptr, f, _);
  }
  findDuplicateDms() {
    return wasm.conversation_findDuplicateDms(this.__wbg_ptr);
  }
  pausedForVersion() {
    const e = wasm.conversation_pausedForVersion(this.__wbg_ptr);
    if (e[3]) throw takeFromExternrefTable0(e[2]);
    let f;
    return (
      e[0] !== 0 &&
        ((f = getStringFromWasm0(e[0], e[1]).slice()),
        wasm.__wbindgen_free(e[0], e[1] * 1, 1)),
      f
    );
  }
  removeSuperAdmin(e) {
    const f = passStringToWasm0(
        e,
        wasm.__wbindgen_malloc,
        wasm.__wbindgen_realloc,
      ),
      _ = WASM_VECTOR_LEN;
    return wasm.conversation_removeSuperAdmin(this.__wbg_ptr, f, _);
  }
  getLastReadTimes() {
    return wasm.conversation_getLastReadTimes(this.__wbg_ptr);
  }
  findEnrichedMessages(e) {
    let f = 0;
    return (
      isLikeNone(e) ||
        (_assertClass(e, ListMessagesOptions), (f = e.__destroy_into_raw())),
      wasm.conversation_findEnrichedMessages(this.__wbg_ptr, f)
    );
  }
  groupImageUrlSquare() {
    let e, f;
    try {
      const v = wasm.conversation_groupImageUrlSquare(this.__wbg_ptr);
      var _ = v[0],
        w = v[1];
      if (v[3]) throw ((_ = 0), (w = 0), takeFromExternrefTable0(v[2]));
      return ((e = _), (f = w), getStringFromWasm0(_, w));
    } finally {
      wasm.__wbindgen_free(e, f, 1);
    }
  }
  addMembersByInboxId(e) {
    const f = passArrayJsValueToWasm0(e, wasm.__wbindgen_malloc),
      _ = WASM_VECTOR_LEN;
    return wasm.conversation_addMembersByInboxId(this.__wbg_ptr, f, _);
  }
  updateGroupDescription(e) {
    const f = passStringToWasm0(
        e,
        wasm.__wbindgen_malloc,
        wasm.__wbindgen_realloc,
      ),
      _ = WASM_VECTOR_LEN;
    return wasm.conversation_updateGroupDescription(this.__wbg_ptr, f, _);
  }
  updatePermissionPolicy(e, f, _) {
    return wasm.conversation_updatePermissionPolicy(
      this.__wbg_ptr,
      e,
      f,
      isLikeNone(_) ? 5 : _,
    );
  }
  removeMembersByInboxId(e) {
    const f = passArrayJsValueToWasm0(e, wasm.__wbindgen_malloc),
      _ = WASM_VECTOR_LEN;
    return wasm.conversation_removeMembersByInboxId(this.__wbg_ptr, f, _);
  }
  findMessagesWithReactions(e) {
    let f = 0;
    return (
      isLikeNone(e) ||
        (_assertClass(e, ListMessagesOptions), (f = e.__destroy_into_raw())),
      wasm.conversation_findMessagesWithReactions(this.__wbg_ptr, f)
    );
  }
  messageDisappearingSettings() {
    const e = wasm.conversation_messageDisappearingSettings(this.__wbg_ptr);
    if (e[2]) throw takeFromExternrefTable0(e[1]);
    return e[0] === 0 ? void 0 : MessageDisappearingSettings.__wrap(e[0]);
  }
  updateGroupImageUrlSquare(e) {
    const f = passStringToWasm0(
        e,
        wasm.__wbindgen_malloc,
        wasm.__wbindgen_realloc,
      ),
      _ = WASM_VECTOR_LEN;
    return wasm.conversation_updateGroupImageUrlSquare(this.__wbg_ptr, f, _);
  }
  id() {
    let e, f;
    try {
      const _ = wasm.conversation_id(this.__wbg_ptr);
      return ((e = _[0]), (f = _[1]), getStringFromWasm0(_[0], _[1]));
    } finally {
      wasm.__wbindgen_free(e, f, 1);
    }
  }
  processStreamedGroupMessage(e) {
    return wasm.conversation_processStreamedGroupMessage(this.__wbg_ptr, e);
  }
  isMessageDisappearingEnabled() {
    const e = wasm.conversation_isMessageDisappearingEnabled(this.__wbg_ptr);
    if (e[2]) throw takeFromExternrefTable0(e[1]);
    return e[0] !== 0;
  }
  removeMessageDisappearingSettings() {
    return wasm.conversation_removeMessageDisappearingSettings(this.__wbg_ptr);
  }
  updateMessageDisappearingSettings(e) {
    _assertClass(e, MessageDisappearingSettings);
    var f = e.__destroy_into_raw();
    return wasm.conversation_updateMessageDisappearingSettings(
      this.__wbg_ptr,
      f,
    );
  }
  send(e, f) {
    _assertClass(e, EncodedContent);
    var _ = e.__destroy_into_raw();
    _assertClass(f, SendMessageOpts);
    var w = f.__destroy_into_raw();
    return wasm.conversation_send(this.__wbg_ptr, _, w);
  }
  sync() {
    return wasm.conversation_sync(this.__wbg_ptr);
  }
  stream(e) {
    const f = wasm.conversation_stream(this.__wbg_ptr, e);
    if (f[2]) throw takeFromExternrefTable0(f[1]);
    return StreamCloser.__wrap(f[0]);
  }
  appData() {
    let e, f;
    try {
      const v = wasm.conversation_appData(this.__wbg_ptr);
      var _ = v[0],
        w = v[1];
      if (v[3]) throw ((_ = 0), (w = 0), takeFromExternrefTable0(v[2]));
      return ((e = _), (f = w), getStringFromWasm0(_, w));
    } finally {
      wasm.__wbindgen_free(e, f, 1);
    }
  }
  isAdmin(e) {
    const f = passStringToWasm0(
        e,
        wasm.__wbindgen_malloc,
        wasm.__wbindgen_realloc,
      ),
      _ = WASM_VECTOR_LEN,
      w = wasm.conversation_isAdmin(this.__wbg_ptr, f, _);
    if (w[2]) throw takeFromExternrefTable0(w[1]);
    return w[0] !== 0;
  }
  addAdmin(e) {
    const f = passStringToWasm0(
        e,
        wasm.__wbindgen_malloc,
        wasm.__wbindgen_realloc,
      ),
      _ = WASM_VECTOR_LEN;
    return wasm.conversation_addAdmin(this.__wbg_ptr, f, _);
  }
  isActive() {
    const e = wasm.conversation_isActive(this.__wbg_ptr);
    if (e[2]) throw takeFromExternrefTable0(e[1]);
    return e[0] !== 0;
  }
}
Symbol.dispose &&
  (Conversation.prototype[Symbol.dispose] = Conversation.prototype.free);
const ConversationDebugInfoFinalization =
  typeof FinalizationRegistry > "u"
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry((a) =>
        wasm.__wbg_conversationdebuginfo_free(a >>> 0, 1),
      );
class ConversationDebugInfo {
  __destroy_into_raw() {
    const e = this.__wbg_ptr;
    return (
      (this.__wbg_ptr = 0),
      ConversationDebugInfoFinalization.unregister(this),
      e
    );
  }
  free() {
    const e = this.__destroy_into_raw();
    wasm.__wbg_conversationdebuginfo_free(e, 0);
  }
  get epoch() {
    const e = wasm.__wbg_get_conversationdebuginfo_epoch(this.__wbg_ptr);
    return BigInt.asUintN(64, e);
  }
  set epoch(e) {
    wasm.__wbg_set_conversationdebuginfo_epoch(this.__wbg_ptr, e);
  }
  get maybeForked() {
    return (
      wasm.__wbg_get_conversationdebuginfo_maybeForked(this.__wbg_ptr) !== 0
    );
  }
  set maybeForked(e) {
    wasm.__wbg_set_conversationdebuginfo_maybeForked(this.__wbg_ptr, e);
  }
  get forkDetails() {
    let e, f;
    try {
      const _ = wasm.__wbg_get_conversationdebuginfo_forkDetails(
        this.__wbg_ptr,
      );
      return ((e = _[0]), (f = _[1]), getStringFromWasm0(_[0], _[1]));
    } finally {
      wasm.__wbindgen_free(e, f, 1);
    }
  }
  set forkDetails(e) {
    const f = passStringToWasm0(
        e,
        wasm.__wbindgen_malloc,
        wasm.__wbindgen_realloc,
      ),
      _ = WASM_VECTOR_LEN;
    wasm.__wbg_set_conversationdebuginfo_forkDetails(this.__wbg_ptr, f, _);
  }
  get isCommitLogForked() {
    const e = wasm.__wbg_get_conversationdebuginfo_isCommitLogForked(
      this.__wbg_ptr,
    );
    return e === 16777215 ? void 0 : e !== 0;
  }
  set isCommitLogForked(e) {
    wasm.__wbg_set_conversationdebuginfo_isCommitLogForked(
      this.__wbg_ptr,
      isLikeNone(e) ? 16777215 : e ? 1 : 0,
    );
  }
  get localCommitLog() {
    let e, f;
    try {
      const _ = wasm.__wbg_get_conversationdebuginfo_localCommitLog(
        this.__wbg_ptr,
      );
      return ((e = _[0]), (f = _[1]), getStringFromWasm0(_[0], _[1]));
    } finally {
      wasm.__wbindgen_free(e, f, 1);
    }
  }
  set localCommitLog(e) {
    const f = passStringToWasm0(
        e,
        wasm.__wbindgen_malloc,
        wasm.__wbindgen_realloc,
      ),
      _ = WASM_VECTOR_LEN;
    wasm.__wbg_set_conversationdebuginfo_localCommitLog(this.__wbg_ptr, f, _);
  }
  get remoteCommitLog() {
    let e, f;
    try {
      const _ = wasm.__wbg_get_conversationdebuginfo_remoteCommitLog(
        this.__wbg_ptr,
      );
      return ((e = _[0]), (f = _[1]), getStringFromWasm0(_[0], _[1]));
    } finally {
      wasm.__wbindgen_free(e, f, 1);
    }
  }
  set remoteCommitLog(e) {
    const f = passStringToWasm0(
        e,
        wasm.__wbindgen_malloc,
        wasm.__wbindgen_realloc,
      ),
      _ = WASM_VECTOR_LEN;
    wasm.__wbg_set_conversationdebuginfo_remoteCommitLog(this.__wbg_ptr, f, _);
  }
  get cursor() {
    const e = wasm.__wbg_get_conversationdebuginfo_cursor(this.__wbg_ptr);
    var f = getArrayJsValueFromWasm0(e[0], e[1]).slice();
    return (wasm.__wbindgen_free(e[0], e[1] * 4, 4), f);
  }
  set cursor(e) {
    const f = passArrayJsValueToWasm0(e, wasm.__wbindgen_malloc),
      _ = WASM_VECTOR_LEN;
    wasm.__wbg_set_conversationdebuginfo_cursor(this.__wbg_ptr, f, _);
  }
}
Symbol.dispose &&
  (ConversationDebugInfo.prototype[Symbol.dispose] =
    ConversationDebugInfo.prototype.free);
const ConversationListItemFinalization =
  typeof FinalizationRegistry > "u"
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry((a) =>
        wasm.__wbg_conversationlistitem_free(a >>> 0, 1),
      );
class ConversationListItem {
  static __wrap(e) {
    e = e >>> 0;
    const f = Object.create(ConversationListItem.prototype);
    return (
      (f.__wbg_ptr = e),
      ConversationListItemFinalization.register(f, f.__wbg_ptr, f),
      f
    );
  }
  __destroy_into_raw() {
    const e = this.__wbg_ptr;
    return (
      (this.__wbg_ptr = 0),
      ConversationListItemFinalization.unregister(this),
      e
    );
  }
  free() {
    const e = this.__destroy_into_raw();
    wasm.__wbg_conversationlistitem_free(e, 0);
  }
  get conversation() {
    const e = wasm.__wbg_get_conversationlistitem_conversation(this.__wbg_ptr);
    return Conversation.__wrap(e);
  }
  set conversation(e) {
    _assertClass(e, Conversation);
    var f = e.__destroy_into_raw();
    wasm.__wbg_set_conversationlistitem_conversation(this.__wbg_ptr, f);
  }
  get lastMessage() {
    const e = wasm.__wbg_get_conversationlistitem_lastMessage(this.__wbg_ptr);
    return e === 0 ? void 0 : Message.__wrap(e);
  }
  set lastMessage(e) {
    let f = 0;
    (isLikeNone(e) || (_assertClass(e, Message), (f = e.__destroy_into_raw())),
      wasm.__wbg_set_conversationlistitem_lastMessage(this.__wbg_ptr, f));
  }
  get isCommitLogForked() {
    const e = wasm.__wbg_get_conversationlistitem_isCommitLogForked(
      this.__wbg_ptr,
    );
    return e === 16777215 ? void 0 : e !== 0;
  }
  set isCommitLogForked(e) {
    wasm.__wbg_set_conversationlistitem_isCommitLogForked(
      this.__wbg_ptr,
      isLikeNone(e) ? 16777215 : e ? 1 : 0,
    );
  }
  constructor(e, f, _) {
    _assertClass(e, Conversation);
    var w = e.__destroy_into_raw();
    let v = 0;
    isLikeNone(f) || (_assertClass(f, Message), (v = f.__destroy_into_raw()));
    const S = wasm.conversationlistitem_new(
      w,
      v,
      isLikeNone(_) ? 16777215 : _ ? 1 : 0,
    );
    return (
      (this.__wbg_ptr = S >>> 0),
      ConversationListItemFinalization.register(this, this.__wbg_ptr, this),
      this
    );
  }
}
Symbol.dispose &&
  (ConversationListItem.prototype[Symbol.dispose] =
    ConversationListItem.prototype.free);
typeof FinalizationRegistry > "u" ||
  new FinalizationRegistry((a) => wasm.__wbg_conversations_free(a >>> 0, 1));
const CreateDMOptionsFinalization =
  typeof FinalizationRegistry > "u"
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry((a) =>
        wasm.__wbg_createdmoptions_free(a >>> 0, 1),
      );
class CreateDMOptions {
  __destroy_into_raw() {
    const e = this.__wbg_ptr;
    return (
      (this.__wbg_ptr = 0),
      CreateDMOptionsFinalization.unregister(this),
      e
    );
  }
  free() {
    const e = this.__destroy_into_raw();
    wasm.__wbg_createdmoptions_free(e, 0);
  }
  constructor(e) {
    let f = 0;
    isLikeNone(e) ||
      (_assertClass(e, MessageDisappearingSettings),
      (f = e.__destroy_into_raw()));
    const _ = wasm.createdmoptions_new(f);
    return (
      (this.__wbg_ptr = _ >>> 0),
      CreateDMOptionsFinalization.register(this, this.__wbg_ptr, this),
      this
    );
  }
  get messageDisappearingSettings() {
    const e = wasm.__wbg_get_createdmoptions_messageDisappearingSettings(
      this.__wbg_ptr,
    );
    return e === 0 ? void 0 : MessageDisappearingSettings.__wrap(e);
  }
  set messageDisappearingSettings(e) {
    let f = 0;
    (isLikeNone(e) ||
      (_assertClass(e, MessageDisappearingSettings),
      (f = e.__destroy_into_raw())),
      wasm.__wbg_set_createdmoptions_messageDisappearingSettings(
        this.__wbg_ptr,
        f,
      ));
  }
}
Symbol.dispose &&
  (CreateDMOptions.prototype[Symbol.dispose] = CreateDMOptions.prototype.free);
const CreateGroupOptionsFinalization =
  typeof FinalizationRegistry > "u"
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry((a) =>
        wasm.__wbg_creategroupoptions_free(a >>> 0, 1),
      );
class CreateGroupOptions {
  __destroy_into_raw() {
    const e = this.__wbg_ptr;
    return (
      (this.__wbg_ptr = 0),
      CreateGroupOptionsFinalization.unregister(this),
      e
    );
  }
  free() {
    const e = this.__destroy_into_raw();
    wasm.__wbg_creategroupoptions_free(e, 0);
  }
  constructor(e, f, _, w, v, S, R) {
    var O = isLikeNone(f)
        ? 0
        : passStringToWasm0(f, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc),
      j = WASM_VECTOR_LEN,
      F = isLikeNone(_)
        ? 0
        : passStringToWasm0(_, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc),
      q = WASM_VECTOR_LEN,
      Q = isLikeNone(w)
        ? 0
        : passStringToWasm0(w, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc),
      te = WASM_VECTOR_LEN;
    let se = 0;
    isLikeNone(v) ||
      (_assertClass(v, PermissionPolicySet), (se = v.__destroy_into_raw()));
    let re = 0;
    isLikeNone(S) ||
      (_assertClass(S, MessageDisappearingSettings),
      (re = S.__destroy_into_raw()));
    var Oe = isLikeNone(R)
        ? 0
        : passStringToWasm0(R, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc),
      Le = WASM_VECTOR_LEN;
    const Be = wasm.creategroupoptions_new(
      isLikeNone(e) ? 3 : e,
      O,
      j,
      F,
      q,
      Q,
      te,
      se,
      re,
      Oe,
      Le,
    );
    return (
      (this.__wbg_ptr = Be >>> 0),
      CreateGroupOptionsFinalization.register(this, this.__wbg_ptr, this),
      this
    );
  }
  get permissions() {
    const e = wasm.__wbg_get_creategroupoptions_permissions(this.__wbg_ptr);
    return e === 3 ? void 0 : e;
  }
  set permissions(e) {
    wasm.__wbg_set_creategroupoptions_permissions(
      this.__wbg_ptr,
      isLikeNone(e) ? 3 : e,
    );
  }
  get groupName() {
    const e = wasm.__wbg_get_creategroupoptions_groupName(this.__wbg_ptr);
    let f;
    return (
      e[0] !== 0 &&
        ((f = getStringFromWasm0(e[0], e[1]).slice()),
        wasm.__wbindgen_free(e[0], e[1] * 1, 1)),
      f
    );
  }
  set groupName(e) {
    var f = isLikeNone(e)
        ? 0
        : passStringToWasm0(e, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc),
      _ = WASM_VECTOR_LEN;
    wasm.__wbg_set_creategroupoptions_groupName(this.__wbg_ptr, f, _);
  }
  get groupImageUrlSquare() {
    const e = wasm.__wbg_get_creategroupoptions_groupImageUrlSquare(
      this.__wbg_ptr,
    );
    let f;
    return (
      e[0] !== 0 &&
        ((f = getStringFromWasm0(e[0], e[1]).slice()),
        wasm.__wbindgen_free(e[0], e[1] * 1, 1)),
      f
    );
  }
  set groupImageUrlSquare(e) {
    var f = isLikeNone(e)
        ? 0
        : passStringToWasm0(e, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc),
      _ = WASM_VECTOR_LEN;
    wasm.__wbg_set_creategroupoptions_groupImageUrlSquare(this.__wbg_ptr, f, _);
  }
  get groupDescription() {
    const e = wasm.__wbg_get_creategroupoptions_groupDescription(
      this.__wbg_ptr,
    );
    let f;
    return (
      e[0] !== 0 &&
        ((f = getStringFromWasm0(e[0], e[1]).slice()),
        wasm.__wbindgen_free(e[0], e[1] * 1, 1)),
      f
    );
  }
  set groupDescription(e) {
    var f = isLikeNone(e)
        ? 0
        : passStringToWasm0(e, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc),
      _ = WASM_VECTOR_LEN;
    wasm.__wbg_set_creategroupoptions_groupDescription(this.__wbg_ptr, f, _);
  }
  get customPermissionPolicySet() {
    const e = wasm.__wbg_get_creategroupoptions_customPermissionPolicySet(
      this.__wbg_ptr,
    );
    return e === 0 ? void 0 : PermissionPolicySet.__wrap(e);
  }
  set customPermissionPolicySet(e) {
    let f = 0;
    (isLikeNone(e) ||
      (_assertClass(e, PermissionPolicySet), (f = e.__destroy_into_raw())),
      wasm.__wbg_set_creategroupoptions_customPermissionPolicySet(
        this.__wbg_ptr,
        f,
      ));
  }
  get messageDisappearingSettings() {
    const e = wasm.__wbg_get_createdmoptions_messageDisappearingSettings(
      this.__wbg_ptr,
    );
    return e === 0 ? void 0 : MessageDisappearingSettings.__wrap(e);
  }
  set messageDisappearingSettings(e) {
    let f = 0;
    (isLikeNone(e) ||
      (_assertClass(e, MessageDisappearingSettings),
      (f = e.__destroy_into_raw())),
      wasm.__wbg_set_createdmoptions_messageDisappearingSettings(
        this.__wbg_ptr,
        f,
      ));
  }
  get appData() {
    const e = wasm.__wbg_get_creategroupoptions_appData(this.__wbg_ptr);
    let f;
    return (
      e[0] !== 0 &&
        ((f = getStringFromWasm0(e[0], e[1]).slice()),
        wasm.__wbindgen_free(e[0], e[1] * 1, 1)),
      f
    );
  }
  set appData(e) {
    var f = isLikeNone(e)
        ? 0
        : passStringToWasm0(e, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc),
      _ = WASM_VECTOR_LEN;
    wasm.__wbg_set_creategroupoptions_appData(this.__wbg_ptr, f, _);
  }
}
Symbol.dispose &&
  (CreateGroupOptions.prototype[Symbol.dispose] =
    CreateGroupOptions.prototype.free);
typeof FinalizationRegistry > "u" ||
  new FinalizationRegistry((a) => wasm.__wbg_credential_free(a >>> 0, 1));
const DecodedMessageFinalization =
  typeof FinalizationRegistry > "u"
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry((a) =>
        wasm.__wbg_decodedmessage_free(a >>> 0, 1),
      );
class DecodedMessage {
  static __wrap(e) {
    e = e >>> 0;
    const f = Object.create(DecodedMessage.prototype);
    return (
      (f.__wbg_ptr = e),
      DecodedMessageFinalization.register(f, f.__wbg_ptr, f),
      f
    );
  }
  static __unwrap(e) {
    return e instanceof DecodedMessage ? e.__destroy_into_raw() : 0;
  }
  __destroy_into_raw() {
    const e = this.__wbg_ptr;
    return (
      (this.__wbg_ptr = 0),
      DecodedMessageFinalization.unregister(this),
      e
    );
  }
  free() {
    const e = this.__destroy_into_raw();
    wasm.__wbg_decodedmessage_free(e, 0);
  }
  get id() {
    const e = wasm.__wbg_get_decodedmessage_id(this.__wbg_ptr);
    var f = getArrayU8FromWasm0(e[0], e[1]).slice();
    return (wasm.__wbindgen_free(e[0], e[1] * 1, 1), f);
  }
  set id(e) {
    const f = passArray8ToWasm0(e, wasm.__wbindgen_malloc),
      _ = WASM_VECTOR_LEN;
    wasm.__wbg_set_decodedmessage_id(this.__wbg_ptr, f, _);
  }
  get sent_at_ns() {
    return wasm.__wbg_get_decodedmessage_sent_at_ns(this.__wbg_ptr);
  }
  set sent_at_ns(e) {
    wasm.__wbg_set_decodedmessage_sent_at_ns(this.__wbg_ptr, e);
  }
  get kind() {
    return wasm.__wbg_get_decodedmessage_kind(this.__wbg_ptr);
  }
  set kind(e) {
    wasm.__wbg_set_decodedmessage_kind(this.__wbg_ptr, e);
  }
  get sender_installation_id() {
    const e = wasm.__wbg_get_decodedmessage_sender_installation_id(
      this.__wbg_ptr,
    );
    var f = getArrayU8FromWasm0(e[0], e[1]).slice();
    return (wasm.__wbindgen_free(e[0], e[1] * 1, 1), f);
  }
  set sender_installation_id(e) {
    const f = passArray8ToWasm0(e, wasm.__wbindgen_malloc),
      _ = WASM_VECTOR_LEN;
    wasm.__wbg_set_decodedmessage_sender_installation_id(this.__wbg_ptr, f, _);
  }
  get sender_inbox_id() {
    let e, f;
    try {
      const _ = wasm.__wbg_get_decodedmessage_sender_inbox_id(this.__wbg_ptr);
      return ((e = _[0]), (f = _[1]), getStringFromWasm0(_[0], _[1]));
    } finally {
      wasm.__wbindgen_free(e, f, 1);
    }
  }
  set sender_inbox_id(e) {
    const f = passStringToWasm0(
        e,
        wasm.__wbindgen_malloc,
        wasm.__wbindgen_realloc,
      ),
      _ = WASM_VECTOR_LEN;
    wasm.__wbg_set_decodedmessage_sender_inbox_id(this.__wbg_ptr, f, _);
  }
  get content_type() {
    const e = wasm.__wbg_get_decodedmessage_content_type(this.__wbg_ptr);
    return ContentTypeId.__wrap(e);
  }
  set content_type(e) {
    _assertClass(e, ContentTypeId);
    var f = e.__destroy_into_raw();
    wasm.__wbg_set_decodedmessage_content_type(this.__wbg_ptr, f);
  }
  get conversation_id() {
    const e = wasm.__wbg_get_decodedmessage_conversation_id(this.__wbg_ptr);
    var f = getArrayU8FromWasm0(e[0], e[1]).slice();
    return (wasm.__wbindgen_free(e[0], e[1] * 1, 1), f);
  }
  set conversation_id(e) {
    const f = passArray8ToWasm0(e, wasm.__wbindgen_malloc),
      _ = WASM_VECTOR_LEN;
    wasm.__wbg_set_decodedmessage_conversation_id(this.__wbg_ptr, f, _);
  }
  get content() {
    const e = wasm.__wbg_get_decodedmessage_content(this.__wbg_ptr);
    return DecodedMessageContent.__wrap(e);
  }
  set content(e) {
    _assertClass(e, DecodedMessageContent);
    var f = e.__destroy_into_raw();
    wasm.__wbg_set_decodedmessage_content(this.__wbg_ptr, f);
  }
  get fallback_text() {
    const e = wasm.__wbg_get_decodedmessage_fallback_text(this.__wbg_ptr);
    let f;
    return (
      e[0] !== 0 &&
        ((f = getStringFromWasm0(e[0], e[1]).slice()),
        wasm.__wbindgen_free(e[0], e[1] * 1, 1)),
      f
    );
  }
  set fallback_text(e) {
    var f = isLikeNone(e)
        ? 0
        : passStringToWasm0(e, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc),
      _ = WASM_VECTOR_LEN;
    wasm.__wbg_set_decodedmessage_fallback_text(this.__wbg_ptr, f, _);
  }
  get reactions() {
    const e = wasm.__wbg_get_decodedmessage_reactions(this.__wbg_ptr);
    var f = getArrayJsValueFromWasm0(e[0], e[1]).slice();
    return (wasm.__wbindgen_free(e[0], e[1] * 4, 4), f);
  }
  set reactions(e) {
    const f = passArrayJsValueToWasm0(e, wasm.__wbindgen_malloc),
      _ = WASM_VECTOR_LEN;
    wasm.__wbg_set_decodedmessage_reactions(this.__wbg_ptr, f, _);
  }
  get delivery_status() {
    return wasm.__wbg_get_decodedmessage_delivery_status(this.__wbg_ptr);
  }
  set delivery_status(e) {
    wasm.__wbg_set_decodedmessage_delivery_status(this.__wbg_ptr, e);
  }
  get num_replies() {
    return wasm.__wbg_get_decodedmessage_num_replies(this.__wbg_ptr);
  }
  set num_replies(e) {
    wasm.__wbg_set_decodedmessage_num_replies(this.__wbg_ptr, e);
  }
}
Symbol.dispose &&
  (DecodedMessage.prototype[Symbol.dispose] = DecodedMessage.prototype.free);
const DecodedMessageContentFinalization =
  typeof FinalizationRegistry > "u"
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry((a) =>
        wasm.__wbg_decodedmessagecontent_free(a >>> 0, 1),
      );
class DecodedMessageContent {
  static __wrap(e) {
    e = e >>> 0;
    const f = Object.create(DecodedMessageContent.prototype);
    return (
      (f.__wbg_ptr = e),
      DecodedMessageContentFinalization.register(f, f.__wbg_ptr, f),
      f
    );
  }
  __destroy_into_raw() {
    const e = this.__wbg_ptr;
    return (
      (this.__wbg_ptr = 0),
      DecodedMessageContentFinalization.unregister(this),
      e
    );
  }
  free() {
    const e = this.__destroy_into_raw();
    wasm.__wbg_decodedmessagecontent_free(e, 0);
  }
  asActions() {
    const e = wasm.decodedmessagecontent_asActions(this.__wbg_ptr);
    if (e[2]) throw takeFromExternrefTable0(e[1]);
    return e[0] === 0 ? void 0 : Actions.__wrap(e[0]);
  }
  asReaction() {
    const e = wasm.decodedmessagecontent_asReaction(this.__wbg_ptr);
    return e === 0 ? void 0 : ReactionPayload.__wrap(e);
  }
  get payloadType() {
    return wasm.decodedmessagecontent_payloadType(this.__wbg_ptr);
  }
  asAttachment() {
    const e = wasm.decodedmessagecontent_asAttachment(this.__wbg_ptr);
    return e === 0 ? void 0 : Attachment.__wrap(e);
  }
  asReadReceipt() {
    const e = wasm.decodedmessagecontent_asReadReceipt(this.__wbg_ptr);
    return e === 0 ? void 0 : ReadReceipt.__wrap(e);
  }
  asGroupUpdated() {
    const e = wasm.decodedmessagecontent_asGroupUpdated(this.__wbg_ptr);
    return e === 0 ? void 0 : GroupUpdated.__wrap(e);
  }
  asLeaveRequest() {
    const e = wasm.decodedmessagecontent_asLeaveRequest(this.__wbg_ptr);
    return e === 0 ? void 0 : LeaveRequest.__wrap(e);
  }
  asRemoteAttachment() {
    const e = wasm.decodedmessagecontent_asRemoteAttachment(this.__wbg_ptr);
    return e === 0 ? void 0 : RemoteAttachment.__wrap(e);
  }
  asWalletSendCalls() {
    const e = wasm.decodedmessagecontent_asWalletSendCalls(this.__wbg_ptr);
    if (e[2]) throw takeFromExternrefTable0(e[1]);
    return takeFromExternrefTable0(e[0]);
  }
  asTransactionReference() {
    const e = wasm.decodedmessagecontent_asTransactionReference(this.__wbg_ptr);
    return e === 0 ? void 0 : TransactionReference.__wrap(e);
  }
  asMultiRemoteAttachment() {
    const e = wasm.decodedmessagecontent_asMultiRemoteAttachment(
      this.__wbg_ptr,
    );
    return e === 0 ? void 0 : MultiRemoteAttachment.__wrap(e);
  }
  asText() {
    const e = wasm.decodedmessagecontent_asText(this.__wbg_ptr);
    return e === 0 ? void 0 : TextContent.__wrap(e);
  }
  asReply() {
    const e = wasm.decodedmessagecontent_asReply(this.__wbg_ptr);
    return e === 0 ? void 0 : EnrichedReply.__wrap(e);
  }
  asCustom() {
    const e = wasm.decodedmessagecontent_asCustom(this.__wbg_ptr);
    return e === 0 ? void 0 : EncodedContent.__wrap(e);
  }
  asIntent() {
    const e = wasm.decodedmessagecontent_asIntent(this.__wbg_ptr);
    if (e[2]) throw takeFromExternrefTable0(e[1]);
    return e[0] === 0 ? void 0 : Intent.__wrap(e[0]);
  }
}
Symbol.dispose &&
  (DecodedMessageContent.prototype[Symbol.dispose] =
    DecodedMessageContent.prototype.free);
const EncodedContentFinalization =
  typeof FinalizationRegistry > "u"
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry((a) =>
        wasm.__wbg_encodedcontent_free(a >>> 0, 1),
      );
class EncodedContent {
  static __wrap(e) {
    e = e >>> 0;
    const f = Object.create(EncodedContent.prototype);
    return (
      (f.__wbg_ptr = e),
      EncodedContentFinalization.register(f, f.__wbg_ptr, f),
      f
    );
  }
  __destroy_into_raw() {
    const e = this.__wbg_ptr;
    return (
      (this.__wbg_ptr = 0),
      EncodedContentFinalization.unregister(this),
      e
    );
  }
  free() {
    const e = this.__destroy_into_raw();
    wasm.__wbg_encodedcontent_free(e, 0);
  }
  constructor(e, f, _, w, v) {
    let S = 0;
    isLikeNone(e) ||
      (_assertClass(e, ContentTypeId), (S = e.__destroy_into_raw()));
    var R = isLikeNone(_)
        ? 0
        : passStringToWasm0(_, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc),
      O = WASM_VECTOR_LEN;
    const j = wasm.encodedcontent_new(
      S,
      f,
      R,
      O,
      isLikeNone(w) ? 4294967297 : w >> 0,
      v,
    );
    return (
      (this.__wbg_ptr = j >>> 0),
      EncodedContentFinalization.register(this, this.__wbg_ptr, this),
      this
    );
  }
  get type() {
    const e = wasm.__wbg_get_encodedcontent_type(this.__wbg_ptr);
    return e === 0 ? void 0 : ContentTypeId.__wrap(e);
  }
  set type(e) {
    let f = 0;
    (isLikeNone(e) ||
      (_assertClass(e, ContentTypeId), (f = e.__destroy_into_raw())),
      wasm.__wbg_set_encodedcontent_type(this.__wbg_ptr, f));
  }
  get parameters() {
    return wasm.__wbg_get_encodedcontent_parameters(this.__wbg_ptr);
  }
  set parameters(e) {
    wasm.__wbg_set_encodedcontent_parameters(this.__wbg_ptr, e);
  }
  get fallback() {
    const e = wasm.__wbg_get_encodedcontent_fallback(this.__wbg_ptr);
    let f;
    return (
      e[0] !== 0 &&
        ((f = getStringFromWasm0(e[0], e[1]).slice()),
        wasm.__wbindgen_free(e[0], e[1] * 1, 1)),
      f
    );
  }
  set fallback(e) {
    var f = isLikeNone(e)
        ? 0
        : passStringToWasm0(e, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc),
      _ = WASM_VECTOR_LEN;
    wasm.__wbg_set_encodedcontent_fallback(this.__wbg_ptr, f, _);
  }
  get compression() {
    const e = wasm.__wbg_get_encodedcontent_compression(this.__wbg_ptr);
    return e === 4294967297 ? void 0 : e;
  }
  set compression(e) {
    wasm.__wbg_set_encodedcontent_compression(
      this.__wbg_ptr,
      isLikeNone(e) ? 4294967297 : e >> 0,
    );
  }
  get content() {
    return wasm.__wbg_get_encodedcontent_content(this.__wbg_ptr);
  }
  set content(e) {
    wasm.__wbg_set_encodedcontent_content(this.__wbg_ptr, e);
  }
}
Symbol.dispose &&
  (EncodedContent.prototype[Symbol.dispose] = EncodedContent.prototype.free);
const EnrichedReplyFinalization =
  typeof FinalizationRegistry > "u"
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry((a) =>
        wasm.__wbg_enrichedreply_free(a >>> 0, 1),
      );
class EnrichedReply {
  static __wrap(e) {
    e = e >>> 0;
    const f = Object.create(EnrichedReply.prototype);
    return (
      (f.__wbg_ptr = e),
      EnrichedReplyFinalization.register(f, f.__wbg_ptr, f),
      f
    );
  }
  __destroy_into_raw() {
    const e = this.__wbg_ptr;
    return (
      (this.__wbg_ptr = 0),
      EnrichedReplyFinalization.unregister(this),
      e
    );
  }
  free() {
    const e = this.__destroy_into_raw();
    wasm.__wbg_enrichedreply_free(e, 0);
  }
  get inReplyTo() {
    const e = wasm.enrichedreply_inReplyTo(this.__wbg_ptr);
    return e === 0 ? void 0 : DecodedMessage.__wrap(e);
  }
  get referenceId() {
    let e, f;
    try {
      const _ = wasm.enrichedreply_referenceId(this.__wbg_ptr);
      return ((e = _[0]), (f = _[1]), getStringFromWasm0(_[0], _[1]));
    } finally {
      wasm.__wbindgen_free(e, f, 1);
    }
  }
  get content() {
    const e = wasm.enrichedreply_content(this.__wbg_ptr);
    return DecodedMessageContent.__wrap(e);
  }
}
Symbol.dispose &&
  (EnrichedReply.prototype[Symbol.dispose] = EnrichedReply.prototype.free);
const GroupMemberFinalization =
  typeof FinalizationRegistry > "u"
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry((a) => wasm.__wbg_groupmember_free(a >>> 0, 1));
class GroupMember {
  __destroy_into_raw() {
    const e = this.__wbg_ptr;
    return ((this.__wbg_ptr = 0), GroupMemberFinalization.unregister(this), e);
  }
  free() {
    const e = this.__destroy_into_raw();
    wasm.__wbg_groupmember_free(e, 0);
  }
  constructor(e, f, _, w, v) {
    const S = passStringToWasm0(
        e,
        wasm.__wbindgen_malloc,
        wasm.__wbindgen_realloc,
      ),
      R = WASM_VECTOR_LEN,
      O = passArrayJsValueToWasm0(f, wasm.__wbindgen_malloc),
      j = WASM_VECTOR_LEN,
      F = passArrayJsValueToWasm0(_, wasm.__wbindgen_malloc),
      q = WASM_VECTOR_LEN,
      Q = wasm.groupmember_new(S, R, O, j, F, q, w, v);
    return (
      (this.__wbg_ptr = Q >>> 0),
      GroupMemberFinalization.register(this, this.__wbg_ptr, this),
      this
    );
  }
  get inboxId() {
    let e, f;
    try {
      const _ = wasm.__wbg_get_groupmember_inboxId(this.__wbg_ptr);
      return ((e = _[0]), (f = _[1]), getStringFromWasm0(_[0], _[1]));
    } finally {
      wasm.__wbindgen_free(e, f, 1);
    }
  }
  set inboxId(e) {
    const f = passStringToWasm0(
        e,
        wasm.__wbindgen_malloc,
        wasm.__wbindgen_realloc,
      ),
      _ = WASM_VECTOR_LEN;
    wasm.__wbg_set_groupmember_inboxId(this.__wbg_ptr, f, _);
  }
  get accountIdentifiers() {
    const e = wasm.__wbg_get_groupmember_accountIdentifiers(this.__wbg_ptr);
    var f = getArrayJsValueFromWasm0(e[0], e[1]).slice();
    return (wasm.__wbindgen_free(e[0], e[1] * 4, 4), f);
  }
  set accountIdentifiers(e) {
    const f = passArrayJsValueToWasm0(e, wasm.__wbindgen_malloc),
      _ = WASM_VECTOR_LEN;
    wasm.__wbg_set_groupmember_accountIdentifiers(this.__wbg_ptr, f, _);
  }
  get installationIds() {
    const e = wasm.__wbg_get_groupmember_installationIds(this.__wbg_ptr);
    var f = getArrayJsValueFromWasm0(e[0], e[1]).slice();
    return (wasm.__wbindgen_free(e[0], e[1] * 4, 4), f);
  }
  set installationIds(e) {
    const f = passArrayJsValueToWasm0(e, wasm.__wbindgen_malloc),
      _ = WASM_VECTOR_LEN;
    wasm.__wbg_set_groupmember_installationIds(this.__wbg_ptr, f, _);
  }
  get permissionLevel() {
    return wasm.__wbg_get_groupmember_permissionLevel(this.__wbg_ptr);
  }
  set permissionLevel(e) {
    wasm.__wbg_set_groupmember_permissionLevel(this.__wbg_ptr, e);
  }
  get consentState() {
    return wasm.__wbg_get_groupmember_consentState(this.__wbg_ptr);
  }
  set consentState(e) {
    wasm.__wbg_set_groupmember_consentState(this.__wbg_ptr, e);
  }
}
Symbol.dispose &&
  (GroupMember.prototype[Symbol.dispose] = GroupMember.prototype.free);
typeof FinalizationRegistry > "u" ||
  new FinalizationRegistry((a) => wasm.__wbg_groupmetadata_free(a >>> 0, 1));
const GroupPermissionsFinalization =
  typeof FinalizationRegistry > "u"
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry((a) =>
        wasm.__wbg_grouppermissions_free(a >>> 0, 1),
      );
class GroupPermissions {
  static __wrap(e) {
    e = e >>> 0;
    const f = Object.create(GroupPermissions.prototype);
    return (
      (f.__wbg_ptr = e),
      GroupPermissionsFinalization.register(f, f.__wbg_ptr, f),
      f
    );
  }
  __destroy_into_raw() {
    const e = this.__wbg_ptr;
    return (
      (this.__wbg_ptr = 0),
      GroupPermissionsFinalization.unregister(this),
      e
    );
  }
  free() {
    const e = this.__destroy_into_raw();
    wasm.__wbg_grouppermissions_free(e, 0);
  }
  policySet() {
    const e = wasm.grouppermissions_policySet(this.__wbg_ptr);
    if (e[2]) throw takeFromExternrefTable0(e[1]);
    return PermissionPolicySet.__wrap(e[0]);
  }
  policyType() {
    const e = wasm.grouppermissions_policyType(this.__wbg_ptr);
    if (e[2]) throw takeFromExternrefTable0(e[1]);
    return e[0];
  }
}
Symbol.dispose &&
  (GroupPermissions.prototype[Symbol.dispose] =
    GroupPermissions.prototype.free);
const GroupSyncSummaryFinalization =
  typeof FinalizationRegistry > "u"
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry((a) =>
        wasm.__wbg_groupsyncsummary_free(a >>> 0, 1),
      );
class GroupSyncSummary {
  static __wrap(e) {
    e = e >>> 0;
    const f = Object.create(GroupSyncSummary.prototype);
    return (
      (f.__wbg_ptr = e),
      GroupSyncSummaryFinalization.register(f, f.__wbg_ptr, f),
      f
    );
  }
  __destroy_into_raw() {
    const e = this.__wbg_ptr;
    return (
      (this.__wbg_ptr = 0),
      GroupSyncSummaryFinalization.unregister(this),
      e
    );
  }
  free() {
    const e = this.__destroy_into_raw();
    wasm.__wbg_groupsyncsummary_free(e, 0);
  }
  constructor(e, f) {
    const _ = wasm.groupsyncsummary_new(e, f);
    return (
      (this.__wbg_ptr = _ >>> 0),
      GroupSyncSummaryFinalization.register(this, this.__wbg_ptr, this),
      this
    );
  }
  get numEligible() {
    return wasm.__wbg_get_groupsyncsummary_numEligible(this.__wbg_ptr) >>> 0;
  }
  set numEligible(e) {
    wasm.__wbg_set_groupsyncsummary_numEligible(this.__wbg_ptr, e);
  }
  get numSynced() {
    return wasm.__wbg_get_groupsyncsummary_numSynced(this.__wbg_ptr) >>> 0;
  }
  set numSynced(e) {
    wasm.__wbg_set_groupsyncsummary_numSynced(this.__wbg_ptr, e);
  }
}
Symbol.dispose &&
  (GroupSyncSummary.prototype[Symbol.dispose] =
    GroupSyncSummary.prototype.free);
const GroupUpdatedFinalization =
  typeof FinalizationRegistry > "u"
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry((a) => wasm.__wbg_groupupdated_free(a >>> 0, 1));
class GroupUpdated {
  static __wrap(e) {
    e = e >>> 0;
    const f = Object.create(GroupUpdated.prototype);
    return (
      (f.__wbg_ptr = e),
      GroupUpdatedFinalization.register(f, f.__wbg_ptr, f),
      f
    );
  }
  __destroy_into_raw() {
    const e = this.__wbg_ptr;
    return ((this.__wbg_ptr = 0), GroupUpdatedFinalization.unregister(this), e);
  }
  free() {
    const e = this.__destroy_into_raw();
    wasm.__wbg_groupupdated_free(e, 0);
  }
  get initiatedByInboxId() {
    let e, f;
    try {
      const _ = wasm.__wbg_get_groupupdated_initiatedByInboxId(this.__wbg_ptr);
      return ((e = _[0]), (f = _[1]), getStringFromWasm0(_[0], _[1]));
    } finally {
      wasm.__wbindgen_free(e, f, 1);
    }
  }
  set initiatedByInboxId(e) {
    const f = passStringToWasm0(
        e,
        wasm.__wbindgen_malloc,
        wasm.__wbindgen_realloc,
      ),
      _ = WASM_VECTOR_LEN;
    wasm.__wbg_set_groupupdated_initiatedByInboxId(this.__wbg_ptr, f, _);
  }
  get addedInboxes() {
    const e = wasm.__wbg_get_groupupdated_addedInboxes(this.__wbg_ptr);
    var f = getArrayJsValueFromWasm0(e[0], e[1]).slice();
    return (wasm.__wbindgen_free(e[0], e[1] * 4, 4), f);
  }
  set addedInboxes(e) {
    const f = passArrayJsValueToWasm0(e, wasm.__wbindgen_malloc),
      _ = WASM_VECTOR_LEN;
    wasm.__wbg_set_groupupdated_addedInboxes(this.__wbg_ptr, f, _);
  }
  get removedInboxes() {
    const e = wasm.__wbg_get_groupupdated_removedInboxes(this.__wbg_ptr);
    var f = getArrayJsValueFromWasm0(e[0], e[1]).slice();
    return (wasm.__wbindgen_free(e[0], e[1] * 4, 4), f);
  }
  set removedInboxes(e) {
    const f = passArrayJsValueToWasm0(e, wasm.__wbindgen_malloc),
      _ = WASM_VECTOR_LEN;
    wasm.__wbg_set_groupupdated_removedInboxes(this.__wbg_ptr, f, _);
  }
  get leftInboxes() {
    const e = wasm.__wbg_get_groupupdated_leftInboxes(this.__wbg_ptr);
    var f = getArrayJsValueFromWasm0(e[0], e[1]).slice();
    return (wasm.__wbindgen_free(e[0], e[1] * 4, 4), f);
  }
  set leftInboxes(e) {
    const f = passArrayJsValueToWasm0(e, wasm.__wbindgen_malloc),
      _ = WASM_VECTOR_LEN;
    wasm.__wbg_set_groupupdated_leftInboxes(this.__wbg_ptr, f, _);
  }
  get metadataFieldChanges() {
    const e = wasm.__wbg_get_groupupdated_metadataFieldChanges(this.__wbg_ptr);
    var f = getArrayJsValueFromWasm0(e[0], e[1]).slice();
    return (wasm.__wbindgen_free(e[0], e[1] * 4, 4), f);
  }
  set metadataFieldChanges(e) {
    const f = passArrayJsValueToWasm0(e, wasm.__wbindgen_malloc),
      _ = WASM_VECTOR_LEN;
    wasm.__wbg_set_groupupdated_metadataFieldChanges(this.__wbg_ptr, f, _);
  }
  get addedAdminInboxes() {
    const e = wasm.__wbg_get_groupupdated_addedAdminInboxes(this.__wbg_ptr);
    var f = getArrayJsValueFromWasm0(e[0], e[1]).slice();
    return (wasm.__wbindgen_free(e[0], e[1] * 4, 4), f);
  }
  set addedAdminInboxes(e) {
    const f = passArrayJsValueToWasm0(e, wasm.__wbindgen_malloc),
      _ = WASM_VECTOR_LEN;
    wasm.__wbg_set_groupupdated_addedAdminInboxes(this.__wbg_ptr, f, _);
  }
  get removedAdminInboxes() {
    const e = wasm.__wbg_get_groupupdated_removedAdminInboxes(this.__wbg_ptr);
    var f = getArrayJsValueFromWasm0(e[0], e[1]).slice();
    return (wasm.__wbindgen_free(e[0], e[1] * 4, 4), f);
  }
  set removedAdminInboxes(e) {
    const f = passArrayJsValueToWasm0(e, wasm.__wbindgen_malloc),
      _ = WASM_VECTOR_LEN;
    wasm.__wbg_set_groupupdated_removedAdminInboxes(this.__wbg_ptr, f, _);
  }
  get addedSuperAdminInboxes() {
    const e = wasm.__wbg_get_groupupdated_addedSuperAdminInboxes(
      this.__wbg_ptr,
    );
    var f = getArrayJsValueFromWasm0(e[0], e[1]).slice();
    return (wasm.__wbindgen_free(e[0], e[1] * 4, 4), f);
  }
  set addedSuperAdminInboxes(e) {
    const f = passArrayJsValueToWasm0(e, wasm.__wbindgen_malloc),
      _ = WASM_VECTOR_LEN;
    wasm.__wbg_set_groupupdated_addedSuperAdminInboxes(this.__wbg_ptr, f, _);
  }
  get removedSuperAdminInboxes() {
    const e = wasm.__wbg_get_groupupdated_removedSuperAdminInboxes(
      this.__wbg_ptr,
    );
    var f = getArrayJsValueFromWasm0(e[0], e[1]).slice();
    return (wasm.__wbindgen_free(e[0], e[1] * 4, 4), f);
  }
  set removedSuperAdminInboxes(e) {
    const f = passArrayJsValueToWasm0(e, wasm.__wbindgen_malloc),
      _ = WASM_VECTOR_LEN;
    wasm.__wbg_set_groupupdated_removedSuperAdminInboxes(this.__wbg_ptr, f, _);
  }
}
Symbol.dispose &&
  (GroupUpdated.prototype[Symbol.dispose] = GroupUpdated.prototype.free);
const HmacKeyFinalization =
  typeof FinalizationRegistry > "u"
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry((a) => wasm.__wbg_hmackey_free(a >>> 0, 1));
class HmacKey {
  __destroy_into_raw() {
    const e = this.__wbg_ptr;
    return ((this.__wbg_ptr = 0), HmacKeyFinalization.unregister(this), e);
  }
  free() {
    const e = this.__destroy_into_raw();
    wasm.__wbg_hmackey_free(e, 0);
  }
  get key() {
    const e = wasm.__wbg_get_hmackey_key(this.__wbg_ptr);
    var f = getArrayU8FromWasm0(e[0], e[1]).slice();
    return (wasm.__wbindgen_free(e[0], e[1] * 1, 1), f);
  }
  set key(e) {
    const f = passArray8ToWasm0(e, wasm.__wbindgen_malloc),
      _ = WASM_VECTOR_LEN;
    wasm.__wbg_set_conversationdebuginfo_forkDetails(this.__wbg_ptr, f, _);
  }
  get epoch() {
    return wasm.__wbg_get_conversationdebuginfo_epoch(this.__wbg_ptr);
  }
  set epoch(e) {
    wasm.__wbg_set_conversationdebuginfo_epoch(this.__wbg_ptr, e);
  }
}
Symbol.dispose && (HmacKey.prototype[Symbol.dispose] = HmacKey.prototype.free);
const IdentityStatsFinalization =
  typeof FinalizationRegistry > "u"
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry((a) =>
        wasm.__wbg_identitystats_free(a >>> 0, 1),
      );
class IdentityStats {
  static __wrap(e) {
    e = e >>> 0;
    const f = Object.create(IdentityStats.prototype);
    return (
      (f.__wbg_ptr = e),
      IdentityStatsFinalization.register(f, f.__wbg_ptr, f),
      f
    );
  }
  __destroy_into_raw() {
    const e = this.__wbg_ptr;
    return (
      (this.__wbg_ptr = 0),
      IdentityStatsFinalization.unregister(this),
      e
    );
  }
  free() {
    const e = this.__destroy_into_raw();
    wasm.__wbg_identitystats_free(e, 0);
  }
  get publish_identity_update() {
    const e = wasm.__wbg_get_apistats_upload_key_package(this.__wbg_ptr);
    return BigInt.asUintN(64, e);
  }
  set publish_identity_update(e) {
    wasm.__wbg_set_apistats_upload_key_package(this.__wbg_ptr, e);
  }
  get get_identity_updates_v2() {
    const e = wasm.__wbg_get_apistats_fetch_key_package(this.__wbg_ptr);
    return BigInt.asUintN(64, e);
  }
  set get_identity_updates_v2(e) {
    wasm.__wbg_set_apistats_fetch_key_package(this.__wbg_ptr, e);
  }
  get get_inbox_ids() {
    const e = wasm.__wbg_get_apistats_send_group_messages(this.__wbg_ptr);
    return BigInt.asUintN(64, e);
  }
  set get_inbox_ids(e) {
    wasm.__wbg_set_apistats_send_group_messages(this.__wbg_ptr, e);
  }
  get verify_smart_contract_wallet_signature() {
    const e = wasm.__wbg_get_apistats_send_welcome_messages(this.__wbg_ptr);
    return BigInt.asUintN(64, e);
  }
  set verify_smart_contract_wallet_signature(e) {
    wasm.__wbg_set_apistats_send_welcome_messages(this.__wbg_ptr, e);
  }
}
Symbol.dispose &&
  (IdentityStats.prototype[Symbol.dispose] = IdentityStats.prototype.free);
const InboxFinalization =
  typeof FinalizationRegistry > "u"
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry((a) => wasm.__wbg_inbox_free(a >>> 0, 1));
class Inbox {
  static __wrap(e) {
    e = e >>> 0;
    const f = Object.create(Inbox.prototype);
    return (
      (f.__wbg_ptr = e),
      InboxFinalization.register(f, f.__wbg_ptr, f),
      f
    );
  }
  static __unwrap(e) {
    return e instanceof Inbox ? e.__destroy_into_raw() : 0;
  }
  __destroy_into_raw() {
    const e = this.__wbg_ptr;
    return ((this.__wbg_ptr = 0), InboxFinalization.unregister(this), e);
  }
  free() {
    const e = this.__destroy_into_raw();
    wasm.__wbg_inbox_free(e, 0);
  }
  get inboxId() {
    let e, f;
    try {
      const _ = wasm.__wbg_get_inbox_inboxId(this.__wbg_ptr);
      return ((e = _[0]), (f = _[1]), getStringFromWasm0(_[0], _[1]));
    } finally {
      wasm.__wbindgen_free(e, f, 1);
    }
  }
  set inboxId(e) {
    const f = passStringToWasm0(
        e,
        wasm.__wbindgen_malloc,
        wasm.__wbindgen_realloc,
      ),
      _ = WASM_VECTOR_LEN;
    wasm.__wbg_set_groupupdated_initiatedByInboxId(this.__wbg_ptr, f, _);
  }
}
Symbol.dispose && (Inbox.prototype[Symbol.dispose] = Inbox.prototype.free);
const InboxStateFinalization =
  typeof FinalizationRegistry > "u"
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry((a) => wasm.__wbg_inboxstate_free(a >>> 0, 1));
class InboxState {
  static __wrap(e) {
    e = e >>> 0;
    const f = Object.create(InboxState.prototype);
    return (
      (f.__wbg_ptr = e),
      InboxStateFinalization.register(f, f.__wbg_ptr, f),
      f
    );
  }
  __destroy_into_raw() {
    const e = this.__wbg_ptr;
    return ((this.__wbg_ptr = 0), InboxStateFinalization.unregister(this), e);
  }
  free() {
    const e = this.__destroy_into_raw();
    wasm.__wbg_inboxstate_free(e, 0);
  }
  constructor(e, f, _, w) {
    const v = passStringToWasm0(
        e,
        wasm.__wbindgen_malloc,
        wasm.__wbindgen_realloc,
      ),
      S = WASM_VECTOR_LEN,
      R = passArrayJsValueToWasm0(_, wasm.__wbindgen_malloc),
      O = WASM_VECTOR_LEN,
      j = passArrayJsValueToWasm0(w, wasm.__wbindgen_malloc),
      F = WASM_VECTOR_LEN,
      q = wasm.inboxstate_new(v, S, f, R, O, j, F);
    return (
      (this.__wbg_ptr = q >>> 0),
      InboxStateFinalization.register(this, this.__wbg_ptr, this),
      this
    );
  }
  get inboxId() {
    let e, f;
    try {
      const _ = wasm.__wbg_get_inboxstate_inboxId(this.__wbg_ptr);
      return ((e = _[0]), (f = _[1]), getStringFromWasm0(_[0], _[1]));
    } finally {
      wasm.__wbindgen_free(e, f, 1);
    }
  }
  set inboxId(e) {
    const f = passStringToWasm0(
        e,
        wasm.__wbindgen_malloc,
        wasm.__wbindgen_realloc,
      ),
      _ = WASM_VECTOR_LEN;
    wasm.__wbg_set_consent_entity(this.__wbg_ptr, f, _);
  }
  get recoveryIdentifier() {
    return wasm.__wbg_get_inboxstate_recoveryIdentifier(this.__wbg_ptr);
  }
  set recoveryIdentifier(e) {
    wasm.__wbg_set_inboxstate_recoveryIdentifier(this.__wbg_ptr, e);
  }
  get installations() {
    const e = wasm.__wbg_get_inboxstate_installations(this.__wbg_ptr);
    var f = getArrayJsValueFromWasm0(e[0], e[1]).slice();
    return (wasm.__wbindgen_free(e[0], e[1] * 4, 4), f);
  }
  set installations(e) {
    const f = passArrayJsValueToWasm0(e, wasm.__wbindgen_malloc),
      _ = WASM_VECTOR_LEN;
    wasm.__wbg_set_inboxstate_installations(this.__wbg_ptr, f, _);
  }
  get accountIdentifiers() {
    const e = wasm.__wbg_get_inboxstate_accountIdentifiers(this.__wbg_ptr);
    var f = getArrayJsValueFromWasm0(e[0], e[1]).slice();
    return (wasm.__wbindgen_free(e[0], e[1] * 4, 4), f);
  }
  set accountIdentifiers(e) {
    const f = passArrayJsValueToWasm0(e, wasm.__wbindgen_malloc),
      _ = WASM_VECTOR_LEN;
    wasm.__wbg_set_inboxstate_accountIdentifiers(this.__wbg_ptr, f, _);
  }
}
Symbol.dispose &&
  (InboxState.prototype[Symbol.dispose] = InboxState.prototype.free);
const InstallationFinalization =
  typeof FinalizationRegistry > "u"
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry((a) => wasm.__wbg_installation_free(a >>> 0, 1));
class Installation {
  static __wrap(e) {
    e = e >>> 0;
    const f = Object.create(Installation.prototype);
    return (
      (f.__wbg_ptr = e),
      InstallationFinalization.register(f, f.__wbg_ptr, f),
      f
    );
  }
  static __unwrap(e) {
    return e instanceof Installation ? e.__destroy_into_raw() : 0;
  }
  __destroy_into_raw() {
    const e = this.__wbg_ptr;
    return ((this.__wbg_ptr = 0), InstallationFinalization.unregister(this), e);
  }
  free() {
    const e = this.__destroy_into_raw();
    wasm.__wbg_installation_free(e, 0);
  }
  constructor(e, f, _) {
    const w = passStringToWasm0(
        f,
        wasm.__wbindgen_malloc,
        wasm.__wbindgen_realloc,
      ),
      v = WASM_VECTOR_LEN,
      S = wasm.installation_new(
        e,
        w,
        v,
        !isLikeNone(_),
        isLikeNone(_) ? BigInt(0) : _,
      );
    return (
      (this.__wbg_ptr = S >>> 0),
      InstallationFinalization.register(this, this.__wbg_ptr, this),
      this
    );
  }
  get bytes() {
    return wasm.__wbg_get_installation_bytes(this.__wbg_ptr);
  }
  set bytes(e) {
    wasm.__wbg_set_installation_bytes(this.__wbg_ptr, e);
  }
  get id() {
    let e, f;
    try {
      const _ = wasm.__wbg_get_installation_id(this.__wbg_ptr);
      return ((e = _[0]), (f = _[1]), getStringFromWasm0(_[0], _[1]));
    } finally {
      wasm.__wbindgen_free(e, f, 1);
    }
  }
  set id(e) {
    const f = passStringToWasm0(
        e,
        wasm.__wbindgen_malloc,
        wasm.__wbindgen_realloc,
      ),
      _ = WASM_VECTOR_LEN;
    wasm.__wbg_set_action_id(this.__wbg_ptr, f, _);
  }
  get clientTimestampNs() {
    const e = wasm.__wbg_get_installation_clientTimestampNs(this.__wbg_ptr);
    return e[0] === 0 ? void 0 : BigInt.asUintN(64, e[1]);
  }
  set clientTimestampNs(e) {
    wasm.__wbg_set_action_expiresAtNs(
      this.__wbg_ptr,
      !isLikeNone(e),
      isLikeNone(e) ? BigInt(0) : e,
    );
  }
}
Symbol.dispose &&
  (Installation.prototype[Symbol.dispose] = Installation.prototype.free);
const IntentFinalization =
  typeof FinalizationRegistry > "u"
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry((a) => wasm.__wbg_intent_free(a >>> 0, 1));
class Intent {
  static __wrap(e) {
    e = e >>> 0;
    const f = Object.create(Intent.prototype);
    return (
      (f.__wbg_ptr = e),
      IntentFinalization.register(f, f.__wbg_ptr, f),
      f
    );
  }
  __destroy_into_raw() {
    const e = this.__wbg_ptr;
    return ((this.__wbg_ptr = 0), IntentFinalization.unregister(this), e);
  }
  free() {
    const e = this.__destroy_into_raw();
    wasm.__wbg_intent_free(e, 0);
  }
  get id() {
    let e, f;
    try {
      const _ = wasm.__wbg_get_intent_id(this.__wbg_ptr);
      return ((e = _[0]), (f = _[1]), getStringFromWasm0(_[0], _[1]));
    } finally {
      wasm.__wbindgen_free(e, f, 1);
    }
  }
  set id(e) {
    const f = passStringToWasm0(
        e,
        wasm.__wbindgen_malloc,
        wasm.__wbindgen_realloc,
      ),
      _ = WASM_VECTOR_LEN;
    wasm.__wbg_set_attachment_mimeType(this.__wbg_ptr, f, _);
  }
  get actionId() {
    let e, f;
    try {
      const _ = wasm.__wbg_get_intent_actionId(this.__wbg_ptr);
      return ((e = _[0]), (f = _[1]), getStringFromWasm0(_[0], _[1]));
    } finally {
      wasm.__wbindgen_free(e, f, 1);
    }
  }
  set actionId(e) {
    const f = passStringToWasm0(
        e,
        wasm.__wbindgen_malloc,
        wasm.__wbindgen_realloc,
      ),
      _ = WASM_VECTOR_LEN;
    wasm.__wbg_set_attachment_content(this.__wbg_ptr, f, _);
  }
  get metadata() {
    return wasm.__wbg_get_intent_metadata(this.__wbg_ptr);
  }
  set metadata(e) {
    wasm.__wbg_set_intent_metadata(this.__wbg_ptr, e);
  }
  constructor(e, f, _) {
    const w = passStringToWasm0(
        e,
        wasm.__wbindgen_malloc,
        wasm.__wbindgen_realloc,
      ),
      v = WASM_VECTOR_LEN,
      S = passStringToWasm0(f, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc),
      R = WASM_VECTOR_LEN,
      O = wasm.intent_new(w, v, S, R, _);
    return (
      (this.__wbg_ptr = O >>> 0),
      IntentFinalization.register(this, this.__wbg_ptr, this),
      this
    );
  }
}
Symbol.dispose && (Intent.prototype[Symbol.dispose] = Intent.prototype.free);
typeof FinalizationRegistry > "u" ||
  new FinalizationRegistry((a) =>
    wasm.__wbg_intounderlyingbytesource_free(a >>> 0, 1),
  );
typeof FinalizationRegistry > "u" ||
  new FinalizationRegistry((a) =>
    wasm.__wbg_intounderlyingsink_free(a >>> 0, 1),
  );
typeof FinalizationRegistry > "u" ||
  new FinalizationRegistry((a) =>
    wasm.__wbg_intounderlyingsource_free(a >>> 0, 1),
  );
const KeyPackageStatusFinalization =
  typeof FinalizationRegistry > "u"
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry((a) =>
        wasm.__wbg_keypackagestatus_free(a >>> 0, 1),
      );
class KeyPackageStatus {
  __destroy_into_raw() {
    const e = this.__wbg_ptr;
    return (
      (this.__wbg_ptr = 0),
      KeyPackageStatusFinalization.unregister(this),
      e
    );
  }
  free() {
    const e = this.__destroy_into_raw();
    wasm.__wbg_keypackagestatus_free(e, 0);
  }
  get lifetime() {
    const e = wasm.__wbg_get_keypackagestatus_lifetime(this.__wbg_ptr);
    return e === 0 ? void 0 : Lifetime.__wrap(e);
  }
  set lifetime(e) {
    let f = 0;
    (isLikeNone(e) || (_assertClass(e, Lifetime), (f = e.__destroy_into_raw())),
      wasm.__wbg_set_keypackagestatus_lifetime(this.__wbg_ptr, f));
  }
  get validationError() {
    const e = wasm.__wbg_get_keypackagestatus_validationError(this.__wbg_ptr);
    let f;
    return (
      e[0] !== 0 &&
        ((f = getStringFromWasm0(e[0], e[1]).slice()),
        wasm.__wbindgen_free(e[0], e[1] * 1, 1)),
      f
    );
  }
  set validationError(e) {
    var f = isLikeNone(e)
        ? 0
        : passStringToWasm0(e, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc),
      _ = WASM_VECTOR_LEN;
    wasm.__wbg_set_keypackagestatus_validationError(this.__wbg_ptr, f, _);
  }
}
Symbol.dispose &&
  (KeyPackageStatus.prototype[Symbol.dispose] =
    KeyPackageStatus.prototype.free);
const LeaveRequestFinalization =
  typeof FinalizationRegistry > "u"
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry((a) => wasm.__wbg_leaverequest_free(a >>> 0, 1));
class LeaveRequest {
  static __wrap(e) {
    e = e >>> 0;
    const f = Object.create(LeaveRequest.prototype);
    return (
      (f.__wbg_ptr = e),
      LeaveRequestFinalization.register(f, f.__wbg_ptr, f),
      f
    );
  }
  __destroy_into_raw() {
    const e = this.__wbg_ptr;
    return ((this.__wbg_ptr = 0), LeaveRequestFinalization.unregister(this), e);
  }
  free() {
    const e = this.__destroy_into_raw();
    wasm.__wbg_leaverequest_free(e, 0);
  }
  get authenticatedNote() {
    return wasm.__wbg_get_leaverequest_authenticatedNote(this.__wbg_ptr);
  }
  set authenticatedNote(e) {
    wasm.__wbg_set_leaverequest_authenticatedNote(
      this.__wbg_ptr,
      isLikeNone(e) ? 0 : addToExternrefTable0(e),
    );
  }
}
Symbol.dispose &&
  (LeaveRequest.prototype[Symbol.dispose] = LeaveRequest.prototype.free);
const LifetimeFinalization =
  typeof FinalizationRegistry > "u"
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry((a) => wasm.__wbg_lifetime_free(a >>> 0, 1));
class Lifetime {
  static __wrap(e) {
    e = e >>> 0;
    const f = Object.create(Lifetime.prototype);
    return (
      (f.__wbg_ptr = e),
      LifetimeFinalization.register(f, f.__wbg_ptr, f),
      f
    );
  }
  __destroy_into_raw() {
    const e = this.__wbg_ptr;
    return ((this.__wbg_ptr = 0), LifetimeFinalization.unregister(this), e);
  }
  free() {
    const e = this.__destroy_into_raw();
    wasm.__wbg_lifetime_free(e, 0);
  }
  get not_before() {
    const e = wasm.__wbg_get_apistats_upload_key_package(this.__wbg_ptr);
    return BigInt.asUintN(64, e);
  }
  set not_before(e) {
    wasm.__wbg_set_apistats_upload_key_package(this.__wbg_ptr, e);
  }
  get not_after() {
    const e = wasm.__wbg_get_apistats_fetch_key_package(this.__wbg_ptr);
    return BigInt.asUintN(64, e);
  }
  set not_after(e) {
    wasm.__wbg_set_apistats_fetch_key_package(this.__wbg_ptr, e);
  }
}
Symbol.dispose &&
  (Lifetime.prototype[Symbol.dispose] = Lifetime.prototype.free);
const ListConversationsOptionsFinalization =
  typeof FinalizationRegistry > "u"
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry((a) =>
        wasm.__wbg_listconversationsoptions_free(a >>> 0, 1),
      );
class ListConversationsOptions {
  __destroy_into_raw() {
    const e = this.__wbg_ptr;
    return (
      (this.__wbg_ptr = 0),
      ListConversationsOptionsFinalization.unregister(this),
      e
    );
  }
  free() {
    const e = this.__destroy_into_raw();
    wasm.__wbg_listconversationsoptions_free(e, 0);
  }
  get consentStates() {
    const e = wasm.__wbg_get_listconversationsoptions_consentStates(
      this.__wbg_ptr,
    );
    let f;
    return (
      e[0] !== 0 &&
        ((f = getArrayJsValueFromWasm0(e[0], e[1]).slice()),
        wasm.__wbindgen_free(e[0], e[1] * 4, 4)),
      f
    );
  }
  set consentStates(e) {
    var f = isLikeNone(e)
        ? 0
        : passArrayJsValueToWasm0(e, wasm.__wbindgen_malloc),
      _ = WASM_VECTOR_LEN;
    wasm.__wbg_set_listconversationsoptions_consentStates(this.__wbg_ptr, f, _);
  }
  get conversationType() {
    const e = wasm.__wbg_get_listconversationsoptions_conversationType(
      this.__wbg_ptr,
    );
    return e === 4 ? void 0 : e;
  }
  set conversationType(e) {
    wasm.__wbg_set_listconversationsoptions_conversationType(
      this.__wbg_ptr,
      isLikeNone(e) ? 4 : e,
    );
  }
  get createdAfterNs() {
    const e = wasm.__wbg_get_listconversationsoptions_createdAfterNs(
      this.__wbg_ptr,
    );
    return e[0] === 0 ? void 0 : e[1];
  }
  set createdAfterNs(e) {
    wasm.__wbg_set_listconversationsoptions_createdAfterNs(
      this.__wbg_ptr,
      !isLikeNone(e),
      isLikeNone(e) ? BigInt(0) : e,
    );
  }
  get createdBeforeNs() {
    const e = wasm.__wbg_get_listconversationsoptions_createdBeforeNs(
      this.__wbg_ptr,
    );
    return e[0] === 0 ? void 0 : e[1];
  }
  set createdBeforeNs(e) {
    wasm.__wbg_set_listconversationsoptions_createdBeforeNs(
      this.__wbg_ptr,
      !isLikeNone(e),
      isLikeNone(e) ? BigInt(0) : e,
    );
  }
  get includeDuplicateDms() {
    const e = wasm.__wbg_get_listconversationsoptions_includeDuplicateDms(
      this.__wbg_ptr,
    );
    return e === 16777215 ? void 0 : e !== 0;
  }
  set includeDuplicateDms(e) {
    wasm.__wbg_set_listconversationsoptions_includeDuplicateDms(
      this.__wbg_ptr,
      isLikeNone(e) ? 16777215 : e ? 1 : 0,
    );
  }
  get orderBy() {
    const e = wasm.__wbg_get_listconversationsoptions_orderBy(this.__wbg_ptr);
    return e === 2 ? void 0 : e;
  }
  set orderBy(e) {
    wasm.__wbg_set_listconversationsoptions_orderBy(
      this.__wbg_ptr,
      isLikeNone(e) ? 2 : e,
    );
  }
  get limit() {
    const e = wasm.__wbg_get_listconversationsoptions_limit(this.__wbg_ptr);
    return e[0] === 0 ? void 0 : e[1];
  }
  set limit(e) {
    wasm.__wbg_set_listconversationsoptions_limit(
      this.__wbg_ptr,
      !isLikeNone(e),
      isLikeNone(e) ? BigInt(0) : e,
    );
  }
  constructor(e, f, _, w, v, S, R) {
    var O = isLikeNone(e)
        ? 0
        : passArrayJsValueToWasm0(e, wasm.__wbindgen_malloc),
      j = WASM_VECTOR_LEN;
    const F = wasm.listconversationsoptions_new(
      O,
      j,
      isLikeNone(f) ? 4 : f,
      !isLikeNone(_),
      isLikeNone(_) ? BigInt(0) : _,
      !isLikeNone(w),
      isLikeNone(w) ? BigInt(0) : w,
      isLikeNone(v) ? 16777215 : v ? 1 : 0,
      !isLikeNone(S),
      isLikeNone(S) ? BigInt(0) : S,
      isLikeNone(R) ? 2 : R,
    );
    return (
      (this.__wbg_ptr = F >>> 0),
      ListConversationsOptionsFinalization.register(this, this.__wbg_ptr, this),
      this
    );
  }
}
Symbol.dispose &&
  (ListConversationsOptions.prototype[Symbol.dispose] =
    ListConversationsOptions.prototype.free);
const ListMessagesOptionsFinalization =
  typeof FinalizationRegistry > "u"
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry((a) =>
        wasm.__wbg_listmessagesoptions_free(a >>> 0, 1),
      );
class ListMessagesOptions {
  __destroy_into_raw() {
    const e = this.__wbg_ptr;
    return (
      (this.__wbg_ptr = 0),
      ListMessagesOptionsFinalization.unregister(this),
      e
    );
  }
  free() {
    const e = this.__destroy_into_raw();
    wasm.__wbg_listmessagesoptions_free(e, 0);
  }
  constructor(e, f, _, w, v, S, R, O, j, F, q, Q) {
    var te = isLikeNone(S)
        ? 0
        : passArrayJsValueToWasm0(S, wasm.__wbindgen_malloc),
      se = WASM_VECTOR_LEN,
      re = isLikeNone(R)
        ? 0
        : passArrayJsValueToWasm0(R, wasm.__wbindgen_malloc),
      Oe = WASM_VECTOR_LEN,
      Le = isLikeNone(j)
        ? 0
        : passArrayJsValueToWasm0(j, wasm.__wbindgen_malloc),
      Be = WASM_VECTOR_LEN;
    const Ve = wasm.listmessagesoptions_new(
      !isLikeNone(e),
      isLikeNone(e) ? BigInt(0) : e,
      !isLikeNone(f),
      isLikeNone(f) ? BigInt(0) : f,
      !isLikeNone(_),
      isLikeNone(_) ? BigInt(0) : _,
      isLikeNone(w) ? 3 : w,
      isLikeNone(v) ? 2 : v,
      te,
      se,
      re,
      Oe,
      isLikeNone(O) ? 2 : O,
      Le,
      Be,
      isLikeNone(F) ? 2 : F,
      !isLikeNone(q),
      isLikeNone(q) ? BigInt(0) : q,
      !isLikeNone(Q),
      isLikeNone(Q) ? BigInt(0) : Q,
    );
    return (
      (this.__wbg_ptr = Ve >>> 0),
      ListMessagesOptionsFinalization.register(this, this.__wbg_ptr, this),
      this
    );
  }
  get contentTypes() {
    const e = wasm.__wbg_get_listmessagesoptions_contentTypes(this.__wbg_ptr);
    let f;
    return (
      e[0] !== 0 &&
        ((f = getArrayJsValueFromWasm0(e[0], e[1]).slice()),
        wasm.__wbindgen_free(e[0], e[1] * 4, 4)),
      f
    );
  }
  set contentTypes(e) {
    var f = isLikeNone(e)
        ? 0
        : passArrayJsValueToWasm0(e, wasm.__wbindgen_malloc),
      _ = WASM_VECTOR_LEN;
    wasm.__wbg_set_listmessagesoptions_contentTypes(this.__wbg_ptr, f, _);
  }
  get excludeContentTypes() {
    const e = wasm.__wbg_get_listmessagesoptions_excludeContentTypes(
      this.__wbg_ptr,
    );
    let f;
    return (
      e[0] !== 0 &&
        ((f = getArrayJsValueFromWasm0(e[0], e[1]).slice()),
        wasm.__wbindgen_free(e[0], e[1] * 4, 4)),
      f
    );
  }
  set excludeContentTypes(e) {
    var f = isLikeNone(e)
        ? 0
        : passArrayJsValueToWasm0(e, wasm.__wbindgen_malloc),
      _ = WASM_VECTOR_LEN;
    wasm.__wbg_set_listmessagesoptions_excludeContentTypes(
      this.__wbg_ptr,
      f,
      _,
    );
  }
  get sentBeforeNs() {
    const e = wasm.__wbg_get_listmessagesoptions_sentBeforeNs(this.__wbg_ptr);
    return e[0] === 0 ? void 0 : e[1];
  }
  set sentBeforeNs(e) {
    wasm.__wbg_set_listmessagesoptions_sentBeforeNs(
      this.__wbg_ptr,
      !isLikeNone(e),
      isLikeNone(e) ? BigInt(0) : e,
    );
  }
  get sentAfterNs() {
    const e = wasm.__wbg_get_listmessagesoptions_sentAfterNs(this.__wbg_ptr);
    return e[0] === 0 ? void 0 : e[1];
  }
  set sentAfterNs(e) {
    wasm.__wbg_set_listmessagesoptions_sentAfterNs(
      this.__wbg_ptr,
      !isLikeNone(e),
      isLikeNone(e) ? BigInt(0) : e,
    );
  }
  get limit() {
    const e = wasm.__wbg_get_listmessagesoptions_limit(this.__wbg_ptr);
    return e[0] === 0 ? void 0 : e[1];
  }
  set limit(e) {
    wasm.__wbg_set_listmessagesoptions_limit(
      this.__wbg_ptr,
      !isLikeNone(e),
      isLikeNone(e) ? BigInt(0) : e,
    );
  }
  get deliveryStatus() {
    const e = wasm.__wbg_get_listmessagesoptions_deliveryStatus(this.__wbg_ptr);
    return e === 3 ? void 0 : e;
  }
  set deliveryStatus(e) {
    wasm.__wbg_set_listmessagesoptions_deliveryStatus(
      this.__wbg_ptr,
      isLikeNone(e) ? 3 : e,
    );
  }
  get direction() {
    const e = wasm.__wbg_get_listmessagesoptions_direction(this.__wbg_ptr);
    return e === 2 ? void 0 : e;
  }
  set direction(e) {
    wasm.__wbg_set_listmessagesoptions_direction(
      this.__wbg_ptr,
      isLikeNone(e) ? 2 : e,
    );
  }
  get kind() {
    const e = wasm.__wbg_get_listmessagesoptions_kind(this.__wbg_ptr);
    return e === 2 ? void 0 : e;
  }
  set kind(e) {
    wasm.__wbg_set_listmessagesoptions_kind(
      this.__wbg_ptr,
      isLikeNone(e) ? 2 : e,
    );
  }
  get excludeSenderInboxIds() {
    const e = wasm.__wbg_get_listmessagesoptions_excludeSenderInboxIds(
      this.__wbg_ptr,
    );
    let f;
    return (
      e[0] !== 0 &&
        ((f = getArrayJsValueFromWasm0(e[0], e[1]).slice()),
        wasm.__wbindgen_free(e[0], e[1] * 4, 4)),
      f
    );
  }
  set excludeSenderInboxIds(e) {
    var f = isLikeNone(e)
        ? 0
        : passArrayJsValueToWasm0(e, wasm.__wbindgen_malloc),
      _ = WASM_VECTOR_LEN;
    wasm.__wbg_set_listmessagesoptions_excludeSenderInboxIds(
      this.__wbg_ptr,
      f,
      _,
    );
  }
  get sortBy() {
    const e = wasm.__wbg_get_listmessagesoptions_sortBy(this.__wbg_ptr);
    return e === 2 ? void 0 : e;
  }
  set sortBy(e) {
    wasm.__wbg_set_listmessagesoptions_sortBy(
      this.__wbg_ptr,
      isLikeNone(e) ? 2 : e,
    );
  }
  get insertedAfterNs() {
    const e = wasm.__wbg_get_listmessagesoptions_insertedAfterNs(
      this.__wbg_ptr,
    );
    return e[0] === 0 ? void 0 : e[1];
  }
  set insertedAfterNs(e) {
    wasm.__wbg_set_listmessagesoptions_insertedAfterNs(
      this.__wbg_ptr,
      !isLikeNone(e),
      isLikeNone(e) ? BigInt(0) : e,
    );
  }
  get insertedBeforeNs() {
    const e = wasm.__wbg_get_listmessagesoptions_insertedBeforeNs(
      this.__wbg_ptr,
    );
    return e[0] === 0 ? void 0 : e[1];
  }
  set insertedBeforeNs(e) {
    wasm.__wbg_set_listmessagesoptions_insertedBeforeNs(
      this.__wbg_ptr,
      !isLikeNone(e),
      isLikeNone(e) ? BigInt(0) : e,
    );
  }
}
Symbol.dispose &&
  (ListMessagesOptions.prototype[Symbol.dispose] =
    ListMessagesOptions.prototype.free);
const LogOptionsFinalization =
  typeof FinalizationRegistry > "u"
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry((a) => wasm.__wbg_logoptions_free(a >>> 0, 1));
class LogOptions {
  __destroy_into_raw() {
    const e = this.__wbg_ptr;
    return ((this.__wbg_ptr = 0), LogOptionsFinalization.unregister(this), e);
  }
  free() {
    const e = this.__destroy_into_raw();
    wasm.__wbg_logoptions_free(e, 0);
  }
  constructor(e, f, _) {
    const w = wasm.logoptions_new(
      e,
      f,
      isLikeNone(_) ? 7 : (__wbindgen_enum_LogLevel.indexOf(_) + 1 || 7) - 1,
    );
    return (
      (this.__wbg_ptr = w >>> 0),
      LogOptionsFinalization.register(this, this.__wbg_ptr, this),
      this
    );
  }
  get structured() {
    return wasm.__wbg_get_logoptions_structured(this.__wbg_ptr) !== 0;
  }
  set structured(e) {
    wasm.__wbg_set_logoptions_structured(this.__wbg_ptr, e);
  }
  get performance() {
    return wasm.__wbg_get_logoptions_performance(this.__wbg_ptr) !== 0;
  }
  set performance(e) {
    wasm.__wbg_set_logoptions_performance(this.__wbg_ptr, e);
  }
  get level() {
    const e = wasm.__wbg_get_logoptions_level(this.__wbg_ptr);
    return __wbindgen_enum_LogLevel[e];
  }
  set level(e) {
    wasm.__wbg_set_logoptions_level(
      this.__wbg_ptr,
      isLikeNone(e) ? 7 : (__wbindgen_enum_LogLevel.indexOf(e) + 1 || 7) - 1,
    );
  }
}
Symbol.dispose &&
  (LogOptions.prototype[Symbol.dispose] = LogOptions.prototype.free);
const MessageFinalization =
  typeof FinalizationRegistry > "u"
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry((a) => wasm.__wbg_message_free(a >>> 0, 1));
class Message {
  static __wrap(e) {
    e = e >>> 0;
    const f = Object.create(Message.prototype);
    return (
      (f.__wbg_ptr = e),
      MessageFinalization.register(f, f.__wbg_ptr, f),
      f
    );
  }
  static __unwrap(e) {
    return e instanceof Message ? e.__destroy_into_raw() : 0;
  }
  __destroy_into_raw() {
    const e = this.__wbg_ptr;
    return ((this.__wbg_ptr = 0), MessageFinalization.unregister(this), e);
  }
  free() {
    const e = this.__destroy_into_raw();
    wasm.__wbg_message_free(e, 0);
  }
  get id() {
    let e, f;
    try {
      const _ = wasm.__wbg_get_message_id(this.__wbg_ptr);
      return ((e = _[0]), (f = _[1]), getStringFromWasm0(_[0], _[1]));
    } finally {
      wasm.__wbindgen_free(e, f, 1);
    }
  }
  set id(e) {
    const f = passStringToWasm0(
        e,
        wasm.__wbindgen_malloc,
        wasm.__wbindgen_realloc,
      ),
      _ = WASM_VECTOR_LEN;
    wasm.__wbg_set_message_id(this.__wbg_ptr, f, _);
  }
  get sentAtNs() {
    return wasm.__wbg_get_message_sentAtNs(this.__wbg_ptr);
  }
  set sentAtNs(e) {
    wasm.__wbg_set_message_sentAtNs(this.__wbg_ptr, e);
  }
  get convoId() {
    let e, f;
    try {
      const _ = wasm.__wbg_get_message_convoId(this.__wbg_ptr);
      return ((e = _[0]), (f = _[1]), getStringFromWasm0(_[0], _[1]));
    } finally {
      wasm.__wbindgen_free(e, f, 1);
    }
  }
  set convoId(e) {
    const f = passStringToWasm0(
        e,
        wasm.__wbindgen_malloc,
        wasm.__wbindgen_realloc,
      ),
      _ = WASM_VECTOR_LEN;
    wasm.__wbg_set_message_convoId(this.__wbg_ptr, f, _);
  }
  get senderInboxId() {
    let e, f;
    try {
      const _ = wasm.__wbg_get_message_senderInboxId(this.__wbg_ptr);
      return ((e = _[0]), (f = _[1]), getStringFromWasm0(_[0], _[1]));
    } finally {
      wasm.__wbindgen_free(e, f, 1);
    }
  }
  set senderInboxId(e) {
    const f = passStringToWasm0(
        e,
        wasm.__wbindgen_malloc,
        wasm.__wbindgen_realloc,
      ),
      _ = WASM_VECTOR_LEN;
    wasm.__wbg_set_message_senderInboxId(this.__wbg_ptr, f, _);
  }
  get content() {
    const e = wasm.__wbg_get_message_content(this.__wbg_ptr);
    return EncodedContent.__wrap(e);
  }
  set content(e) {
    _assertClass(e, EncodedContent);
    var f = e.__destroy_into_raw();
    wasm.__wbg_set_message_content(this.__wbg_ptr, f);
  }
  get kind() {
    return wasm.__wbg_get_message_kind(this.__wbg_ptr);
  }
  set kind(e) {
    wasm.__wbg_set_message_kind(this.__wbg_ptr, e);
  }
  get deliveryStatus() {
    return wasm.__wbg_get_message_deliveryStatus(this.__wbg_ptr);
  }
  set deliveryStatus(e) {
    wasm.__wbg_set_message_deliveryStatus(this.__wbg_ptr, e);
  }
  constructor(e, f, _, w, v, S, R) {
    const O = passStringToWasm0(
        e,
        wasm.__wbindgen_malloc,
        wasm.__wbindgen_realloc,
      ),
      j = WASM_VECTOR_LEN,
      F = passStringToWasm0(_, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc),
      q = WASM_VECTOR_LEN,
      Q = passStringToWasm0(w, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc),
      te = WASM_VECTOR_LEN;
    _assertClass(v, EncodedContent);
    var se = v.__destroy_into_raw();
    const re = wasm.message_new(O, j, f, F, q, Q, te, se, S, R);
    return (
      (this.__wbg_ptr = re >>> 0),
      MessageFinalization.register(this, this.__wbg_ptr, this),
      this
    );
  }
}
Symbol.dispose && (Message.prototype[Symbol.dispose] = Message.prototype.free);
const MessageDisappearingSettingsFinalization =
  typeof FinalizationRegistry > "u"
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry((a) =>
        wasm.__wbg_messagedisappearingsettings_free(a >>> 0, 1),
      );
class MessageDisappearingSettings {
  static __wrap(e) {
    e = e >>> 0;
    const f = Object.create(MessageDisappearingSettings.prototype);
    return (
      (f.__wbg_ptr = e),
      MessageDisappearingSettingsFinalization.register(f, f.__wbg_ptr, f),
      f
    );
  }
  __destroy_into_raw() {
    const e = this.__wbg_ptr;
    return (
      (this.__wbg_ptr = 0),
      MessageDisappearingSettingsFinalization.unregister(this),
      e
    );
  }
  free() {
    const e = this.__destroy_into_raw();
    wasm.__wbg_messagedisappearingsettings_free(e, 0);
  }
  get fromNs() {
    return wasm.__wbg_get_conversationdebuginfo_epoch(this.__wbg_ptr);
  }
  set fromNs(e) {
    wasm.__wbg_set_conversationdebuginfo_epoch(this.__wbg_ptr, e);
  }
  get inNs() {
    return wasm.__wbg_get_messagedisappearingsettings_inNs(this.__wbg_ptr);
  }
  set inNs(e) {
    wasm.__wbg_set_messagedisappearingsettings_inNs(this.__wbg_ptr, e);
  }
  constructor(e, f) {
    const _ = wasm.messagedisappearingsettings_new(e, f);
    return (
      (this.__wbg_ptr = _ >>> 0),
      MessageDisappearingSettingsFinalization.register(
        this,
        this.__wbg_ptr,
        this,
      ),
      this
    );
  }
}
Symbol.dispose &&
  (MessageDisappearingSettings.prototype[Symbol.dispose] =
    MessageDisappearingSettings.prototype.free);
const MessageWithReactionsFinalization =
  typeof FinalizationRegistry > "u"
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry((a) =>
        wasm.__wbg_messagewithreactions_free(a >>> 0, 1),
      );
class MessageWithReactions {
  static __wrap(e) {
    e = e >>> 0;
    const f = Object.create(MessageWithReactions.prototype);
    return (
      (f.__wbg_ptr = e),
      MessageWithReactionsFinalization.register(f, f.__wbg_ptr, f),
      f
    );
  }
  __destroy_into_raw() {
    const e = this.__wbg_ptr;
    return (
      (this.__wbg_ptr = 0),
      MessageWithReactionsFinalization.unregister(this),
      e
    );
  }
  free() {
    const e = this.__destroy_into_raw();
    wasm.__wbg_messagewithreactions_free(e, 0);
  }
  get message() {
    const e = wasm.__wbg_get_messagewithreactions_message(this.__wbg_ptr);
    return Message.__wrap(e);
  }
  set message(e) {
    _assertClass(e, Message);
    var f = e.__destroy_into_raw();
    wasm.__wbg_set_messagewithreactions_message(this.__wbg_ptr, f);
  }
  get reactions() {
    const e = wasm.__wbg_get_messagewithreactions_reactions(this.__wbg_ptr);
    var f = getArrayJsValueFromWasm0(e[0], e[1]).slice();
    return (wasm.__wbindgen_free(e[0], e[1] * 4, 4), f);
  }
  set reactions(e) {
    const f = passArrayJsValueToWasm0(e, wasm.__wbindgen_malloc),
      _ = WASM_VECTOR_LEN;
    wasm.__wbg_set_messagewithreactions_reactions(this.__wbg_ptr, f, _);
  }
}
Symbol.dispose &&
  (MessageWithReactions.prototype[Symbol.dispose] =
    MessageWithReactions.prototype.free);
const MetadataFieldChangeFinalization =
  typeof FinalizationRegistry > "u"
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry((a) =>
        wasm.__wbg_metadatafieldchange_free(a >>> 0, 1),
      );
class MetadataFieldChange {
  static __wrap(e) {
    e = e >>> 0;
    const f = Object.create(MetadataFieldChange.prototype);
    return (
      (f.__wbg_ptr = e),
      MetadataFieldChangeFinalization.register(f, f.__wbg_ptr, f),
      f
    );
  }
  static __unwrap(e) {
    return e instanceof MetadataFieldChange ? e.__destroy_into_raw() : 0;
  }
  __destroy_into_raw() {
    const e = this.__wbg_ptr;
    return (
      (this.__wbg_ptr = 0),
      MetadataFieldChangeFinalization.unregister(this),
      e
    );
  }
  free() {
    const e = this.__destroy_into_raw();
    wasm.__wbg_metadatafieldchange_free(e, 0);
  }
  get fieldName() {
    let e, f;
    try {
      const _ = wasm.__wbg_get_metadatafieldchange_fieldName(this.__wbg_ptr);
      return ((e = _[0]), (f = _[1]), getStringFromWasm0(_[0], _[1]));
    } finally {
      wasm.__wbindgen_free(e, f, 1);
    }
  }
  set fieldName(e) {
    const f = passStringToWasm0(
        e,
        wasm.__wbindgen_malloc,
        wasm.__wbindgen_realloc,
      ),
      _ = WASM_VECTOR_LEN;
    wasm.__wbg_set_groupupdated_initiatedByInboxId(this.__wbg_ptr, f, _);
  }
  get oldValue() {
    const e = wasm.__wbg_get_metadatafieldchange_oldValue(this.__wbg_ptr);
    let f;
    return (
      e[0] !== 0 &&
        ((f = getStringFromWasm0(e[0], e[1]).slice()),
        wasm.__wbindgen_free(e[0], e[1] * 1, 1)),
      f
    );
  }
  set oldValue(e) {
    var f = isLikeNone(e)
        ? 0
        : passStringToWasm0(e, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc),
      _ = WASM_VECTOR_LEN;
    wasm.__wbg_set_metadatafieldchange_oldValue(this.__wbg_ptr, f, _);
  }
  get newValue() {
    const e = wasm.__wbg_get_metadatafieldchange_newValue(this.__wbg_ptr);
    let f;
    return (
      e[0] !== 0 &&
        ((f = getStringFromWasm0(e[0], e[1]).slice()),
        wasm.__wbindgen_free(e[0], e[1] * 1, 1)),
      f
    );
  }
  set newValue(e) {
    var f = isLikeNone(e)
        ? 0
        : passStringToWasm0(e, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc),
      _ = WASM_VECTOR_LEN;
    wasm.__wbg_set_metadatafieldchange_newValue(this.__wbg_ptr, f, _);
  }
}
Symbol.dispose &&
  (MetadataFieldChange.prototype[Symbol.dispose] =
    MetadataFieldChange.prototype.free);
const MultiRemoteAttachmentFinalization =
  typeof FinalizationRegistry > "u"
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry((a) =>
        wasm.__wbg_multiremoteattachment_free(a >>> 0, 1),
      );
class MultiRemoteAttachment {
  static __wrap(e) {
    e = e >>> 0;
    const f = Object.create(MultiRemoteAttachment.prototype);
    return (
      (f.__wbg_ptr = e),
      MultiRemoteAttachmentFinalization.register(f, f.__wbg_ptr, f),
      f
    );
  }
  __destroy_into_raw() {
    const e = this.__wbg_ptr;
    return (
      (this.__wbg_ptr = 0),
      MultiRemoteAttachmentFinalization.unregister(this),
      e
    );
  }
  free() {
    const e = this.__destroy_into_raw();
    wasm.__wbg_multiremoteattachment_free(e, 0);
  }
  get attachments() {
    const e = wasm.__wbg_get_multiremoteattachment_attachments(this.__wbg_ptr);
    var f = getArrayJsValueFromWasm0(e[0], e[1]).slice();
    return (wasm.__wbindgen_free(e[0], e[1] * 4, 4), f);
  }
  set attachments(e) {
    const f = passArrayJsValueToWasm0(e, wasm.__wbindgen_malloc),
      _ = WASM_VECTOR_LEN;
    wasm.__wbg_set_multiremoteattachment_attachments(this.__wbg_ptr, f, _);
  }
  constructor(e) {
    const f = passArrayJsValueToWasm0(e, wasm.__wbindgen_malloc),
      _ = WASM_VECTOR_LEN,
      w = wasm.multiremoteattachment_new(f, _);
    return (
      (this.__wbg_ptr = w >>> 0),
      MultiRemoteAttachmentFinalization.register(this, this.__wbg_ptr, this),
      this
    );
  }
}
Symbol.dispose &&
  (MultiRemoteAttachment.prototype[Symbol.dispose] =
    MultiRemoteAttachment.prototype.free);
typeof FinalizationRegistry > "u" ||
  new FinalizationRegistry((a) => wasm.__wbg_opfs_free(a >>> 0, 1));
typeof FinalizationRegistry > "u" ||
  new FinalizationRegistry((a) => wasm.__wbg_passkeysignature_free(a >>> 0, 1));
const PermissionPolicySetFinalization =
  typeof FinalizationRegistry > "u"
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry((a) =>
        wasm.__wbg_permissionpolicyset_free(a >>> 0, 1),
      );
class PermissionPolicySet {
  static __wrap(e) {
    e = e >>> 0;
    const f = Object.create(PermissionPolicySet.prototype);
    return (
      (f.__wbg_ptr = e),
      PermissionPolicySetFinalization.register(f, f.__wbg_ptr, f),
      f
    );
  }
  __destroy_into_raw() {
    const e = this.__wbg_ptr;
    return (
      (this.__wbg_ptr = 0),
      PermissionPolicySetFinalization.unregister(this),
      e
    );
  }
  free() {
    const e = this.__destroy_into_raw();
    wasm.__wbg_permissionpolicyset_free(e, 0);
  }
  constructor(e, f, _, w, v, S, R, O) {
    const j = wasm.permissionpolicyset_new(e, f, _, w, v, S, R, O);
    return (
      (this.__wbg_ptr = j >>> 0),
      PermissionPolicySetFinalization.register(this, this.__wbg_ptr, this),
      this
    );
  }
  get addMemberPolicy() {
    return wasm.__wbg_get_permissionpolicyset_addMemberPolicy(this.__wbg_ptr);
  }
  set addMemberPolicy(e) {
    wasm.__wbg_set_permissionpolicyset_addMemberPolicy(this.__wbg_ptr, e);
  }
  get removeMemberPolicy() {
    return wasm.__wbg_get_permissionpolicyset_removeMemberPolicy(
      this.__wbg_ptr,
    );
  }
  set removeMemberPolicy(e) {
    wasm.__wbg_set_permissionpolicyset_removeMemberPolicy(this.__wbg_ptr, e);
  }
  get addAdminPolicy() {
    return wasm.__wbg_get_permissionpolicyset_addAdminPolicy(this.__wbg_ptr);
  }
  set addAdminPolicy(e) {
    wasm.__wbg_set_permissionpolicyset_addAdminPolicy(this.__wbg_ptr, e);
  }
  get removeAdminPolicy() {
    return wasm.__wbg_get_permissionpolicyset_removeAdminPolicy(this.__wbg_ptr);
  }
  set removeAdminPolicy(e) {
    wasm.__wbg_set_permissionpolicyset_removeAdminPolicy(this.__wbg_ptr, e);
  }
  get updateGroupNamePolicy() {
    return wasm.__wbg_get_permissionpolicyset_updateGroupNamePolicy(
      this.__wbg_ptr,
    );
  }
  set updateGroupNamePolicy(e) {
    wasm.__wbg_set_permissionpolicyset_updateGroupNamePolicy(this.__wbg_ptr, e);
  }
  get updateGroupDescriptionPolicy() {
    return wasm.__wbg_get_permissionpolicyset_updateGroupDescriptionPolicy(
      this.__wbg_ptr,
    );
  }
  set updateGroupDescriptionPolicy(e) {
    wasm.__wbg_set_permissionpolicyset_updateGroupDescriptionPolicy(
      this.__wbg_ptr,
      e,
    );
  }
  get updateGroupImageUrlSquarePolicy() {
    return wasm.__wbg_get_permissionpolicyset_updateGroupImageUrlSquarePolicy(
      this.__wbg_ptr,
    );
  }
  set updateGroupImageUrlSquarePolicy(e) {
    wasm.__wbg_set_permissionpolicyset_updateGroupImageUrlSquarePolicy(
      this.__wbg_ptr,
      e,
    );
  }
  get updateMessageDisappearingPolicy() {
    return wasm.__wbg_get_permissionpolicyset_updateMessageDisappearingPolicy(
      this.__wbg_ptr,
    );
  }
  set updateMessageDisappearingPolicy(e) {
    wasm.__wbg_set_permissionpolicyset_updateMessageDisappearingPolicy(
      this.__wbg_ptr,
      e,
    );
  }
}
Symbol.dispose &&
  (PermissionPolicySet.prototype[Symbol.dispose] =
    PermissionPolicySet.prototype.free);
const ReactionFinalization =
  typeof FinalizationRegistry > "u"
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry((a) => wasm.__wbg_reaction_free(a >>> 0, 1));
class Reaction {
  static __wrap(e) {
    e = e >>> 0;
    const f = Object.create(Reaction.prototype);
    return (
      (f.__wbg_ptr = e),
      ReactionFinalization.register(f, f.__wbg_ptr, f),
      f
    );
  }
  __destroy_into_raw() {
    const e = this.__wbg_ptr;
    return ((this.__wbg_ptr = 0), ReactionFinalization.unregister(this), e);
  }
  free() {
    const e = this.__destroy_into_raw();
    wasm.__wbg_reaction_free(e, 0);
  }
  get reference() {
    let e, f;
    try {
      const _ = wasm.__wbg_get_reaction_reference(this.__wbg_ptr);
      return ((e = _[0]), (f = _[1]), getStringFromWasm0(_[0], _[1]));
    } finally {
      wasm.__wbindgen_free(e, f, 1);
    }
  }
  set reference(e) {
    const f = passStringToWasm0(
        e,
        wasm.__wbindgen_malloc,
        wasm.__wbindgen_realloc,
      ),
      _ = WASM_VECTOR_LEN;
    wasm.__wbg_set_consent_entity(this.__wbg_ptr, f, _);
  }
  get referenceInboxId() {
    let e, f;
    try {
      const _ = wasm.__wbg_get_reaction_referenceInboxId(this.__wbg_ptr);
      return ((e = _[0]), (f = _[1]), getStringFromWasm0(_[0], _[1]));
    } finally {
      wasm.__wbindgen_free(e, f, 1);
    }
  }
  set referenceInboxId(e) {
    const f = passStringToWasm0(
        e,
        wasm.__wbindgen_malloc,
        wasm.__wbindgen_realloc,
      ),
      _ = WASM_VECTOR_LEN;
    wasm.__wbg_set_reaction_referenceInboxId(this.__wbg_ptr, f, _);
  }
  get action() {
    return wasm.__wbg_get_reaction_action(this.__wbg_ptr);
  }
  set action(e) {
    wasm.__wbg_set_reaction_action(this.__wbg_ptr, e);
  }
  get content() {
    let e, f;
    try {
      const _ = wasm.__wbg_get_reaction_content(this.__wbg_ptr);
      return ((e = _[0]), (f = _[1]), getStringFromWasm0(_[0], _[1]));
    } finally {
      wasm.__wbindgen_free(e, f, 1);
    }
  }
  set content(e) {
    const f = passStringToWasm0(
        e,
        wasm.__wbindgen_malloc,
        wasm.__wbindgen_realloc,
      ),
      _ = WASM_VECTOR_LEN;
    wasm.__wbg_set_reaction_content(this.__wbg_ptr, f, _);
  }
  get schema() {
    return wasm.__wbg_get_reaction_schema(this.__wbg_ptr);
  }
  set schema(e) {
    wasm.__wbg_set_reaction_schema(this.__wbg_ptr, e);
  }
  constructor(e, f, _, w, v) {
    const S = passStringToWasm0(
        e,
        wasm.__wbindgen_malloc,
        wasm.__wbindgen_realloc,
      ),
      R = WASM_VECTOR_LEN,
      O = passStringToWasm0(f, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc),
      j = WASM_VECTOR_LEN,
      F = passStringToWasm0(w, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc),
      q = WASM_VECTOR_LEN,
      Q = wasm.reaction_new(S, R, O, j, _, F, q, v);
    return (
      (this.__wbg_ptr = Q >>> 0),
      ReactionFinalization.register(this, this.__wbg_ptr, this),
      this
    );
  }
}
Symbol.dispose &&
  (Reaction.prototype[Symbol.dispose] = Reaction.prototype.free);
const ReactionPayloadFinalization =
  typeof FinalizationRegistry > "u"
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry((a) =>
        wasm.__wbg_reactionpayload_free(a >>> 0, 1),
      );
class ReactionPayload {
  static __wrap(e) {
    e = e >>> 0;
    const f = Object.create(ReactionPayload.prototype);
    return (
      (f.__wbg_ptr = e),
      ReactionPayloadFinalization.register(f, f.__wbg_ptr, f),
      f
    );
  }
  __destroy_into_raw() {
    const e = this.__wbg_ptr;
    return (
      (this.__wbg_ptr = 0),
      ReactionPayloadFinalization.unregister(this),
      e
    );
  }
  free() {
    const e = this.__destroy_into_raw();
    wasm.__wbg_reactionpayload_free(e, 0);
  }
  get reference() {
    let e, f;
    try {
      const _ = wasm.__wbg_get_reactionpayload_reference(this.__wbg_ptr);
      return ((e = _[0]), (f = _[1]), getStringFromWasm0(_[0], _[1]));
    } finally {
      wasm.__wbindgen_free(e, f, 1);
    }
  }
  set reference(e) {
    const f = passStringToWasm0(
        e,
        wasm.__wbindgen_malloc,
        wasm.__wbindgen_realloc,
      ),
      _ = WASM_VECTOR_LEN;
    wasm.__wbg_set_consent_entity(this.__wbg_ptr, f, _);
  }
  get referenceInboxId() {
    let e, f;
    try {
      const _ = wasm.__wbg_get_reactionpayload_referenceInboxId(this.__wbg_ptr);
      return ((e = _[0]), (f = _[1]), getStringFromWasm0(_[0], _[1]));
    } finally {
      wasm.__wbindgen_free(e, f, 1);
    }
  }
  set referenceInboxId(e) {
    const f = passStringToWasm0(
        e,
        wasm.__wbindgen_malloc,
        wasm.__wbindgen_realloc,
      ),
      _ = WASM_VECTOR_LEN;
    wasm.__wbg_set_reaction_referenceInboxId(this.__wbg_ptr, f, _);
  }
  get action() {
    return wasm.__wbg_get_reaction_action(this.__wbg_ptr);
  }
  set action(e) {
    wasm.__wbg_set_reaction_action(this.__wbg_ptr, e);
  }
  get content() {
    let e, f;
    try {
      const _ = wasm.__wbg_get_reactionpayload_content(this.__wbg_ptr);
      return ((e = _[0]), (f = _[1]), getStringFromWasm0(_[0], _[1]));
    } finally {
      wasm.__wbindgen_free(e, f, 1);
    }
  }
  set content(e) {
    const f = passStringToWasm0(
        e,
        wasm.__wbindgen_malloc,
        wasm.__wbindgen_realloc,
      ),
      _ = WASM_VECTOR_LEN;
    wasm.__wbg_set_reaction_content(this.__wbg_ptr, f, _);
  }
  get schema() {
    return wasm.__wbg_get_reaction_schema(this.__wbg_ptr);
  }
  set schema(e) {
    wasm.__wbg_set_reaction_schema(this.__wbg_ptr, e);
  }
}
Symbol.dispose &&
  (ReactionPayload.prototype[Symbol.dispose] = ReactionPayload.prototype.free);
const ReadReceiptFinalization =
  typeof FinalizationRegistry > "u"
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry((a) => wasm.__wbg_readreceipt_free(a >>> 0, 1));
class ReadReceipt {
  static __wrap(e) {
    e = e >>> 0;
    const f = Object.create(ReadReceipt.prototype);
    return (
      (f.__wbg_ptr = e),
      ReadReceiptFinalization.register(f, f.__wbg_ptr, f),
      f
    );
  }
  __destroy_into_raw() {
    const e = this.__wbg_ptr;
    return ((this.__wbg_ptr = 0), ReadReceiptFinalization.unregister(this), e);
  }
  free() {
    const e = this.__destroy_into_raw();
    wasm.__wbg_readreceipt_free(e, 0);
  }
}
Symbol.dispose &&
  (ReadReceipt.prototype[Symbol.dispose] = ReadReceipt.prototype.free);
const RemoteAttachmentFinalization =
  typeof FinalizationRegistry > "u"
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry((a) =>
        wasm.__wbg_remoteattachment_free(a >>> 0, 1),
      );
class RemoteAttachment {
  static __wrap(e) {
    e = e >>> 0;
    const f = Object.create(RemoteAttachment.prototype);
    return (
      (f.__wbg_ptr = e),
      RemoteAttachmentFinalization.register(f, f.__wbg_ptr, f),
      f
    );
  }
  __destroy_into_raw() {
    const e = this.__wbg_ptr;
    return (
      (this.__wbg_ptr = 0),
      RemoteAttachmentFinalization.unregister(this),
      e
    );
  }
  free() {
    const e = this.__destroy_into_raw();
    wasm.__wbg_remoteattachment_free(e, 0);
  }
  get url() {
    let e, f;
    try {
      const _ = wasm.__wbg_get_remoteattachment_url(this.__wbg_ptr);
      return ((e = _[0]), (f = _[1]), getStringFromWasm0(_[0], _[1]));
    } finally {
      wasm.__wbindgen_free(e, f, 1);
    }
  }
  set url(e) {
    const f = passStringToWasm0(
        e,
        wasm.__wbindgen_malloc,
        wasm.__wbindgen_realloc,
      ),
      _ = WASM_VECTOR_LEN;
    wasm.__wbg_set_attachment_mimeType(this.__wbg_ptr, f, _);
  }
  get contentDigest() {
    let e, f;
    try {
      const _ = wasm.__wbg_get_remoteattachment_contentDigest(this.__wbg_ptr);
      return ((e = _[0]), (f = _[1]), getStringFromWasm0(_[0], _[1]));
    } finally {
      wasm.__wbindgen_free(e, f, 1);
    }
  }
  set contentDigest(e) {
    const f = passStringToWasm0(
        e,
        wasm.__wbindgen_malloc,
        wasm.__wbindgen_realloc,
      ),
      _ = WASM_VECTOR_LEN;
    wasm.__wbg_set_attachment_content(this.__wbg_ptr, f, _);
  }
  get secret() {
    const e = wasm.__wbg_get_remoteattachment_secret(this.__wbg_ptr);
    var f = getArrayU8FromWasm0(e[0], e[1]).slice();
    return (wasm.__wbindgen_free(e[0], e[1] * 1, 1), f);
  }
  set secret(e) {
    const f = passArray8ToWasm0(e, wasm.__wbindgen_malloc),
      _ = WASM_VECTOR_LEN;
    wasm.__wbg_set_remoteattachment_secret(this.__wbg_ptr, f, _);
  }
  get salt() {
    const e = wasm.__wbg_get_remoteattachment_salt(this.__wbg_ptr);
    var f = getArrayU8FromWasm0(e[0], e[1]).slice();
    return (wasm.__wbindgen_free(e[0], e[1] * 1, 1), f);
  }
  set salt(e) {
    const f = passArray8ToWasm0(e, wasm.__wbindgen_malloc),
      _ = WASM_VECTOR_LEN;
    wasm.__wbg_set_remoteattachment_salt(this.__wbg_ptr, f, _);
  }
  get nonce() {
    const e = wasm.__wbg_get_remoteattachment_nonce(this.__wbg_ptr);
    var f = getArrayU8FromWasm0(e[0], e[1]).slice();
    return (wasm.__wbindgen_free(e[0], e[1] * 1, 1), f);
  }
  set nonce(e) {
    const f = passArray8ToWasm0(e, wasm.__wbindgen_malloc),
      _ = WASM_VECTOR_LEN;
    wasm.__wbg_set_remoteattachment_nonce(this.__wbg_ptr, f, _);
  }
  get scheme() {
    let e, f;
    try {
      const _ = wasm.__wbg_get_remoteattachment_scheme(this.__wbg_ptr);
      return ((e = _[0]), (f = _[1]), getStringFromWasm0(_[0], _[1]));
    } finally {
      wasm.__wbindgen_free(e, f, 1);
    }
  }
  set scheme(e) {
    const f = passStringToWasm0(
        e,
        wasm.__wbindgen_malloc,
        wasm.__wbindgen_realloc,
      ),
      _ = WASM_VECTOR_LEN;
    wasm.__wbg_set_remoteattachment_scheme(this.__wbg_ptr, f, _);
  }
  get contentLength() {
    return wasm.__wbg_get_remoteattachment_contentLength(this.__wbg_ptr) >>> 0;
  }
  set contentLength(e) {
    wasm.__wbg_set_remoteattachment_contentLength(this.__wbg_ptr, e);
  }
  get filename() {
    const e = wasm.__wbg_get_remoteattachment_filename(this.__wbg_ptr);
    let f;
    return (
      e[0] !== 0 &&
        ((f = getStringFromWasm0(e[0], e[1]).slice()),
        wasm.__wbindgen_free(e[0], e[1] * 1, 1)),
      f
    );
  }
  set filename(e) {
    var f = isLikeNone(e)
        ? 0
        : passStringToWasm0(e, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc),
      _ = WASM_VECTOR_LEN;
    wasm.__wbg_set_remoteattachment_filename(this.__wbg_ptr, f, _);
  }
}
Symbol.dispose &&
  (RemoteAttachment.prototype[Symbol.dispose] =
    RemoteAttachment.prototype.free);
const RemoteAttachmentInfoFinalization =
  typeof FinalizationRegistry > "u"
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry((a) =>
        wasm.__wbg_remoteattachmentinfo_free(a >>> 0, 1),
      );
class RemoteAttachmentInfo {
  static __wrap(e) {
    e = e >>> 0;
    const f = Object.create(RemoteAttachmentInfo.prototype);
    return (
      (f.__wbg_ptr = e),
      RemoteAttachmentInfoFinalization.register(f, f.__wbg_ptr, f),
      f
    );
  }
  static __unwrap(e) {
    return e instanceof RemoteAttachmentInfo ? e.__destroy_into_raw() : 0;
  }
  __destroy_into_raw() {
    const e = this.__wbg_ptr;
    return (
      (this.__wbg_ptr = 0),
      RemoteAttachmentInfoFinalization.unregister(this),
      e
    );
  }
  free() {
    const e = this.__destroy_into_raw();
    wasm.__wbg_remoteattachmentinfo_free(e, 0);
  }
  get secret() {
    return wasm.__wbg_get_remoteattachmentinfo_secret(this.__wbg_ptr);
  }
  set secret(e) {
    wasm.__wbg_set_remoteattachmentinfo_secret(this.__wbg_ptr, e);
  }
  get contentDigest() {
    let e, f;
    try {
      const _ = wasm.__wbg_get_remoteattachmentinfo_contentDigest(
        this.__wbg_ptr,
      );
      return ((e = _[0]), (f = _[1]), getStringFromWasm0(_[0], _[1]));
    } finally {
      wasm.__wbindgen_free(e, f, 1);
    }
  }
  set contentDigest(e) {
    const f = passStringToWasm0(
        e,
        wasm.__wbindgen_malloc,
        wasm.__wbindgen_realloc,
      ),
      _ = WASM_VECTOR_LEN;
    wasm.__wbg_set_remoteattachmentinfo_contentDigest(this.__wbg_ptr, f, _);
  }
  get nonce() {
    return wasm.__wbg_get_remoteattachmentinfo_nonce(this.__wbg_ptr);
  }
  set nonce(e) {
    wasm.__wbg_set_remoteattachmentinfo_nonce(this.__wbg_ptr, e);
  }
  get scheme() {
    let e, f;
    try {
      const _ = wasm.__wbg_get_remoteattachmentinfo_scheme(this.__wbg_ptr);
      return ((e = _[0]), (f = _[1]), getStringFromWasm0(_[0], _[1]));
    } finally {
      wasm.__wbindgen_free(e, f, 1);
    }
  }
  set scheme(e) {
    const f = passStringToWasm0(
        e,
        wasm.__wbindgen_malloc,
        wasm.__wbindgen_realloc,
      ),
      _ = WASM_VECTOR_LEN;
    wasm.__wbg_set_remoteattachmentinfo_scheme(this.__wbg_ptr, f, _);
  }
  get url() {
    let e, f;
    try {
      const _ = wasm.__wbg_get_remoteattachmentinfo_url(this.__wbg_ptr);
      return ((e = _[0]), (f = _[1]), getStringFromWasm0(_[0], _[1]));
    } finally {
      wasm.__wbindgen_free(e, f, 1);
    }
  }
  set url(e) {
    const f = passStringToWasm0(
        e,
        wasm.__wbindgen_malloc,
        wasm.__wbindgen_realloc,
      ),
      _ = WASM_VECTOR_LEN;
    wasm.__wbg_set_action_label(this.__wbg_ptr, f, _);
  }
  get salt() {
    return wasm.__wbg_get_remoteattachmentinfo_salt(this.__wbg_ptr);
  }
  set salt(e) {
    wasm.__wbg_set_remoteattachmentinfo_salt(this.__wbg_ptr, e);
  }
  get contentLength() {
    const e = wasm.__wbg_get_remoteattachmentinfo_contentLength(this.__wbg_ptr);
    return e === 4294967297 ? void 0 : e;
  }
  set contentLength(e) {
    wasm.__wbg_set_remoteattachmentinfo_contentLength(
      this.__wbg_ptr,
      isLikeNone(e) ? 4294967297 : e >>> 0,
    );
  }
  get filename() {
    const e = wasm.__wbg_get_remoteattachmentinfo_filename(this.__wbg_ptr);
    let f;
    return (
      e[0] !== 0 &&
        ((f = getStringFromWasm0(e[0], e[1]).slice()),
        wasm.__wbindgen_free(e[0], e[1] * 1, 1)),
      f
    );
  }
  set filename(e) {
    var f = isLikeNone(e)
        ? 0
        : passStringToWasm0(e, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc),
      _ = WASM_VECTOR_LEN;
    wasm.__wbg_set_remoteattachmentinfo_filename(this.__wbg_ptr, f, _);
  }
  constructor(e, f, _, w, v, S, R, O) {
    const j = passStringToWasm0(
        f,
        wasm.__wbindgen_malloc,
        wasm.__wbindgen_realloc,
      ),
      F = WASM_VECTOR_LEN,
      q = passStringToWasm0(w, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc),
      Q = WASM_VECTOR_LEN,
      te = passStringToWasm0(
        v,
        wasm.__wbindgen_malloc,
        wasm.__wbindgen_realloc,
      ),
      se = WASM_VECTOR_LEN;
    var re = isLikeNone(O)
        ? 0
        : passStringToWasm0(O, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc),
      Oe = WASM_VECTOR_LEN;
    const Le = wasm.remoteattachmentinfo_new(
      e,
      j,
      F,
      _,
      q,
      Q,
      te,
      se,
      S,
      isLikeNone(R) ? 4294967297 : R >>> 0,
      re,
      Oe,
    );
    return (
      (this.__wbg_ptr = Le >>> 0),
      RemoteAttachmentInfoFinalization.register(this, this.__wbg_ptr, this),
      this
    );
  }
}
Symbol.dispose &&
  (RemoteAttachmentInfo.prototype[Symbol.dispose] =
    RemoteAttachmentInfo.prototype.free);
const ReplyFinalization =
  typeof FinalizationRegistry > "u"
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry((a) => wasm.__wbg_reply_free(a >>> 0, 1));
class Reply {
  static __wrap(e) {
    e = e >>> 0;
    const f = Object.create(Reply.prototype);
    return (
      (f.__wbg_ptr = e),
      ReplyFinalization.register(f, f.__wbg_ptr, f),
      f
    );
  }
  __destroy_into_raw() {
    const e = this.__wbg_ptr;
    return ((this.__wbg_ptr = 0), ReplyFinalization.unregister(this), e);
  }
  free() {
    const e = this.__destroy_into_raw();
    wasm.__wbg_reply_free(e, 0);
  }
  get content() {
    const e = wasm.__wbg_get_reply_content(this.__wbg_ptr);
    return EncodedContent.__wrap(e);
  }
  set content(e) {
    _assertClass(e, EncodedContent);
    var f = e.__destroy_into_raw();
    wasm.__wbg_set_reply_content(this.__wbg_ptr, f);
  }
  get reference() {
    let e, f;
    try {
      const _ = wasm.__wbg_get_reply_reference(this.__wbg_ptr);
      return ((e = _[0]), (f = _[1]), getStringFromWasm0(_[0], _[1]));
    } finally {
      wasm.__wbindgen_free(e, f, 1);
    }
  }
  set reference(e) {
    const f = passStringToWasm0(
        e,
        wasm.__wbindgen_malloc,
        wasm.__wbindgen_realloc,
      ),
      _ = WASM_VECTOR_LEN;
    wasm.__wbg_set_remoteattachment_scheme(this.__wbg_ptr, f, _);
  }
  get referenceInboxId() {
    const e = wasm.__wbg_get_reply_referenceInboxId(this.__wbg_ptr);
    let f;
    return (
      e[0] !== 0 &&
        ((f = getStringFromWasm0(e[0], e[1]).slice()),
        wasm.__wbindgen_free(e[0], e[1] * 1, 1)),
      f
    );
  }
  set referenceInboxId(e) {
    var f = isLikeNone(e)
        ? 0
        : passStringToWasm0(e, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc),
      _ = WASM_VECTOR_LEN;
    wasm.__wbg_set_remoteattachment_filename(this.__wbg_ptr, f, _);
  }
  constructor(e, f, _) {
    _assertClass(e, EncodedContent);
    var w = e.__destroy_into_raw();
    const v = passStringToWasm0(
        f,
        wasm.__wbindgen_malloc,
        wasm.__wbindgen_realloc,
      ),
      S = WASM_VECTOR_LEN;
    var R = isLikeNone(_)
        ? 0
        : passStringToWasm0(_, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc),
      O = WASM_VECTOR_LEN;
    const j = wasm.reply_new(w, v, S, R, O);
    return (
      (this.__wbg_ptr = j >>> 0),
      ReplyFinalization.register(this, this.__wbg_ptr, this),
      this
    );
  }
}
Symbol.dispose && (Reply.prototype[Symbol.dispose] = Reply.prototype.free);
const SendMessageOptsFinalization =
  typeof FinalizationRegistry > "u"
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry((a) =>
        wasm.__wbg_sendmessageopts_free(a >>> 0, 1),
      );
class SendMessageOpts {
  __destroy_into_raw() {
    const e = this.__wbg_ptr;
    return (
      (this.__wbg_ptr = 0),
      SendMessageOptsFinalization.unregister(this),
      e
    );
  }
  free() {
    const e = this.__destroy_into_raw();
    wasm.__wbg_sendmessageopts_free(e, 0);
  }
  constructor(e) {
    const f = wasm.sendmessageopts_new(e);
    return (
      (this.__wbg_ptr = f >>> 0),
      SendMessageOptsFinalization.register(this, this.__wbg_ptr, this),
      this
    );
  }
  get shouldPush() {
    return wasm.__wbg_get_sendmessageopts_shouldPush(this.__wbg_ptr) !== 0;
  }
  set shouldPush(e) {
    wasm.__wbg_set_sendmessageopts_shouldPush(this.__wbg_ptr, e);
  }
}
Symbol.dispose &&
  (SendMessageOpts.prototype[Symbol.dispose] = SendMessageOpts.prototype.free);
typeof FinalizationRegistry > "u" ||
  new FinalizationRegistry((a) =>
    wasm.__wbg_signaturerequesthandle_free(a >>> 0, 1),
  );
const StreamCloserFinalization =
  typeof FinalizationRegistry > "u"
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry((a) => wasm.__wbg_streamcloser_free(a >>> 0, 1));
class StreamCloser {
  static __wrap(e) {
    e = e >>> 0;
    const f = Object.create(StreamCloser.prototype);
    return (
      (f.__wbg_ptr = e),
      StreamCloserFinalization.register(f, f.__wbg_ptr, f),
      f
    );
  }
  __destroy_into_raw() {
    const e = this.__wbg_ptr;
    return ((this.__wbg_ptr = 0), StreamCloserFinalization.unregister(this), e);
  }
  free() {
    const e = this.__destroy_into_raw();
    wasm.__wbg_streamcloser_free(e, 0);
  }
  endAndWait() {
    return wasm.streamcloser_endAndWait(this.__wbg_ptr);
  }
  waitForReady() {
    return wasm.streamcloser_waitForReady(this.__wbg_ptr);
  }
  end() {
    wasm.streamcloser_end(this.__wbg_ptr);
  }
  isClosed() {
    return wasm.streamcloser_isClosed(this.__wbg_ptr) !== 0;
  }
}
Symbol.dispose &&
  (StreamCloser.prototype[Symbol.dispose] = StreamCloser.prototype.free);
const TextContentFinalization =
  typeof FinalizationRegistry > "u"
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry((a) => wasm.__wbg_textcontent_free(a >>> 0, 1));
class TextContent {
  static __wrap(e) {
    e = e >>> 0;
    const f = Object.create(TextContent.prototype);
    return (
      (f.__wbg_ptr = e),
      TextContentFinalization.register(f, f.__wbg_ptr, f),
      f
    );
  }
  __destroy_into_raw() {
    const e = this.__wbg_ptr;
    return ((this.__wbg_ptr = 0), TextContentFinalization.unregister(this), e);
  }
  free() {
    const e = this.__destroy_into_raw();
    wasm.__wbg_textcontent_free(e, 0);
  }
  get content() {
    let e, f;
    try {
      const _ = wasm.__wbg_get_textcontent_content(this.__wbg_ptr);
      return ((e = _[0]), (f = _[1]), getStringFromWasm0(_[0], _[1]));
    } finally {
      wasm.__wbindgen_free(e, f, 1);
    }
  }
  set content(e) {
    const f = passStringToWasm0(
        e,
        wasm.__wbindgen_malloc,
        wasm.__wbindgen_realloc,
      ),
      _ = WASM_VECTOR_LEN;
    wasm.__wbg_set_groupupdated_initiatedByInboxId(this.__wbg_ptr, f, _);
  }
}
Symbol.dispose &&
  (TextContent.prototype[Symbol.dispose] = TextContent.prototype.free);
const TransactionMetadataFinalization =
  typeof FinalizationRegistry > "u"
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry((a) =>
        wasm.__wbg_transactionmetadata_free(a >>> 0, 1),
      );
class TransactionMetadata {
  static __wrap(e) {
    e = e >>> 0;
    const f = Object.create(TransactionMetadata.prototype);
    return (
      (f.__wbg_ptr = e),
      TransactionMetadataFinalization.register(f, f.__wbg_ptr, f),
      f
    );
  }
  __destroy_into_raw() {
    const e = this.__wbg_ptr;
    return (
      (this.__wbg_ptr = 0),
      TransactionMetadataFinalization.unregister(this),
      e
    );
  }
  free() {
    const e = this.__destroy_into_raw();
    wasm.__wbg_transactionmetadata_free(e, 0);
  }
  get transactionType() {
    let e, f;
    try {
      const _ = wasm.__wbg_get_transactionmetadata_transactionType(
        this.__wbg_ptr,
      );
      return ((e = _[0]), (f = _[1]), getStringFromWasm0(_[0], _[1]));
    } finally {
      wasm.__wbindgen_free(e, f, 1);
    }
  }
  set transactionType(e) {
    const f = passStringToWasm0(
        e,
        wasm.__wbindgen_malloc,
        wasm.__wbindgen_realloc,
      ),
      _ = WASM_VECTOR_LEN;
    wasm.__wbg_set_transactionmetadata_transactionType(this.__wbg_ptr, f, _);
  }
  get currency() {
    let e, f;
    try {
      const _ = wasm.__wbg_get_transactionmetadata_currency(this.__wbg_ptr);
      return ((e = _[0]), (f = _[1]), getStringFromWasm0(_[0], _[1]));
    } finally {
      wasm.__wbindgen_free(e, f, 1);
    }
  }
  set currency(e) {
    const f = passStringToWasm0(
        e,
        wasm.__wbindgen_malloc,
        wasm.__wbindgen_realloc,
      ),
      _ = WASM_VECTOR_LEN;
    wasm.__wbg_set_remoteattachment_secret(this.__wbg_ptr, f, _);
  }
  get amount() {
    return wasm.__wbg_get_transactionmetadata_amount(this.__wbg_ptr);
  }
  set amount(e) {
    wasm.__wbg_set_transactionmetadata_amount(this.__wbg_ptr, e);
  }
  get decimals() {
    return wasm.__wbg_get_transactionmetadata_decimals(this.__wbg_ptr) >>> 0;
  }
  set decimals(e) {
    wasm.__wbg_set_transactionmetadata_decimals(this.__wbg_ptr, e);
  }
  get fromAddress() {
    let e, f;
    try {
      const _ = wasm.__wbg_get_transactionmetadata_fromAddress(this.__wbg_ptr);
      return ((e = _[0]), (f = _[1]), getStringFromWasm0(_[0], _[1]));
    } finally {
      wasm.__wbindgen_free(e, f, 1);
    }
  }
  set fromAddress(e) {
    const f = passStringToWasm0(
        e,
        wasm.__wbindgen_malloc,
        wasm.__wbindgen_realloc,
      ),
      _ = WASM_VECTOR_LEN;
    wasm.__wbg_set_transactionmetadata_fromAddress(this.__wbg_ptr, f, _);
  }
  get toAddress() {
    let e, f;
    try {
      const _ = wasm.__wbg_get_transactionmetadata_toAddress(this.__wbg_ptr);
      return ((e = _[0]), (f = _[1]), getStringFromWasm0(_[0], _[1]));
    } finally {
      wasm.__wbindgen_free(e, f, 1);
    }
  }
  set toAddress(e) {
    const f = passStringToWasm0(
        e,
        wasm.__wbindgen_malloc,
        wasm.__wbindgen_realloc,
      ),
      _ = WASM_VECTOR_LEN;
    wasm.__wbg_set_remoteattachment_nonce(this.__wbg_ptr, f, _);
  }
}
Symbol.dispose &&
  (TransactionMetadata.prototype[Symbol.dispose] =
    TransactionMetadata.prototype.free);
const TransactionReferenceFinalization =
  typeof FinalizationRegistry > "u"
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry((a) =>
        wasm.__wbg_transactionreference_free(a >>> 0, 1),
      );
class TransactionReference {
  static __wrap(e) {
    e = e >>> 0;
    const f = Object.create(TransactionReference.prototype);
    return (
      (f.__wbg_ptr = e),
      TransactionReferenceFinalization.register(f, f.__wbg_ptr, f),
      f
    );
  }
  __destroy_into_raw() {
    const e = this.__wbg_ptr;
    return (
      (this.__wbg_ptr = 0),
      TransactionReferenceFinalization.unregister(this),
      e
    );
  }
  free() {
    const e = this.__destroy_into_raw();
    wasm.__wbg_transactionreference_free(e, 0);
  }
  get namespace() {
    const e = wasm.__wbg_get_transactionreference_namespace(this.__wbg_ptr);
    let f;
    return (
      e[0] !== 0 &&
        ((f = getStringFromWasm0(e[0], e[1]).slice()),
        wasm.__wbindgen_free(e[0], e[1] * 1, 1)),
      f
    );
  }
  set namespace(e) {
    var f = isLikeNone(e)
        ? 0
        : passStringToWasm0(e, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc),
      _ = WASM_VECTOR_LEN;
    wasm.__wbg_set_transactionreference_namespace(this.__wbg_ptr, f, _);
  }
  get networkId() {
    let e, f;
    try {
      const _ = wasm.__wbg_get_transactionreference_networkId(this.__wbg_ptr);
      return ((e = _[0]), (f = _[1]), getStringFromWasm0(_[0], _[1]));
    } finally {
      wasm.__wbindgen_free(e, f, 1);
    }
  }
  set networkId(e) {
    const f = passStringToWasm0(
        e,
        wasm.__wbindgen_malloc,
        wasm.__wbindgen_realloc,
      ),
      _ = WASM_VECTOR_LEN;
    wasm.__wbg_set_transactionreference_networkId(this.__wbg_ptr, f, _);
  }
  get reference() {
    let e, f;
    try {
      const _ = wasm.__wbg_get_transactionreference_reference(this.__wbg_ptr);
      return ((e = _[0]), (f = _[1]), getStringFromWasm0(_[0], _[1]));
    } finally {
      wasm.__wbindgen_free(e, f, 1);
    }
  }
  set reference(e) {
    const f = passStringToWasm0(
        e,
        wasm.__wbindgen_malloc,
        wasm.__wbindgen_realloc,
      ),
      _ = WASM_VECTOR_LEN;
    wasm.__wbg_set_transactionreference_reference(this.__wbg_ptr, f, _);
  }
  get metadata() {
    const e = wasm.__wbg_get_transactionreference_metadata(this.__wbg_ptr);
    return e === 0 ? void 0 : TransactionMetadata.__wrap(e);
  }
  set metadata(e) {
    let f = 0;
    (isLikeNone(e) ||
      (_assertClass(e, TransactionMetadata), (f = e.__destroy_into_raw())),
      wasm.__wbg_set_transactionreference_metadata(this.__wbg_ptr, f));
  }
}
Symbol.dispose &&
  (TransactionReference.prototype[Symbol.dispose] =
    TransactionReference.prototype.free);
const XmtpCursorFinalization =
  typeof FinalizationRegistry > "u"
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry((a) => wasm.__wbg_xmtpcursor_free(a >>> 0, 1));
class XmtpCursor {
  static __wrap(e) {
    e = e >>> 0;
    const f = Object.create(XmtpCursor.prototype);
    return (
      (f.__wbg_ptr = e),
      XmtpCursorFinalization.register(f, f.__wbg_ptr, f),
      f
    );
  }
  static __unwrap(e) {
    return e instanceof XmtpCursor ? e.__destroy_into_raw() : 0;
  }
  __destroy_into_raw() {
    const e = this.__wbg_ptr;
    return ((this.__wbg_ptr = 0), XmtpCursorFinalization.unregister(this), e);
  }
  free() {
    const e = this.__destroy_into_raw();
    wasm.__wbg_xmtpcursor_free(e, 0);
  }
  get originator_id() {
    return wasm.__wbg_get_xmtpcursor_originator_id(this.__wbg_ptr) >>> 0;
  }
  set originator_id(e) {
    wasm.__wbg_set_xmtpcursor_originator_id(this.__wbg_ptr, e);
  }
  get sequence_id() {
    return wasm.__wbg_get_conversationdebuginfo_epoch(this.__wbg_ptr);
  }
  set sequence_id(e) {
    wasm.__wbg_set_conversationdebuginfo_epoch(this.__wbg_ptr, e);
  }
}
Symbol.dispose &&
  (XmtpCursor.prototype[Symbol.dispose] = XmtpCursor.prototype.free);
const byteToHex = [];
for (let a = 0; a < 256; ++a) byteToHex.push((a + 256).toString(16).slice(1));
function unsafeStringify(a, e = 0) {
  return (
    byteToHex[a[e + 0]] +
    byteToHex[a[e + 1]] +
    byteToHex[a[e + 2]] +
    byteToHex[a[e + 3]] +
    "-" +
    byteToHex[a[e + 4]] +
    byteToHex[a[e + 5]] +
    "-" +
    byteToHex[a[e + 6]] +
    byteToHex[a[e + 7]] +
    "-" +
    byteToHex[a[e + 8]] +
    byteToHex[a[e + 9]] +
    "-" +
    byteToHex[a[e + 10]] +
    byteToHex[a[e + 11]] +
    byteToHex[a[e + 12]] +
    byteToHex[a[e + 13]] +
    byteToHex[a[e + 14]] +
    byteToHex[a[e + 15]]
  ).toLowerCase();
}
let getRandomValues;
const rnds8 = new Uint8Array(16);
function rng() {
  if (!getRandomValues) {
    if (typeof crypto > "u" || !crypto.getRandomValues)
      throw new Error(
        "crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported",
      );
    getRandomValues = crypto.getRandomValues.bind(crypto);
  }
  return getRandomValues(rnds8);
}
const randomUUID =
    typeof crypto < "u" && crypto.randomUUID && crypto.randomUUID.bind(crypto),
  native = { randomUUID };
function v4(a, e, f) {
  if (native.randomUUID && !a) return native.randomUUID();
  a = a || {};
  const _ = a.random ?? a.rng?.() ?? rng();
  if (_.length < 16) throw new Error("Random bytes length must be >= 16");
  return (
    (_[6] = (_[6] & 15) | 64),
    (_[8] = (_[8] & 63) | 128),
    unsafeStringify(_)
  );
}
const M$1 = (a) => {
  console.error(a.message);
};
class b {
  #e;
  #t;
  #r = new Map();
  constructor(e, f) {
    ((this.#e = e),
      this.#e.addEventListener("message", this.handleMessage),
      f && this.#e.addEventListener("error", M$1),
      (this.#t = f));
  }
  sendMessage(e, f) {
    const _ = v4();
    return (
      this.#e.postMessage({ action: e, id: _, data: f }),
      new Promise((w, v) => {
        this.#r.set(_, { resolve: w, reject: v });
      })
    );
  }
  handleMessage = (e) => {
    const f = e.data;
    this.#t && console.log("client received event data", f);
    const _ = this.#r.get(f.id);
    _ &&
      (this.#r.delete(f.id),
      "error" in f ? _.reject(f.error) : _.resolve(f.result));
  };
  handleStreamMessage = (e, f, _) => {
    const w = (v) => {
      const S = v.data;
      if (S.streamId === e) {
        if (S.action === "stream.fail") return void _?.onFail?.();
        "error" in S ? f(S.error, void 0) : f(null, S.result);
      }
    };
    return (
      this.#e.addEventListener("message", w),
      async () => {
        (await this.sendMessage("endStream", { streamId: e }),
          this.#e.removeEventListener("message", w));
      }
    );
  };
  close() {
    (this.#e.removeEventListener("message", this.handleMessage),
      this.#t && this.#e.removeEventListener("error", M$1),
      this.#e.terminate());
  }
}
const A = (a) => ({
    authorityId: a.authorityId,
    typeId: a.typeId,
    versionMajor: a.versionMajor,
    versionMinor: a.versionMinor,
  }),
  k = (a) =>
    new t$7({
      authorityId: a.authorityId,
      typeId: a.typeId,
      versionMajor: a.versionMajor,
      versionMinor: a.versionMinor,
    }),
  T = (a) => ({
    type: A(a.type),
    parameters: a.parameters,
    fallback: a.fallback,
    compression: a.compression,
    content: a.content,
  }),
  C$1 = (a) => ({
    type: k(a.type),
    parameters: a.parameters,
    fallback: a.fallback,
    compression: a.compression,
    content: a.content,
  });
class ie {
  #e;
  content;
  contentType;
  conversationId;
  deliveryStatus;
  fallback;
  compression;
  id;
  kind;
  parameters;
  encodedContent;
  senderInboxId;
  sentAtNs;
  constructor(e, f) {
    switch (
      ((this.#e = e),
      (this.id = f.id),
      (this.sentAtNs = f.sentAtNs),
      (this.conversationId = f.convoId),
      (this.senderInboxId = f.senderInboxId),
      (this.encodedContent = f.content),
      f.kind)
    ) {
      case GroupMessageKind.Application:
        this.kind = "application";
        break;
      case GroupMessageKind.MembershipChange:
        this.kind = "membership_change";
    }
    switch (f.deliveryStatus) {
      case DeliveryStatus.Unpublished:
        this.deliveryStatus = "unpublished";
        break;
      case DeliveryStatus.Published:
        this.deliveryStatus = "published";
        break;
      case DeliveryStatus.Failed:
        this.deliveryStatus = "failed";
    }
    ((this.contentType = k(f.content.type)),
      (this.parameters = new Map(Object.entries(f.content.parameters))),
      (this.fallback = f.content.fallback),
      (this.compression = f.content.compression));
    try {
      this.content = this.#e.decodeContent(f, this.contentType);
    } catch {
      this.content = void 0;
    }
  }
}
class ae extends Error {
  constructor() {
    super(
      "Signer unavailable, use Client.create to create a client with a signer",
    );
  }
}
class oe extends Error {
  constructor(e) {
    super(`Codec not found for "${e.toString()}" content type`);
  }
}
class de extends Error {
  constructor() {
    super(
      "Unable to create add account signature text, `allowInboxReassign` must be true",
    );
  }
}
class ce extends Error {
  constructor(e) {
    super(`Account already associated with inbox ${e}`);
  }
}
let ge$1 = class extends Error {
  constructor(e) {
    super(`Invalid group membership change for message ${e}`);
  }
};
class he extends Error {
  constructor() {
    super("Content type is required when sending content other than text");
  }
}
class pe extends Error {
  constructor(e) {
    super(`Stream failed, retried ${e} ${"time" + (e !== 1 ? "s" : "")}`);
  }
}
class me extends Error {
  constructor() {
    super("Stream retry attempts must be greater than 0");
  }
}
class ye {
  isDone = !1;
  #e = [];
  #t;
  onDone;
  onReturn;
  constructor() {
    ((this.#t = []), (this.isDone = !1));
  }
  flush() {
    for (; this.#e.length > 0; ) {
      const e = this.#e.shift();
      e && e({ done: !0, value: void 0 });
    }
  }
  done() {
    (this.flush(),
      (this.#t = []),
      (this.#e = []),
      (this.isDone = !0),
      this.onDone?.());
  }
  push = (e) => {
    if (this.isDone) return;
    const f = this.#e.shift();
    f ? f({ done: !1, value: e }) : this.#t.push(e);
  };
  next = () =>
    this.isDone
      ? Promise.resolve({ done: !0, value: void 0 })
      : this.#t.length > 0
        ? Promise.resolve({ done: !1, value: this.#t.shift() })
        : new Promise((e) => {
            this.#e.push(e);
          });
  return = () => (
    this.onReturn?.(),
    this.done(),
    Promise.resolve({ done: !0, value: void 0 })
  );
  end = () => this.return();
  [Symbol.asyncIterator]() {
    return this;
  }
}
const Ie = ["end", "isDone", "next", "return", Symbol.asyncIterator],
  ve = (a) => Ie.includes(a),
  we = 1e4,
  fe$1 = 6,
  Me = async (a, e, f) => {
    const {
      onEnd: _,
      onError: w,
      onFail: v,
      onRestart: S,
      onRetry: R,
      onValue: O,
      retryAttempts: j = fe$1,
      retryDelay: F = we,
      retryOnFail: q = !0,
    } = f ?? {};
    if (q && j < 0) throw new me();
    const Q = new ye(),
      te = (Oe, Le) => {
        if (Oe) w?.(Oe);
        else if (Le !== void 0)
          try {
            if (e) {
              const Be = e(Le);
              ((Ve) =>
                !!Ve &&
                (typeof Ve == "object" || typeof Ve == "function") &&
                "then" in Ve &&
                typeof Ve.then == "function")(Be)
                ? Be.then((Ve) => {
                    (Q.push(Ve), O?.(Ve));
                  }).catch((Ve) => {
                    w?.(Ve);
                  })
                : (Q.push(Be), O?.(Be));
            } else (Q.push(Le), O?.(Le));
          } catch (Be) {
            w?.(Be);
          }
      },
      se = async (Oe = j) => {
        try {
          if (Oe === 0) throw (Q.end(), new pe(j));
          (await ((Le = F), new Promise((Ve) => setTimeout(Ve, Le))),
            R?.(j - Oe + 1, j));
          const Be = await a(te, () => {
            (v?.(), se());
          });
          ((Q.onDone = () => {
            (Be(), _?.());
          }),
            S?.());
        } catch (Be) {
          (w?.(Be), se(Oe - 1));
        }
        var Le;
      },
      re = () => {
        if (!q) throw (Q.end(), new pe(0));
        se();
      };
    try {
      const Oe = await a(te, () => {
        (v?.(), re());
      });
      Q.onDone = () => {
        (Oe(), _?.());
      };
    } catch (Oe) {
      (w?.(Oe), re());
    }
    return new Proxy(Q, {
      get(Oe, Le, Be) {
        if (ve(Le)) return Reflect.get(Oe, Le, Be);
      },
      set: () => !0,
      has: (Oe, Le) => ve(Le),
      ownKeys: () => Ie,
      getOwnPropertyDescriptor(Oe, Le) {
        if (ve(Le))
          return {
            enumerable: !0,
            configurable: !0,
            value: Reflect.get(Oe, Le),
          };
      },
    });
  };
class be {
  #e;
  #t;
  #r;
  #n;
  #s;
  #i;
  constructor(e, f, _) {
    ((this.#t = e), (this.#n = f), this.#a(_));
  }
  #a(e) {
    ((this.#e = e?.addedByInboxId),
      (this.#s = e?.metadata),
      (this.#r = e?.createdAtNs),
      (this.#i = e?.isCommitLogForked));
  }
  get id() {
    return this.#n;
  }
  get isCommitLogForked() {
    return this.#i;
  }
  get addedByInboxId() {
    return this.#e;
  }
  get createdAtNs() {
    return this.#r;
  }
  get createdAt() {
    return this.#r ? ((e = this.#r), new Date(Number(e / 1000000n))) : void 0;
    var e;
  }
  get metadata() {
    return this.#s;
  }
  async lastMessage() {
    const e = await this.#t.sendMessage("conversation.lastMessage", {
      id: this.#n,
    });
    return e ? new ie(this.#t, e) : void 0;
  }
  async isActive() {
    return this.#t.sendMessage("conversation.isActive", { id: this.#n });
  }
  async members() {
    return this.#t.sendMessage("conversation.members", { id: this.#n });
  }
  async sync() {
    const e = await this.#t.sendMessage("conversation.sync", { id: this.#n });
    return (this.#a(e), e);
  }
  async publishMessages() {
    return this.#t.sendMessage("conversation.publishMessages", { id: this.#n });
  }
  async sendOptimistic(e, f) {
    if (typeof e != "string" && !f) throw new he();
    const { encodedContent: _, sendOptions: w } =
      typeof e == "string"
        ? this.#t.prepareForSend(e, f ?? n$3)
        : this.#t.prepareForSend(e, f);
    return this.#t.sendMessage("conversation.sendOptimistic", {
      id: this.#n,
      content: _,
      sendOptions: w,
    });
  }
  async send(e, f) {
    if (typeof e != "string" && !f) throw new he();
    const { encodedContent: _, sendOptions: w } =
      typeof e == "string"
        ? this.#t.prepareForSend(e, f ?? n$3)
        : this.#t.prepareForSend(e, f);
    return this.#t.sendMessage("conversation.send", {
      id: this.#n,
      content: _,
      sendOptions: w,
    });
  }
  async messages(e) {
    return (
      await this.#t.sendMessage("conversation.messages", {
        id: this.#n,
        options: e,
      })
    ).map((f) => new ie(this.#t, f));
  }
  async countMessages(e) {
    return await this.#t.sendMessage("conversation.countMessages", {
      id: this.#n,
      options: e,
    });
  }
  async consentState() {
    return this.#t.sendMessage("conversation.consentState", { id: this.#n });
  }
  async updateConsentState(e) {
    return this.#t.sendMessage("conversation.updateConsentState", {
      id: this.#n,
      state: e,
    });
  }
  async messageDisappearingSettings() {
    return this.#t.sendMessage("conversation.messageDisappearingSettings", {
      id: this.#n,
    });
  }
  async updateMessageDisappearingSettings(e, f) {
    return this.#t.sendMessage(
      "conversation.updateMessageDisappearingSettings",
      { id: this.#n, fromNs: e, inNs: f },
    );
  }
  async removeMessageDisappearingSettings() {
    return this.#t.sendMessage(
      "conversation.removeMessageDisappearingSettings",
      { id: this.#n },
    );
  }
  async isMessageDisappearingEnabled() {
    return this.#t.sendMessage("conversation.isMessageDisappearingEnabled", {
      id: this.#n,
    });
  }
  async stream(e) {
    return Me(
      async (f, _) => {
        const w = v4();
        return (
          e?.disableSync || (await this.sync()),
          await this.#t.sendMessage("conversation.stream", {
            groupId: this.#n,
            streamId: w,
          }),
          this.#t.handleStreamMessage(w, f, { ...e, onFail: _ })
        );
      },
      (f) => new ie(this.#t, f),
      e,
    );
  }
  async pausedForVersion() {
    return this.#t.sendMessage("conversation.pausedForVersion", {
      id: this.#n,
    });
  }
  async getHmacKeys() {
    return this.#t.sendMessage("conversation.getHmacKeys", { id: this.#n });
  }
  async debugInfo() {
    return this.#t.sendMessage("conversation.debugInfo", { id: this.#n });
  }
}
class Se extends be {
  #e;
  #t;
  constructor(e, f, _) {
    (super(e, f, _), (this.#e = e), (this.#t = f));
  }
  async peerInboxId() {
    return this.#e.sendMessage("dm.peerInboxId", { id: this.#t });
  }
  async getDuplicateDms() {
    return this.#e.sendMessage("dm.getDuplicateDms", { id: this.#t });
  }
}
class xe extends be {
  #e = [];
  #t;
  #r;
  #n;
  #s;
  #i;
  #a = [];
  #l(e) {
    ((this.#i = e?.name ?? ""),
      (this.#s = e?.imageUrl ?? ""),
      (this.#r = e?.description ?? ""),
      (this.#e = e?.admins ?? []),
      (this.#a = e?.superAdmins ?? []));
  }
  constructor(e, f, _) {
    (super(e, f, _), (this.#t = e), (this.#n = f), this.#l(_));
  }
  async sync() {
    const e = await super.sync();
    return (this.#l(e), e);
  }
  get name() {
    return this.#i;
  }
  async updateName(e) {
    (await this.#t.sendMessage("group.updateName", { id: this.#n, name: e }),
      (this.#i = e));
  }
  get imageUrl() {
    return this.#s;
  }
  async updateImageUrl(e) {
    (await this.#t.sendMessage("group.updateImageUrl", {
      id: this.#n,
      imageUrl: e,
    }),
      (this.#s = e));
  }
  get description() {
    return this.#r;
  }
  async updateDescription(e) {
    (await this.#t.sendMessage("group.updateDescription", {
      id: this.#n,
      description: e,
    }),
      (this.#r = e));
  }
  get admins() {
    return this.#e;
  }
  get superAdmins() {
    return this.#a;
  }
  async listAdmins() {
    const e = await this.#t.sendMessage("group.listAdmins", { id: this.#n });
    return ((this.#e = e), e);
  }
  async listSuperAdmins() {
    const e = await this.#t.sendMessage("group.listSuperAdmins", {
      id: this.#n,
    });
    return ((this.#a = e), e);
  }
  async permissions() {
    return this.#t.sendMessage("group.permissions", { id: this.#n });
  }
  async updatePermission(e, f, _) {
    return this.#t.sendMessage("group.updatePermission", {
      id: this.#n,
      permissionType: e,
      policy: f,
      metadataField: _,
    });
  }
  async isAdmin(e) {
    return (await this.listAdmins()).includes(e);
  }
  async isSuperAdmin(e) {
    return (await this.listSuperAdmins()).includes(e);
  }
  async addMembersByIdentifiers(e) {
    return this.#t.sendMessage("group.addMembersByIdentifiers", {
      id: this.#n,
      identifiers: e,
    });
  }
  async addMembers(e) {
    return this.#t.sendMessage("group.addMembers", {
      id: this.#n,
      inboxIds: e,
    });
  }
  async removeMembersByIdentifiers(e) {
    return this.#t.sendMessage("group.removeMembersByIdentifiers", {
      id: this.#n,
      identifiers: e,
    });
  }
  async removeMembers(e) {
    return this.#t.sendMessage("group.removeMembers", {
      id: this.#n,
      inboxIds: e,
    });
  }
  async addAdmin(e) {
    return this.#t.sendMessage("group.addAdmin", { id: this.#n, inboxId: e });
  }
  async removeAdmin(e) {
    return this.#t.sendMessage("group.removeAdmin", {
      id: this.#n,
      inboxId: e,
    });
  }
  async addSuperAdmin(e) {
    return this.#t.sendMessage("group.addSuperAdmin", {
      id: this.#n,
      inboxId: e,
    });
  }
  async removeSuperAdmin(e) {
    return this.#t.sendMessage("group.removeSuperAdmin", {
      id: this.#n,
      inboxId: e,
    });
  }
}
class Ae {
  #e;
  constructor(e) {
    this.#e = e;
  }
  async sync() {
    return this.#e.sendMessage("conversations.sync", void 0);
  }
  async syncAll(e) {
    return this.#e.sendMessage("conversations.syncAll", { consentStates: e });
  }
  async getConversationById(e) {
    const f = await this.#e.sendMessage("conversations.getConversationById", {
      id: e,
    });
    if (f)
      return f.metadata.conversationType === "group"
        ? new xe(this.#e, f.id, f)
        : new Se(this.#e, f.id, f);
  }
  async getMessageById(e) {
    const f = await this.#e.sendMessage("conversations.getMessageById", {
      id: e,
    });
    return f ? new ie(this.#e, f) : void 0;
  }
  async getDmByInboxId(e) {
    const f = await this.#e.sendMessage("conversations.getDmByInboxId", {
      inboxId: e,
    });
    return f ? new Se(this.#e, f.id, f) : void 0;
  }
  async getDmByIdentifier(e) {
    const f = await this.#e.findInboxIdByIdentifier(e);
    if (f) return this.getDmByInboxId(f);
  }
  async list(e) {
    return (await this.#e.sendMessage("conversations.list", { options: e }))
      .map((f) => {
        switch (f.metadata.conversationType) {
          case "dm":
            return new Se(this.#e, f.id, f);
          case "group":
            return new xe(this.#e, f.id, f);
          default:
            return;
        }
      })
      .filter((f) => f !== void 0);
  }
  async listGroups(e) {
    return (
      await this.#e.sendMessage("conversations.listGroups", { options: e })
    ).map((f) => new xe(this.#e, f.id, f));
  }
  async listDms(e) {
    return (
      await this.#e.sendMessage("conversations.listDms", { options: e })
    ).map((f) => new Se(this.#e, f.id, f));
  }
  async newGroupOptimistic(e) {
    const f = await this.#e.sendMessage("conversations.newGroupOptimistic", {
      options: e,
    });
    return new xe(this.#e, f.id, f);
  }
  async newGroupWithIdentifiers(e, f) {
    const _ = await this.#e.sendMessage(
      "conversations.newGroupWithIdentifiers",
      { identifiers: e, options: f },
    );
    return new xe(this.#e, _.id, _);
  }
  async newGroup(e, f) {
    const _ = await this.#e.sendMessage("conversations.newGroup", {
      inboxIds: e,
      options: f,
    });
    return new xe(this.#e, _.id, _);
  }
  async newDmWithIdentifier(e, f) {
    const _ = await this.#e.sendMessage("conversations.newDmWithIdentifier", {
      identifier: e,
      options: f,
    });
    return new Se(this.#e, _.id, _);
  }
  async newDm(e, f) {
    const _ = await this.#e.sendMessage("conversations.newDm", {
      inboxId: e,
      options: f,
    });
    return new Se(this.#e, _.id, _);
  }
  async getHmacKeys() {
    return this.#e.sendMessage("conversations.getHmacKeys", void 0);
  }
  async stream(e) {
    return Me(
      async (f, _) => {
        const w = v4();
        return (
          e?.disableSync || (await this.sync()),
          await this.#e.sendMessage("conversations.stream", {
            streamId: w,
            conversationType: e?.conversationType,
          }),
          this.#e.handleStreamMessage(w, f, { ...e, onFail: _ })
        );
      },
      (f) =>
        f.metadata.conversationType === "group"
          ? new xe(this.#e, f.id, f)
          : new Se(this.#e, f.id, f),
      e,
    );
  }
  async streamGroups(e) {
    return this.stream({ ...e, conversationType: ConversationType.Group });
  }
  async streamDms(e) {
    return this.stream({ ...e, conversationType: ConversationType.Dm });
  }
  async streamAllMessages(e) {
    return Me(
      async (f, _) => {
        const w = v4();
        return (
          e?.disableSync || (await this.sync()),
          await this.#e.sendMessage("conversations.streamAllMessages", {
            streamId: w,
            conversationType: e?.conversationType,
            consentStates: e?.consentStates,
          }),
          this.#e.handleStreamMessage(w, f, { ...e, onFail: _ })
        );
      },
      (f) => new ie(this.#e, f),
      e,
    );
  }
  async streamAllGroupMessages(e) {
    return this.streamAllMessages({
      ...e,
      conversationType: ConversationType.Group,
    });
  }
  async streamAllDmMessages(e) {
    return this.streamAllMessages({
      ...e,
      conversationType: ConversationType.Dm,
    });
  }
  async streamMessageDeletions(e) {
    return Me(
      async (f) => {
        const _ = v4();
        return (
          await this.#e.sendMessage("conversations.streamMessageDeletions", {
            streamId: _,
          }),
          this.#e.handleStreamMessage(_, f, e)
        );
      },
      void 0,
      e,
    );
  }
}
class ke {
  #e;
  constructor(e) {
    this.#e = e;
  }
  apiStatistics() {
    return this.#e.sendMessage("debugInformation.apiStatistics", void 0);
  }
  apiIdentityStatistics() {
    return this.#e.sendMessage(
      "debugInformation.apiIdentityStatistics",
      void 0,
    );
  }
  apiAggregateStatistics() {
    return this.#e.sendMessage(
      "debugInformation.apiAggregateStatistics",
      void 0,
    );
  }
  clearAllStatistics() {
    return this.#e.sendMessage("debugInformation.clearAllStatistics", void 0);
  }
  uploadDebugArchive(e) {
    return this.#e.sendMessage("debugInformation.uploadDebugArchive", {
      serverUrl: e,
    });
  }
}
class De {
  #e;
  constructor(e) {
    this.#e = e;
  }
  sync() {
    return this.#e.sendMessage("preferences.sync", void 0);
  }
  async inboxState(e) {
    return this.#e.sendMessage("preferences.inboxState", {
      refreshFromNetwork: e ?? !1,
    });
  }
  async inboxStateFromInboxIds(e, f) {
    return this.#e.sendMessage("preferences.inboxStateFromInboxIds", {
      inboxIds: e,
      refreshFromNetwork: f ?? !1,
    });
  }
  async getLatestInboxState(e) {
    return this.#e.sendMessage("preferences.getLatestInboxState", {
      inboxId: e,
    });
  }
  async setConsentStates(e) {
    return this.#e.sendMessage("preferences.setConsentStates", { records: e });
  }
  async getConsentState(e, f) {
    return this.#e.sendMessage("preferences.getConsentState", {
      entityType: e,
      entity: f,
    });
  }
  async streamConsent(e) {
    return Me(
      async (f, _) => {
        const w = v4();
        return (
          await this.sync(),
          await this.#e.sendMessage("preferences.streamConsent", {
            streamId: w,
          }),
          this.#e.handleStreamMessage(w, f, { ...e, onFail: _ })
        );
      },
      void 0,
      e,
    );
  }
  async streamPreferences(e) {
    return Me(
      async (f, _) => {
        const w = v4();
        return (
          await this.sync(),
          await this.#e.sendMessage("preferences.streamPreferences", {
            streamId: w,
          }),
          this.#e.handleStreamMessage(w, f, { ...e, onFail: _ })
        );
      },
      void 0,
      e,
    );
  }
}
const Pe = async (a, e) => {
    switch (a.type) {
      case "EOA":
        return {
          type: "EOA",
          identifier: await a.getIdentifier(),
          signature: e,
        };
      case "SCW":
        return {
          type: "SCW",
          identifier: await a.getIdentifier(),
          signature: e,
          chainId: a.getChainId(),
          blockNumber: a.getBlockNumber?.(),
        };
    }
  },
  Te = (a) => {
    console.error(a.message);
  };
class Ce {
  #e;
  #t;
  #r = new Map();
  constructor(e, f) {
    ((this.#e = e),
      this.#e.addEventListener("message", this.handleMessage),
      f && this.#e.addEventListener("error", Te),
      (this.#t = f));
  }
  async init() {
    return this.sendMessage("utils.init", { enableLogging: this.#t });
  }
  sendMessage(e, f) {
    const _ = v4();
    return (
      this.#e.postMessage({ action: e, id: _, data: f }),
      new Promise((w, v) => {
        this.#r.set(_, { resolve: w, reject: v });
      })
    );
  }
  handleMessage = (e) => {
    const f = e.data;
    this.#t && console.log("utils received event data", f);
    const _ = this.#r.get(f.id);
    _ &&
      (this.#r.delete(f.id),
      "error" in f ? _.reject(f.error) : _.resolve(f.result));
  };
  close() {
    (this.#e.removeEventListener("message", this.handleMessage),
      this.#t && this.#e.removeEventListener("error", Te),
      this.#e.terminate());
  }
}
class Ne extends Ce {
  constructor(e) {
    super(
      new Worker(new URL("/assets/utils-B0OGD2Bx.js", import.meta.url), {
        type: "module",
      }),
      e ?? !1,
    );
  }
  async generateInboxId(e) {
    return this.sendMessage("utils.generateInboxId", { identifier: e });
  }
  async getInboxIdForIdentifier(e, f, _) {
    return this.sendMessage("utils.getInboxIdForIdentifier", {
      identifier: e,
      env: f,
      gatewayHost: _,
    });
  }
  async revokeInstallationsSignatureText(e, f, _, w, v) {
    return this.sendMessage("utils.revokeInstallationsSignatureText", {
      env: w,
      identifier: e,
      inboxId: f,
      installationIds: _,
      signatureRequestId: v4(),
      gatewayHost: v,
    });
  }
  async revokeInstallations(e, f, _, w, v) {
    const S = await e.getIdentifier(),
      { signatureText: R, signatureRequestId: O } =
        await this.revokeInstallationsSignatureText(S, f, _, w, v),
      j = await e.signMessage(R),
      F = await Pe(e, j);
    return this.sendMessage("utils.revokeInstallations", {
      signer: F,
      signatureRequestId: O,
      env: w,
      gatewayHost: v,
    });
  }
  async inboxStateFromInboxIds(e, f, _) {
    return this.sendMessage("utils.inboxStateFromInboxIds", {
      inboxIds: e,
      env: f,
      gatewayHost: _,
    });
  }
}
class Re extends b {
  #e;
  #t;
  #r;
  #n;
  #s;
  #i;
  #a;
  #l = !1;
  #u;
  #o;
  #c;
  constructor(e) {
    (super(
      new Worker(new URL("/assets/client-C5vmSN-E.js", import.meta.url), {
        type: "module",
      }),
      e?.loggingLevel !== void 0 && e.loggingLevel !== "off",
    ),
      (this.#c = e),
      (this.#t = new Ae(this)),
      (this.#r = new ke(this)),
      (this.#u = new De(this)));
    const f = [new r$5(), new r$4(), ...(e?.codecs ?? [])];
    this.#e = new Map(f.map((_) => [_.contentType.toString(), _]));
  }
  async init(e) {
    const f = await this.sendMessage("client.init", {
      identifier: e,
      options: this.#c,
    });
    ((this.#n = e),
      (this.#s = f.inboxId),
      (this.#i = f.installationId),
      (this.#a = f.installationIdBytes),
      (this.#l = !0));
  }
  static async create(e, f) {
    const _ = new Re(f);
    return (
      (_.#o = e),
      await _.init(await e.getIdentifier()),
      f?.disableAutoRegister || (await _.register()),
      _
    );
  }
  static async build(e, f) {
    const _ = new Re({ ...f, disableAutoRegister: !0 });
    return (await _.init(e), _);
  }
  get options() {
    return this.#c;
  }
  get signer() {
    return this.#o;
  }
  get isReady() {
    return this.#l;
  }
  get inboxId() {
    return this.#s;
  }
  get accountIdentifier() {
    return this.#n;
  }
  get installationId() {
    return this.#i;
  }
  get installationIdBytes() {
    return this.#a;
  }
  get conversations() {
    return this.#t;
  }
  get debugInformation() {
    return this.#r;
  }
  get preferences() {
    return this.#u;
  }
  async libxmtpVersion() {
    return this.sendMessage("client.libxmtpVersion", void 0);
  }
  async appVersion() {
    return this.sendMessage("client.appVersion", void 0);
  }
  async unsafe_createInboxSignatureText() {
    return this.sendMessage("client.createInboxSignatureText", {
      signatureRequestId: v4(),
    });
  }
  async unsafe_addAccountSignatureText(e, f = !1) {
    if (!f) throw new de();
    return this.sendMessage("client.addAccountSignatureText", {
      newIdentifier: e,
      signatureRequestId: v4(),
    });
  }
  async unsafe_removeAccountSignatureText(e) {
    return this.sendMessage("client.removeAccountSignatureText", {
      identifier: e,
      signatureRequestId: v4(),
    });
  }
  async unsafe_revokeAllOtherInstallationsSignatureText() {
    return this.sendMessage("client.revokeAllOtherInstallationsSignatureText", {
      signatureRequestId: v4(),
    });
  }
  async unsafe_revokeInstallationsSignatureText(e) {
    return this.sendMessage("client.revokeInstallationsSignatureText", {
      installationIds: e,
      signatureRequestId: v4(),
    });
  }
  async unsafe_changeRecoveryIdentifierSignatureText(e) {
    return this.sendMessage("client.changeRecoveryIdentifierSignatureText", {
      identifier: e,
      signatureRequestId: v4(),
    });
  }
  async unsafe_applySignatureRequest(e, f) {
    return this.sendMessage("client.applySignatureRequest", {
      signer: e,
      signatureRequestId: f,
    });
  }
  async register() {
    if (!this.#o) throw new ae();
    const { signatureText: e, signatureRequestId: f } =
      await this.unsafe_createInboxSignatureText();
    if (!e || !f) return;
    const _ = await this.#o.signMessage(e),
      w = await Pe(this.#o, _);
    return this.sendMessage("client.registerIdentity", {
      signer: w,
      signatureRequestId: f,
    });
  }
  async unsafe_addAccount(e, f = !1) {
    if (!this.#o) throw new ae();
    if (!f) throw new de();
    const _ = await this.findInboxIdByIdentifier(await e.getIdentifier());
    if (_) throw new ce(_);
    const { signatureText: w, signatureRequestId: v } =
        await this.unsafe_addAccountSignatureText(await e.getIdentifier(), !0),
      S = await e.signMessage(w),
      R = await Pe(e, S);
    return this.sendMessage("client.addAccount", {
      identifier: R.identifier,
      signer: R,
      signatureRequestId: v,
    });
  }
  async removeAccount(e) {
    if (!this.#o) throw new ae();
    const { signatureText: f, signatureRequestId: _ } =
        await this.unsafe_removeAccountSignatureText(e),
      w = await this.#o.signMessage(f),
      v = await Pe(this.#o, w);
    return this.sendMessage("client.removeAccount", {
      identifier: e,
      signer: v,
      signatureRequestId: _,
    });
  }
  async revokeAllOtherInstallations() {
    if (!this.#o) throw new ae();
    const { signatureText: e, signatureRequestId: f } =
      await this.unsafe_revokeAllOtherInstallationsSignatureText();
    if (!e) return;
    const _ = await this.#o.signMessage(e),
      w = await Pe(this.#o, _);
    return this.sendMessage("client.revokeAllOtherInstallations", {
      signer: w,
      signatureRequestId: f,
    });
  }
  async revokeInstallations(e) {
    if (!this.#o) throw new ae();
    const { signatureText: f, signatureRequestId: _ } =
        await this.unsafe_revokeInstallationsSignatureText(e),
      w = await this.#o.signMessage(f),
      v = await Pe(this.#o, w);
    return this.sendMessage("client.revokeInstallations", {
      installationIds: e,
      signer: v,
      signatureRequestId: _,
    });
  }
  static async revokeInstallations(e, f, _, w, v, S) {
    const R = new Ne(S);
    (await R.init(), await R.revokeInstallations(e, f, _, w, v), R.close());
  }
  static async inboxStateFromInboxIds(e, f, _, w) {
    const v = new Ne(_);
    await v.init();
    const S = await v.inboxStateFromInboxIds(e, f, w);
    return (v.close(), S);
  }
  async changeRecoveryIdentifier(e) {
    if (!this.#o) throw new ae();
    const { signatureText: f, signatureRequestId: _ } =
        await this.unsafe_changeRecoveryIdentifierSignatureText(e),
      w = await this.#o.signMessage(f),
      v = await Pe(this.#o, w);
    return this.sendMessage("client.changeRecoveryIdentifier", {
      identifier: e,
      signer: v,
      signatureRequestId: _,
    });
  }
  async isRegistered() {
    return this.sendMessage("client.isRegistered", void 0);
  }
  async canMessage(e) {
    return this.sendMessage("client.canMessage", { identifiers: e });
  }
  static async canMessage(e, f) {
    const _ = new Map(),
      w = new Ne();
    for (const v of e) {
      const S = await w.getInboxIdForIdentifier(v, f);
      _.set(v.identifier.toLowerCase(), S !== void 0);
    }
    return (w.close(), _);
  }
  async findInboxIdByIdentifier(e) {
    return this.sendMessage("client.findInboxIdByIdentifier", {
      identifier: e,
    });
  }
  codecFor(e) {
    return this.#e.get(e.toString());
  }
  encodeContent(e, f) {
    const _ = this.codecFor(f);
    if (!_) throw new oe(f);
    return this.#d(e, _);
  }
  prepareForSend(e, f) {
    const _ = this.codecFor(f);
    if (!_) throw new oe(f);
    return { encodedContent: this.#d(e, _), sendOptions: this.#f(e, _) };
  }
  #d(e, f) {
    const _ = f.encode(e, this),
      w = f.fallback(e);
    return (w && (_.fallback = w), T(_));
  }
  #f(e, f) {
    return { shouldPush: f.shouldPush(e) };
  }
  decodeContent(e, f) {
    const _ = this.codecFor(f);
    if (!_) throw new oe(f);
    if (f.sameAs(o) && e.kind !== GroupMessageKind.MembershipChange)
      throw new ge$1(e.id);
    const w = C$1(e.content);
    return _.decode(w, this);
  }
  signWithInstallationKey(e) {
    return this.sendMessage("client.signWithInstallationKey", {
      signatureText: e,
    });
  }
  verifySignedWithInstallationKey(e, f) {
    return this.sendMessage("client.verifySignedWithInstallationKey", {
      signatureText: e,
      signatureBytes: f,
    });
  }
  verifySignedWithPublicKey(e, f, _) {
    return this.sendMessage("client.verifySignedWithPublicKey", {
      signatureText: e,
      signatureBytes: f,
      publicKey: _,
    });
  }
  async getKeyPackageStatusesForInstallationIds(e) {
    return this.sendMessage("client.getKeyPackageStatusesForInstallationIds", {
      installationIds: e,
    });
  }
}
const n$2 = new t$7({
  authorityId: "xmtp.org",
  typeId: "markdown",
  versionMajor: 1,
  versionMinor: 0,
});
var t$5;
(function (a) {
  ((a.utf8 = "UTF-8"), (a.unknown = "unknown"));
})(t$5 || (t$5 = {}));
let r$3 = class {
  get contentType() {
    return n$2;
  }
  encode(e) {
    return {
      type: n$2,
      parameters: { encoding: t$5.utf8 },
      content: new TextEncoder().encode(e),
    };
  }
  decode(e) {
    if (e.parameters.encoding !== t$5.utf8)
      throw new Error(`unrecognized encoding ${e.parameters.encoding}`);
    return new TextDecoder().decode(e.content);
  }
  fallback() {}
  shouldPush() {
    return !0;
  }
};
const n$1 = new t$7({
  authorityId: "xmtp.org",
  typeId: "reaction",
  versionMajor: 1,
  versionMinor: 0,
});
let t$4 = class {
  get contentType() {
    return n$1;
  }
  encode(e) {
    const {
      action: f,
      reference: _,
      referenceInboxId: w,
      schema: v,
      content: S,
    } = e;
    return {
      type: this.contentType,
      parameters: {},
      content: new TextEncoder().encode(
        JSON.stringify({
          action: f,
          reference: _,
          referenceInboxId: w,
          schema: v,
          content: S,
        }),
      ),
    };
  }
  decode(e) {
    const f = new TextDecoder().decode(e.content);
    try {
      const w = JSON.parse(f),
        {
          action: v,
          reference: S,
          referenceInboxId: R,
          schema: O,
          content: j,
        } = w;
      return {
        action: v,
        reference: S,
        referenceInboxId: R,
        schema: O,
        content: j,
      };
    } catch {}
    const _ = e.parameters;
    return {
      action: _.action,
      reference: _.reference,
      schema: _.schema,
      content: f,
    };
  }
  fallback(e) {
    switch (e.action) {
      case "added":
        return `Reacted ${e.content} to an earlier message`;
      case "removed":
        return `Removed ${e.content} from an earlier message`;
      default:
        return;
    }
  }
  shouldPush() {
    return !1;
  }
};
const t$3 = new t$7({
  authorityId: "xmtp.org",
  typeId: "readReceipt",
  versionMajor: 1,
  versionMinor: 0,
});
let r$2 = class {
  get contentType() {
    return t$3;
  }
  encode() {
    return { type: t$3, parameters: {}, content: new Uint8Array() };
  }
  decode() {
    return {};
  }
  fallback() {}
  shouldPush() {
    return !1;
  }
};
/*! noble-secp256k1 - MIT License (c) 2019 Paul Miller (paulmillr.com) */ const B256 =
    2n ** 256n,
  P = B256 - 0x1000003d1n,
  N = B256 - 0x14551231950b75fc4402da1732fc9bebfn,
  Gx = 0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798n,
  Gy = 0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8n,
  CURVE = { a: 0n, b: 7n },
  fLen = 32,
  curve = (a) => M(M(a * a) * a + CURVE.b),
  err = (a = "") => {
    throw new Error(a);
  },
  isB = (a) => typeof a == "bigint",
  isS = (a) => typeof a == "string",
  fe = (a) => isB(a) && 0n < a && a < P,
  ge = (a) => isB(a) && 0n < a && a < N,
  isu8 = (a) =>
    a instanceof Uint8Array ||
    (ArrayBuffer.isView(a) && a.constructor.name === "Uint8Array"),
  au8 = (a, e) =>
    !isu8(a) || (typeof e == "number" && e > 0 && a.length !== e)
      ? err("Uint8Array expected")
      : a,
  u8n = (a) => new Uint8Array(a),
  toU8 = (a, e) => au8(isS(a) ? h2b(a) : u8n(au8(a)), e),
  M = (a, e = P) => {
    const f = a % e;
    return f >= 0n ? f : e + f;
  },
  aPoint = (a) => (a instanceof Point ? a : err("Point expected"));
class Point {
  constructor(e, f, _) {
    ((this.px = e), (this.py = f), (this.pz = _), Object.freeze(this));
  }
  static fromAffine(e) {
    return e.x === 0n && e.y === 0n ? I : new Point(e.x, e.y, 1n);
  }
  static fromHex(e) {
    e = toU8(e);
    let f;
    const _ = e[0],
      w = e.subarray(1),
      v = slc(w, 0, fLen),
      S = e.length;
    if (S === 33 && [2, 3].includes(_)) {
      fe(v) || err("Point hex invalid: x not FE");
      let R = sqrt(curve(v));
      const O = (R & 1n) === 1n;
      (((_ & 1) === 1) !== O && (R = M(-R)), (f = new Point(v, R, 1n)));
    }
    return (
      S === 65 && _ === 4 && (f = new Point(v, slc(w, fLen, 2 * fLen), 1n)),
      f ? f.ok() : err("Point invalid: not on curve")
    );
  }
  static fromPrivateKey(e) {
    return G.mul(toPriv(e));
  }
  get x() {
    return this.aff().x;
  }
  get y() {
    return this.aff().y;
  }
  equals(e) {
    const { px: f, py: _, pz: w } = this,
      { px: v, py: S, pz: R } = aPoint(e),
      O = M(f * R),
      j = M(v * w),
      F = M(_ * R),
      q = M(S * w);
    return O === j && F === q;
  }
  negate() {
    return new Point(this.px, M(-this.py), this.pz);
  }
  double() {
    return this.add(this);
  }
  add(e) {
    const { px: f, py: _, pz: w } = this,
      { px: v, py: S, pz: R } = aPoint(e),
      { a: O, b: j } = CURVE;
    let F = 0n,
      q = 0n,
      Q = 0n;
    const te = M(j * 3n);
    let se = M(f * v),
      re = M(_ * S),
      Oe = M(w * R),
      Le = M(f + _),
      Be = M(v + S);
    ((Le = M(Le * Be)), (Be = M(se + re)), (Le = M(Le - Be)), (Be = M(f + w)));
    let Ve = M(v + R);
    return (
      (Be = M(Be * Ve)),
      (Ve = M(se + Oe)),
      (Be = M(Be - Ve)),
      (Ve = M(_ + w)),
      (F = M(S + R)),
      (Ve = M(Ve * F)),
      (F = M(re + Oe)),
      (Ve = M(Ve - F)),
      (Q = M(O * Be)),
      (F = M(te * Oe)),
      (Q = M(F + Q)),
      (F = M(re - Q)),
      (Q = M(re + Q)),
      (q = M(F * Q)),
      (re = M(se + se)),
      (re = M(re + se)),
      (Oe = M(O * Oe)),
      (Be = M(te * Be)),
      (re = M(re + Oe)),
      (Oe = M(se - Oe)),
      (Oe = M(O * Oe)),
      (Be = M(Be + Oe)),
      (se = M(re * Be)),
      (q = M(q + se)),
      (se = M(Ve * Be)),
      (F = M(Le * F)),
      (F = M(F - se)),
      (se = M(Le * re)),
      (Q = M(Ve * Q)),
      (Q = M(Q + se)),
      new Point(F, q, Q)
    );
  }
  mul(e, f = !0) {
    if (!f && e === 0n) return I;
    if ((ge(e) || err("scalar invalid"), this.equals(G))) return wNAF(e).p;
    let _ = I,
      w = G;
    for (let v = this; e > 0n; v = v.double(), e >>= 1n)
      e & 1n ? (_ = _.add(v)) : f && (w = w.add(v));
    return _;
  }
  mulAddQUns(e, f, _) {
    return this.mul(f, !1).add(e.mul(_, !1)).ok();
  }
  toAffine() {
    const { px: e, py: f, pz: _ } = this;
    if (this.equals(I)) return { x: 0n, y: 0n };
    if (_ === 1n) return { x: e, y: f };
    const w = inv(_, P);
    return (
      M(_ * w) !== 1n && err("inverse invalid"),
      { x: M(e * w), y: M(f * w) }
    );
  }
  assertValidity() {
    const { x: e, y: f } = this.aff();
    return (
      (!fe(e) || !fe(f)) && err("Point invalid: x or y"),
      M(f * f) === curve(e) ? this : err("Point invalid: not on curve")
    );
  }
  multiply(e) {
    return this.mul(e);
  }
  aff() {
    return this.toAffine();
  }
  ok() {
    return this.assertValidity();
  }
  toHex(e = !0) {
    const { x: f, y: _ } = this.aff();
    return (
      (e ? ((_ & 1n) === 0n ? "02" : "03") : "04") + n2h(f) + (e ? "" : n2h(_))
    );
  }
  toRawBytes(e = !0) {
    return h2b(this.toHex(e));
  }
}
Point.BASE = new Point(Gx, Gy, 1n);
Point.ZERO = new Point(0n, 1n, 0n);
const { BASE: G, ZERO: I } = Point,
  padh = (a, e) => a.toString(16).padStart(e, "0"),
  b2h = (a) =>
    Array.from(au8(a))
      .map((e) => padh(e, 2))
      .join(""),
  C = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 },
  _ch = (a) => {
    if (a >= C._0 && a <= C._9) return a - C._0;
    if (a >= C.A && a <= C.F) return a - (C.A - 10);
    if (a >= C.a && a <= C.f) return a - (C.a - 10);
  },
  h2b = (a) => {
    const e = "hex invalid";
    if (!isS(a)) return err(e);
    const f = a.length,
      _ = f / 2;
    if (f % 2) return err(e);
    const w = u8n(_);
    for (let v = 0, S = 0; v < _; v++, S += 2) {
      const R = _ch(a.charCodeAt(S)),
        O = _ch(a.charCodeAt(S + 1));
      if (R === void 0 || O === void 0) return err(e);
      w[v] = R * 16 + O;
    }
    return w;
  },
  b2n = (a) => BigInt("0x" + (b2h(a) || "0")),
  slc = (a, e, f) => b2n(a.slice(e, f)),
  n2b = (a) =>
    isB(a) && a >= 0n && a < B256
      ? h2b(padh(a, 2 * fLen))
      : err("bigint expected"),
  n2h = (a) => b2h(n2b(a)),
  concatB = (...a) => {
    const e = u8n(a.reduce((_, w) => _ + au8(w).length, 0));
    let f = 0;
    return (
      a.forEach((_) => {
        (e.set(_, f), (f += _.length));
      }),
      e
    );
  },
  inv = (a, e) => {
    (a === 0n || e <= 0n) && err("no inverse n=" + a + " mod=" + e);
    let f = M(a, e),
      _ = e,
      w = 0n,
      v = 1n;
    for (; f !== 0n; ) {
      const S = _ / f,
        R = _ % f,
        O = w - v * S;
      ((_ = f), (f = R), (w = v), (v = O));
    }
    return _ === 1n ? M(w, e) : err("no inverse");
  },
  sqrt = (a) => {
    let e = 1n;
    for (let f = a, _ = (P + 1n) / 4n; _ > 0n; _ >>= 1n)
      (_ & 1n && (e = (e * f) % P), (f = (f * f) % P));
    return M(e * e) === a ? e : err("sqrt invalid");
  },
  toPriv = (a) => (
    isB(a) || (a = b2n(toU8(a, fLen))),
    ge(a) ? a : err("private key invalid 3")
  ),
  cr = () =>
    typeof globalThis == "object" && "crypto" in globalThis
      ? globalThis.crypto
      : void 0;
let _hmacSync;
const hashToPrivateKey = (a) => {
    ((a = toU8(a)),
      (a.length < fLen + 8 || a.length > 1024) && err("expected 40-1024b"));
    const e = M(b2n(a), N - 1n);
    return n2b(e + 1n);
  },
  etc = {
    hexToBytes: h2b,
    bytesToHex: b2h,
    concatBytes: concatB,
    bytesToNumberBE: b2n,
    numberToBytesBE: n2b,
    mod: M,
    invert: inv,
    hmacSha256Async: async (a, ...e) => {
      const f = cr(),
        _ = f && f.subtle;
      if (!_)
        return err("etc.hmacSha256Async or crypto.subtle must be defined");
      const w = await _.importKey(
        "raw",
        a,
        { name: "HMAC", hash: { name: "SHA-256" } },
        !1,
        ["sign"],
      );
      return u8n(await _.sign("HMAC", w, concatB(...e)));
    },
    hmacSha256Sync: _hmacSync,
    hashToPrivateKey,
    randomBytes: (a = 32) => {
      const e = cr();
      return (
        (!e || !e.getRandomValues) &&
          err("crypto.getRandomValues must be defined"),
        e.getRandomValues(u8n(a))
      );
    },
  };
Object.defineProperties(etc, {
  hmacSha256Sync: {
    configurable: !1,
    get() {
      return _hmacSync;
    },
    set(a) {
      _hmacSync || (_hmacSync = a);
    },
  },
});
const W = 8,
  precompute = () => {
    const a = [],
      e = 256 / W + 1;
    let f = G,
      _ = f;
    for (let w = 0; w < e; w++) {
      ((_ = f), a.push(_));
      for (let v = 1; v < 2 ** (W - 1); v++) ((_ = _.add(f)), a.push(_));
      f = _.double();
    }
    return a;
  };
let Gpows;
const wNAF = (a) => {
  const e = Gpows || (Gpows = precompute()),
    f = (F, q) => {
      let Q = q.negate();
      return F ? Q : q;
    };
  let _ = I,
    w = G;
  const v = 1 + 256 / W,
    S = 2 ** (W - 1),
    R = BigInt(2 ** W - 1),
    O = 2 ** W,
    j = BigInt(W);
  for (let F = 0; F < v; F++) {
    const q = F * S;
    let Q = Number(a & R);
    ((a >>= j), Q > S && ((Q -= O), (a += 1n)));
    const te = q,
      se = q + Math.abs(Q) - 1,
      re = F % 2 !== 0,
      Oe = Q < 0;
    Q === 0 ? (w = w.add(f(re, e[te]))) : (_ = _.add(f(Oe, e[se])));
  }
  return { p: _, f: w };
};
new t$7({
  authorityId: "xmtp.org",
  typeId: "attachment",
  versionMajor: 1,
  versionMinor: 0,
});
class c {
  aes256GcmHkdfSha256;
  constructor(e) {
    if (!e.aes256GcmHkdfSha256) throw new Error("invalid ciphertext");
    if (e.aes256GcmHkdfSha256.payload.length < 16)
      throw new Error(
        `invalid ciphertext ciphertext length: ${e.aes256GcmHkdfSha256.payload.length}`,
      );
    if (e.aes256GcmHkdfSha256.hkdfSalt.length !== 32)
      throw new Error(
        `invalid ciphertext salt length: ${e.aes256GcmHkdfSha256.hkdfSalt.length}`,
      );
    if (e.aes256GcmHkdfSha256.gcmNonce.length !== 12)
      throw new Error(
        `invalid ciphertext nonce length: ${e.aes256GcmHkdfSha256.gcmNonce.length}`,
      );
    this.aes256GcmHkdfSha256 = e.aes256GcmHkdfSha256;
  }
  toBytes() {
    return Ciphertext.encode(this).finish();
  }
  static fromBytes(e) {
    return new c(Ciphertext.decode(e));
  }
}
const s = window.crypto,
  i = new Uint8Array().buffer;
function d(a, e) {
  return { name: "AES-GCM", iv: a };
}
async function h(a, e) {
  const f = await s.subtle.importKey("raw", a, "HKDF", !1, ["deriveKey"]);
  return s.subtle.deriveKey(
    { name: "HKDF", hash: "SHA-256", salt: e, info: i },
    f,
    { name: "AES-GCM", length: 256 },
    !1,
    ["encrypt", "decrypt"],
  );
}
new Uint8Array().buffer;
const m = new t$7({
  authorityId: "xmtp.org",
  typeId: "remoteStaticAttachment",
  versionMajor: 1,
  versionMinor: 0,
});
class l {
  static async load(e, f) {
    const _ = await fetch(e.url),
      w = new Uint8Array(await _.arrayBuffer());
    if (w.length === 0)
      throw new Error(`no payload for remote attachment at ${e.url}`);
    const v = new Uint8Array(await s.subtle.digest("SHA-256", w));
    if (etc.bytesToHex(v) !== e.contentDigest)
      throw new Error("content digest does not match");
    const S = new c({
        aes256GcmHkdfSha256: {
          hkdfSalt: e.salt,
          gcmNonce: e.nonce,
          payload: w,
        },
      }),
      R = await (async function (F, q) {
        if (!F.aes256GcmHkdfSha256)
          throw new Error("invalid payload ciphertext");
        const Q = await h(q, F.aes256GcmHkdfSha256.hkdfSalt),
          te = await s.subtle.decrypt(
            d(F.aes256GcmHkdfSha256.gcmNonce),
            Q,
            F.aes256GcmHkdfSha256.payload,
          );
        return new Uint8Array(te);
      })(S, e.secret),
      O = EncodedContent$1.decode(R);
    if (!O.type) throw new Error("no content type");
    const j = f.codecFor(new t$7(O.type));
    if (!j) throw new Error(`no codec found for ${O.type.typeId}`);
    return j.decode(O, f);
  }
  static async encodeEncrypted(e, f) {
    const _ = s.getRandomValues(new Uint8Array(32)),
      w = EncodedContent$1.encode(f.encode(e, { codecFor() {} })).finish(),
      v = await (async function (F, q) {
        const Q = s.getRandomValues(new Uint8Array(32)),
          te = s.getRandomValues(new Uint8Array(12)),
          se = await h(q, Q),
          re = await s.subtle.encrypt(d(te), se, F);
        return new c({
          aes256GcmHkdfSha256: {
            payload: new Uint8Array(re),
            hkdfSalt: Q,
            gcmNonce: te,
          },
        });
      })(w, _),
      S = v.aes256GcmHkdfSha256?.hkdfSalt,
      R = v.aes256GcmHkdfSha256?.gcmNonce,
      O = v.aes256GcmHkdfSha256?.payload;
    if (!S || !R || !O) throw new Error("missing encryption key");
    const j = new Uint8Array(await s.subtle.digest("SHA-256", O));
    return {
      digest: etc.bytesToHex(j),
      secret: _,
      salt: S,
      nonce: R,
      payload: O,
    };
  }
  get contentType() {
    return m;
  }
  encode(e) {
    if (!e.url.startsWith("https")) throw new Error("scheme must be https");
    return {
      type: m,
      parameters: {
        contentDigest: e.contentDigest,
        salt: etc.bytesToHex(e.salt),
        nonce: etc.bytesToHex(e.nonce),
        secret: etc.bytesToHex(e.secret),
        scheme: e.scheme,
        contentLength: String(e.contentLength),
        filename: e.filename,
      },
      content: new TextEncoder().encode(e.url),
    };
  }
  decode(e) {
    return {
      url: new TextDecoder().decode(e.content),
      contentDigest: e.parameters.contentDigest,
      salt: etc.hexToBytes(e.parameters.salt),
      nonce: etc.hexToBytes(e.parameters.nonce),
      secret: etc.hexToBytes(e.parameters.secret),
      scheme: e.parameters.scheme,
      contentLength: parseInt(e.parameters.contentLength, 10),
      filename: e.parameters.filename,
    };
  }
  fallback(e) {
    return `Cant display "${e.filename}". This app doesnt support attachments.`;
  }
  shouldPush() {
    return !0;
  }
}
const t$2 = new t$7({
  authorityId: "xmtp.org",
  typeId: "reply",
  versionMajor: 1,
  versionMinor: 0,
});
let r$1 = class {
  get contentType() {
    return t$2;
  }
  encode(e, f) {
    const _ = f.codecFor(e.contentType);
    if (!_)
      throw new Error(
        `missing codec for content type "${e.contentType.toString()}"`,
      );
    const w = _.encode(e.content, f),
      v = EncodedContent$1.encode(w).finish(),
      S = { contentType: e.contentType.toString(), reference: e.reference };
    return (
      e.referenceInboxId && (S.referenceInboxId = e.referenceInboxId),
      { type: this.contentType, parameters: S, content: v }
    );
  }
  decode(e, f) {
    const _ = EncodedContent$1.decode(e.content);
    if (!_.type) throw new Error("missing content type");
    const w = new t$7(_.type),
      v = f.codecFor(w);
    if (!v) throw new Error(`missing codec for content type "${w.toString()}"`);
    return {
      reference: e.parameters.reference,
      referenceInboxId: e.parameters.referenceInboxId,
      contentType: w,
      content: v.decode(_, f),
    };
  }
  fallback(e) {
    return typeof e.content == "string"
      ? `Replied with ${e.content} to an earlier message`
      : "Replied to an earlier message";
  }
  shouldPush() {
    return !0;
  }
};
const t$1 = new t$7({
  authorityId: "xmtp.org",
  typeId: "transactionReference",
  versionMajor: 1,
  versionMinor: 0,
});
class r {
  get contentType() {
    return t$1;
  }
  encode(e) {
    return {
      type: t$1,
      parameters: {},
      content: new TextEncoder().encode(JSON.stringify(e)),
    };
  }
  decode(e) {
    const f = e.content;
    return JSON.parse(new TextDecoder().decode(f));
  }
  fallback(e) {
    return e.reference
      ? `[Crypto transaction] Use a blockchain explorer to learn more using the transaction hash: ${e.reference}`
      : "Crypto transaction";
  }
  shouldPush() {
    return !0;
  }
}
const t = new t$7({
  authorityId: "xmtp.org",
  typeId: "walletSendCalls",
  versionMajor: 1,
  versionMinor: 0,
});
class n {
  get contentType() {
    return t;
  }
  encode(e) {
    return {
      type: t,
      parameters: {},
      content: new TextEncoder().encode(JSON.stringify(e)),
    };
  }
  decode(e) {
    const f = e.content;
    return JSON.parse(new TextDecoder().decode(f));
  }
  fallback(e) {
    return `[Transaction request generated]: ${JSON.stringify(e)}`;
  }
  shouldPush() {
    return !0;
  }
}
const createEphemeralSigner = (a) => {
  const e = privateKeyToAccount(a);
  return {
    type: "EOA",
    getIdentifier: () => ({
      identifier: e.address.toLowerCase(),
      identifierKind: "Ethereum",
    }),
    signMessage: async (_) => {
      const w = await e.signMessage({ message: _ });
      return toBytes(w);
    },
  };
};
async function createXMTPClient(a) {
  if (typeof window > "u")
    throw new Error("XMTP client can only be created in browser environment");
  const e = createEphemeralSigner(a),
    f = [new t$4(), new r$1(), new l(), new r(), new n(), new r$2(), new r$3()];
  return await Re.create(e, {
    env: "production",
    loggingLevel: "warn",
    appVersion: "xmtp-agents/0",
    codecs: f,
  });
}
function useXMTPClient() {
  const [a, e] = reactExports.useState(null),
    [f, _] = reactExports.useState(!0),
    [w, v] = reactExports.useState(null);
  return (
    reactExports.useEffect(() => {
      if (typeof window > "u") {
        console.log(
          "[useXMTPClient] Window not available, skipping initialization",
        );
        return;
      }
      let S = !0;
      return (
        console.log("[useXMTPClient] Starting client initialization"),
        (async () => {
          try {
            (console.log("[useXMTPClient] Setting loading state to true"),
              _(!0),
              v(null),
              console.log(
                "[useXMTPClient] Waiting 100ms before initialization",
              ),
              await new Promise((F) => setTimeout(F, 100)),
              console.log(
                "[useXMTPClient] Getting or creating ephemeral account key",
              ));
            const O = getOrCreateEphemeralAccountKey();
            (console.log("[useXMTPClient] Account key length:", O.length),
              console.log("[useXMTPClient] Creating XMTP client..."));
            const j = await createXMTPClient(O);
            (console.log(
              "[useXMTPClient] XMTP client created, inboxId:",
              j.inboxId,
            ),
              S
                ? (console.log(
                    "[useXMTPClient] Component still mounted, setting client state",
                  ),
                  e(j),
                  _(!1),
                  console.log(
                    "[useXMTPClient] Client initialized successfully, state updated",
                  ))
                : (console.log(
                    "[useXMTPClient] Component unmounted, closing client",
                  ),
                  j.close()));
          } catch (O) {
            (console.error("[useXMTPClient] Failed to initialize:", O),
              console.error("[useXMTPClient] Error details:", {
                message: O instanceof Error ? O.message : String(O),
                stack: O instanceof Error ? O.stack : void 0,
              }),
              S &&
                (v(O instanceof Error ? O : new Error(String(O))),
                _(!1),
                console.log(
                  "[useXMTPClient] Error state set, isLoading set to false",
                )));
          }
        })(),
        () => {
          (console.log("[useXMTPClient] Cleanup: unmounting"),
            (S = !1),
            a &&
              (console.log("[useXMTPClient] Cleanup: closing client"),
              a.close()));
        }
      );
    }, []),
    { client: a, isLoading: f, error: w }
  );
}
async function findOrCreateDmWithAddress(a, e) {
  const f = await a.findInboxIdByIdentifier({
    identifier: e.toLowerCase(),
    identifierKind: "Ethereum",
  });
  if (!f) throw new Error(`Address ${e} is not registered on XMTP`);
  const _ = await a.conversations.getDmByInboxId(f);
  return (
    _ ||
    (await a.conversations.newDmWithIdentifier({
      identifier: e.toLowerCase(),
      identifierKind: "Ethereum",
    }))
  );
}
const FIXED_AGENT_ADDRESS$1 = "0x194c31cae1418d5256e8c58e0d08aee1046c6ed0";
function useXMTPConversations(a) {
  const [e, f] = reactExports.useState([]),
    [_, w] = reactExports.useState(null),
    [v, S] = reactExports.useState(!1),
    [R, O] = reactExports.useState(null);
  return (
    reactExports.useEffect(() => {
      if (!a) return;
      let j = !0,
        F = null;
      return (
        (async () => {
          try {
            (S(!0),
              O(null),
              console.log(
                "[useXMTPConversations] Initializing conversations...",
              ),
              await a.conversations.sync(),
              console.log("[useXMTPConversations] Synced conversations"));
            const Q = await findOrCreateDmWithAddress(a, FIXED_AGENT_ADDRESS$1);
            console.log(
              "[useXMTPConversations] Created/found fixed conversation:",
              Q.id,
            );
            const te = await a.conversations.list();
            (console.log(
              "[useXMTPConversations] Loaded conversations:",
              te.length,
            ),
              j && (f(te), w(Q), S(!1)));
            const se = await a.conversations.stream({
              onValue: (re) => {
                (console.log(
                  "[useXMTPConversations] New conversation received:",
                  re.id,
                ),
                  j &&
                    f((Oe) =>
                      Oe.some((Be) => Be.id === re.id)
                        ? Oe.map((Be) => (Be.id === re.id ? re : Be))
                        : [...Oe, re],
                    ));
              },
            });
            F = async () => {
              await se.end();
            };
          } catch (Q) {
            (console.error("[useXMTPConversations] Failed to initialize:", Q),
              j && (O(Q instanceof Error ? Q : new Error(String(Q))), S(!1)));
          }
        })(),
        () => {
          ((j = !1), F && F().catch(console.error));
        }
      );
    }, [a]),
    {
      conversations: e,
      selectedConversation: _,
      setSelectedConversation: w,
      isLoading: v,
      error: R,
    }
  );
}
const FIXED_AGENT_ADDRESS = "0x194c31cae1418d5256e8c58e0d08aee1046c6ed0";
function ChatArea() {
  const [a, e] = reactExports.useState([]),
    { client: f, isLoading: _, error: w } = useXMTPClient();
  useXMTPConversations(f);
  const v = reactExports.useRef(null);
  (console.log("[ChatArea] Render - client state:", {
    hasClient: !!f,
    isLoading: _,
    hasError: !!w,
    clientInboxId: f?.inboxId,
  }),
    reactExports.useEffect(() => {
      if (
        (console.log("[ChatArea] useEffect triggered - client state:", {
          hasClient: !!f,
          isLoading: _,
          hasError: !!w,
        }),
        !f)
      ) {
        console.log("[ChatArea] XMTP client not ready yet", {
          isLoading: _,
          error: w?.message,
        });
        return;
      }
      (console.log("[ChatArea] Client is ready, inboxId:", f.inboxId),
        (async () => {
          try {
            console.log(
              "[ChatArea] Finding or creating conversation with agent:",
              FIXED_AGENT_ADDRESS,
            );
            const O = await findOrCreateDmWithAddress(f, FIXED_AGENT_ADDRESS);
            if (
              ((v.current = O),
              console.log("[ChatArea] Conversation ready:", O.id),
              !O)
            ) {
              console.error("[ChatArea] Failed to get conversation");
              return;
            }
            await (async () => {
              try {
                (console.log("[ChatArea] Loading existing messages..."),
                  await O.sync());
                const Q = await O.messages();
                console.log("[ChatArea] Loaded", Q.length, "existing messages");
                const te = Q.filter((se) => typeof se.content == "string").map(
                  (se) => {
                    const re = se.senderInboxId === f?.inboxId;
                    return {
                      id: se.id,
                      role: re ? "user" : "assistant",
                      content: se.content,
                    };
                  },
                );
                (e(te),
                  console.log("[ChatArea] Messages set in state:", te.length));
              } catch (Q) {
                console.error("[ChatArea] Error loading messages:", Q);
              }
            })();
            const q = (async () => {
              try {
                console.log("[ChatArea] Starting message stream...");
                const Q = await O.stream({
                  onValue: (te) => {
                    if (
                      (console.log("[ChatArea] New message received:", {
                        id: te.id,
                        content: te.content,
                        contentType: typeof te.content,
                        senderInboxId: te.senderInboxId,
                      }),
                      typeof te.content != "string")
                    ) {
                      console.log("[ChatArea] Skipping non-text message");
                      return;
                    }
                    const se = te.senderInboxId === f?.inboxId,
                      re = {
                        id: te.id,
                        role: se ? "user" : "assistant",
                        content: te.content,
                      };
                    e((Oe) =>
                      Oe.some((Be) => Be.id === te.id)
                        ? (console.log(
                            "[ChatArea] Message already exists, skipping:",
                            te.id,
                          ),
                          Oe)
                        : (console.log(
                            "[ChatArea] Adding new message to state",
                          ),
                          [...Oe, re]),
                    );
                  },
                });
                return () => {
                  Q.end().catch(console.error);
                };
              } catch (Q) {
                console.error("[ChatArea] Error setting up message stream:", Q);
              }
            })();
            return () => {
              q.then((Q) => Q?.()).catch(console.error);
            };
          } catch (O) {
            console.error("[ChatArea] Error setting up conversation:", O);
          }
        })());
    }, [f]));
  const S = async (R) => {
    if (
      (console.log("[ChatArea] handleSendMessage called with:", R),
      console.log("[ChatArea] Client state at send time:", {
        hasClient: !!f,
        isLoading: _,
        hasError: !!w,
        clientInboxId: f?.inboxId,
      }),
      !f)
    ) {
      console.error("[ChatArea] Cannot send message: XMTP client not ready", {
        isLoading: _,
        error: w?.message,
      });
      return;
    }
    let O = v.current;
    if (!O) {
      console.log("[ChatArea] Conversation not in ref, finding/creating it...");
      try {
        ((O = await findOrCreateDmWithAddress(f, FIXED_AGENT_ADDRESS)),
          (v.current = O),
          console.log("[ChatArea] Got conversation:", O.id));
      } catch (F) {
        console.error("[ChatArea] Failed to get conversation:", F);
        return;
      }
    }
    console.log("[ChatArea] Using conversation:", O.id);
    const j = { id: `temp-${Date.now()}`, role: "user", content: R };
    e(
      (F) => (
        console.log("[ChatArea] Adding temporary message to UI"),
        [...F, j]
      ),
    );
    try {
      (console.log(
        "[ChatArea] Sending message via XMTP to agent:",
        FIXED_AGENT_ADDRESS,
      ),
        await O.send(R),
        console.log("[ChatArea] Message sent successfully via XMTP"),
        e((F) => {
          const q = F.filter((Q) => Q.id !== j.id);
          return (
            console.log(
              "[ChatArea] Removing temp message, keeping sent message",
            ),
            q
          );
        }));
    } catch (F) {
      (console.error("[ChatArea] Error sending message:", F),
        e((q) => {
          const Q = q.filter((te) => te.id !== j.id);
          return (
            console.log("[ChatArea] Removing temp message due to error"),
            Q
          );
        }));
    }
  };
  return jsxRuntimeExports.jsxs("div", {
    className:
      "overscroll-behavior-contain flex h-dvh min-w-0 touch-pan-y flex-col bg-background",
    children: [
      jsxRuntimeExports.jsx(ChatHeader, {
        chatId: "wireframe",
        isReadonly: !1,
      }),
      jsxRuntimeExports.jsx("div", {
        className: "relative flex-1",
        children: jsxRuntimeExports.jsx("div", {
          className: "absolute inset-0 touch-pan-y overflow-y-auto",
          children: jsxRuntimeExports.jsxs("div", {
            className:
              "mx-auto flex min-w-0 max-w-4xl flex-col gap-4 px-2 py-4 md:gap-6 md:px-4",
            children: [
              a.length === 0 && jsxRuntimeExports.jsx(Greeting, {}),
              a.map((R) =>
                jsxRuntimeExports.jsx(
                  "div",
                  {
                    className:
                      "group/message is-user fade-in w-full animate-in duration-150",
                    children: jsxRuntimeExports.jsx("div", {
                      className:
                        "flex w-full items-start gap-2 md:gap-3 justify-end",
                      children: jsxRuntimeExports.jsx("div", {
                        className:
                          "flex flex-col gap-2 md:gap-4 max-w-[calc(100%-2.5rem)] sm:max-w-[min(fit-content,80%)]",
                        children: jsxRuntimeExports.jsx("div", {
                          className:
                            "flex flex-col gap-2 overflow-hidden text-sm group-[.is-user]:bg-primary group-[.is-user]:text-primary-foreground group-[.is-assistant]:bg-secondary group-[.is-assistant]:text-foreground w-fit break-words rounded-md px-3 py-2",
                          children: jsxRuntimeExports.jsx("div", {
                            className:
                              "space-y-4 whitespace-normal size-full [&>*:first-child]:mt-0 [&>*:last-child]:mb-0 [&_code]:whitespace-pre-wrap [&_code]:break-words [&_pre]:max-w-full [&_pre]:overflow-x-auto",
                            children: jsxRuntimeExports.jsx("p", {
                              children: R.content,
                            }),
                          }),
                        }),
                      }),
                    }),
                  },
                  R.id,
                ),
              ),
            ],
          }),
        }),
      }),
      jsxRuntimeExports.jsx("div", {
        className:
          "sticky bottom-0 z-1 mx-auto flex w-full max-w-4xl gap-2 border-t-0 bg-background px-2 pb-3 md:px-4 md:pb-4",
        children: jsxRuntimeExports.jsx(InputArea, {
          messages: a,
          sendMessage: S,
        }),
      }),
    ],
  });
}
var ENTRY_FOCUS = "rovingFocusGroup.onEntryFocus",
  EVENT_OPTIONS = { bubbles: !1, cancelable: !0 },
  GROUP_NAME$2 = "RovingFocusGroup",
  [Collection$1, useCollection$1, createCollectionScope$1] =
    createCollection(GROUP_NAME$2),
  [createRovingFocusGroupContext, createRovingFocusGroupScope] =
    createContextScope(GROUP_NAME$2, [createCollectionScope$1]),
  [RovingFocusProvider, useRovingFocusContext] =
    createRovingFocusGroupContext(GROUP_NAME$2),
  RovingFocusGroup = reactExports.forwardRef((a, e) =>
    jsxRuntimeExports.jsx(Collection$1.Provider, {
      scope: a.__scopeRovingFocusGroup,
      children: jsxRuntimeExports.jsx(Collection$1.Slot, {
        scope: a.__scopeRovingFocusGroup,
        children: jsxRuntimeExports.jsx(RovingFocusGroupImpl, { ...a, ref: e }),
      }),
    }),
  );
RovingFocusGroup.displayName = GROUP_NAME$2;
var RovingFocusGroupImpl = reactExports.forwardRef((a, e) => {
    const {
        __scopeRovingFocusGroup: f,
        orientation: _,
        loop: w = !1,
        dir: v,
        currentTabStopId: S,
        defaultCurrentTabStopId: R,
        onCurrentTabStopIdChange: O,
        onEntryFocus: j,
        preventScrollOnEntryFocus: F = !1,
        ...q
      } = a,
      Q = reactExports.useRef(null),
      te = useComposedRefs(e, Q),
      se = useDirection(v),
      [re, Oe] = useControllableState({
        prop: S,
        defaultProp: R ?? null,
        onChange: O,
        caller: GROUP_NAME$2,
      }),
      [Le, Be] = reactExports.useState(!1),
      Ve = useCallbackRef$1(j),
      ze = useCollection$1(f),
      Ge = reactExports.useRef(!1),
      [Ke, qe] = reactExports.useState(0);
    return (
      reactExports.useEffect(() => {
        const nt = Q.current;
        if (nt)
          return (
            nt.addEventListener(ENTRY_FOCUS, Ve),
            () => nt.removeEventListener(ENTRY_FOCUS, Ve)
          );
      }, [Ve]),
      jsxRuntimeExports.jsx(RovingFocusProvider, {
        scope: f,
        orientation: _,
        dir: se,
        loop: w,
        currentTabStopId: re,
        onItemFocus: reactExports.useCallback((nt) => Oe(nt), [Oe]),
        onItemShiftTab: reactExports.useCallback(() => Be(!0), []),
        onFocusableItemAdd: reactExports.useCallback(
          () => qe((nt) => nt + 1),
          [],
        ),
        onFocusableItemRemove: reactExports.useCallback(
          () => qe((nt) => nt - 1),
          [],
        ),
        children: jsxRuntimeExports.jsx(Primitive$1.div, {
          tabIndex: Le || Ke === 0 ? -1 : 0,
          "data-orientation": _,
          ...q,
          ref: te,
          style: { outline: "none", ...a.style },
          onMouseDown: composeEventHandlers(a.onMouseDown, () => {
            Ge.current = !0;
          }),
          onFocus: composeEventHandlers(a.onFocus, (nt) => {
            const pt = !Ge.current;
            if (nt.target === nt.currentTarget && pt && !Le) {
              const gt = new CustomEvent(ENTRY_FOCUS, EVENT_OPTIONS);
              if ((nt.currentTarget.dispatchEvent(gt), !gt.defaultPrevented)) {
                const mt = ze().filter(($e) => $e.focusable),
                  dt = mt.find(($e) => $e.active),
                  _t = mt.find(($e) => $e.id === re),
                  at = [dt, _t, ...mt]
                    .filter(Boolean)
                    .map(($e) => $e.ref.current);
                focusFirst$1(at, F);
              }
            }
            Ge.current = !1;
          }),
          onBlur: composeEventHandlers(a.onBlur, () => Be(!1)),
        }),
      })
    );
  }),
  ITEM_NAME$2 = "RovingFocusGroupItem",
  RovingFocusGroupItem = reactExports.forwardRef((a, e) => {
    const {
        __scopeRovingFocusGroup: f,
        focusable: _ = !0,
        active: w = !1,
        tabStopId: v,
        children: S,
        ...R
      } = a,
      O = useId(),
      j = v || O,
      F = useRovingFocusContext(ITEM_NAME$2, f),
      q = F.currentTabStopId === j,
      Q = useCollection$1(f),
      {
        onFocusableItemAdd: te,
        onFocusableItemRemove: se,
        currentTabStopId: re,
      } = F;
    return (
      reactExports.useEffect(() => {
        if (_) return (te(), () => se());
      }, [_, te, se]),
      jsxRuntimeExports.jsx(Collection$1.ItemSlot, {
        scope: f,
        id: j,
        focusable: _,
        active: w,
        children: jsxRuntimeExports.jsx(Primitive$1.span, {
          tabIndex: q ? 0 : -1,
          "data-orientation": F.orientation,
          ...R,
          ref: e,
          onMouseDown: composeEventHandlers(a.onMouseDown, (Oe) => {
            _ ? F.onItemFocus(j) : Oe.preventDefault();
          }),
          onFocus: composeEventHandlers(a.onFocus, () => F.onItemFocus(j)),
          onKeyDown: composeEventHandlers(a.onKeyDown, (Oe) => {
            if (Oe.key === "Tab" && Oe.shiftKey) {
              F.onItemShiftTab();
              return;
            }
            if (Oe.target !== Oe.currentTarget) return;
            const Le = getFocusIntent(Oe, F.orientation, F.dir);
            if (Le !== void 0) {
              if (Oe.metaKey || Oe.ctrlKey || Oe.altKey || Oe.shiftKey) return;
              Oe.preventDefault();
              let Ve = Q()
                .filter((ze) => ze.focusable)
                .map((ze) => ze.ref.current);
              if (Le === "last") Ve.reverse();
              else if (Le === "prev" || Le === "next") {
                Le === "prev" && Ve.reverse();
                const ze = Ve.indexOf(Oe.currentTarget);
                Ve = F.loop ? wrapArray$1(Ve, ze + 1) : Ve.slice(ze + 1);
              }
              setTimeout(() => focusFirst$1(Ve));
            }
          }),
          children:
            typeof S == "function"
              ? S({ isCurrentTabStop: q, hasTabStop: re != null })
              : S,
        }),
      })
    );
  });
RovingFocusGroupItem.displayName = ITEM_NAME$2;
var MAP_KEY_TO_FOCUS_INTENT = {
  ArrowLeft: "prev",
  ArrowUp: "prev",
  ArrowRight: "next",
  ArrowDown: "next",
  PageUp: "first",
  Home: "first",
  PageDown: "last",
  End: "last",
};
function getDirectionAwareKey(a, e) {
  return e !== "rtl"
    ? a
    : a === "ArrowLeft"
      ? "ArrowRight"
      : a === "ArrowRight"
        ? "ArrowLeft"
        : a;
}
function getFocusIntent(a, e, f) {
  const _ = getDirectionAwareKey(a.key, f);
  if (
    !(e === "vertical" && ["ArrowLeft", "ArrowRight"].includes(_)) &&
    !(e === "horizontal" && ["ArrowUp", "ArrowDown"].includes(_))
  )
    return MAP_KEY_TO_FOCUS_INTENT[_];
}
function focusFirst$1(a, e = !1) {
  const f = document.activeElement;
  for (const _ of a)
    if (
      _ === f ||
      (_.focus({ preventScroll: e }), document.activeElement !== f)
    )
      return;
}
function wrapArray$1(a, e) {
  return a.map((f, _) => a[(e + _) % a.length]);
}
var Root = RovingFocusGroup,
  Item = RovingFocusGroupItem;
function createSlot(a) {
  const e = createSlotClone(a),
    f = reactExports.forwardRef((_, w) => {
      const { children: v, ...S } = _,
        R = reactExports.Children.toArray(v),
        O = R.find(isSlottable);
      if (O) {
        const j = O.props.children,
          F = R.map((q) =>
            q === O
              ? reactExports.Children.count(j) > 1
                ? reactExports.Children.only(null)
                : reactExports.isValidElement(j)
                  ? j.props.children
                  : null
              : q,
          );
        return jsxRuntimeExports.jsx(e, {
          ...S,
          ref: w,
          children: reactExports.isValidElement(j)
            ? reactExports.cloneElement(j, void 0, F)
            : null,
        });
      }
      return jsxRuntimeExports.jsx(e, { ...S, ref: w, children: v });
    });
  return ((f.displayName = `${a}.Slot`), f);
}
function createSlotClone(a) {
  const e = reactExports.forwardRef((f, _) => {
    const { children: w, ...v } = f;
    if (reactExports.isValidElement(w)) {
      const S = getElementRef(w),
        R = mergeProps(v, w.props);
      return (
        w.type !== reactExports.Fragment && (R.ref = _ ? composeRefs(_, S) : S),
        reactExports.cloneElement(w, R)
      );
    }
    return reactExports.Children.count(w) > 1
      ? reactExports.Children.only(null)
      : null;
  });
  return ((e.displayName = `${a}.SlotClone`), e);
}
var SLOTTABLE_IDENTIFIER = Symbol("radix.slottable");
function isSlottable(a) {
  return (
    reactExports.isValidElement(a) &&
    typeof a.type == "function" &&
    "__radixId" in a.type &&
    a.type.__radixId === SLOTTABLE_IDENTIFIER
  );
}
function mergeProps(a, e) {
  const f = { ...e };
  for (const _ in e) {
    const w = a[_],
      v = e[_];
    /^on[A-Z]/.test(_)
      ? w && v
        ? (f[_] = (...R) => {
            const O = v(...R);
            return (w(...R), O);
          })
        : w && (f[_] = w)
      : _ === "style"
        ? (f[_] = { ...w, ...v })
        : _ === "className" && (f[_] = [w, v].filter(Boolean).join(" "));
  }
  return { ...a, ...f };
}
function getElementRef(a) {
  let e = Object.getOwnPropertyDescriptor(a.props, "ref")?.get,
    f = e && "isReactWarning" in e && e.isReactWarning;
  return f
    ? a.ref
    : ((e = Object.getOwnPropertyDescriptor(a, "ref")?.get),
      (f = e && "isReactWarning" in e && e.isReactWarning),
      f ? a.props.ref : a.props.ref || a.ref);
}
var SELECTION_KEYS = ["Enter", " "],
  FIRST_KEYS = ["ArrowDown", "PageUp", "Home"],
  LAST_KEYS = ["ArrowUp", "PageDown", "End"],
  FIRST_LAST_KEYS = [...FIRST_KEYS, ...LAST_KEYS],
  SUB_OPEN_KEYS = {
    ltr: [...SELECTION_KEYS, "ArrowRight"],
    rtl: [...SELECTION_KEYS, "ArrowLeft"],
  },
  SUB_CLOSE_KEYS = { ltr: ["ArrowLeft"], rtl: ["ArrowRight"] },
  MENU_NAME = "Menu",
  [Collection, useCollection, createCollectionScope] =
    createCollection(MENU_NAME),
  [createMenuContext, createMenuScope] = createContextScope(MENU_NAME, [
    createCollectionScope,
    createPopperScope,
    createRovingFocusGroupScope,
  ]),
  usePopperScope = createPopperScope(),
  useRovingFocusGroupScope = createRovingFocusGroupScope(),
  [MenuProvider, useMenuContext] = createMenuContext(MENU_NAME),
  [MenuRootProvider, useMenuRootContext] = createMenuContext(MENU_NAME),
  Menu = (a) => {
    const {
        __scopeMenu: e,
        open: f = !1,
        children: _,
        dir: w,
        onOpenChange: v,
        modal: S = !0,
      } = a,
      R = usePopperScope(e),
      [O, j] = reactExports.useState(null),
      F = reactExports.useRef(!1),
      q = useCallbackRef$1(v),
      Q = useDirection(w);
    return (
      reactExports.useEffect(() => {
        const te = () => {
            ((F.current = !0),
              document.addEventListener("pointerdown", se, {
                capture: !0,
                once: !0,
              }),
              document.addEventListener("pointermove", se, {
                capture: !0,
                once: !0,
              }));
          },
          se = () => (F.current = !1);
        return (
          document.addEventListener("keydown", te, { capture: !0 }),
          () => {
            (document.removeEventListener("keydown", te, { capture: !0 }),
              document.removeEventListener("pointerdown", se, { capture: !0 }),
              document.removeEventListener("pointermove", se, { capture: !0 }));
          }
        );
      }, []),
      jsxRuntimeExports.jsx(Root2$1, {
        ...R,
        children: jsxRuntimeExports.jsx(MenuProvider, {
          scope: e,
          open: f,
          onOpenChange: q,
          content: O,
          onContentChange: j,
          children: jsxRuntimeExports.jsx(MenuRootProvider, {
            scope: e,
            onClose: reactExports.useCallback(() => q(!1), [q]),
            isUsingKeyboardRef: F,
            dir: Q,
            modal: S,
            children: _,
          }),
        }),
      })
    );
  };
Menu.displayName = MENU_NAME;
var ANCHOR_NAME = "MenuAnchor",
  MenuAnchor = reactExports.forwardRef((a, e) => {
    const { __scopeMenu: f, ..._ } = a,
      w = usePopperScope(f);
    return jsxRuntimeExports.jsx(Anchor, { ...w, ..._, ref: e });
  });
MenuAnchor.displayName = ANCHOR_NAME;
var PORTAL_NAME$1 = "MenuPortal",
  [PortalProvider, usePortalContext] = createMenuContext(PORTAL_NAME$1, {
    forceMount: void 0,
  }),
  MenuPortal = (a) => {
    const { __scopeMenu: e, forceMount: f, children: _, container: w } = a,
      v = useMenuContext(PORTAL_NAME$1, e);
    return jsxRuntimeExports.jsx(PortalProvider, {
      scope: e,
      forceMount: f,
      children: jsxRuntimeExports.jsx(Presence, {
        present: f || v.open,
        children: jsxRuntimeExports.jsx(Portal$3, {
          asChild: !0,
          container: w,
          children: _,
        }),
      }),
    });
  };
MenuPortal.displayName = PORTAL_NAME$1;
var CONTENT_NAME$1 = "MenuContent",
  [MenuContentProvider, useMenuContentContext] =
    createMenuContext(CONTENT_NAME$1),
  MenuContent = reactExports.forwardRef((a, e) => {
    const f = usePortalContext(CONTENT_NAME$1, a.__scopeMenu),
      { forceMount: _ = f.forceMount, ...w } = a,
      v = useMenuContext(CONTENT_NAME$1, a.__scopeMenu),
      S = useMenuRootContext(CONTENT_NAME$1, a.__scopeMenu);
    return jsxRuntimeExports.jsx(Collection.Provider, {
      scope: a.__scopeMenu,
      children: jsxRuntimeExports.jsx(Presence, {
        present: _ || v.open,
        children: jsxRuntimeExports.jsx(Collection.Slot, {
          scope: a.__scopeMenu,
          children: S.modal
            ? jsxRuntimeExports.jsx(MenuRootContentModal, { ...w, ref: e })
            : jsxRuntimeExports.jsx(MenuRootContentNonModal, { ...w, ref: e }),
        }),
      }),
    });
  }),
  MenuRootContentModal = reactExports.forwardRef((a, e) => {
    const f = useMenuContext(CONTENT_NAME$1, a.__scopeMenu),
      _ = reactExports.useRef(null),
      w = useComposedRefs(e, _);
    return (
      reactExports.useEffect(() => {
        const v = _.current;
        if (v) return hideOthers(v);
      }, []),
      jsxRuntimeExports.jsx(MenuContentImpl, {
        ...a,
        ref: w,
        trapFocus: f.open,
        disableOutsidePointerEvents: f.open,
        disableOutsideScroll: !0,
        onFocusOutside: composeEventHandlers(
          a.onFocusOutside,
          (v) => v.preventDefault(),
          { checkForDefaultPrevented: !1 },
        ),
        onDismiss: () => f.onOpenChange(!1),
      })
    );
  }),
  MenuRootContentNonModal = reactExports.forwardRef((a, e) => {
    const f = useMenuContext(CONTENT_NAME$1, a.__scopeMenu);
    return jsxRuntimeExports.jsx(MenuContentImpl, {
      ...a,
      ref: e,
      trapFocus: !1,
      disableOutsidePointerEvents: !1,
      disableOutsideScroll: !1,
      onDismiss: () => f.onOpenChange(!1),
    });
  }),
  Slot = createSlot("MenuContent.ScrollLock"),
  MenuContentImpl = reactExports.forwardRef((a, e) => {
    const {
        __scopeMenu: f,
        loop: _ = !1,
        trapFocus: w,
        onOpenAutoFocus: v,
        onCloseAutoFocus: S,
        disableOutsidePointerEvents: R,
        onEntryFocus: O,
        onEscapeKeyDown: j,
        onPointerDownOutside: F,
        onFocusOutside: q,
        onInteractOutside: Q,
        onDismiss: te,
        disableOutsideScroll: se,
        ...re
      } = a,
      Oe = useMenuContext(CONTENT_NAME$1, f),
      Le = useMenuRootContext(CONTENT_NAME$1, f),
      Be = usePopperScope(f),
      Ve = useRovingFocusGroupScope(f),
      ze = useCollection(f),
      [Ge, Ke] = reactExports.useState(null),
      qe = reactExports.useRef(null),
      nt = useComposedRefs(e, qe, Oe.onContentChange),
      pt = reactExports.useRef(0),
      gt = reactExports.useRef(""),
      mt = reactExports.useRef(0),
      dt = reactExports.useRef(null),
      _t = reactExports.useRef("right"),
      bt = reactExports.useRef(0),
      at = se ? ReactRemoveScroll : reactExports.Fragment,
      $e = se ? { as: Slot, allowPinchZoom: !0 } : void 0,
      Ye = (tt) => {
        const ht = gt.current + tt,
          Fe = ze().filter((it) => !it.disabled),
          Ue = document.activeElement,
          ot = Fe.find((it) => it.ref.current === Ue)?.textValue,
          lt = Fe.map((it) => it.textValue),
          ut = getNextMatch(lt, ht, ot),
          yt = Fe.find((it) => it.textValue === ut)?.ref.current;
        ((function it(Et) {
          ((gt.current = Et),
            window.clearTimeout(pt.current),
            Et !== "" && (pt.current = window.setTimeout(() => it(""), 1e3)));
        })(ht),
          yt && setTimeout(() => yt.focus()));
      };
    (reactExports.useEffect(() => () => window.clearTimeout(pt.current), []),
      useFocusGuards());
    const Qe = reactExports.useCallback(
      (tt) =>
        _t.current === dt.current?.side &&
        isPointerInGraceArea(tt, dt.current?.area),
      [],
    );
    return jsxRuntimeExports.jsx(MenuContentProvider, {
      scope: f,
      searchRef: gt,
      onItemEnter: reactExports.useCallback(
        (tt) => {
          Qe(tt) && tt.preventDefault();
        },
        [Qe],
      ),
      onItemLeave: reactExports.useCallback(
        (tt) => {
          Qe(tt) || (qe.current?.focus(), Ke(null));
        },
        [Qe],
      ),
      onTriggerLeave: reactExports.useCallback(
        (tt) => {
          Qe(tt) && tt.preventDefault();
        },
        [Qe],
      ),
      pointerGraceTimerRef: mt,
      onPointerGraceIntentChange: reactExports.useCallback((tt) => {
        dt.current = tt;
      }, []),
      children: jsxRuntimeExports.jsx(at, {
        ...$e,
        children: jsxRuntimeExports.jsx(FocusScope, {
          asChild: !0,
          trapped: w,
          onMountAutoFocus: composeEventHandlers(v, (tt) => {
            (tt.preventDefault(), qe.current?.focus({ preventScroll: !0 }));
          }),
          onUnmountAutoFocus: S,
          children: jsxRuntimeExports.jsx(DismissableLayer, {
            asChild: !0,
            disableOutsidePointerEvents: R,
            onEscapeKeyDown: j,
            onPointerDownOutside: F,
            onFocusOutside: q,
            onInteractOutside: Q,
            onDismiss: te,
            children: jsxRuntimeExports.jsx(Root, {
              asChild: !0,
              ...Ve,
              dir: Le.dir,
              orientation: "vertical",
              loop: _,
              currentTabStopId: Ge,
              onCurrentTabStopIdChange: Ke,
              onEntryFocus: composeEventHandlers(O, (tt) => {
                Le.isUsingKeyboardRef.current || tt.preventDefault();
              }),
              preventScrollOnEntryFocus: !0,
              children: jsxRuntimeExports.jsx(Content, {
                role: "menu",
                "aria-orientation": "vertical",
                "data-state": getOpenState(Oe.open),
                "data-radix-menu-content": "",
                dir: Le.dir,
                ...Be,
                ...re,
                ref: nt,
                style: { outline: "none", ...re.style },
                onKeyDown: composeEventHandlers(re.onKeyDown, (tt) => {
                  const Fe =
                      tt.target.closest("[data-radix-menu-content]") ===
                      tt.currentTarget,
                    Ue = tt.ctrlKey || tt.altKey || tt.metaKey,
                    ot = tt.key.length === 1;
                  Fe &&
                    (tt.key === "Tab" && tt.preventDefault(),
                    !Ue && ot && Ye(tt.key));
                  const lt = qe.current;
                  if (tt.target !== lt || !FIRST_LAST_KEYS.includes(tt.key))
                    return;
                  tt.preventDefault();
                  const yt = ze()
                    .filter((it) => !it.disabled)
                    .map((it) => it.ref.current);
                  (LAST_KEYS.includes(tt.key) && yt.reverse(), focusFirst(yt));
                }),
                onBlur: composeEventHandlers(a.onBlur, (tt) => {
                  tt.currentTarget.contains(tt.target) ||
                    (window.clearTimeout(pt.current), (gt.current = ""));
                }),
                onPointerMove: composeEventHandlers(
                  a.onPointerMove,
                  whenMouse((tt) => {
                    const ht = tt.target,
                      Fe = bt.current !== tt.clientX;
                    if (tt.currentTarget.contains(ht) && Fe) {
                      const Ue = tt.clientX > bt.current ? "right" : "left";
                      ((_t.current = Ue), (bt.current = tt.clientX));
                    }
                  }),
                ),
              }),
            }),
          }),
        }),
      }),
    });
  });
MenuContent.displayName = CONTENT_NAME$1;
var GROUP_NAME$1 = "MenuGroup",
  MenuGroup = reactExports.forwardRef((a, e) => {
    const { __scopeMenu: f, ..._ } = a;
    return jsxRuntimeExports.jsx(Primitive$1.div, {
      role: "group",
      ..._,
      ref: e,
    });
  });
MenuGroup.displayName = GROUP_NAME$1;
var LABEL_NAME$1 = "MenuLabel",
  MenuLabel = reactExports.forwardRef((a, e) => {
    const { __scopeMenu: f, ..._ } = a;
    return jsxRuntimeExports.jsx(Primitive$1.div, { ..._, ref: e });
  });
MenuLabel.displayName = LABEL_NAME$1;
var ITEM_NAME$1 = "MenuItem",
  ITEM_SELECT = "menu.itemSelect",
  MenuItem = reactExports.forwardRef((a, e) => {
    const { disabled: f = !1, onSelect: _, ...w } = a,
      v = reactExports.useRef(null),
      S = useMenuRootContext(ITEM_NAME$1, a.__scopeMenu),
      R = useMenuContentContext(ITEM_NAME$1, a.__scopeMenu),
      O = useComposedRefs(e, v),
      j = reactExports.useRef(!1),
      F = () => {
        const q = v.current;
        if (!f && q) {
          const Q = new CustomEvent(ITEM_SELECT, {
            bubbles: !0,
            cancelable: !0,
          });
          (q.addEventListener(ITEM_SELECT, (te) => _?.(te), { once: !0 }),
            dispatchDiscreteCustomEvent(q, Q),
            Q.defaultPrevented ? (j.current = !1) : S.onClose());
        }
      };
    return jsxRuntimeExports.jsx(MenuItemImpl, {
      ...w,
      ref: O,
      disabled: f,
      onClick: composeEventHandlers(a.onClick, F),
      onPointerDown: (q) => {
        (a.onPointerDown?.(q), (j.current = !0));
      },
      onPointerUp: composeEventHandlers(a.onPointerUp, (q) => {
        j.current || q.currentTarget?.click();
      }),
      onKeyDown: composeEventHandlers(a.onKeyDown, (q) => {
        const Q = R.searchRef.current !== "";
        f ||
          (Q && q.key === " ") ||
          (SELECTION_KEYS.includes(q.key) &&
            (q.currentTarget.click(), q.preventDefault()));
      }),
    });
  });
MenuItem.displayName = ITEM_NAME$1;
var MenuItemImpl = reactExports.forwardRef((a, e) => {
    const { __scopeMenu: f, disabled: _ = !1, textValue: w, ...v } = a,
      S = useMenuContentContext(ITEM_NAME$1, f),
      R = useRovingFocusGroupScope(f),
      O = reactExports.useRef(null),
      j = useComposedRefs(e, O),
      [F, q] = reactExports.useState(!1),
      [Q, te] = reactExports.useState("");
    return (
      reactExports.useEffect(() => {
        const se = O.current;
        se && te((se.textContent ?? "").trim());
      }, [v.children]),
      jsxRuntimeExports.jsx(Collection.ItemSlot, {
        scope: f,
        disabled: _,
        textValue: w ?? Q,
        children: jsxRuntimeExports.jsx(Item, {
          asChild: !0,
          ...R,
          focusable: !_,
          children: jsxRuntimeExports.jsx(Primitive$1.div, {
            role: "menuitem",
            "data-highlighted": F ? "" : void 0,
            "aria-disabled": _ || void 0,
            "data-disabled": _ ? "" : void 0,
            ...v,
            ref: j,
            onPointerMove: composeEventHandlers(
              a.onPointerMove,
              whenMouse((se) => {
                _
                  ? S.onItemLeave(se)
                  : (S.onItemEnter(se),
                    se.defaultPrevented ||
                      se.currentTarget.focus({ preventScroll: !0 }));
              }),
            ),
            onPointerLeave: composeEventHandlers(
              a.onPointerLeave,
              whenMouse((se) => S.onItemLeave(se)),
            ),
            onFocus: composeEventHandlers(a.onFocus, () => q(!0)),
            onBlur: composeEventHandlers(a.onBlur, () => q(!1)),
          }),
        }),
      })
    );
  }),
  CHECKBOX_ITEM_NAME$1 = "MenuCheckboxItem",
  MenuCheckboxItem = reactExports.forwardRef((a, e) => {
    const { checked: f = !1, onCheckedChange: _, ...w } = a;
    return jsxRuntimeExports.jsx(ItemIndicatorProvider, {
      scope: a.__scopeMenu,
      checked: f,
      children: jsxRuntimeExports.jsx(MenuItem, {
        role: "menuitemcheckbox",
        "aria-checked": isIndeterminate(f) ? "mixed" : f,
        ...w,
        ref: e,
        "data-state": getCheckedState(f),
        onSelect: composeEventHandlers(
          w.onSelect,
          () => _?.(isIndeterminate(f) ? !0 : !f),
          { checkForDefaultPrevented: !1 },
        ),
      }),
    });
  });
MenuCheckboxItem.displayName = CHECKBOX_ITEM_NAME$1;
var RADIO_GROUP_NAME$1 = "MenuRadioGroup",
  [RadioGroupProvider, useRadioGroupContext] = createMenuContext(
    RADIO_GROUP_NAME$1,
    { value: void 0, onValueChange: () => {} },
  ),
  MenuRadioGroup = reactExports.forwardRef((a, e) => {
    const { value: f, onValueChange: _, ...w } = a,
      v = useCallbackRef$1(_);
    return jsxRuntimeExports.jsx(RadioGroupProvider, {
      scope: a.__scopeMenu,
      value: f,
      onValueChange: v,
      children: jsxRuntimeExports.jsx(MenuGroup, { ...w, ref: e }),
    });
  });
MenuRadioGroup.displayName = RADIO_GROUP_NAME$1;
var RADIO_ITEM_NAME$1 = "MenuRadioItem",
  MenuRadioItem = reactExports.forwardRef((a, e) => {
    const { value: f, ..._ } = a,
      w = useRadioGroupContext(RADIO_ITEM_NAME$1, a.__scopeMenu),
      v = f === w.value;
    return jsxRuntimeExports.jsx(ItemIndicatorProvider, {
      scope: a.__scopeMenu,
      checked: v,
      children: jsxRuntimeExports.jsx(MenuItem, {
        role: "menuitemradio",
        "aria-checked": v,
        ..._,
        ref: e,
        "data-state": getCheckedState(v),
        onSelect: composeEventHandlers(_.onSelect, () => w.onValueChange?.(f), {
          checkForDefaultPrevented: !1,
        }),
      }),
    });
  });
MenuRadioItem.displayName = RADIO_ITEM_NAME$1;
var ITEM_INDICATOR_NAME = "MenuItemIndicator",
  [ItemIndicatorProvider, useItemIndicatorContext] = createMenuContext(
    ITEM_INDICATOR_NAME,
    { checked: !1 },
  ),
  MenuItemIndicator = reactExports.forwardRef((a, e) => {
    const { __scopeMenu: f, forceMount: _, ...w } = a,
      v = useItemIndicatorContext(ITEM_INDICATOR_NAME, f);
    return jsxRuntimeExports.jsx(Presence, {
      present: _ || isIndeterminate(v.checked) || v.checked === !0,
      children: jsxRuntimeExports.jsx(Primitive$1.span, {
        ...w,
        ref: e,
        "data-state": getCheckedState(v.checked),
      }),
    });
  });
MenuItemIndicator.displayName = ITEM_INDICATOR_NAME;
var SEPARATOR_NAME$1 = "MenuSeparator",
  MenuSeparator = reactExports.forwardRef((a, e) => {
    const { __scopeMenu: f, ..._ } = a;
    return jsxRuntimeExports.jsx(Primitive$1.div, {
      role: "separator",
      "aria-orientation": "horizontal",
      ..._,
      ref: e,
    });
  });
MenuSeparator.displayName = SEPARATOR_NAME$1;
var ARROW_NAME$1 = "MenuArrow",
  MenuArrow = reactExports.forwardRef((a, e) => {
    const { __scopeMenu: f, ..._ } = a,
      w = usePopperScope(f);
    return jsxRuntimeExports.jsx(Arrow, { ...w, ..._, ref: e });
  });
MenuArrow.displayName = ARROW_NAME$1;
var SUB_NAME = "MenuSub",
  [MenuSubProvider, useMenuSubContext] = createMenuContext(SUB_NAME),
  SUB_TRIGGER_NAME$1 = "MenuSubTrigger",
  MenuSubTrigger = reactExports.forwardRef((a, e) => {
    const f = useMenuContext(SUB_TRIGGER_NAME$1, a.__scopeMenu),
      _ = useMenuRootContext(SUB_TRIGGER_NAME$1, a.__scopeMenu),
      w = useMenuSubContext(SUB_TRIGGER_NAME$1, a.__scopeMenu),
      v = useMenuContentContext(SUB_TRIGGER_NAME$1, a.__scopeMenu),
      S = reactExports.useRef(null),
      { pointerGraceTimerRef: R, onPointerGraceIntentChange: O } = v,
      j = { __scopeMenu: a.__scopeMenu },
      F = reactExports.useCallback(() => {
        (S.current && window.clearTimeout(S.current), (S.current = null));
      }, []);
    return (
      reactExports.useEffect(() => F, [F]),
      reactExports.useEffect(() => {
        const q = R.current;
        return () => {
          (window.clearTimeout(q), O(null));
        };
      }, [R, O]),
      jsxRuntimeExports.jsx(MenuAnchor, {
        asChild: !0,
        ...j,
        children: jsxRuntimeExports.jsx(MenuItemImpl, {
          id: w.triggerId,
          "aria-haspopup": "menu",
          "aria-expanded": f.open,
          "aria-controls": w.contentId,
          "data-state": getOpenState(f.open),
          ...a,
          ref: composeRefs(e, w.onTriggerChange),
          onClick: (q) => {
            (a.onClick?.(q),
              !(a.disabled || q.defaultPrevented) &&
                (q.currentTarget.focus(), f.open || f.onOpenChange(!0)));
          },
          onPointerMove: composeEventHandlers(
            a.onPointerMove,
            whenMouse((q) => {
              (v.onItemEnter(q),
                !q.defaultPrevented &&
                  !a.disabled &&
                  !f.open &&
                  !S.current &&
                  (v.onPointerGraceIntentChange(null),
                  (S.current = window.setTimeout(() => {
                    (f.onOpenChange(!0), F());
                  }, 100))));
            }),
          ),
          onPointerLeave: composeEventHandlers(
            a.onPointerLeave,
            whenMouse((q) => {
              F();
              const Q = f.content?.getBoundingClientRect();
              if (Q) {
                const te = f.content?.dataset.side,
                  se = te === "right",
                  re = se ? -5 : 5,
                  Oe = Q[se ? "left" : "right"],
                  Le = Q[se ? "right" : "left"];
                (v.onPointerGraceIntentChange({
                  area: [
                    { x: q.clientX + re, y: q.clientY },
                    { x: Oe, y: Q.top },
                    { x: Le, y: Q.top },
                    { x: Le, y: Q.bottom },
                    { x: Oe, y: Q.bottom },
                  ],
                  side: te,
                }),
                  window.clearTimeout(R.current),
                  (R.current = window.setTimeout(
                    () => v.onPointerGraceIntentChange(null),
                    300,
                  )));
              } else {
                if ((v.onTriggerLeave(q), q.defaultPrevented)) return;
                v.onPointerGraceIntentChange(null);
              }
            }),
          ),
          onKeyDown: composeEventHandlers(a.onKeyDown, (q) => {
            const Q = v.searchRef.current !== "";
            a.disabled ||
              (Q && q.key === " ") ||
              (SUB_OPEN_KEYS[_.dir].includes(q.key) &&
                (f.onOpenChange(!0), f.content?.focus(), q.preventDefault()));
          }),
        }),
      })
    );
  });
MenuSubTrigger.displayName = SUB_TRIGGER_NAME$1;
var SUB_CONTENT_NAME$1 = "MenuSubContent",
  MenuSubContent = reactExports.forwardRef((a, e) => {
    const f = usePortalContext(CONTENT_NAME$1, a.__scopeMenu),
      { forceMount: _ = f.forceMount, ...w } = a,
      v = useMenuContext(CONTENT_NAME$1, a.__scopeMenu),
      S = useMenuRootContext(CONTENT_NAME$1, a.__scopeMenu),
      R = useMenuSubContext(SUB_CONTENT_NAME$1, a.__scopeMenu),
      O = reactExports.useRef(null),
      j = useComposedRefs(e, O);
    return jsxRuntimeExports.jsx(Collection.Provider, {
      scope: a.__scopeMenu,
      children: jsxRuntimeExports.jsx(Presence, {
        present: _ || v.open,
        children: jsxRuntimeExports.jsx(Collection.Slot, {
          scope: a.__scopeMenu,
          children: jsxRuntimeExports.jsx(MenuContentImpl, {
            id: R.contentId,
            "aria-labelledby": R.triggerId,
            ...w,
            ref: j,
            align: "start",
            side: S.dir === "rtl" ? "left" : "right",
            disableOutsidePointerEvents: !1,
            disableOutsideScroll: !1,
            trapFocus: !1,
            onOpenAutoFocus: (F) => {
              (S.isUsingKeyboardRef.current && O.current?.focus(),
                F.preventDefault());
            },
            onCloseAutoFocus: (F) => F.preventDefault(),
            onFocusOutside: composeEventHandlers(a.onFocusOutside, (F) => {
              F.target !== R.trigger && v.onOpenChange(!1);
            }),
            onEscapeKeyDown: composeEventHandlers(a.onEscapeKeyDown, (F) => {
              (S.onClose(), F.preventDefault());
            }),
            onKeyDown: composeEventHandlers(a.onKeyDown, (F) => {
              const q = F.currentTarget.contains(F.target),
                Q = SUB_CLOSE_KEYS[S.dir].includes(F.key);
              q &&
                Q &&
                (v.onOpenChange(!1), R.trigger?.focus(), F.preventDefault());
            }),
          }),
        }),
      }),
    });
  });
MenuSubContent.displayName = SUB_CONTENT_NAME$1;
function getOpenState(a) {
  return a ? "open" : "closed";
}
function isIndeterminate(a) {
  return a === "indeterminate";
}
function getCheckedState(a) {
  return isIndeterminate(a) ? "indeterminate" : a ? "checked" : "unchecked";
}
function focusFirst(a) {
  const e = document.activeElement;
  for (const f of a)
    if (f === e || (f.focus(), document.activeElement !== e)) return;
}
function wrapArray(a, e) {
  return a.map((f, _) => a[(e + _) % a.length]);
}
function getNextMatch(a, e, f) {
  const w = e.length > 1 && Array.from(e).every((j) => j === e[0]) ? e[0] : e,
    v = f ? a.indexOf(f) : -1;
  let S = wrapArray(a, Math.max(v, 0));
  w.length === 1 && (S = S.filter((j) => j !== f));
  const O = S.find((j) => j.toLowerCase().startsWith(w.toLowerCase()));
  return O !== f ? O : void 0;
}
function isPointInPolygon(a, e) {
  const { x: f, y: _ } = a;
  let w = !1;
  for (let v = 0, S = e.length - 1; v < e.length; S = v++) {
    const R = e[v],
      O = e[S],
      j = R.x,
      F = R.y,
      q = O.x,
      Q = O.y;
    F > _ != Q > _ && f < ((q - j) * (_ - F)) / (Q - F) + j && (w = !w);
  }
  return w;
}
function isPointerInGraceArea(a, e) {
  if (!e) return !1;
  const f = { x: a.clientX, y: a.clientY };
  return isPointInPolygon(f, e);
}
function whenMouse(a) {
  return (e) => (e.pointerType === "mouse" ? a(e) : void 0);
}
var Root3 = Menu,
  Anchor2 = MenuAnchor,
  Portal = MenuPortal,
  Content2$1 = MenuContent,
  Group = MenuGroup,
  Label = MenuLabel,
  Item2$1 = MenuItem,
  CheckboxItem = MenuCheckboxItem,
  RadioGroup = MenuRadioGroup,
  RadioItem = MenuRadioItem,
  ItemIndicator = MenuItemIndicator,
  Separator = MenuSeparator,
  Arrow2 = MenuArrow,
  SubTrigger = MenuSubTrigger,
  SubContent = MenuSubContent,
  DROPDOWN_MENU_NAME = "DropdownMenu",
  [createDropdownMenuContext] = createContextScope(DROPDOWN_MENU_NAME, [
    createMenuScope,
  ]),
  useMenuScope = createMenuScope(),
  [DropdownMenuProvider, useDropdownMenuContext] =
    createDropdownMenuContext(DROPDOWN_MENU_NAME),
  DropdownMenu$1 = (a) => {
    const {
        __scopeDropdownMenu: e,
        children: f,
        dir: _,
        open: w,
        defaultOpen: v,
        onOpenChange: S,
        modal: R = !0,
      } = a,
      O = useMenuScope(e),
      j = reactExports.useRef(null),
      [F, q] = useControllableState({
        prop: w,
        defaultProp: v ?? !1,
        onChange: S,
        caller: DROPDOWN_MENU_NAME,
      });
    return jsxRuntimeExports.jsx(DropdownMenuProvider, {
      scope: e,
      triggerId: useId(),
      triggerRef: j,
      contentId: useId(),
      open: F,
      onOpenChange: q,
      onOpenToggle: reactExports.useCallback(() => q((Q) => !Q), [q]),
      modal: R,
      children: jsxRuntimeExports.jsx(Root3, {
        ...O,
        open: F,
        onOpenChange: q,
        dir: _,
        modal: R,
        children: f,
      }),
    });
  };
DropdownMenu$1.displayName = DROPDOWN_MENU_NAME;
var TRIGGER_NAME = "DropdownMenuTrigger",
  DropdownMenuTrigger$1 = reactExports.forwardRef((a, e) => {
    const { __scopeDropdownMenu: f, disabled: _ = !1, ...w } = a,
      v = useDropdownMenuContext(TRIGGER_NAME, f),
      S = useMenuScope(f);
    return jsxRuntimeExports.jsx(Anchor2, {
      asChild: !0,
      ...S,
      children: jsxRuntimeExports.jsx(Primitive$1.button, {
        type: "button",
        id: v.triggerId,
        "aria-haspopup": "menu",
        "aria-expanded": v.open,
        "aria-controls": v.open ? v.contentId : void 0,
        "data-state": v.open ? "open" : "closed",
        "data-disabled": _ ? "" : void 0,
        disabled: _,
        ...w,
        ref: composeRefs(e, v.triggerRef),
        onPointerDown: composeEventHandlers(a.onPointerDown, (R) => {
          !_ &&
            R.button === 0 &&
            R.ctrlKey === !1 &&
            (v.onOpenToggle(), v.open || R.preventDefault());
        }),
        onKeyDown: composeEventHandlers(a.onKeyDown, (R) => {
          _ ||
            (["Enter", " "].includes(R.key) && v.onOpenToggle(),
            R.key === "ArrowDown" && v.onOpenChange(!0),
            ["Enter", " ", "ArrowDown"].includes(R.key) && R.preventDefault());
        }),
      }),
    });
  });
DropdownMenuTrigger$1.displayName = TRIGGER_NAME;
var PORTAL_NAME = "DropdownMenuPortal",
  DropdownMenuPortal = (a) => {
    const { __scopeDropdownMenu: e, ...f } = a,
      _ = useMenuScope(e);
    return jsxRuntimeExports.jsx(Portal, { ..._, ...f });
  };
DropdownMenuPortal.displayName = PORTAL_NAME;
var CONTENT_NAME = "DropdownMenuContent",
  DropdownMenuContent$1 = reactExports.forwardRef((a, e) => {
    const { __scopeDropdownMenu: f, ..._ } = a,
      w = useDropdownMenuContext(CONTENT_NAME, f),
      v = useMenuScope(f),
      S = reactExports.useRef(!1);
    return jsxRuntimeExports.jsx(Content2$1, {
      id: w.contentId,
      "aria-labelledby": w.triggerId,
      ...v,
      ..._,
      ref: e,
      onCloseAutoFocus: composeEventHandlers(a.onCloseAutoFocus, (R) => {
        (S.current || w.triggerRef.current?.focus(),
          (S.current = !1),
          R.preventDefault());
      }),
      onInteractOutside: composeEventHandlers(a.onInteractOutside, (R) => {
        const O = R.detail.originalEvent,
          j = O.button === 0 && O.ctrlKey === !0,
          F = O.button === 2 || j;
        (!w.modal || F) && (S.current = !0);
      }),
      style: {
        ...a.style,
        "--radix-dropdown-menu-content-transform-origin":
          "var(--radix-popper-transform-origin)",
        "--radix-dropdown-menu-content-available-width":
          "var(--radix-popper-available-width)",
        "--radix-dropdown-menu-content-available-height":
          "var(--radix-popper-available-height)",
        "--radix-dropdown-menu-trigger-width":
          "var(--radix-popper-anchor-width)",
        "--radix-dropdown-menu-trigger-height":
          "var(--radix-popper-anchor-height)",
      },
    });
  });
DropdownMenuContent$1.displayName = CONTENT_NAME;
var GROUP_NAME = "DropdownMenuGroup",
  DropdownMenuGroup = reactExports.forwardRef((a, e) => {
    const { __scopeDropdownMenu: f, ..._ } = a,
      w = useMenuScope(f);
    return jsxRuntimeExports.jsx(Group, { ...w, ..._, ref: e });
  });
DropdownMenuGroup.displayName = GROUP_NAME;
var LABEL_NAME = "DropdownMenuLabel",
  DropdownMenuLabel$1 = reactExports.forwardRef((a, e) => {
    const { __scopeDropdownMenu: f, ..._ } = a,
      w = useMenuScope(f);
    return jsxRuntimeExports.jsx(Label, { ...w, ..._, ref: e });
  });
DropdownMenuLabel$1.displayName = LABEL_NAME;
var ITEM_NAME = "DropdownMenuItem",
  DropdownMenuItem$1 = reactExports.forwardRef((a, e) => {
    const { __scopeDropdownMenu: f, ..._ } = a,
      w = useMenuScope(f);
    return jsxRuntimeExports.jsx(Item2$1, { ...w, ..._, ref: e });
  });
DropdownMenuItem$1.displayName = ITEM_NAME;
var CHECKBOX_ITEM_NAME = "DropdownMenuCheckboxItem",
  DropdownMenuCheckboxItem$1 = reactExports.forwardRef((a, e) => {
    const { __scopeDropdownMenu: f, ..._ } = a,
      w = useMenuScope(f);
    return jsxRuntimeExports.jsx(CheckboxItem, { ...w, ..._, ref: e });
  });
DropdownMenuCheckboxItem$1.displayName = CHECKBOX_ITEM_NAME;
var RADIO_GROUP_NAME = "DropdownMenuRadioGroup",
  DropdownMenuRadioGroup = reactExports.forwardRef((a, e) => {
    const { __scopeDropdownMenu: f, ..._ } = a,
      w = useMenuScope(f);
    return jsxRuntimeExports.jsx(RadioGroup, { ...w, ..._, ref: e });
  });
DropdownMenuRadioGroup.displayName = RADIO_GROUP_NAME;
var RADIO_ITEM_NAME = "DropdownMenuRadioItem",
  DropdownMenuRadioItem$1 = reactExports.forwardRef((a, e) => {
    const { __scopeDropdownMenu: f, ..._ } = a,
      w = useMenuScope(f);
    return jsxRuntimeExports.jsx(RadioItem, { ...w, ..._, ref: e });
  });
DropdownMenuRadioItem$1.displayName = RADIO_ITEM_NAME;
var INDICATOR_NAME = "DropdownMenuItemIndicator",
  DropdownMenuItemIndicator = reactExports.forwardRef((a, e) => {
    const { __scopeDropdownMenu: f, ..._ } = a,
      w = useMenuScope(f);
    return jsxRuntimeExports.jsx(ItemIndicator, { ...w, ..._, ref: e });
  });
DropdownMenuItemIndicator.displayName = INDICATOR_NAME;
var SEPARATOR_NAME = "DropdownMenuSeparator",
  DropdownMenuSeparator$1 = reactExports.forwardRef((a, e) => {
    const { __scopeDropdownMenu: f, ..._ } = a,
      w = useMenuScope(f);
    return jsxRuntimeExports.jsx(Separator, { ...w, ..._, ref: e });
  });
DropdownMenuSeparator$1.displayName = SEPARATOR_NAME;
var ARROW_NAME = "DropdownMenuArrow",
  DropdownMenuArrow = reactExports.forwardRef((a, e) => {
    const { __scopeDropdownMenu: f, ..._ } = a,
      w = useMenuScope(f);
    return jsxRuntimeExports.jsx(Arrow2, { ...w, ..._, ref: e });
  });
DropdownMenuArrow.displayName = ARROW_NAME;
var SUB_TRIGGER_NAME = "DropdownMenuSubTrigger",
  DropdownMenuSubTrigger$1 = reactExports.forwardRef((a, e) => {
    const { __scopeDropdownMenu: f, ..._ } = a,
      w = useMenuScope(f);
    return jsxRuntimeExports.jsx(SubTrigger, { ...w, ..._, ref: e });
  });
DropdownMenuSubTrigger$1.displayName = SUB_TRIGGER_NAME;
var SUB_CONTENT_NAME = "DropdownMenuSubContent",
  DropdownMenuSubContent$1 = reactExports.forwardRef((a, e) => {
    const { __scopeDropdownMenu: f, ..._ } = a,
      w = useMenuScope(f);
    return jsxRuntimeExports.jsx(SubContent, {
      ...w,
      ..._,
      ref: e,
      style: {
        ...a.style,
        "--radix-dropdown-menu-content-transform-origin":
          "var(--radix-popper-transform-origin)",
        "--radix-dropdown-menu-content-available-width":
          "var(--radix-popper-available-width)",
        "--radix-dropdown-menu-content-available-height":
          "var(--radix-popper-available-height)",
        "--radix-dropdown-menu-trigger-width":
          "var(--radix-popper-anchor-width)",
        "--radix-dropdown-menu-trigger-height":
          "var(--radix-popper-anchor-height)",
      },
    });
  });
DropdownMenuSubContent$1.displayName = SUB_CONTENT_NAME;
var Root2 = DropdownMenu$1,
  Trigger = DropdownMenuTrigger$1,
  Portal2 = DropdownMenuPortal,
  Content2 = DropdownMenuContent$1,
  Label2 = DropdownMenuLabel$1,
  Item2 = DropdownMenuItem$1,
  CheckboxItem2 = DropdownMenuCheckboxItem$1,
  RadioItem2 = DropdownMenuRadioItem$1,
  ItemIndicator2 = DropdownMenuItemIndicator,
  Separator2 = DropdownMenuSeparator$1,
  SubTrigger2 = DropdownMenuSubTrigger$1,
  SubContent2 = DropdownMenuSubContent$1;
const DropdownMenu = Root2,
  DropdownMenuTrigger = Trigger,
  DropdownMenuSubTrigger = reactExports.forwardRef(
    ({ className: a, inset: e, children: f, ..._ }, w) =>
      jsxRuntimeExports.jsxs(SubTrigger2, {
        ref: w,
        className: cn(
          "flex cursor-default select-none items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent data-[state=open]:bg-accent [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0",
          e && "pl-8",
          a,
        ),
        ..._,
        children: [
          f,
          jsxRuntimeExports.jsx(ChevronRight, { className: "ml-auto" }),
        ],
      }),
  );
DropdownMenuSubTrigger.displayName = SubTrigger2.displayName;
const DropdownMenuSubContent = reactExports.forwardRef(
  ({ className: a, ...e }, f) =>
    jsxRuntimeExports.jsx(SubContent2, {
      ref: f,
      className: cn(
        "z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 origin-[--radix-dropdown-menu-content-transform-origin]",
        a,
      ),
      ...e,
    }),
);
DropdownMenuSubContent.displayName = SubContent2.displayName;
const DropdownMenuContent = reactExports.forwardRef(
  ({ className: a, sideOffset: e = 4, ...f }, _) =>
    jsxRuntimeExports.jsx(Portal2, {
      children: jsxRuntimeExports.jsx(Content2, {
        ref: _,
        sideOffset: e,
        className: cn(
          "z-50 max-h-[var(--radix-dropdown-menu-content-available-height)] min-w-[8rem] overflow-y-auto overflow-x-hidden rounded-md border bg-popover p-1 text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 origin-[--radix-dropdown-menu-content-transform-origin]",
          a,
        ),
        ...f,
      }),
    }),
);
DropdownMenuContent.displayName = Content2.displayName;
const DropdownMenuItem = reactExports.forwardRef(
  ({ className: a, inset: e, ...f }, _) =>
    jsxRuntimeExports.jsx(Item2, {
      ref: _,
      className: cn(
        "relative flex cursor-default select-none items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0",
        e && "pl-8",
        a,
      ),
      ...f,
    }),
);
DropdownMenuItem.displayName = Item2.displayName;
const DropdownMenuCheckboxItem = reactExports.forwardRef(
  ({ className: a, children: e, checked: f, ..._ }, w) =>
    jsxRuntimeExports.jsxs(CheckboxItem2, {
      ref: w,
      className: cn(
        "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
        a,
      ),
      checked: f,
      ..._,
      children: [
        jsxRuntimeExports.jsx("span", {
          className:
            "absolute left-2 flex h-3.5 w-3.5 items-center justify-center",
          children: jsxRuntimeExports.jsx(ItemIndicator2, {
            children: jsxRuntimeExports.jsx(Check, { className: "h-4 w-4" }),
          }),
        }),
        e,
      ],
    }),
);
DropdownMenuCheckboxItem.displayName = CheckboxItem2.displayName;
const DropdownMenuRadioItem = reactExports.forwardRef(
  ({ className: a, children: e, ...f }, _) =>
    jsxRuntimeExports.jsxs(RadioItem2, {
      ref: _,
      className: cn(
        "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
        a,
      ),
      ...f,
      children: [
        jsxRuntimeExports.jsx("span", {
          className:
            "absolute left-2 flex h-3.5 w-3.5 items-center justify-center",
          children: jsxRuntimeExports.jsx(ItemIndicator2, {
            children: jsxRuntimeExports.jsx(Circle, {
              className: "h-2 w-2 fill-current",
            }),
          }),
        }),
        e,
      ],
    }),
);
DropdownMenuRadioItem.displayName = RadioItem2.displayName;
const DropdownMenuLabel = reactExports.forwardRef(
  ({ className: a, inset: e, ...f }, _) =>
    jsxRuntimeExports.jsx(Label2, {
      ref: _,
      className: cn("px-2 py-1.5 text-sm font-semibold", e && "pl-8", a),
      ...f,
    }),
);
DropdownMenuLabel.displayName = Label2.displayName;
const DropdownMenuSeparator = reactExports.forwardRef(
  ({ className: a, ...e }, f) =>
    jsxRuntimeExports.jsx(Separator2, {
      ref: f,
      className: cn("-mx-1 my-1 h-px bg-muted", a),
      ...e,
    }),
);
DropdownMenuSeparator.displayName = Separator2.displayName;
const ChevronUpIcon = ({ size: a = 16, ...e }) =>
  jsxRuntimeExports.jsx("svg", {
    height: a,
    strokeLinejoin: "round",
    style: { color: "currentcolor", ...e.style },
    viewBox: "0 0 16 16",
    width: a,
    ...e,
    children: jsxRuntimeExports.jsx("path", {
      clipRule: "evenodd",
      d: "M7.29289 4.29289C7.68342 3.90237 8.31658 3.90237 8.70711 4.29289L13.7071 9.29289C14.0976 9.68342 14.0976 10.3166 13.7071 10.7071C13.3166 11.0976 12.6834 11.0976 12.2929 10.7071L8 6.41421L3.70711 10.7071C3.31658 11.0976 2.68342 11.0976 2.29289 10.7071C1.90237 10.3166 1.90237 9.68342 2.29289 9.29289L7.29289 4.29289Z",
      fill: "currentColor",
      fillRule: "evenodd",
    }),
  });
function SidebarUserNav() {
  return jsxRuntimeExports.jsx(SidebarMenu, {
    children: jsxRuntimeExports.jsx(SidebarMenuItem, {
      children: jsxRuntimeExports.jsxs(DropdownMenu, {
        children: [
          jsxRuntimeExports.jsx(DropdownMenuTrigger, {
            asChild: !0,
            children: jsxRuntimeExports.jsxs(SidebarMenuButton, {
              className:
                "h-10 justify-between bg-background data-[state=open]:bg-sidebar-accent data-[state=open]:text-sidebar-accent-foreground",
              "data-testid": "user-nav-button",
              children: [
                jsxRuntimeExports.jsx("div", {
                  className:
                    "flex aspect-square size-6 items-center justify-center rounded-full bg-sidebar-primary text-sidebar-primary-foreground",
                  children: jsxRuntimeExports.jsx("span", {
                    className: "text-xs font-semibold",
                    children: "G",
                  }),
                }),
                jsxRuntimeExports.jsx("span", {
                  className: "flex-1 truncate text-left",
                  "data-testid": "user-email",
                  children: "Guest",
                }),
                jsxRuntimeExports.jsx(ChevronUpIcon, {
                  className: "ml-auto shrink-0",
                  size: 16,
                }),
              ],
            }),
          }),
          jsxRuntimeExports.jsxs(DropdownMenuContent, {
            className: "w-(--radix-popper-anchor-width)",
            "data-testid": "user-nav-menu",
            side: "top",
            children: [
              jsxRuntimeExports.jsx(DropdownMenuItem, {
                className: "cursor-pointer",
                "data-testid": "user-nav-item-theme",
                children: "Toggle dark mode",
              }),
              jsxRuntimeExports.jsx(DropdownMenuSeparator, {}),
              jsxRuntimeExports.jsx(DropdownMenuItem, {
                asChild: !0,
                "data-testid": "user-nav-item-auth",
                children: jsxRuntimeExports.jsx("button", {
                  className: "w-full cursor-pointer",
                  type: "button",
                  children: "Login to your account",
                }),
              }),
            ],
          }),
        ],
      }),
    }),
  });
}
function Sidebar() {
  return jsxRuntimeExports.jsxs(Sidebar$1, {
    className: "group-data-[side=left]:border-r-0",
    children: [
      jsxRuntimeExports.jsx(SidebarHeader, {
        children: jsxRuntimeExports.jsx(SidebarMenu, {
          children: jsxRuntimeExports.jsxs("div", {
            className: "flex flex-row items-center justify-between",
            children: [
              jsxRuntimeExports.jsx("span", {
                className:
                  "cursor-pointer rounded-md px-2 font-semibold text-lg hover:bg-muted",
                children: "XMTP Agents",
              }),
              jsxRuntimeExports.jsxs("div", {
                className: "flex flex-row gap-1",
                children: [
                  jsxRuntimeExports.jsxs(Tooltip, {
                    children: [
                      jsxRuntimeExports.jsx(TooltipTrigger, {
                        asChild: !0,
                        children: jsxRuntimeExports.jsx(Button, {
                          className: "h-8 p-1 md:h-fit md:p-2",
                          type: "button",
                          variant: "ghost",
                          children: jsxRuntimeExports.jsx(TrashIcon, {}),
                        }),
                      }),
                      jsxRuntimeExports.jsx(TooltipContent, {
                        align: "end",
                        className: "hidden md:block",
                        children: "Delete All Chats",
                      }),
                    ],
                  }),
                  jsxRuntimeExports.jsxs(Tooltip, {
                    children: [
                      jsxRuntimeExports.jsx(TooltipTrigger, {
                        asChild: !0,
                        children: jsxRuntimeExports.jsx(Button, {
                          className: "h-8 p-1 md:h-fit md:p-2",
                          type: "button",
                          variant: "ghost",
                          children: jsxRuntimeExports.jsx(PlusIcon, {}),
                        }),
                      }),
                      jsxRuntimeExports.jsx(TooltipContent, {
                        align: "end",
                        className: "hidden md:block",
                        children: "New Chat",
                      }),
                    ],
                  }),
                ],
              }),
            ],
          }),
        }),
      }),
      jsxRuntimeExports.jsx(SidebarContent, {
        children: jsxRuntimeExports.jsx("div", {
          className:
            "flex w-full flex-row items-center justify-center gap-2 px-2 text-sm text-muted-foreground",
          children:
            "Your conversations will appear here once you start chatting!",
        }),
      }),
      jsxRuntimeExports.jsx(SidebarFooter, {
        children: jsxRuntimeExports.jsx(SidebarUserNav, {}),
      }),
    ],
  });
}
function App() {
  const { client: a, error: e } = useXMTPClient(),
    { conversations: f, error: _ } = useXMTPConversations(a);
  return (
    e && console.error("[Home] XMTP Client error:", e),
    _ && console.error("[Home] XMTP Conversations error:", _),
    a &&
      f.length > 0 &&
      console.log("[Home] XMTP initialized:", {
        clientInboxId: a.inboxId,
        conversationsCount: f.length,
        conversations: f.map((w) => ({ id: w.id, type: w.constructor.name })),
      }),
    jsxRuntimeExports.jsxs(SidebarProvider, {
      defaultOpen: !0,
      children: [
        jsxRuntimeExports.jsx(Sidebar, {}),
        jsxRuntimeExports.jsx(SidebarInset, {
          children: jsxRuntimeExports.jsx(ChatArea, {}),
        }),
      ],
    })
  );
}
clientExports.createRoot(document.getElementById("root")).render(
  jsxRuntimeExports.jsx(reactExports.StrictMode, {
    children: jsxRuntimeExports.jsx(App, {}),
  }),
);
//# sourceMappingURL=index-CvEH12yB.js.map
